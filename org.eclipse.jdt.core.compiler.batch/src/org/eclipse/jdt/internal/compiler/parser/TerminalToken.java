/*******************************************************************************
 * Copyright (c) 2000, 2022 IBM Corporation and others.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * This is an implementation of an early-draft specification developed under the Java
 * Community Process (JCP) and is made available for testing and evaluation purposes
 * only. The code is not compatible with any specification of the JCP.
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
package org.eclipse.jdt.internal.compiler.parser;

import java.util.HashMap;
import java.util.Map;

/**
 * IMPORTANT NOTE: These constants are dedicated to the internal Scanner implementation.
 * It is mirrored in org.eclipse.jdt.core.compiler public package where it is API.
 * The mirror implementation is using the backward compatible ITerminalSymbols constant
 * definitions (stable with 2.0), whereas the internal implementation uses TerminalTokens
 * which constant values reflect the latest parser generation state.
 */
/**
 * Maps each terminal symbol in the java-grammar into a unique integer.
 * This integer is used to represent the terminal when computing a parsing action.
 *
 * Disclaimer : These constant values are generated automatically using a Java
 * grammar, therefore their actual values are subject to change if new keywords
 * were added to the language (for instance, 'assert' is a keyword in 1.4).
 */
public enum TerminalToken {

	// special tokens not part of grammar - not autogenerated
							TokenNameInvalid(-1),
							TokenNameNotAToken(0),
							TokenNameWHITESPACE(1000),
							TokenNameCOMMENT_LINE(1001),
							TokenNameCOMMENT_BLOCK(1002),
							TokenNameCOMMENT_JAVADOC(1003),
							TokenNameSingleQuoteStringLiteral(1004),
							TokenNameCOMMENT_MARKDOWN(1005),

	// BEGIN_AUTOGENERATED_REGION
							TokenNameIdentifier(27),
							TokenNameabstract(52),
							TokenNameassert(91),
							TokenNameboolean(104),
							TokenNamebreak(92),
							TokenNamebyte(105),
							TokenNamecase(106),
							TokenNamecatch(107),
							TokenNamechar(108),
							TokenNameclass(70),
							TokenNamecontinue(93),
							TokenNameconst(136),
							TokenNamedefault(87),
							TokenNamedo(94),
							TokenNamedouble(109),
							TokenNameelse(118),
							TokenNameenum(84),
							TokenNameextends(103),
							TokenNamefalse(40),
							TokenNamefinal(53),
							TokenNamefinally(117),
							TokenNamefloat(110),
							TokenNamefor(95),
							TokenNamegoto(137),
							TokenNameif(96),
							TokenNameimplements(132),
							TokenNameimport(111),
							TokenNameinstanceof(14),
							TokenNameint(112),
							TokenNameinterface(83),
							TokenNamelong(113),
							TokenNamenative(54),
							TokenNamenew(36),
							TokenNamenon_sealed(55),
							TokenNamenull(41),
							TokenNamepackage(102),
							TokenNameprivate(56),
							TokenNameprotected(57),
							TokenNamepublic(58),
							TokenNamereturn(97),
							TokenNameshort(114),
							TokenNamestatic(38),
							TokenNamestrictfp(59),
							TokenNamesuper(34),
							TokenNameswitch(63),
							TokenNamesynchronized(39),
							TokenNamethis(35),
							TokenNamethrow(88),
							TokenNamethrows(119),
							TokenNametransient(60),
							TokenNametrue(42),
							TokenNametry(98),
							TokenNamevoid(115),
							TokenNamevolatile(61),
							TokenNamewhile(89),
							TokenNamemodule(116),
							TokenNameopen(120),
							TokenNamerequires(121),
							TokenNametransitive(127),
							TokenNameexports(122),
							TokenNameopens(123),
							TokenNameto(133),
							TokenNameuses(124),
							TokenNameprovides(125),
							TokenNamewith(134),
							TokenNameIntegerLiteral(43),
							TokenNameLongLiteral(44),
							TokenNameFloatingPointLiteral(45),
							TokenNameDoubleLiteral(46),
							TokenNameCharacterLiteral(47),
							TokenNameStringLiteral(48),
							TokenNameTextBlock(49),
							TokenNamePLUS_PLUS(8),
							TokenNameMINUS_MINUS(9),
							TokenNameEQUAL_EQUAL(19),
							TokenNameLESS_EQUAL(15),
							TokenNameGREATER_EQUAL(16),
							TokenNameNOT_EQUAL(20),
							TokenNameLEFT_SHIFT(18),
							TokenNameRIGHT_SHIFT(12),
							TokenNameUNSIGNED_RIGHT_SHIFT(13),
							TokenNamePLUS_EQUAL(71),
							TokenNameMINUS_EQUAL(72),
							TokenNameMULTIPLY_EQUAL(73),
							TokenNameDIVIDE_EQUAL(74),
							TokenNameAND_EQUAL(75),
							TokenNameOR_EQUAL(76),
							TokenNameXOR_EQUAL(77),
							TokenNameREMAINDER_EQUAL(78),
							TokenNameLEFT_SHIFT_EQUAL(79),
							TokenNameRIGHT_SHIFT_EQUAL(80),
							TokenNameUNSIGNED_RIGHT_SHIFT_EQUAL(81),
							TokenNameOR_OR(26),
							TokenNameAND_AND(25),
							TokenNamePLUS(1),
							TokenNameMINUS(2),
							TokenNameNOT(64),
							TokenNameREMAINDER(5),
							TokenNameXOR(22),
							TokenNameAND(21),
							TokenNameMULTIPLY(4),
							TokenNameOR(23),
							TokenNameTWIDDLE(65),
							TokenNameDIVIDE(6),
							TokenNameGREATER(17),
							TokenNameLESS(7),
							TokenNameLPAREN(28),
							TokenNameRPAREN(29),
							TokenNameLBRACE(62),
							TokenNameRBRACE(33),
							TokenNameLBRACKET(11),
							TokenNameRBRACKET(101),
							TokenNameSEMICOLON(31),
							TokenNameQUESTION(24),
							TokenNameCOLON(82),
							TokenNameCOMMA(32),
							TokenNameDOT(3),
							TokenNameEQUAL(68),
							TokenNameAT(37),
							TokenNameELLIPSIS(128),
							TokenNameARROW(126),
							TokenNameCOLON_COLON(10),
							TokenNameBeginLambda(86),
							TokenNameBeginIntersectionCast(67),
							TokenNameBeginTypeArguments(99),
							TokenNameAT308(30),
							TokenNameAT308DOTDOTDOT(135),
							TokenNameCaseArrow(90),
							TokenNameRestrictedIdentifierYield(100),
							TokenNameRestrictedIdentifierrecord(85),
							TokenNameRestrictedIdentifiersealed(50),
							TokenNameRestrictedIdentifierpermits(129),
							TokenNameBeginCasePattern(130),
							TokenNameRestrictedIdentifierWhen(131),
							TokenNameUNDERSCORE(66),
							TokenNameRestrictedIdentifiervalue(51),
							TokenNameEOF(69),
							TokenNameERROR(138);

// END_AUTOGENERATED_REGION

	private final static Map<Integer, TerminalToken> tokenMap = new HashMap<>(256);
	static {
		for (TerminalToken t : TerminalToken.values()) {
			tokenMap.put(t.tokenNumber(), t);
		}
	}

	private final int tokenNumber;

	// Constructor
	TerminalToken(int number) {
		this.tokenNumber = number;
	}

	public int tokenNumber() {
		return this.tokenNumber;
	}

	public static boolean isRestrictedKeyword(TerminalToken tokenType) {
		return switch (tokenType) {
			case TokenNameRestrictedIdentifierYield, TokenNameRestrictedIdentifierrecord, TokenNameRestrictedIdentifierWhen,
					TokenNameRestrictedIdentifiersealed, TokenNameRestrictedIdentifierpermits,
					TokenNameRestrictedIdentifiervalue -> true;
			default -> false;
		};
	}

	public static TerminalToken getRestrictedKeyword(char [] text) {
		if (text != null) {
			int len = text.length;
			if (len == 4 && text[0] == 'w' ||
				len == 5 && text[0] == 'y' ||
				len == 6 && (text[0] == 'r' || text[0] == 's') ||
				len == 7 && text[0] == 'p') {
				return getRestrictedKeyword(new String(text));
			}
		}
		return TokenNameNotAToken;
	}

	public static TerminalToken getRestrictedKeyword(String text) {
		return switch (text) {
			case "yield"   -> TokenNameRestrictedIdentifierYield;   //$NON-NLS-1$
			case "record"  -> TokenNameRestrictedIdentifierrecord;  //$NON-NLS-1$
			case "when"    -> TokenNameRestrictedIdentifierWhen;    //$NON-NLS-1$
			case "sealed"  -> TokenNameRestrictedIdentifiersealed;  //$NON-NLS-1$
			case "permits" -> TokenNameRestrictedIdentifierpermits; //$NON-NLS-1$
			case "value" -> TokenNameRestrictedIdentifiervalue; //$NON-NLS-1$
			default        -> TokenNameNotAToken;
		};
	}

	public static TerminalToken of(int act) {
		TerminalToken token = tokenMap.get(act);
		if (token == null) {
			// Really shouldn't occur -- perhaps if parser non-terminals are looked up?
			throw new IllegalArgumentException("Unknown token number = " + act); //$NON-NLS-1$
		}
		return token;
	}

	static TerminalToken maybeOf(int act) {
		return tokenMap.get(act);
	}

}

