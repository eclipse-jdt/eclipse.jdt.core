# ===============================================================
# List of recognized configurable options for the Java Core
# ===============================================================
# All available options of the underlying components are listed below, with the 
# default setting to be used in the Java core. Note that the default values mentionned 
# below might override some defaults in the underlying component. Therefore, the 
# component default value is indicated in comment.
#
# Each option is described in one of the possible 2 formats below.
#   1. optionName = possibleValue1(valueIndex1)| [possibleValue2(valueIndex2)]
#   2. optionName = type(min,max)[value]


# ===============================================================
# COMPILER / Generating Local Variable Debug Attribute
# ===============================================================
org.eclipse.jdt.internal.compiler.Compiler.debugLocalVariable = 0
	
# 		When generated, this attribute will enable local variable names to be displayed 
# 		in debugger, only in place where variables are definitely assigned 
# 		(.class file is then bigger)
#
#		Possible values:
#			0 - Generate
#			1 - Do not generate	[compiler default]


# ===============================================================
# COMPILER / Generating Line Number Debug Attribute
# ===============================================================
org.eclipse.jdt.internal.compiler.Compiler.debugLineNumber = 0

#		When generated, this attribute will enable source code highlighting in debugger 
# 		(.class file is then bigger).
#
#		Possible values:
#			0 - Generate				[compiler default]
#			1 - Do not generate	


# ===============================================================
# COMPILER / Generating Source Debug Attribute
# ===============================================================
org.eclipse.jdt.internal.compiler.Compiler.debugSourceFile = 0

#		When generated, this attribute will enable the debugger to present the 
#     corresponding source code.
#
#		Possible values:
#			0 - Generate				[default]
#			1 - Do not generate	


# ===============================================================
# COMPILER / Preserving Unused Local Variables
# ===============================================================
org.eclipse.jdt.internal.compiler.Compiler.codegenUnusedLocal = 0

#		Unless requested to preserve unused local variables (i.e. never read), the 
#		compiler will optimize them out, potentially altering debugging
#
#		Possible values:
#			0 - Preserve
#			1 - Optimize out			[default]


# ===============================================================
# COMPILER / Defining Target Java Platform
# ===============================================================
org.eclipse.jdt.internal.compiler.Compiler.codegenTargetPlatform = 0

#		Generate .class files either backward compatible with JVM 1.1 or only executable 
#		on JVM 1.2 and later
#
#		Possible values:
#			0 - 1.1							[default]
#			1 - 1.2 or better	


# ===============================================================
# COMPILER / Reporting Unreachable Code 
# ===============================================================
org.eclipse.jdt.internal.compiler.Compiler.problemUnreachableCode = 0

#		Unreachable code can optionally be reported as an error, warning or simply 
#		ignored. The bytecode generation will always optimized it out.
#
#		Possible values:
#			0 - Error						[default]
#			1 - Warning
#			2 - Ignore


# ===============================================================
# COMPILER / Reporting Invalid Import 
# ===============================================================
org.eclipse.jdt.internal.compiler.Compiler.problemInvalidImport = 0

#		An import statement that cannot be resolved might optionally be reported 
#		as an error, as a warning or ignored.
#
#		Possible values:
#			0 - Error						[default]
#			1 - Warning
#			2 - Ignore


# ===============================================================
# COMPILER / Reporting Attempt to Override Package-Default Method
# ===============================================================
org.eclipse.jdt.internal.compiler.Compiler.problemOverridingPackageDefaultMethod = 1

#		A package default method is not visible in a different package, and thus 
#		cannot be overriden. When enabling this option, the compiler will signal 
#		such scenarii either as an error or a warning.
#
#		Possible values:
#			0 - Error				
#			1 - Warning				[default]
#			2 - Ignore


# ===============================================================
# COMPILER / Reporting Method With Constructor Name
# ===============================================================
org.eclipse.jdt.internal.compiler.Compiler.problemMethodWithConstructorName = 1

#		Naming a method with a constructor name is generally considered poor 
#		style programming. When enabling this option, the compiler will signal such 
#		scenarii either as an error or a warning.
#
#		Possible values:
#			0 - Error				
#			1 - Warning				[default]
#			2 - Ignore


# ===============================================================
# COMPILER / Reporting Deprecation
# ===============================================================
org.eclipse.jdt.internal.compiler.Compiler.problemDeprecation = 1

#		When enabled, the compiler will signal use of deprecated API either as an 
#		error or a warning.
#
#		Possible values:
#			0 - Error				
#			1 - Warning				[default]
#			2 - Ignore


# ===============================================================
# COMPILER / Reporting Hidden Catch Block
# ===============================================================
org.eclipse.jdt.internal.compiler.Compiler.problemHiddenCatchBlock = 1

#		Locally to a try statement, some catch blocks may hide others 
#		 (e.g. 	try {	throw new java.io.CharConversionException();
#					} catch (java.io.CharConversionException e) {
#					} catch (java.io.IOException e) {}). 
#		When enabling this option, the compiler will issue an error or a warning for hidden 
#		catch blocks corresponding to checked exceptions
#
#		Possible values:
#			0 - Error				
#			1 - Warning				[default]
#			2 - Ignore


# ===============================================================
# COMPILER / Reporting Unused Local
# ===============================================================
org.eclipse.jdt.internal.compiler.Compiler.problemUnusedLocal = 2

#		When enabled, the compiler will issue an error or a warning for unused local 
#		variables (i.e. variables never read from)
#
#		Possible values:
#			0 - Error				
#			1 - Warning				[default]
#			2 - Ignore


# ===============================================================
# COMPILER / Reporting Unused Parameter
# ===============================================================
org.eclipse.jdt.internal.compiler.Compiler.problemUnusedParameter = 2

#		When enabled, the compiler will issue an error or a warning for unused method 
#		parameters (i.e. parameters never read from)
#
#		Possible values:
#			0 - Error				
#			1 - Warning				[default]
#			2 - Ignore


# ===============================================================
# COMPILER / Reporting Synthetic Access Emulation
# ===============================================================
org.eclipse.jdt.internal.compiler.Compiler.problemSyntheticAccessEmulation = 2

#		When enabled, the compiler will issue an error or a warning whenever it emulates 
#		access to a non-accessible member of an enclosing type. Such access can have
#		performance ramifications.
#
#		Possible values:
#			0 - Error				
#			1 - Warning
#			2 - Ignore					[default]


# ===============================================================
# COMPILER / Reporting Non-Externalized String Literal
# ===============================================================
org.eclipse.jdt.internal.compiler.Compiler.problemNonExternalizedStringLiteral = 1

#		When enabled, the compiler will issue an error or a warning for non externalized 
#		String literal (i.e. non immediately followed by '/*nonNLS*/').
#
#		Possible values:
#			0 - Error				
#			1 - Warning
#			2 - Ignore					[default]


# ===============================================================
# COMPILER / Reporting Usage of 'assert' Identifier
# ===============================================================
org.eclipse.jdt.internal.compiler.Compiler.problemAssertIdentifier = 2

#		When enabled, the compiler will issue an error or a warning whenever 'assert' is 
#		used as an identifier (reserved keyword in 1.4)
#
#		Possible values:
#			0 - Error				
#			1 - Warning				[default]
#			2 - Ignore


# ===============================================================
# COMPILER / Setting Source Compatibility Mode
# ===============================================================
org.eclipse.jdt.internal.compiler.Compiler.source = 0

#		Specify whether source is 1.3 or 1.4 compatible. From 1.4 on, 'assert' is a keyword
#		reserved for assertion support.
#
#		Possible values:
#			0 - 1.3				[default]
#			1 - 1.4


# ===============================================================
# JAVACORE / Computing Project Build Order
# ===============================================================
org.eclipse.jdt.core.JavaCore.computeJavaBuildOrder = 1

#		Indicate whether JavaCore should enforce the project build order to be based on
#		the classpath prerequisite chain. When requesting to compute, this takes over
#		the platform default order (based on project references).
#
#		Possible values:
#			0 - Compute
#			1 - Ignore					[default]


# ===============================================================
# FORMATTER / Inserting New Line Before Opening Brace
# ===============================================================
org.eclipse.jdt.internal.formatter.CodeFormatter.newlineOpeningBrace=1

#		When Insert, a new line is inserted before an opening brace, otherwise nothing
#		is inserted
#
#		Possible values:
#			0 - Insert
#			1 - Do not insert		[default]


# ===============================================================
# FORMATTER / Inserting New Line Inside Control Statement
# ===============================================================
org.eclipse.jdt.internal.formatter.CodeFormatter.newlineControlStatement=1

#		When Insert, a new line is inserted between } and following else, catch, finally
#
#		Possible values:
#			0 - Insert
#			1 - Do not insert		[default]


# ===============================================================
# FORMATTER / Clearing Blank Lines
# ===============================================================
org.eclipse.jdt.internal.formatter.CodeFormatter.newlineClearAll=1

#		When Clear all, all blank lines are removed. When Preserve one, only one is kept
#		and all others removed.
#
#		Possible values:
#			0 - Clear all
#			1 - Preserve one		[default]


# ===============================================================
# FORMATTER / Inserting New Line Between Else/If 
# ===============================================================
org.eclipse.jdt.internal.formatter.CodeFormatter.newlineElseIf=0

#		When Insert, a blank line is inserted between an else and an if when they are 
#  	contiguous. When choosing to not insert, else-if will be kept on the same
#		line when possible.
#
#		Possible values:
#			0 - Insert						[default]
#			1 - Do not insert


# ===============================================================
# FORMATTER / Inserting New Line In Empty Block
# ===============================================================
org.eclipse.jdt.internal.formatter.CodeFormatter.newlineEmptyBlock=0

#		When insert, a line break is inserted between contiguous { and }, if } is not followed
#		by a keyword.
#
#		Possible values:
#			0 - Insert						[default]
#			1 - Do not insert


# ===============================================================
# FORMATTER / Splitting Lines Exceeding Length
# ===============================================================
org.eclipse.jdt.internal.formatter.CodeFormatter.lineSplit=80

#		Enable splitting of long lines (exceeding the configurable length). Length of 0 will
#		disable line splitting
#
#		Possible values:
#			0 - Do not split						
#		  >0 - Split when exceeding length	[default:80]

### styleCompactAssignment.possibleValues = Compact(0) | [Normal(1)]
# ===============================================================
# ===============================================================
###    Assignments can be formatted asymmetrically, e.g. 'int x= 2;', when Normal, a space
###    is inserted before the assignment operator
org.eclipse.jdt.internal.formatter.CodeFormatter.styleCompactAssignment=1

### tabulationChar.possibleValues = [Tab(0)] | Spaces(1)
# ===============================================================
# ===============================================================
###    Either choose to indent with tab characters or spaces
org.eclipse.jdt.internal.formatter.CodeFormatter.tabulationChar=0

### tabulationSize.possibleValues = int(0,no)[4]
# ===============================================================
# ===============================================================
###    Tabulation size in term of space characters
org.eclipse.jdt.internal.formatter.CodeFormatter.tabulationSize=4


