/*******************************************************************************
 * Copyright (c) 2000, 2022 IBM Corporation and others.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *     Stephan Herrmann - Contribution for
 *								bug 383690 - [compiler] location of error re uninitialized final field should be aligned
 *								bug 388800 - [1.8] adjust tests to 1.8 JRE
 *								bug 388795 - [compiler] detection of name clash depends on order of super interfaces
 *								bug 388739 - [1.8][compiler] consider default methods when detecting whether a class needs to be declared abstract
 *								bug 395681 - [compiler] Improve simulation of javac6 behavior from bug 317719 after fixing bug 388795
 *								bug 406928 - computation of inherited methods seems damaged (affecting @Overrides)
 *								Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
 *								Bug 424286 - [1.8] Update type inference to spec version 0.9.1
 *								Bug 426676 - [1.8][compiler] Wrong generic method type inferred from lambda expression
 *								Bug 423505 - [1.8] Implement "18.5.4 More Specific Method Inference"
 *								Bug 434483 - [1.8][compiler][inference] Type inference not picked up with method reference
 *     Harry Terkelsen - Bug 460491 - NPE in ParameterizedTypeBinding.collectSubstitutes
 *******************************************************************************/
package org.eclipse.jdt.core.tests.compiler.regression;

import static java.lang.Math.abs;
import static java.util.stream.Collectors.toList;

import java.io.File;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Consumer;
import java.util.function.IntFunction;
import java.util.stream.IntStream;

import junit.framework.Test;

import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jdt.core.ToolFactory;
import org.eclipse.jdt.core.tests.util.Util;
import org.eclipse.jdt.core.util.ClassFileBytesDisassembler;
import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;

@SuppressWarnings({ "unchecked", "rawtypes" })
public class GenericTypeTest extends AbstractComparableTest {

	public GenericTypeTest(String name) {
		super(name);
	}

	// Static initializer to specify tests subset using TESTS_* static variables
	// All specified tests which does not belong to the class are skipped...
	static {
//		TESTS_NAMES = new String[] { "test0593" };
//		TESTS_NUMBERS = new int[] { 470, 627 };
//		TESTS_RANGE = new int[] { 1097, -1 };
	}
	public static Test suite() {
		return buildComparableTestSuite(testClass());
	}

	public static Class testClass() {
		return GenericTypeTest.class;
	}

	@Override
	protected Map getCompilerOptions() {
		Map options = super.getCompilerOptions();
		options.put(CompilerOptions.OPTION_ReportMissingOverrideAnnotationForInterfaceMethodImplementation, CompilerOptions.DISABLED);
		options.put(CompilerOptions.OPTION_ReportUnusedLocal, CompilerOptions.IGNORE);
		options.put(CompilerOptions.OPTION_ReportUnusedParameter, CompilerOptions.IGNORE);
		options.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.IGNORE);
		options.put(CompilerOptions.OPTION_ReportUnusedTypeParameter, CompilerOptions.IGNORE);
		return options;
	}

	public void test0001() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<Tx1 extends String, Tx2 extends Comparable>  extends XS<Tx2> {
					
					    public static void main(String[] args) {
					        Integer w = new X<String,Integer>().get(new Integer(12));
					        System.out.println("SUCCESS");
					    }
					}
					class XS <Txs> {
					    Txs get(Txs t) {
					        return t;
					    }
					}
					"""
			},
			"SUCCESS");
	}

	public void test0002() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<Xp1 extends String, Xp2 extends Comparable>  extends XS<Xp2> {
					
					    public static void main(String[] args) {
					        Integer w = new X<String,Integer>().get(new Integer(12));
					        System.out.println("SUCCESS");
					    }
					    Xp2 get(Xp2 t){
					        System.out.print("{X::get}");
					        return super.get(t);
					    }
					}
					
					class XS <XSp1> {
					    XSp1 get(XSp1 t) {
					        System.out.print("{XS::get}");
					        return t;
					    }
					}
					"""
			},
			"{X::get}{XS::get}SUCCESS");
	}

	// check cannot bind superclass to type variable
	public void test0003() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"public class X <X> extends X {\n" +
				"}\n",
			},
			"""
				----------
				1. WARNING in X.java (at line 1)
					public class X <X> extends X {
					                ^
				The type parameter X is hiding the type X<X>
				----------
				2. ERROR in X.java (at line 1)
					public class X <X> extends X {
					                           ^
				Cannot refer to the type parameter X as a supertype
				----------
				""");
	}

	// check cannot bind superinterface to type variable
	public void test0004() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"public class X <X> implements X {\n" +
				"}\n",
			},
			"""
				----------
				1. WARNING in X.java (at line 1)
					public class X <X> implements X {
					                ^
				The type parameter X is hiding the type X<X>
				----------
				2. ERROR in X.java (at line 1)
					public class X <X> implements X {
					                              ^
				Cannot refer to the type parameter X as a supertype
				----------
				""");
	}

	// check cannot bind type variable in static context
	public void test0005() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
					   \s
					    T t;
					    static {
					        T s;
					    }
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 5)
					T s;
					^
				Cannot make a static reference to the non-static type T
				----------
				""");
	}

	// check static references to type variables
	public void test0006() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
					   \s
					    T ok1;
					    static {
					        T wrong1;
					    }
					    static void foo(T wrong2) {
							T wrong3;
					    }
					    class MX extends T {
					        T ok2;
					    }
					    static class SMX extends T {
					        T wrong4;
					    }
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 5)
					T wrong1;
					^
				Cannot make a static reference to the non-static type T
				----------
				2. ERROR in X.java (at line 7)
					static void foo(T wrong2) {
					                ^
				Cannot make a static reference to the non-static type T
				----------
				3. ERROR in X.java (at line 8)
					T wrong3;
					^
				Cannot make a static reference to the non-static type T
				----------
				4. ERROR in X.java (at line 10)
					class MX extends T {
					                 ^
				Cannot refer to the type parameter T as a supertype
				----------
				5. ERROR in X.java (at line 13)
					static class SMX extends T {
					                         ^
				Cannot make a static reference to the non-static type T
				----------
				6. ERROR in X.java (at line 14)
					T wrong4;
					^
				Cannot make a static reference to the non-static type T
				----------
				""");
	}

	// check static references to type variables
	public void test0007() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
					   \s
					    T ok1;
					    static class SMX {
					        T wrong4;
					    }
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 5)
					T wrong4;
					^
				Cannot make a static reference to the non-static type T
				----------
				""");
	}

	// check static references to type variables
	public void test0008() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
					   \s
					     T ok;
					    static T wrong;
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					static T wrong;
					       ^
				Cannot make a static reference to the non-static type T
				----------
				""");
	}

	// Object cannot be generic
	public void test0009() {
		this.runNegativeTest(
			new String[] {
				"Object.java",
				"""
					package java.lang;
					public class Object <T> {
					}
					""",
			},
			"""
				----------
				1. ERROR in Object.java (at line 2)
					public class Object <T> {
					                     ^
				The type java.lang.Object cannot be declared as a generic
				----------
				""");
	}

	public void test0010() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					class Foo {}\s
					public class X<T extends Object & Comparable<? super T>> {
					    public static void main(String[] args) {
					        new X<Foo>();
					    }
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					new X<Foo>();
					      ^^^
				Bound mismatch: The type Foo is not a valid substitute for the bounded parameter <T extends Object & Comparable<? super T>> of the type X<T>
				----------
				""");
	}

	public void test0011() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T extends Object & Comparable<? super T>> {
					    public static void main(String[] args) {
					        new X<Foo>();
					    }
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					new X<Foo>();
					      ^^^
				Foo cannot be resolved to a type
				----------
				""");
	}

	public void test0012() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends String> {
					    T foo(T t) {
					        return t;
					    }
					   \s
					    public static void main(String[] args) {
					        String s = new X<String>().foo("SUCCESS");
					        System.out.println(s);
					    }
					}
					""",
			},
			"SUCCESS");
	}

	public void test0013() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends String> {
					    T foo(T t) {
					        return t;
					    }
					    public static void main(String[] args) {
					        new X<String>().baz("SUCCESS");
					    }
					    void baz(final T t) {
					        new Object() {
					            void print() {
					                System.out.println(foo(t));
					            }
					        }.print();
					    }
					}
					""",
			},
			"SUCCESS");
	}

	public void test0014() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends Exception> {
					    T foo(T t) throws T {
					        return t;
					    }
					    public static void main(String[] args) {
					        new X<EX>().baz(new EX());
					    }
					    void baz(final T t) {
					        new Object() {
					            void print() {
					                System.out.println(foo(t));
					            }
					        }.print();
					    }
					}
					class EX extends Exception {
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 11)
					System.out.println(foo(t));
					                   ^^^^^^
				Unhandled exception type T
				----------
				2. WARNING in X.java (at line 16)
					class EX extends Exception {
					      ^^
				The serializable class EX does not declare a static final serialVersionUID field of type long
				----------
				""");
	}
	public void test0015() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends Exception> {
					    String foo() throws T {
					        return "SUCCESS";
					    }
					    public static void main(String[] args) {
					        new X<EX>().baz(new EX());
					    }
					    void baz(final T t) {
					        new Object() {
					            void print() {
					                try {
						                System.out.println(foo());
					                } catch (Exception t) {
					                }
					            }
					        }.print();
					    }
					}
					class EX extends Exception {
					}
					""",
			},
			"SUCCESS");
	}

	public void test0016() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <E extends Exception> {
					    void foo(E e) throws E {
					        throw e;
					    }
					    void bar(E e) {
					        try {
					            foo(e);
					        } catch(Exception ex) {
						        System.out.println("SUCCESS");
					        }
					    }
					    public static void main(String[] args) {
					        new X<Exception>().bar(new Exception());
					    }
					}
					""",
			},
			"SUCCESS");
	}
	public void test0017() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.io.IOException;
					public class X <E extends Exception> {
					    void foo(E e) throws E {
					        throw e;
					    }
					    void bar(E e) {
					        try {
					            foo(e);
					        } catch(Exception ex) {
						        System.out.println("SUCCESS");
					        }
					    }
					    public static void main(String[] args) {
					        new X<IOException>().bar(new Exception());
					    }
					}
					""" ,
			},
			"""
				----------
				1. ERROR in X.java (at line 14)
					new X<IOException>().bar(new Exception());
					                     ^^^
				The method bar(IOException) in the type X<IOException> is not applicable for the arguments (Exception)
				----------
				""");
	}
	public void test0018() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
					    T foo(T t) {
					        System.out.println(t);
					        return t;
					    }
					    public static void main(String[] args) {
					        new X<XY>() {
					            void run() {
					                foo(new XY());
					            }
					        }.run();
					    }
					}
					class XY {
					    public String toString() {
					        return "SUCCESS";
					    }
					}
					""",
			},
			"SUCCESS");
	}
	public void test0019() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
					     private T foo(T t) {
					        System.out.println(t);
					        return t;
					    }
					    public static void main(String[] args) {
					        new X<XY>() {
					            void run() {
					                foo(new XY());
					            }
					        }.run();
					    }
					}
					class XY {
					    public String toString() {
					        return "SUCCESS";
					    }
					}""",
			},
			"""
				----------
				1. ERROR in X.java (at line 9)
					foo(new XY());
					^^^
				The method foo(T) in the type X<T> is not applicable for the arguments (XY)
				----------
				2. WARNING in X.java (at line 15)
					public String toString() {
					              ^^^^^^^^^^
				The method toString() of type XY should be tagged with @Override since it actually overrides a superclass method
				----------
				""");
	}
	public void test0020() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
					     void foo(Y<T> y) {
							System.out.print("SUCC");
					    }
					    public static void main(String[] args) {
					        new X<String>().bar();
					    }
					    void bar() {
					        new Y<T>() {
					            @Override
					            public void pre() {
					                foo(this);
					            }
					        }.print("ESS");
					    }
					}
					class Y <P> {
						public void print(P p) {
							pre();
							System.out.println(p);
						}
						public void pre() {
						}
					}""",
			},
			"""
				----------
				1. ERROR in X.java (at line 14)
					}.print("ESS");
					  ^^^^^
				The method print(T) in the type Y<T> is not applicable for the arguments (String)
				----------
				""");
	}
	public void test0021() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends String> {
					    void foo(T t) {
					    }
					    void bar(String x) {
					        foo(x);
					    }
					    public static void main(String[] args) {
					        new X<String>().foo(new Object());
					    }
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 1)
					public class X <T extends String> {
					                          ^^^^^^
				The type parameter T should not be bounded by the final type String. Final types cannot be further extended
				----------
				2. ERROR in X.java (at line 5)
					foo(x);
					^^^
				The method foo(T) in the type X<T> is not applicable for the arguments (String)
				----------
				3. ERROR in X.java (at line 8)
					new X<String>().foo(new Object());
					                ^^^
				The method foo(String) in the type X<String> is not applicable for the arguments (Object)
				----------
				""");
	}

	public void test0022() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends String> {
					    X(T t) {
					        System.out.println(t);
					    }
					   \s
					    public static void main(String[] args) {
					       new X<String>("SUCCESS");
					    }
					}
					""",
			},
			"SUCCESS");
	}

	public void test0023() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends String> {
					    X(final T t) {
					        new Object() {
					            void print() {
					                System.out.println(t);
					            }
					        }.print();
					    }
					    public static void main(String[] args) {
					        new X<String>("SUCCESS");
					    }
					}
					""",
			},
			"SUCCESS");
	}

	public void test0024() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends Exception> {
					    X(final T t) throws T {
					        new Object() {
					            void print() {
					                System.out.println(t);
					            }
					        }.print();
					    }
					    public static void main(String[] args) {
					        new X<EX>(new EX());
					    }
					}
					class EX extends Exception {
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 10)
					new X<EX>(new EX());
					^^^^^^^^^^^^^^^^^^^
				Unhandled exception type EX
				----------
				2. WARNING in X.java (at line 13)
					class EX extends Exception {
					      ^^
				The serializable class EX does not declare a static final serialVersionUID field of type long
				----------
				""");
	}

	public void test0025() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends Exception> {
					    String foo() throws T {
					        return "SUCCESS";
					    }
					    public static void main(String[] args) {
					        new X<EX>(new EX());
					    }
					    X(final T t) {
					        new Object() {
					            void print() {
					                try {
						                System.out.println(foo());
					                } catch (Exception t) {
					                }
					            }
					        }.print();
					    }
					}
					class EX extends Exception {
					}
					""",
			},
			"SUCCESS");
	}

	public void test0026() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <E extends Exception> {
					    void foo(E e) throws E {
					        throw e;
					    }
					    X(E e) {
					        try {
					            foo(e);
					        } catch(Exception ex) {
						        System.out.println("SUCCESS");
					        }
					    }
					    public static void main(String[] args) {
					        new X<Exception>(new Exception());
					    }
					}
					""",
			},
			"SUCCESS");
	}
	public void test0027() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.io.IOException;
					public class X <E extends Exception> {
					    void foo(E e) throws E {
					        throw e;
					    }
					    X(E e) {
					        try {
					            foo(e);
					        } catch(Exception ex) {
						        System.out.println("SUCCESS");
					        }
					    }
					    public static void main(String[] args) {
					        new X<IOException>(new Exception());
					    }
					}
					""" ,
			},
			"""
				----------
				1. ERROR in X.java (at line 14)
					new X<IOException>(new Exception());
					^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				The constructor X<IOException>(Exception) is undefined
				----------
				""");
	}

	public void test0028() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
					    T t;
					    X(T t) {
					        this.t = t;
					    }
					    public static void main(String[] args) {
					        String s = new X<String>("SU").t;
					        System.out.print(s);
					        s = new X<String>("failed").t = "CC";
					        System.out.print(s);
					        s = new X<String>("").t += "ESS";
					        System.out.println(s);
					    }
					}
					""",
			},
			"SUCCESS");
	}

	public void test0029() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
					    T t;
					    X() {
					    }
					    T foo(T a, T b) {
					        T s;
					        s = t = a;
							s = t += b;
							return t;
					    }
					    public static void main(String[] args) {
					        System.out.println(new X<String>().foo("SUC", "CESS"));
					    }
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 8)
					s = t += b;
					    ^^^^^^
				The operator += is undefined for the argument type(s) T, T
				----------
				""");
	}

	public void test0030() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
					    T t;
					    X() {
					    }
					    T foo(T a) {
					        T s;
					        s = t = a;
							return t;
					    }
					    public static void main(String[] args) {
					        System.out.println(new X<String>().foo("SUCCESS"));
					    }
					}
					""" ,
			},
			"SUCCESS");
	}

	public void test0031() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
					    T t;
					    X(T t) {
					        this.t = t;
					    }
					    public static void main(String[] args) {
					        new X<String>("OUTER").bar();
					    }
					    void bar() {
					        new X<String>("INNER") {
					            void run() {
					               \s
					                new Object() {
					                    void run() {
							                String s = t = "SUC";
							                s = t+= "CESS";
									        System.out.println(t);
					                    }
					                }.run();
					            }
					        }.run();
					    }
					}
					""" ,
			},
			"SUCCESS");
	}

	public void test0032() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
					    T t;
					    X(T t) {
					        this.t = t;
					    }
					    public static void main(String[] args) {
					        new X<String>("OUTER").bar();
					    }
					    void bar() {
					        new X<String>("INNER") {
					            void run() {
					                String s = t = "SUC";
					                s = t+= "CESS";
							        System.out.println(t);
					            }
					        }.run();
					    }
					}
					""" ,
			},
			"SUCCESS");
	}

	public void test0033() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <E, T> {
						void foo(E e){}
						void foo(T t){}
					}
					""" ,
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					void foo(E e){}
					     ^^^^^^^^
				Erasure of method foo(E) is the same as another method in type X<E,T>
				----------
				2. ERROR in X.java (at line 3)
					void foo(T t){}
					     ^^^^^^^^
				Erasure of method foo(T) is the same as another method in type X<E,T>
				----------
				""");
	}

	public void test0034() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <E extends Exception, T extends Exception> {
						void foo(E e){}
						void foo(T t){}
					}
					""" ,
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					void foo(E e){}
					     ^^^^^^^^
				Erasure of method foo(E) is the same as another method in type X<E,T>
				----------
				2. ERROR in X.java (at line 3)
					void foo(T t){}
					     ^^^^^^^^
				Erasure of method foo(T) is the same as another method in type X<E,T>
				----------
				""");
	}

	public void test0035() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <E extends Exception, T extends Thread> {
						void foo(E e, Thread t){}
						void foo(Exception e, T t){}
					}
					""" ,
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					void foo(E e, Thread t){}
					     ^^^^^^^^^^^^^^^^^^
				Erasure of method foo(E, Thread) is the same as another method in type X<E,T>
				----------
				2. ERROR in X.java (at line 3)
					void foo(Exception e, T t){}
					     ^^^^^^^^^^^^^^^^^^^^^
				Erasure of method foo(Exception, T) is the same as another method in type X<E,T>
				----------
				""");
	}

	public void test0036() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <E extends Exception, T extends Thread> {
						void foo(E e){}
						void foo(T t){}
					    public static void main(String[] args) {
							 System.out.println("SUCCESS");
					    }
					}
					""" ,
			},
			"SUCCESS");
	}

	public void test0037() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <E extends Cloneable, T extends Thread & Cloneable> {
						void foo(E e){}
						void foo(T t){}
					    public static void main(String[] args) {
							 System.out.println("SUCCESS");
					    }
					}
					""" ,
			},
			"SUCCESS");
	}

	public void test0038() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <E extends Cloneable, T extends Thread & Cloneable> {
						void foo(E e){}
						void foo(T t){}
						public static void main(String[] args) {
							X<XY,XY> x = new X<XY, XY>();
							x.foo(new XY());
						}
					}
					class XY extends Thread implements Cloneable {
					}
					""" ,
			},		"""
				----------
				1. ERROR in X.java (at line 6)
					x.foo(new XY());
					  ^^^
				The method foo(XY) is ambiguous for the type X<XY,XY>
				----------
				""");
	}

	public void test0039() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <E extends Cloneable, T extends Thread> {
						void foo(L<E> l1){}
						void foo(L<T> l2){}
						void foo(L l){}
					}
					
					class L<E> {
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					void foo(L<E> l1){}
					     ^^^^^^^^^^^^
				Erasure of method foo(L<E>) is the same as another method in type X<E,T>
				----------
				2. ERROR in X.java (at line 3)
					void foo(L<T> l2){}
					     ^^^^^^^^^^^^
				Erasure of method foo(L<T>) is the same as another method in type X<E,T>
				----------
				3. ERROR in X.java (at line 4)
					void foo(L l){}
					     ^^^^^^^^
				Erasure of method foo(L) is the same as another method in type X<E,T>
				----------
				4. WARNING in X.java (at line 4)
					void foo(L l){}
					         ^
				L is a raw type. References to generic type L<E> should be parameterized
				----------
				""");
	}

	public void test0040() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends X> {
					    public static void main(String[] args) {
					        System.out.println("SUCCESS");
					    }   \s
					}
					""",
			},
			"SUCCESS");
	}

	public void test0041() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T, U extends T> {
					    public static void main(String[] args) {
					        System.out.println("SUCCESS");
					    }   \s
					}
					""",
			},
			"SUCCESS");
	}

	// **
	public void test0042() {
		String[] test = new String[] {
			"X.java",
			"public class X <T extends U, U> {}"
		};
		if (this.complianceLevel < ClassFileConstants.JDK1_7) {
			this.runNegativeTest(
				test,
				"""
					----------
					1. ERROR in X.java (at line 1)
						public class X <T extends U, U> {}
						                ^
					Illegal forward reference to type parameter U
					----------
					""");
		} else {
			this.runConformTest(test, "");
		}
	}

	public void test0043() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends L<T> , U extends T> {
					    public static void main(String[] args) {
					        System.out.println("SUCCESS");
					    }
					}
					class L<E>{}
					""",
			},
			"SUCCESS");
	}

	public void test0044() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X extends L<X> {
					    public static void main(String[] args) {
					        System.out.println("SUCCESS");
					    }   \s
					}
					class L<E> {}
					""",
			},
			"SUCCESS");
	}

	public void test0045() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					    public Z<T> var;
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					public Z<T> var;
					       ^
				Z cannot be resolved to a type
				----------
				2. ERROR in X.java (at line 2)
					public Z<T> var;
					         ^
				T cannot be resolved to a type
				----------
				""");
	}
	public void test0046() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					    public Object<T> var;
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					public Object<T> var;
					       ^^^^^^
				The type Object is not generic; it cannot be parameterized with arguments <T>
				----------
				2. ERROR in X.java (at line 2)
					public Object<T> var;
					              ^
				T cannot be resolved to a type
				----------
				""");
	}
	public void test0047() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
					    private T t;
					    X(T t) {
					        this.t = t;
					    }
					    public static void main(String[] args) {
					        new X<String>("OUTER").bar();
					    }
					    void bar() {
					        new MX<String>("INNER") {
					            void run() {
					               \s
					                new Object() {
					                    void run() {
							                String s = t = "SUC";
							                s = t+= "CESS";
									        System.out.println(t);
					                    }
					                }.run();
					            }
					        }.run();
					    }
					}
					class MX<U> {
					    MX(U u){}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 15)
					String s = t = "SUC";
					           ^^^^^^^^^
				Type mismatch: cannot convert from T to String
				----------
				2. ERROR in X.java (at line 15)
					String s = t = "SUC";
					               ^^^^^
				Type mismatch: cannot convert from String to T
				----------
				3. ERROR in X.java (at line 16)
					s = t+= "CESS";
					    ^^^^^^^^^^
				The operator += is undefined for the argument type(s) T, String
				----------
				""");
	}
	// Access to enclosing 't' of type 'T' (not substituted from X<X> as private thus non inherited)
	public void test0048() {
		this.runNegativeTest(
			// test directory preparation
			new String[] { /* test files */
				"X.java",
				"""
					public class X <T> {
					    private T t;
					    X(T t) {
					        this.t = t;
					    }
					    public static void main(String[] args) {
					        new X<String>("OUTER").bar();
					    }
					    void bar() {
					        new X<X>(this) {
					            void run() {
					                new Object() {
					                    void run() {
					                        X x = t;
									        System.out.println(x);
					                    }
					                }.run();
					            }
					        }.run();
					    }
					}
					""",
			},
			// compiler results
			"----------\n" + /* expected compiler log */
			"1. WARNING in X.java (at line 10)\n" +
			"	new X<X>(this) {\n" +
			"	      ^\n" +
			"X is a raw type. References to generic type X<T> should be parameterized\n" +
			"----------\n" +
			"2. WARNING in X.java (at line 14)\n" +
			"	X x = t;\n" +
			"	^\n" +
			"X is a raw type. References to generic type X<T> should be parameterized\n" +
			"----------\n" +
			"3. ERROR in X.java (at line 14)\n" +
			"	X x = t;\n" +
			"	      ^\n" +
			"Type mismatch: cannot convert from T to X\n" +
			"----------\n",
			// javac options
			JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
	}
	public void test0049() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
					    public T t;
					    X(T t) {
					        this.t = t;
					    }
					    public static void main(String[] args) {
					        new X<String>("OUTER").bar();
					    }
					    void bar() {
					        new X<X>(this) {
					            void run() {
					                new Object() {
					                    void run() {
					                        X x = t;
									        System.out.println("SUCCESS");
					                    }
					                }.run();
					            }
					        }.run();
					    }
					}
					""",
			},
			"SUCCESS");
	}
	public void test0050() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends N> {
						static class N {}\
					}
					class Y <T extends Y.N> {
						static class N {}\
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 1)
					public class X <T extends N> {
					                          ^
				N cannot be resolved to a type
				----------
				""");
	}
	public void test0050a() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					class Super {class M {}}
					public class X <T extends M> extends Super {}
					class Y <T extends Y.M> extends Super {}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					public class X <T extends M> extends Super {}
					                          ^
				M cannot be resolved to a type
				----------
				""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98504
	public void test0050b() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
						class M extends Y implements I {}
					}
					class Y {
						static interface I { void foo(); }
					}
					interface I {}
					"""
			},
			"");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98504 - variation
	public void test0050c() {
		this.runConformTest(
			new String[] {
				"Test.java",
				"""
					public class Test<T extends Test.InnerTest> implements Base<T> {
						static class InnerTest implements Inner {}
					}
					interface Base<T> {
						interface Inner {}
					}
					"""
			},
			"");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=101387
	public void test0050d() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<I, C extends I> {}
					class Y extends X<Y.M, Y.N> {
						static class M {}
						static class N extends M {}
					}
					"""
			},
			"");
	}
	public void test0051() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					class Super {class M {}}
					public class X extends Super {
						class N <T extends M> {}
						public static void main(String[] args) {
							System.out.println("SUCCESS");
						}
					}
					""",
			},
			"SUCCESS");
	}
	public void test0052() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T> extends p.A<T> {
						public static void main(String[] args) {
							System.out.println("SUCCESS");
						}
					}
					""",
				"p/A.java",
				"""
					package p;\s
					public class A<P> {
					}
					""",
			},
			"SUCCESS");
	}
	public void test0053() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T> extends p.A<T> {
					    protected T t;
					    X(T t) {
					        this.t = t;
					    }
					    public static void main(String[] args) {
					        new X<String>("OUTER").bar();
					    }
					    void bar() {
					        new X<X>(this) {
					            void run() {
					                new Object() {
					                    void run() {
					                        print(t);
					                    }
					                }.run();
					            }
					        }.run();
					    }
					}
					""",
				"p/A.java",
				"""
					package p;\s
					public class A<P> {
					    protected void print(P p) {
					        System.out.println("SUCCESS");
					    }
					}
					""",
			},
			"SUCCESS");
	}
	public void test0054() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T> extends p.A<T> {
					    protected T t;
					    X(T t) {
					        this.t = t;
					    }
					    public static void main(String[] args) {
					        new X<String>("OUTER").bar();
					    }
					    void bar() {
					        new X<X>(this) {
					            void run() {
					                new Object() {
					                    void run() {
					                        print(X.this.t);
					                    }
					                }.run();
					            }
					        }.run();
					    }
					}
					""",
				"p/A.java",
				"""
					package p;\s
					public class A<P> {
					    protected void print(P p) {
					        System.out.println("SUCCESS");
					    }
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 10)
					new X<X>(this) {
					      ^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				2. ERROR in X.java (at line 14)
					print(X.this.t);
					^^^^^
				The method print(X) in the type A<X> is not applicable for the arguments (T)
				----------
				""");
	}

	public void test0055() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T> extends p.A<T> {
					    protected T t;
					    X(T t) {
					        super(t);
					        this.t = t;
					    }
					    public static void main(String[] args) {
						  X<String> xs = new X<String>("SUCCESS");
						  System.out.println(xs.t);
					    }
					}
					""",
				"p/A.java",
				"""
					package p;\s
					public class A<P> {
						 protected P p;
					    protected A(P p) {
					       this.p = p;\s
					    }\s
					    protected void print(P p) {
					        System.out.println("SUCCESS");
					    }
					}
					""",
			},
			"SUCCESS");
	}

	public void test0056() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T> extends p.A<T> {
					    protected T t;
					    X(T t) {
					        super(t);
					        this.t = t;
					    }
					    public static void main(String[] args) {
						  X<String> xs = new X<String>("SUCCESS");
						  System.out.println((X)xs.t);
					    }
					}
					""",
				"p/A.java",
				"""
					package p;\s
					public class A<P> {
						 protected P p;
					    protected A(P p) {
					       this.p = p;\s
					    }\s
					    protected void print(P p) {
					        System.out.println("SUCCESS");
					    }
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 9)
					System.out.println((X)xs.t);
					                   ^^^^^^^
				Cannot cast from String to X
				----------
				----------
				1. WARNING in p\\A.java (at line 7)
					protected void print(P p) {
					                       ^
				The parameter p is hiding a field from type A<P>
				----------
				""");
	}

	public void test0057() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T> extends p.A<T> {
					    protected T t;
					    X(T t) {
					        super(t);
					        this.t = t;
					    }
					    public static void main(String[] args) {
						  X<X<String>> xs = new X<X<String>>(new X<String>("SUCCESS"));
						  System.out.println(xs.t.t);
					    }
					}
					""",
				"p/A.java",
				"""
					package p;\s
					public class A<P> {
						 protected P p;
					    protected A(P p) {
					       this.p = p;\s
					    }\s
					    protected void print(P p) {
					        System.out.println("SUCCESS");
					    }
					}
					""",
			},
			"SUCCESS");
	}

	// JSR14-v10[2.1,2.2]: Valid multiple parameter types
	public void test0058() {
		this.runConformTest(
			new String[] {
				"test/X.java",
				"""
					package test;
					// Valid Parameterized Type Declaration
					public class X<A1, A2, A3> {
					}
					// Valid Type Syntax
					class Y {
						X<String, Number, Integer> x;
					}
					"""
			}
		);
	}
	// JSR14-v10[2.1,2.2]: Invalid multiple parameter types: more declared than referenced
	public void test0059() {
		this.runNegativeTest(
			new String[] {
				"test/X.java",
				"""
					package test;
					// Valid Parameterized Type Declaration
					public class X<A1, A2, A3, A4> {
					}
					// Invalid Valid Type Syntax (not enough parameters)
					class Y {
						X<String, Number, Integer> x;
					}
					"""
			},
			"""
				----------
				1. ERROR in test\\X.java (at line 7)
					X<String, Number, Integer> x;
					^
				Incorrect number of arguments for type X<A1,A2,A3,A4>; it cannot be parameterized with arguments <String, Number, Integer>
				----------
				"""
		);
	}
	// JSR14-v10[2.1,2.2]: Invalid multiple parameter types: more referenced than declared
	public void test0060() {
		this.runNegativeTest(
			new String[] {
				"test/X.java",
				"""
					package test;
					// Valid Parameterized Type Declaration
					public class X<A1, A2> {
					}
					// Invalid Valid Type Syntax (too many parameters)
					class Y {
						X<String, Number, Integer> x;
					}
					"""
			},
			"""
				----------
				1. ERROR in test\\X.java (at line 7)
					X<String, Number, Integer> x;
					^
				Incorrect number of arguments for type X<A1,A2>; it cannot be parameterized with arguments <String, Number, Integer>
				----------
				"""
		);
	}
	// JSR14-v10[2.1,2.2]: Invalid multiple parameter types: primitive types
	public void test0061() {
		this.runNegativeTest(
			new String[] {
				"test/X.java",
				"""
					package test;
					// Valid Parameterized Type Declaration
					public class X<A1, A2, A3, A4, A5, A6, A7> {
					}
					// Invalid Valid Type Syntax (primitive cannot be parameters)
					class Y {
						X<int, short, long, float, double, boolean, char> x;
					}
					"""
			},
			"""
				----------
				1. ERROR in test\\X.java (at line 7)
					X<int, short, long, float, double, boolean, char> x;
					  ^^^
				Syntax error, insert "Dimensions" to complete TypeArgument
				----------
				2. ERROR in test\\X.java (at line 7)
					X<int, short, long, float, double, boolean, char> x;
					       ^^^^^
				Syntax error, insert "Dimensions" to complete TypeArgument
				----------
				3. ERROR in test\\X.java (at line 7)
					X<int, short, long, float, double, boolean, char> x;
					              ^^^^
				Syntax error, insert "Dimensions" to complete TypeArgument
				----------
				4. ERROR in test\\X.java (at line 7)
					X<int, short, long, float, double, boolean, char> x;
					                    ^^^^^
				Syntax error, insert "Dimensions" to complete TypeArgument
				----------
				5. ERROR in test\\X.java (at line 7)
					X<int, short, long, float, double, boolean, char> x;
					                           ^^^^^^
				Syntax error, insert "Dimensions" to complete TypeArgument
				----------
				6. ERROR in test\\X.java (at line 7)
					X<int, short, long, float, double, boolean, char> x;
					                                   ^^^^^^^
				Syntax error, insert "Dimensions" to complete TypeArgument
				----------
				7. ERROR in test\\X.java (at line 7)
					X<int, short, long, float, double, boolean, char> x;
					                                            ^^^^
				Syntax error, insert "Dimensions" to complete ReferenceType
				----------
				""");
	}
	// JSR14-v10[2.1,2.2]: Valid multiple parameter types: primitive type arrays
	public void test0062() {
		this.runConformTest(
			new String[] {
				"test/X.java",
				"""
					package test;
					// Valid Parameterized Type Declaration
					public class X<A1, A2, A3, A4, A5, A6, A7, A8> {
					}
					// Valid Type Syntax
					class Y {
						X<int[], short[][], long[][][], float[][][][], double[][][][][], boolean[][][][][][], char[][][][][][][], Object[][][][][][][][][]> x;
					}
					"""
			},
			""
		);
	}
	public void test0063() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T> extends p.A<T> {
					   \s
					    X(T t) {
					        super(t);
					    }
					    public static void main(String[] args) {
					        X x = new X(args);
					        X<String> xs = new X<String>(args);
						}
					}
					""",
				"p/A.java",
				"""
					package p;\s
					public class A<P> {
						 protected P p;
					    protected A(P p) {
					       this.p = p;\s
					    }\s
					    protected void print(P p) {
					        System.out.println("SUCCESS"+p);
					    }
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 7)
					X x = new X(args);
					^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				2. WARNING in X.java (at line 7)
					X x = new X(args);
					      ^^^^^^^^^^^
				Type safety: The constructor X(Object) belongs to the raw type X. References to generic type X<T> should be parameterized
				----------
				3. WARNING in X.java (at line 7)
					X x = new X(args);
					          ^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				4. ERROR in X.java (at line 8)
					X<String> xs = new X<String>(args);
					               ^^^^^^^^^^^^^^^^^^^
				The constructor X<String>(String[]) is undefined
				----------
				----------
				1. WARNING in p\\A.java (at line 7)
					protected void print(P p) {
					                       ^
				The parameter p is hiding a field from type A<P>
				----------
				""");
	}
	// raw type: variable map to its strict erasure
	public void test0064() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"public class X<T extends Exception & IX> {\n" +
				"    T t;\n" +
				"    void bar(T t) {\n" +
				"        t.getMessage();\n" +
				"        t.foo();\n" +
				"    }\n" +
				"    public static void main(String[] args) {\n" +
				"		X x = new X();\n" + // raw type
				"		x.t.getMessage();\n" + // T is strictly exception !
				"		x.t.foo();\n" +
				"	}\n" +
				"}\n" +
				"\n" +
				"interface IX {\n" +
				"    void foo();\n" +
				"}\n",
			},
			"""
				----------
				1. WARNING in X.java (at line 3)
					void bar(T t) {
					           ^
				The parameter t is hiding a field from type X<T>
				----------
				2. WARNING in X.java (at line 8)
					X x = new X();
					^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				3. WARNING in X.java (at line 8)
					X x = new X();
					          ^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				4. ERROR in X.java (at line 10)
					x.t.foo();
					    ^^^
				The method foo() is undefined for the type Exception
				----------
				""");
	}
	// raw type: assignments
	public void test0065() {
		Map customOptions = getCompilerOptions();
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.io.IOException;
					
					public class X<T extends Exception> {
					
					    public static void main(String[] args) {
							X x = new X();
							X<IOException> xioe = new X<IOException>(); // ok
						\t
							X x2 = xioe;
							X<IOException> xioe2 = x; // unsafe
						}
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 6)
					X x = new X();
					^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				2. WARNING in X.java (at line 6)
					X x = new X();
					          ^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				3. WARNING in X.java (at line 9)
					X x2 = xioe;
					^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				4. WARNING in X.java (at line 10)
					X<IOException> xioe2 = x; // unsafe
					                       ^
				Type safety: The expression of type X needs unchecked conversion to conform to X<IOException>
				----------
				""",
			null,
			true,
			customOptions);
	}

	// JSR14-v10[2.1,2.2]: Invalid PT declaration (mix with reference)
	public void test0066() {
		this.runNegativeTest(
			new String[] {
				"test/X1.java",
				"""
					package test;
					// Valid Consecutive Parameterized Type Declaration
					public class X1<A1 extends X2<A2>> {
						A1 a1;
					}
					// Valid Parameterized Type Declaration
					class X2<A2>{
						A2 a2;
					}
					"""
			},
			"""
				----------
				1. ERROR in test\\X1.java (at line 3)
					public class X1<A1 extends X2<A2>> {
					                              ^^
				A2 cannot be resolved to a type
				----------
				"""
		);
	}

	// JSR14-v10[2.1,2.2]: Invalid PT declaration (mix with reference)
	public void test0067() {
		this.runNegativeTest(
			new String[] {
				"test/X1.java",
				"""
					package test;
					// Valid Consecutive Parameterized Type Declaration
					public class X1< A1 extends X2	<	A2	>     			> {
						A1 a1;
					}
					// Valid Parameterized Type Declaration
					class X2<A2>{
						A2 a2;
					}
					"""
			},
			"""
				----------
				1. ERROR in test\\X1.java (at line 3)
					public class X1< A1 extends X2	<	A2	>     			> {
					                              	 	^^
				A2 cannot be resolved to a type
				----------
				"""
		);
	}

	// JSR14-V10[2.4]: Not terminated consecutive declaration
	// TODO (david) diagnosis message on error 3 sounds strange, doesn't it?
	public void _test0068() {
		this.runNegativeTest(
			new String[] {
				"test/X1.java",
				"""
					package test;
					// Invalid Consecutive Parameterized Type Declaration
					public class X1<A1 extends X2<A2> {
						A1 a1;
					}
					// Invalid Parameterized Type Declaration
					class X2<A2 {
						A2 a2;
					}
					"""
			},
			"""
				----------
				1. ERROR in test\\X1.java (at line 3)
					public class X1<A1 extends X2<A2> {
					                              ^^
				A2 cannot be resolved to a type
				----------
				2. ERROR in test\\X1.java (at line 3)
					public class X1<A1 extends X2<A2> {
					                                ^
				Syntax error, insert ">" to complete ReferenceType1
				----------
				3. ERROR in test\\X1.java (at line 7)
					class X2<A2 {
					         ^^
				Syntax error on token "A2", > expected after this token
				----------
				"""
		);
	}

	// JSR14-V10[2.4]: Not terminated consecutive declaration
	public void test0069() {
		this.runNegativeTest(
			new String[] {
				"test/X1.java",
				"""
					package test;
					// Invalid Consecutive Parameterized Type Declaration
					public class X1<A1 extends X2<A2 {
						A1 a1;
					}
					// Invalid Parameterized Type Declaration
					class X2<A2> {
						A2 a2;
					}
					"""
			},
			"""
				----------
				1. ERROR in test\\X1.java (at line 3)
					public class X1<A1 extends X2<A2 {
					                              ^^
				Syntax error, insert ">>" to complete ReferenceType2
				----------
				"""
		);
	}

	// JSR14-v10[2.4]: Unexpected consecutive PT declaration (right-shift symbol)
	// TODO (david) surround expected token with (double-)quotes
	public void test0070() {
		this.runNegativeTest(
			new String[] {
				"test/X1.java",
				"""
					package test;
					// Invalid Consecutive Parameterized Type Declaration
					public class X1<A1>> {
						A1 a1;
					}
					"""
			},
			"""
				----------
				1. ERROR in test\\X1.java (at line 3)
					public class X1<A1>> {
					                  ^^
				Syntax error on token ">>", > expected
				----------
				"""
		);
	}

	// JSR14-v10[2.1,2.2]: Unexpected consecutive PT declaration (with spaces)
	public void test0071() {
		this.runNegativeTest(
			new String[] {
				"test/X1.java",
				"""
					package test;
					// Invalid Consecutive Parameterized Type Declaration
					public class X1 < A1 > > {
						A1 a1;
					}
					"""
			},
			"""
				----------
				1. ERROR in test\\X1.java (at line 3)
					public class X1 < A1 > > {
					                       ^
				Syntax error on token ">", delete this token
				----------
				"""
		);
	}

	// JSR14-v10[2.4]: Unexpected consecutive PT declaration (unary right-shift symbol)
	// TODO (david) surround expected token with (double-)quotes
	public void test0072() {
		this.runNegativeTest(
			new String[] {
				"test/X1.java",
				"""
					package test;
					// Invalid Consecutive Parameterized Type Declaration
					public class X1<A1>>> {
						A1 a1;
					}
					"""
			},
			"""
				----------
				1. ERROR in test\\X1.java (at line 3)
					public class X1<A1>>> {
					                  ^^^
				Syntax error on token ">>>", > expected
				----------
				"""
		);
	}

	// JSR14-v10[2.4]: Unexpected consecutive PT declaration (right-shift symbol)
	// TODO (david) surround expected token with (double-)quotes
	public void test0073() {
		this.runNegativeTest(
			new String[] {
				"test/X1.java",
				"""
					package test;
					// Invalid Consecutive Parameterized Type Declaration
					public class X1<A1 extends X2<A1>>> {
						A1 a1;
					}
					// Valid Parameterized Type Declaration
					class X2<A2> {
						A2 a2;
					}
					"""
			},
			"""
				----------
				1. ERROR in test\\X1.java (at line 3)
					public class X1<A1 extends X2<A1>>> {
					                                ^^^
				Syntax error on token ">>>", >> expected
				----------
				"""
		);
	}

	// JSR14-v10[2.1,2.2]: Unexpected consecutive PT declaration (with spaces)
	public void test0074() {
		this.runNegativeTest(
			new String[] {
				"test/X1.java",
				"""
					package test;
					// Invalid Consecutive Parameterized Type Declaration
					public class X1 < A1 > > > {
						A1 a1;
					}
					"""
			},
			"""
				----------
				1. ERROR in test\\X1.java (at line 3)
					public class X1 < A1 > > > {
					                       ^^^
				Syntax error on tokens, delete these tokens
				----------
				"""
		);
	}

	// A is not an interface
	public void test0075() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends Object & p.A<? super T>> extends p.A<T> {
					    protected T t;
					    X(T t) {
					        super(t);
					        this.t = t;
					    }
					}""",
				"p/A.java",
				"""
					package p;
					public class A<P> {
					    protected P p;
					    protected A(P p) {
					        this.p = p;
					    }
					}"""
			},
		"""
			----------
			1. ERROR in X.java (at line 1)
				public class X <T extends Object & p.A<? super T>> extends p.A<T> {
				                                   ^^^
			The type A<? super T> is not an interface; it cannot be specified as a bounded parameter
			----------
			"""
		);
	}

	// A is not an interface
	public void test0076() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends Object & p.A> extends p.A<T> {
					    protected T t;
					    X(T t) {
					        super(t);
					        this.t = t;
					    }
					}""",
				"p/A.java",
				"""
					package p;
					public class A<P> {
					    protected P p;
					    protected A(P p) {
					        this.p = p;
					    }
					}"""
			},
			"""
				----------
				1. WARNING in X.java (at line 1)
					public class X <T extends Object & p.A> extends p.A<T> {
					                                   ^^^
				A is a raw type. References to generic type A<P> should be parameterized
				----------
				2. ERROR in X.java (at line 1)
					public class X <T extends Object & p.A> extends p.A<T> {
					                                   ^^^
				The type A is not an interface; it cannot be specified as a bounded parameter
				----------
				"""
		);
	}
	// unsafe type operation: only for constructors with signature change
	public void test0077() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T> extends p.A<T> {
						 X() {
							super(null);
						}
					    X(T t) {
					        super(t);
					    }
					    X(X<T> xt) {
					        super(xt.t);
					    }
					    public static void main(String[] args) {
					        X x = new X();
					        X x1 = new X(args);
					        X x2 = new X(x);
					        X<String> xs = new X<String>(args);
						}
					}
					""",
				"p/A.java",
				"""
					package p;
					public class A<P> {
					    protected P p;
					    protected A(P p) {
					        this.p = p;
					    }
					}"""
			},
			"""
				----------
				1. ERROR in X.java (at line 9)
					super(xt.t);
					         ^
				t cannot be resolved or is not a field
				----------
				2. WARNING in X.java (at line 12)
					X x = new X();
					^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				3. WARNING in X.java (at line 12)
					X x = new X();
					          ^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				4. WARNING in X.java (at line 13)
					X x1 = new X(args);
					^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				5. WARNING in X.java (at line 13)
					X x1 = new X(args);
					       ^^^^^^^^^^^
				Type safety: The constructor X(Object) belongs to the raw type X. References to generic type X<T> should be parameterized
				----------
				6. WARNING in X.java (at line 13)
					X x1 = new X(args);
					           ^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				7. WARNING in X.java (at line 14)
					X x2 = new X(x);
					^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				8. WARNING in X.java (at line 14)
					X x2 = new X(x);
					       ^^^^^^^^
				Type safety: The constructor X(X) belongs to the raw type X. References to generic type X<T> should be parameterized
				----------
				9. WARNING in X.java (at line 14)
					X x2 = new X(x);
					           ^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				10. ERROR in X.java (at line 15)
					X<String> xs = new X<String>(args);
					               ^^^^^^^^^^^^^^^^^^^
				The constructor X<String>(String[]) is undefined
				----------
				""");
	}
	public void test0078() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import p.A;
					public class X {
					    X(A<String> a, A<String> b) {
					    }
					    void foo(A<String> a) {
					    }
					    public static void main(String[] args) {
					        X x = new X((A)null, (A)null);
					        A a = new A((A)null);
							x.foo(a);
							a.print(x);
							A<String> as = new A<String>(null);
							as.print("hello");
						}
					}
					""",
				"p/A.java",
				"""
					package p;
					public class A<P> {
					    protected P p;
					    protected A(P p) {
					        this.p = p;
					    }
					    protected void print(P p) {
					        System.out.println("SUCCESS"+p);
					    }
					    protected void print(A<P> a) {
					        print(a.p);
					    }
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 8)
					X x = new X((A)null, (A)null);
					            ^^^^^^^
				Type safety: The expression of type A needs unchecked conversion to conform to A<String>
				----------
				2. WARNING in X.java (at line 8)
					X x = new X((A)null, (A)null);
					             ^
				A is a raw type. References to generic type A<P> should be parameterized
				----------
				3. WARNING in X.java (at line 8)
					X x = new X((A)null, (A)null);
					                     ^^^^^^^
				Type safety: The expression of type A needs unchecked conversion to conform to A<String>
				----------
				4. WARNING in X.java (at line 8)
					X x = new X((A)null, (A)null);
					                      ^
				A is a raw type. References to generic type A<P> should be parameterized
				----------
				5. WARNING in X.java (at line 9)
					A a = new A((A)null);
					^
				A is a raw type. References to generic type A<P> should be parameterized
				----------
				6. ERROR in X.java (at line 9)
					A a = new A((A)null);
					      ^^^^^^^^^^^^^^
				The constructor A(P) is not visible
				----------
				7. WARNING in X.java (at line 9)
					A a = new A((A)null);
					          ^
				A is a raw type. References to generic type A<P> should be parameterized
				----------
				8. WARNING in X.java (at line 9)
					A a = new A((A)null);
					             ^
				A is a raw type. References to generic type A<P> should be parameterized
				----------
				9. WARNING in X.java (at line 10)
					x.foo(a);
					      ^
				Type safety: The expression of type A needs unchecked conversion to conform to A<String>
				----------
				10. ERROR in X.java (at line 11)
					a.print(x);
					  ^^^^^
				The method print(P) from the type A is not visible
				----------
				11. ERROR in X.java (at line 12)
					A<String> as = new A<String>(null);
					               ^^^^^^^^^^^^^^^^^^^
				The constructor A<String>(P) is not visible
				----------
				12. ERROR in X.java (at line 13)
					as.print("hello");
					   ^^^^^
				The method print(P) from the type A<String> is not visible
				----------
				----------
				1. WARNING in p\\A.java (at line 7)
					protected void print(P p) {
					                       ^
				The parameter p is hiding a field from type A<P>
				----------
				""");
	}

	// JSR14-v10[2.4]: Valid consecutive Type Parameters Brackets
	public void test0079() {
		this.runConformTest(
			new String[] {
				"test/X.java",
				"""
					package test;
					public class X<A extends X1<X2<X3<String>>>> {
						A a;
						public static void main(String[] args) {
							X<X1<X2<X3<String>>>> x = new X<X1<X2<X3<String>>>>();
							x.a = new X1<X2<X3<String>>>();
							x.a.a1 = new X2<X3<String>>();
							x.a.a1.a2 = new X3<String>();
							x.a.a1.a2.a3 = "SUCCESS";
							System.out.println(x.a.a1.a2.a3);
						}
					}
					class X1<A extends X2<X3<String>>> {
						A a1;
					}
					class X2<A extends X3<String>> {
						A a2;
					}
					class X3<A> {
						A a3;
					}
					"""
			},
			"SUCCESS"
		);
	}
	// TODO (david) remove errors: insert dimension to complete array type
	public void _test0080() {
		this.runNegativeTest(
			new String[] {
				"test/X.java",
				"""
					package test;
					public class X<A extends X1<X2<X3<String>>> {}
					class X1<A extends X2<X3<String>> {}
					class X2<A extends X3<String> {}
					class X3<A {}
					"""
			},
			"""
				----------
				1. ERROR in test\\X.java (at line 2)
					public class X<A extends X1<X2<X3<String>>> {}
					                                        ^^^
				Syntax error, insert ">" to complete ReferenceType1
				----------
				2. ERROR in test\\X.java (at line 3)
					class X1<A extends X2<X3<String>> {}
					                               ^^
				Syntax error, insert ">" to complete ReferenceType1
				----------
				3. ERROR in test\\X.java (at line 4)
					class X2<A extends X3<String> {}
					                            ^
				Syntax error, insert ">" to complete ReferenceType1
				----------
				4. ERROR in test\\X.java (at line 5)
					class X3<A {}
					         ^
				Syntax error on token "A", > expected after this token
				----------
				"""
		);
	}
	// TODO (david) remove errors: insert dimension to complete array type
	public void test0081() {
		this.runNegativeTest(
			new String[] {
				"test/X.java",
				"""
					package test;
					public class X<A extends X1<X2<X3<String>> {}
					class X1<A extends X2<X3<String> {}
					class X2<A extends X3<String {}
					class X3<A> {}
					"""
			},
			"""
				----------
				1. ERROR in test\\X.java (at line 2)
					public class X<A extends X1<X2<X3<String>> {}
					                                        ^^
				Syntax error, insert ">>" to complete ReferenceType2
				----------
				2. ERROR in test\\X.java (at line 3)
					class X1<A extends X2<X3<String> {}
					                               ^
				Syntax error, insert ">>" to complete ReferenceType2
				----------
				3. ERROR in test\\X.java (at line 4)
					class X2<A extends X3<String {}
					                      ^^^^^^
				Syntax error, insert ">>" to complete ReferenceType2
				----------
				"""
		);
	}
	// TODO (david) remove error: insert dimension to complete array type
	public void test0082() {
		this.runNegativeTest(
			new String[] {
				"test/X.java",
				"""
					package test;
					public class X<A extends X1<X2<X3<String> {}
					class X1<A extends X2<X3<String {}
					class X2<A extends X3<String>> {}
					class X3<A> {}
					"""
			},
			"""
				----------
				1. ERROR in test\\X.java (at line 2)
					public class X<A extends X1<X2<X3<String> {}
					                                        ^
				Syntax error, insert ">>>" to complete ReferenceType3
				----------
				2. ERROR in test\\X.java (at line 3)
					class X1<A extends X2<X3<String {}
					                         ^^^^^^
				Syntax error, insert ">>>" to complete ReferenceType3
				----------
				"""
		);
	}
	// TODO (david) remove error: insert dimension to complete array type
	public void _test0083() {
		this.runNegativeTest(
			new String[] {
				"test/X.java",
				"""
					package test;
					public class X<A extends X1<X2<X3<String {}
					class X1<A extends X2<X3<String>>> {}
					class X2<A extends X3<String>> {}
					class X3<A> {}
					"""
			},
			"""
				----------
				1. ERROR in test\\X.java (at line 2)
					public class X<A extends X1<X2<X3<String {}
					                                  ^^^^^^
				Syntax error, insert ">>>" to complete ReferenceType3
				----------
				2. ERROR in test\\X.java (at line 2)
					public class X<A extends X1<X2<X3<String {}
					                                  ^^^^^^
				Syntax error, insert ">" to complete ReferenceType1
				----------
				""");
	}
	public void test0084() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					    X(AX<String> a, AX<String> b) {
					    }
					    void foo(AX<String> a) {
					    }
					    public static void main(String[] args) {
					        X x = new X((AX)null, (AX)null);
					        AX a = new AX((AX)null);
					        AX a2 = new AX(null);
							x.foo(a);
							a.foo(a);
							a.bar(a);
							AX<String> as = new AX<String>(null);
							as.print(a);
							as.bar(a);
						}
					}
					class AX <P> {
					    AX(AX<P> ax){}
					    AX(P p){}
					    void print(P p){}
					    void foo(AX rawAx){}
					    void bar(AX<P> ax){}
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 7)
					X x = new X((AX)null, (AX)null);
					            ^^^^^^^^
				Type safety: The expression of type AX needs unchecked conversion to conform to AX<String>
				----------
				2. WARNING in X.java (at line 7)
					X x = new X((AX)null, (AX)null);
					             ^^
				AX is a raw type. References to generic type AX<P> should be parameterized
				----------
				3. WARNING in X.java (at line 7)
					X x = new X((AX)null, (AX)null);
					                      ^^^^^^^^
				Type safety: The expression of type AX needs unchecked conversion to conform to AX<String>
				----------
				4. WARNING in X.java (at line 7)
					X x = new X((AX)null, (AX)null);
					                       ^^
				AX is a raw type. References to generic type AX<P> should be parameterized
				----------
				5. WARNING in X.java (at line 8)
					AX a = new AX((AX)null);
					^^
				AX is a raw type. References to generic type AX<P> should be parameterized
				----------
				6. WARNING in X.java (at line 8)
					AX a = new AX((AX)null);
					       ^^^^^^^^^^^^^^^^
				Type safety: The constructor AX(AX) belongs to the raw type AX. References to generic type AX<P> should be parameterized
				----------
				7. WARNING in X.java (at line 8)
					AX a = new AX((AX)null);
					           ^^
				AX is a raw type. References to generic type AX<P> should be parameterized
				----------
				8. WARNING in X.java (at line 8)
					AX a = new AX((AX)null);
					               ^^
				AX is a raw type. References to generic type AX<P> should be parameterized
				----------
				9. WARNING in X.java (at line 9)
					AX a2 = new AX(null);
					^^
				AX is a raw type. References to generic type AX<P> should be parameterized
				----------
				10. WARNING in X.java (at line 9)
					AX a2 = new AX(null);
					        ^^^^^^^^^^^^
				Type safety: The constructor AX(AX) belongs to the raw type AX. References to generic type AX<P> should be parameterized
				----------
				11. WARNING in X.java (at line 9)
					AX a2 = new AX(null);
					            ^^
				AX is a raw type. References to generic type AX<P> should be parameterized
				----------
				12. WARNING in X.java (at line 10)
					x.foo(a);
					      ^
				Type safety: The expression of type AX needs unchecked conversion to conform to AX<String>
				----------
				13. WARNING in X.java (at line 12)
					a.bar(a);
					^^^^^^^^
				Type safety: The method bar(AX) belongs to the raw type AX. References to generic type AX<P> should be parameterized
				----------
				14. ERROR in X.java (at line 13)
					AX<String> as = new AX<String>(null);
					                ^^^^^^^^^^^^^^^^^^^^
				The constructor AX<String>(AX<String>) is ambiguous
				----------
				15. ERROR in X.java (at line 14)
					as.print(a);
					   ^^^^^
				The method print(String) in the type AX<String> is not applicable for the arguments (AX)
				----------
				16. WARNING in X.java (at line 15)
					as.bar(a);
					       ^
				Type safety: The expression of type AX needs unchecked conversion to conform to AX<String>
				----------
				17. WARNING in X.java (at line 22)
					void foo(AX rawAx){}
					         ^^
				AX is a raw type. References to generic type AX<P> should be parameterized
				----------
				""");
	}

	public void test0085() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
					   \s
					    public static void main(String[] args) {
					        AX ax = new AX();
					        X x = (X)ax.p;
					        System.out.println(x);
					    }
					}
					
					class AX <P> {
					   \s
					    P p;
					}
					""",
			},
		"null");
	}

	public void test0086() {
		Map customOptions = getCompilerOptions();
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
					   \s
					    public static void main(String[] args) {
					        AX ax = new AX();
					        AX ax2 = ax.p;
					        ax.p = new AX<String>();
					        System.out.println(ax2);
					    }
					}
					
					class AX <P> {
					    AX<P> p;
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 4)
					AX ax = new AX();
					^^
				AX is a raw type. References to generic type AX<P> should be parameterized
				----------
				2. WARNING in X.java (at line 4)
					AX ax = new AX();
					            ^^
				AX is a raw type. References to generic type AX<P> should be parameterized
				----------
				3. WARNING in X.java (at line 5)
					AX ax2 = ax.p;
					^^
				AX is a raw type. References to generic type AX<P> should be parameterized
				----------
				4. WARNING in X.java (at line 6)
					ax.p = new AX<String>();
					   ^
				Type safety: The field p from the raw type AX is assigned a value of type AX<String>. References to generic type AX<P> should be parameterized
				----------
				""",
		null,
		true,
		customOptions);
	}

	public void test0087() {
		Map customOptions = getCompilerOptions();
		// check no unsafe type operation problem is issued
		customOptions.put(CompilerOptions.OPTION_ReportUncheckedTypeOperation, CompilerOptions.ERROR);
		customOptions.put(CompilerOptions.OPTION_ReportRawTypeReference, CompilerOptions.IGNORE);
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
					   \s
					    public static void main(String[] args) {
					        AX ax = new AX();
					        AX ax2 = ax.p;
					        AX ax3 = new AX<String>();
					        System.out.println("SUCCESS");
					    }
					}
					
					class AX <P> {
					    AX<P> p;
					}
					""",
			},
		"SUCCESS",
		null,
		true,
		null,
		customOptions,
		null/*no custom requestor*/);
	}

	public void test0088() {
		Map customOptions = getCompilerOptions();
		// check no unsafe type operation problem is issued
		customOptions.put(CompilerOptions.OPTION_ReportUncheckedTypeOperation, CompilerOptions.ERROR);
		customOptions.put(CompilerOptions.OPTION_ReportRawTypeReference, CompilerOptions.IGNORE);
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
					     AX ax = new AX();
					     AX ax2 = ax.p;
					     AX ax3 = new AX<String>();
					}
					
					class AX <P> {
					    AX<P> p;
					}
					""",
			},
		"",
		null,
		true,
		null,
		customOptions,
		null/*no custom requestor*/);
	}

	public void test0089() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
					    T q;
					     public static void main(String[] args) {
					         X<String[]> xss = new X<String[]>();
					         X<X<String[]>> xxs = new X<X<String[]>>();
					         xxs.q = xss;
					         System.out.println("SUCCESS");
					     }
					}
					""",
			},
		"SUCCESS");
	}

	public void test0090() {
		Map customOptions = getCompilerOptions();
		// check no unsafe type operation problem is issued
		customOptions.put(CompilerOptions.OPTION_ReportUncheckedTypeOperation, CompilerOptions.ERROR);
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
					    T q;
					   \s
					     public static void main(String[] args) {
					         X<String[]> xss = new X<String[]>();
					         X<X<String[]>> xxs = new X<X<String[]>>();
					         xxs.q = xss;
					         System.out.println("SUCCESS");
					     }
					      void foo(X[] xs) {
					          xs[0] = new X<String>();
					     }
					}
					""",
			},
		"SUCCESS",
		null,
		true,
		null,
		customOptions,
		null/*no custom requestor*/);
	}

	public void test0091() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
					      void foo(X<String>[] xs) {
					     }
					}
					""",
			},
			"");
	}

	public void test0092() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
					    T t;
					    X(T t) {
					        this.t = t;
					    }
					     void foo() {
					         X<String> xs = new X<String>("");
					         X<String> xs2 = (X<String>) xs;
					        \s
					         ((X)xs).t = this;
					        \s
					         System.out.prinln((T) this.t);
					     }
					     public static void main(String[] args) {
							new X<String>("SUCCESS").foo();
						}
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 8)
					X<String> xs2 = (X<String>) xs;
					                ^^^^^^^^^^^^^^
				Unnecessary cast from X<String> to X<String>
				----------
				2. WARNING in X.java (at line 10)
					((X)xs).t = this;
					  ^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				3. WARNING in X.java (at line 10)
					((X)xs).t = this;
					        ^
				Type safety: The field t from the raw type X is assigned a value of type X<T>. References to generic type X<T> should be parameterized
				----------
				4. ERROR in X.java (at line 12)
					System.out.prinln((T) this.t);
					           ^^^^^^
				The method prinln(T) is undefined for the type PrintStream
				----------
				""");
	}

	// **
	public void test0093() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
					    public static void main(String[] args) {
					        AX ax = new AX();
					        AX ax2 = new AX();
					        ax.p = ax2.p;
					        System.out.println("SUCCESS");
					    }
					}
					class AX <P> {
					    AX<P> p;
					}
					""",
			},
		"SUCCESS");
	}

	// same as test001, but every type is now a SourceTypeBinding
	public void test0094() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<Tx1 extends S, Tx2 extends C>  extends XS<Tx2> {
					
					    public static void main(String[] args) {
					        I w = new X<S,I>().get(new I());
					        System.out.println("SUCCESS");
					    }
					}
					class S {}
					class I implements C<I> {}
					interface C<Tc> {}
					class XS <Txs> {
					    Txs get(Txs t) {
					        return t;
					    }
					}
					"""
			},
			"SUCCESS");
	}
	public void test0095() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<Tx1 extends S, Tx2 extends C>  extends XS<Tx2> {
					
					    public static void main(String[] args) {
					        I w = new X<S,I>().get(new I());
					        System.out.println("SUCCESS");
					    }
					}
					class S {}
					class I implements C {}
					interface C<Tc> {}
					class XS <Txs> {
					    Txs get(Txs t) {
					        return t;
					    }
					}
					"""
			},
			"SUCCESS");
	}
	public void test0096() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"public class X<T> extends X {}\n"
			},
			"""
				----------
				1. ERROR in X.java (at line 1)
					public class X<T> extends X {}
					                          ^
				Cycle detected: the type X<T> cannot extend/implement itself or one of its own member types
				----------
				""");
	}
	public void test0097() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"public class X<T> extends X<String> {}\n"
			},
			"""
				----------
				1. ERROR in X.java (at line 1)
					public class X<T> extends X<String> {}
					                          ^
				Cycle detected: the type X<T> cannot extend/implement itself or one of its own member types
				----------
				""");
	}
	public void test0098() {
		Map customOptions = getCompilerOptions();
		customOptions.put(CompilerOptions.OPTION_ReportUncheckedTypeOperation, CompilerOptions.ERROR);
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
					   \s
					    public static void main(String[] args) {
					        AX ax = new AX();
					        AX ax2 = ax.p;
					        ax.p = new AX<String>();
					        ax.q = new AX<String>();
					        ax.r = new AX<Object>();
					        ax.s = new AX<String>();
					        System.out.println(ax2);
					    }
					}
					
					class AX <P> {
					    AX<P> p;
					    AX<Object> q;
					    AX<String> r;
					    BX<String> s;
					}
					
					class BX<Q> {
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 4)
					AX ax = new AX();
					^^
				AX is a raw type. References to generic type AX<P> should be parameterized
				----------
				2. WARNING in X.java (at line 4)
					AX ax = new AX();
					            ^^
				AX is a raw type. References to generic type AX<P> should be parameterized
				----------
				3. WARNING in X.java (at line 5)
					AX ax2 = ax.p;
					^^
				AX is a raw type. References to generic type AX<P> should be parameterized
				----------
				4. ERROR in X.java (at line 6)
					ax.p = new AX<String>();
					   ^
				Type safety: The field p from the raw type AX is assigned a value of type AX<String>. References to generic type AX<P> should be parameterized
				----------
				5. ERROR in X.java (at line 7)
					ax.q = new AX<String>();
					   ^
				Type safety: The field q from the raw type AX is assigned a value of type AX<String>. References to generic type AX<P> should be parameterized
				----------
				6. ERROR in X.java (at line 8)
					ax.r = new AX<Object>();
					   ^
				Type safety: The field r from the raw type AX is assigned a value of type AX<Object>. References to generic type AX<P> should be parameterized
				----------
				7. ERROR in X.java (at line 9)
					ax.s = new AX<String>();
					       ^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from AX<String> to BX
				----------
				""",
		null,
		true,
		customOptions);
	}
	// wildcard bound cannot be base type
	// TODO (david) only syntax error should be related to wilcard bound being a base type. Ripple effect is severe here.
	public void test0099() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X  <T extends AX<? super int>> {
					    public static void main(String[] args) {
							AX<String> ax;
							System.out.println("SUCCESS");
						}
						void foo(X<?> x) {
						}
					}
					
					class AX<P> {
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 1)
					public class X  <T extends AX<? super int>> {
					                                      ^^^
				Syntax error, insert "Dimensions" to complete ArrayType
				----------
				"""
);
	}

	// type parameterized with wildcard cannot appear in allocation
	public void test0100() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
					    T t;
					    X(T t){
					        this.t = t;
					    }
					    public static void main(String[] args) {
							X<? extends AX> x = new X<? extends AX>(new AX<String>());
							System.out.println("SUCCESS");
						}
					}
					
					class AX<P> {
					    P foo() { return null; }
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 7)
					X<? extends AX> x = new X<? extends AX>(new AX<String>());
					            ^^
				AX is a raw type. References to generic type AX<P> should be parameterized
				----------
				2. ERROR in X.java (at line 7)
					X<? extends AX> x = new X<? extends AX>(new AX<String>());
					                        ^
				Cannot instantiate the type X<? extends AX>
				----------
				3. WARNING in X.java (at line 7)
					X<? extends AX> x = new X<? extends AX>(new AX<String>());
					                                    ^^
				AX is a raw type. References to generic type AX<P> should be parameterized
				----------
				""");
	}

	// wilcard may not pass parameter bound check
	public void test0101() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends String> {
					    T t;
					    X(T t){
					        this.t = t;
					    }
					    public static void main(String[] args) {
							X<? extends AX> x = new X<AX<String>>(new AX<String>());
							x.t.foo("SUCCESS");
						}
					}
					
					class AX<P> {
					   void foo(P p) {\s
							System.out.println(p);
					   }
					}
					
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 1)
					public class X <T extends String> {
					                          ^^^^^^
				The type parameter T should not be bounded by the final type String. Final types cannot be further extended
				----------
				2. ERROR in X.java (at line 7)
					X<? extends AX> x = new X<AX<String>>(new AX<String>());
					  ^^^^^^^^^^^^
				Bound mismatch: The type ? extends AX is not a valid substitute for the bounded parameter <T extends String> of the type X<T>
				----------
				3. WARNING in X.java (at line 7)
					X<? extends AX> x = new X<AX<String>>(new AX<String>());
					            ^^
				AX is a raw type. References to generic type AX<P> should be parameterized
				----------
				4. ERROR in X.java (at line 7)
					X<? extends AX> x = new X<AX<String>>(new AX<String>());
					                          ^^
				Bound mismatch: The type AX<String> is not a valid substitute for the bounded parameter <T extends String> of the type X<T>
				----------
				5. WARNING in X.java (at line 8)
					x.t.foo("SUCCESS");
					^^^^^^^^^^^^^^^^^^
				Type safety: The method foo(Object) belongs to the raw type AX. References to generic type AX<P> should be parameterized
				----------
				""");
	}
	// unbound wildcard implicitly bound by matching parameter bounds
	public void test0102() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends AX> {
					    T t;
					    X(T t){
					        this.t = t;
					    }
					    public static void main(String[] args) {
							X<?> x = new X<BX<String>>(new BX<String>());
							x.t.foo("SUCC");
							x.t.bar("ESS");
						}
					}
					
					class AX<P> {
					   void foo(P p) {\s
							System.out.print(p);
					   }
					}
					
					class BX<Q> extends AX<Q> {
					   void bar(Q q) {\s
							System.out.println(q);
					   }
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 1)
					public class X <T extends AX> {
					                          ^^
				AX is a raw type. References to generic type AX<P> should be parameterized
				----------
				2. WARNING in X.java (at line 8)
					x.t.foo("SUCC");
					^^^^^^^^^^^^^^^
				Type safety: The method foo(Object) belongs to the raw type AX. References to generic type AX<P> should be parameterized
				----------
				3. ERROR in X.java (at line 9)
					x.t.bar("ESS");
					    ^^^
				The method bar(String) is undefined for the type capture#2-of ?
				----------
				""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=85303
	public void test0103() throws Exception {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends AX> {
					    T t;
					    X(T t){
					        this.t = t;
					    }
					    public static void main(String[] args) {
							X<? extends BX> x = new X<BX<String>>(new BX<String>());
							x.t.foo("SUCC");
							x.t.bar("ESS");
						}
					}
					
					class AX<P> {
					   void foo(P p) {\s
							System.out.print(p);
					   }
					}
					
					class BX<Q> extends AX<Q> {
					   void bar(Q q) {\s
							System.out.println(q);
					   }
					}
					""",
			},
			"SUCCESS");
		String expectedOutput =
			"""
			  // Method descriptor #25 ([Ljava/lang/String;)V
			  // Stack: 4, Locals: 2
			  public static void main(java.lang.String[] args);
			     0  new X [1]
			     3  dup
			     4  new BX [26]
			     7  dup
			     8  invokespecial BX() [28]
			    11  invokespecial X(AX) [29]
			    14  astore_1 [x]
			    15  aload_1 [x]
			    16  getfield X.t : AX [16]
			    19  checkcast BX [26]
			    22  ldc <String "SUCC"> [31]
			    24  invokevirtual BX.foo(java.lang.Object) : void [33]
			    27  aload_1 [x]
			    28  getfield X.t : AX [16]
			    31  checkcast BX [26]
			    34  ldc <String "ESS"> [37]
			    36  invokevirtual BX.bar(java.lang.Object) : void [39]
			    39  return
			      Line numbers:
			        [pc: 0, line: 7]
			        [pc: 15, line: 8]
			        [pc: 27, line: 9]
			        [pc: 39, line: 10]
			      Local variable table:
			        [pc: 0, pc: 40] local: args index: 0 type: java.lang.String[]
			        [pc: 15, pc: 40] local: x index: 1 type: X
			      Local variable type table:
			        [pc: 15, pc: 40] local: x index: 1 type: X<? extends BX>
			""";

		File f = new File(OUTPUT_DIR + File.separator + "X.class");
		byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
		ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
		String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
		int index = result.indexOf(expectedOutput);
		if (index == -1 || expectedOutput.length() == 0) {
			System.out.println(Util.displayString(result, 3));
		}
		if (index == -1) {
			assertEquals("Wrong contents", expectedOutput, result);
		}
	}

	// wildcard bound check
	public void test0104() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends AX> {
					    T t;
					    X(T t){
					        this.t = t;
					    }
					    public static void main(String[] args) {
							X<? extends BX> x = new X<AX<String>>(new AX<String>());
							x.t.foo("SUCC");
							x.t.bar("ESS");
						}
					}
					
					class AX<P> {
					   void foo(P p) {\s
							System.out.print(p);
					   }
					}
					
					class BX<Q> extends AX<Q> {
					   void bar(Q q) {\s
							System.out.println(q);
					   }
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 1)
					public class X <T extends AX> {
					                          ^^
				AX is a raw type. References to generic type AX<P> should be parameterized
				----------
				2. WARNING in X.java (at line 7)
					X<? extends BX> x = new X<AX<String>>(new AX<String>());
					            ^^
				BX is a raw type. References to generic type BX<Q> should be parameterized
				----------
				3. ERROR in X.java (at line 7)
					X<? extends BX> x = new X<AX<String>>(new AX<String>());
					                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from X<AX<String>> to X<? extends BX>
				----------
				4. WARNING in X.java (at line 8)
					x.t.foo("SUCC");
					^^^^^^^^^^^^^^^
				Type safety: The method foo(Object) belongs to the raw type AX. References to generic type AX<P> should be parameterized
				----------
				5. WARNING in X.java (at line 9)
					x.t.bar("ESS");
					^^^^^^^^^^^^^^
				Type safety: The method bar(Object) belongs to the raw type BX. References to generic type BX<Q> should be parameterized
				----------
				""");
	}
	public void test0105() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends AX> {
					    T t;
					    X(T t){
					        this.t = t;
					    }
					    public static void main(String[] args) {
							X<? extends AX> x = new X<AX<String>>(new AX<String>());
							x.t.foo("SUCCESS");
						}
					}
					
					class AX<P> {
					   void foo(P p) {\s
							System.out.println(p);
					   }
					}
					""",
			},
			"SUCCESS");
	}
	public void test0106() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends AX> {
					    T t;
					    X(T t){
					        this.t = t;
					    }
					    public static void main(String[] args) {
					        X<BX<String>> x = new X<BX<String>>(new BX<String>());
							x.t.foo("SUCC");
							x.t.bar("ESS");
						}
					}
					
					class AX<P> {
					   void foo(P p) {\s
							System.out.print(p);
					   }
					}
					
					class BX<Q> extends AX<Q> {
					   void bar(Q q) {\s
							System.out.println(q);
					   }
					}
					""",
			},
			"SUCCESS");
	}
	// unsafe assignment thru binaries
	public void test0107() {
		Map customOptions = getCompilerOptions();
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.ArrayList;
					
					public class X  {
					   \s
					    public static void main(String[] args) {
					       \s
					        Iterable<String> is = new ArrayList();
							is.iterator();
					    }
					}
					
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 7)
					Iterable<String> is = new ArrayList();
					                      ^^^^^^^^^^^^^^^
				Type safety: The expression of type ArrayList needs unchecked conversion to conform to Iterable<String>
				----------
				2. WARNING in X.java (at line 7)
					Iterable<String> is = new ArrayList();
					                          ^^^^^^^^^
				ArrayList is a raw type. References to generic type ArrayList<E> should be parameterized
				----------
				""",
			null,
			true,
			customOptions);
	}
	// class literal: Integer.class of type Class<Integer>
	public void test0108() {
	    // also ensure no unsafe type operation problem is issued (assignment to variable of type raw)
		Map customOptions = getCompilerOptions();
		customOptions.put(CompilerOptions.OPTION_ReportUncheckedTypeOperation, CompilerOptions.ERROR);
		customOptions.put(CompilerOptions.OPTION_ReportRawTypeReference, CompilerOptions.IGNORE);
		this.runConformTest(
			new String[] {
				"X.java",
			"""
				public class X {
				    Class k;
				    public static void main(String args[]) {
				        new X().foo();
				    }
				    void foo() {
				        Class c = this.getClass();
				        this.k = this.getClass();
				        this.k = Integer.class;
				        try {
				            Integer i = Integer.class.newInstance();
				        } catch (Exception e) {
				        }
				        System.out.println("SUCCESS");
				    }
				}
				""",
			},
		"SUCCESS",
		null,
		true,
		null,
		customOptions,
		null/*no custom requestor*/);
	}
	// parameterized interface cannot be implemented simultaneously with distinct arguments
	public void test0109() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X implements AX<String> {}
					class Y extends X implements AX<Thread> {}
					interface AX<P> {}
					
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					class Y extends X implements AX<Thread> {}
					      ^
				The interface AX cannot be implemented more than once with different arguments: AX<String> and AX<Thread>
				----------
				""");
	}
	public void test0110() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X implements AX {}
					class Y extends X implements AX<Thread> {}
					interface AX<P> {}
					
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 1)
					public class X implements AX {}
					                          ^^
				AX is a raw type. References to generic type AX<P> should be parameterized
				----------
				2. ERROR in X.java (at line 2)
					class Y extends X implements AX<Thread> {}
					      ^
				The interface AX cannot be implemented more than once with different arguments: AX and AX<Thread>
				----------
				""");
	}
	public void test0111() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X implements AX<Object> {}
					class Y extends X implements AX {}
					interface AX<P> {}
					
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					class Y extends X implements AX {}
					      ^
				The interface AX cannot be implemented more than once with different arguments: AX<Object> and AX
				----------
				2. WARNING in X.java (at line 2)
					class Y extends X implements AX {}
					                             ^^
				AX is a raw type. References to generic type AX<P> should be parameterized
				----------
				""");
	}
	// test member types
	public void test0112() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>>{
					    void foo(X<Thread>.MX<String>.MMX<X> mx) {}
					    class MX <MT> {
					        class MMX <MMT> {}
					    }
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 1)
					public class X <T extends X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>>{
					                            ^^^^^^^^
				X.MX.MMX is a raw type. References to generic type X<T>.MX<MT>.MMX<MMT> should be parameterized
				----------
				2. ERROR in X.java (at line 1)
					public class X <T extends X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>>{
					                            ^^^^^^^^
				Bound mismatch: The type X.MX.MMX is not a valid substitute for the bounded parameter <T extends X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>> of the type X<T>
				----------
				3. ERROR in X.java (at line 2)
					void foo(X<Thread>.MX<String>.MMX<X> mx) {}
					           ^^^^^^
				Bound mismatch: The type Thread is not a valid substitute for the bounded parameter <T extends X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>> of the type X<T>
				----------
				4. WARNING in X.java (at line 2)
					void foo(X<Thread>.MX<String>.MMX<X> mx) {}
					                                  ^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				""");
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>>{
					    class MX <MT extends Comparable> {
					        class MMX <MMT> {}
					    }
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 1)
					public class X <T extends X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>>{
					                            ^^^^^^^^
				X.MX.MMX is a raw type. References to generic type X<T>.MX<MT>.MMX<MMT> should be parameterized
				----------
				2. ERROR in X.java (at line 1)
					public class X <T extends X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>>{
					                            ^^^^^^^^
				Bound mismatch: The type X.MX.MMX is not a valid substitute for the bounded parameter <T extends X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>> of the type X<T>
				----------
				3. ERROR in X.java (at line 1)
					public class X <T extends X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>>{
					                                         ^^^^^^^^
				Bound mismatch: The type Runnable is not a valid substitute for the bounded parameter <MT extends Comparable> of the type X<T>.MX<MT>
				----------
				4. WARNING in X.java (at line 2)
					class MX <MT extends Comparable> {
					                     ^^^^^^^^^^
				Comparable is a raw type. References to generic type Comparable<T> should be parameterized
				----------
				""");
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>>{
					    class MX <MT> {
					        class MMX <MMT extends Comparable> {}
					    }
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 1)
					public class X <T extends X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>>{
					                            ^^^^^^^^
				X.MX.MMX is a raw type. References to generic type X<T>.MX<MT>.MMX<MMT> should be parameterized
				----------
				2. ERROR in X.java (at line 1)
					public class X <T extends X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>>{
					                            ^^^^^^^^
				Bound mismatch: The type X.MX.MMX is not a valid substitute for the bounded parameter <T extends X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>> of the type X<T>
				----------
				3. ERROR in X.java (at line 1)
					public class X <T extends X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>>{
					                                                       ^^^^^^^^
				Bound mismatch: The type Iterable<String> is not a valid substitute for the bounded parameter <MMT extends Comparable> of the type X<T>.MX<MT>.MMX<MMT>
				----------
				4. WARNING in X.java (at line 3)
					class MMX <MMT extends Comparable> {}
					                       ^^^^^^^^^^
				Comparable is a raw type. References to generic type Comparable<T> should be parameterized
				----------
				""");
	}
	public void test0113() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
					  class MX<U> {
					  }
					
					  public static void main(String[] args) {
					    new X<Thread>().foo();
						System.out.println("SUCCESS");
					  }
					  void foo() {
							new X<String>().new MX<T>();
					  }
					}
					""",
			},
			"SUCCESS");
	}
	public void test0114() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
					  class MX<U> {
					  }
					
					  public static void main(String[] args) {
					    new X<Thread>().foo(new X<String>().new MX<Thread>());
					  }
					  void foo(X<String>.MX<Thread> mx) {
						System.out.println("SUCCESS");
					  }
					}
					""",
			},
			"SUCCESS");
	}
	public void test0115() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
					  class MX<U> {
					  }
					
					  public static void main(String[] args) {
					    new X<Thread>().foo(new X<String>().new MX<Thread>());
					  }
					  void foo(X.MX mx) {
						System.out.println("SUCCESS");
					  }
					}
					""",
			},
			"SUCCESS");
	}
	public void test0116() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
					  class MX<U> {
					  }
					
					  public static void main(String[] args) {
					    new X<Thread>().foo(new X<String>().new MX<Thread>());
					  }
					  void foo(X<?>.MX<?> mx) {
						System.out.println("SUCCESS");
					  }
					}
					""",
			},
			"SUCCESS");
	}
	// test member types
	public void test0117() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>>{
					    public static void main(String [] args) {
					       \s
					        new X<X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>>().new MX<Exception>();
					        System.out.println("SUCCESS");
					    }
					    void foo(X<X.MX.MMX>.MX<X>.MMX<X> mx) {
					    }
					   \s
					    class MX <MT> {
					        class MMX <MMT> {
					        }
					    }
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 1)
					public class X <T extends X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>>{
					                            ^^^^^^^^
				X.MX.MMX is a raw type. References to generic type X<T>.MX<MT>.MMX<MMT> should be parameterized
				----------
				2. ERROR in X.java (at line 1)
					public class X <T extends X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>>{
					                            ^^^^^^^^
				Bound mismatch: The type X.MX.MMX is not a valid substitute for the bounded parameter <T extends X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>> of the type X<T>
				----------
				3. WARNING in X.java (at line 4)
					new X<X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>>().new MX<Exception>();
					        ^^^^^^^^
				X.MX.MMX is a raw type. References to generic type X<T>.MX<MT>.MMX<MMT> should be parameterized
				----------
				4. ERROR in X.java (at line 4)
					new X<X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>>().new MX<Exception>();
					        ^^^^^^^^
				Bound mismatch: The type X.MX.MMX is not a valid substitute for the bounded parameter <T extends X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>> of the type X<T>
				----------
				5. WARNING in X.java (at line 7)
					void foo(X<X.MX.MMX>.MX<X>.MMX<X> mx) {
					           ^^^^^^^^
				X.MX.MMX is a raw type. References to generic type X<T>.MX<MT>.MMX<MMT> should be parameterized
				----------
				6. ERROR in X.java (at line 7)
					void foo(X<X.MX.MMX>.MX<X>.MMX<X> mx) {
					           ^^^^^^^^
				Bound mismatch: The type X.MX.MMX is not a valid substitute for the bounded parameter <T extends X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>> of the type X<T>
				----------
				7. WARNING in X.java (at line 7)
					void foo(X<X.MX.MMX>.MX<X>.MMX<X> mx) {
					                        ^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				8. WARNING in X.java (at line 7)
					void foo(X<X.MX.MMX>.MX<X>.MMX<X> mx) {
					                               ^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				""");
	}
	// test generic method with recursive parameter bound <T extends Comparable<? super T>>
	public void test0118() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					    public static void main(String[] args) {
					        java.util.Collections.sort(new java.util.LinkedList<String>());
					        System.out.println("SUCCESS");
					    }
					}
					"""
			},
			"SUCCESS");
	}
	// test generic method
	public void test0118a() {
		this.runConformTest(
			// test directory preparation
			true /* flush output directory */,
			new String[] { /* test files */
				"X.java",
				"""
					class A<T> {}
					
					public class X {
						static <T extends A<U>, U> void foo() {}
						void bar(A<?> a) {
							foo();
						}
					}"""
			},
			// compiler results
			null /* do not check compiler log */,
			// runtime results
			"" /* expected output string */,
			null /* do not check error string */,
			// javac options
			JavacTestOptions.JavacHasABug.JavacBugFixed_7 /* javac test options */);
	}
	// test binary member types **
	public void _test0119() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>>{
					    public static void main(String [] args) {
					       \s
					        new X<X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>>().new MX<Exception>();
					        System.out.println("SUCCESS");
					    }
					    void foo(X<X.MX.MMX>.MX<Object>.MMX<X> mx) {
					    }
					    void foo2(X<X.MX.MMX>.MX<Iterable>.MMX<X> mx) {
					    }
					    void foo3(X<X<X.MX.MMX>.MX<Runnable>.MMX<Iterable<String>>> mx) {
					    }
					   \s
					    class MX <MT> {
					        class MMX <MMT> {
					        }
					    }
					}
					""",
			},
			"SUCCESS"
		);

		// TODO (philippe) bounds checks are done before binaryType X is finished creating its type variables
		this.runConformTest(
			new String[] {
				"Y.java",
				"""
					public class Y extends X {
					    public static void main(String [] args) {
					        System.out.println("SUCCESS");
					    }
					}
					""",
			},
			"SUCCESS",
			null,
			false, // do not flush output
			null);
	}
	// test generic method
	public void test0120() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T>{
					    public static void main(String[] args) {
					       \s
					        String s = new X<String>().foo("SUCCESS");
						}
					    <U extends String> T foo (U u) {
					        System.out.println(u);
					        return null;
					    }
					}
					""",
			},
			"SUCCESS");
	}
	// test generic method
	public void test0120a() {
		this.runConformTest(
			// test directory preparation
			new String[] { /* test files */
				"X.java",
				"""
					public class X<E> {
					    <U extends X<?>> U foo() {
					    	return null;
					    }
					    <V extends X<?>> V bar() {
					        return foo();
					    }
					}"""
			},
			// javac options
			JavacTestOptions.JavacHasABug.JavacBug6302954 /* javac test options */);
	}
	// substitute array types
	public void test0121() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
					    public static void main(String[] args) {
							new X<String>().foo(args);
						}
					   \s
					    void foo(T[] ts) {
					        System.out.println("SUCCESS");
					    }
					}
					""",
			},
			"SUCCESS");
	}
	// generic method with most specific common supertype: U --> String
	public void test0122() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
					    public static void main(String[] args) {
							new X<String>().foo(args, new X<X<String>>());
						}
					    <U> void foo(U[] us, X<X<U>> xxu) {
					        System.out.println("SUCCESS");
					    }
					}
					""",
			},
			"SUCCESS");
	}
	// invalid parameterized type
	public void test0123() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
					    T<String> ts;
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					T<String> ts;
					^
				The type T is not generic; it cannot be parameterized with arguments <String>
				----------
				""");
	}
	// generic method with indirect type inference: BX<String, Thread> --> AX<W>
	public void test0124() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					   \s
					    <W> void foo(AX<W> aw) {
					        System.out.println("SUCCESS");
					     }
					   \s
					    public static void main(String[] args) {
							new X().foo(new BX<String,Thread>());
						}
					}
					
					class AX<T> {
					}
					class BX<U, V> extends AX<V> {
					}
					""",
			},
			"SUCCESS");
	}
	// generic method with indirect type inference: CX  --> AX<W>
	public void test0125() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					   \s
					    <W> void foo(AX<W> aw) {
					        System.out.println("SUCCESS");
					     }
					   \s
					    public static void main(String[] args) {
							new X().foo(new CX());
						}
					}
					
					class AX<T> {
					}
					class BX<U, V> extends AX<V> {
					}
					class CX extends BX<String, Thread> {
					}
					""",
			},
			"SUCCESS");
	}
	// variation on test0125 with typo: CX extends B instead of BX.
	public void test0126() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					   \s
					    <W> void foo(AX<W> aw) {
					        System.out.println("SUCCESS");
					     }
					   \s
					    public static void main(String[] args) {
							new X().foo(new CX());
						}
					}
					
					class AX<T> {
					}
					class BX<U, V> extends AX<V> {
					}
					class CX extends B<String, Thread> {
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 8)
					new X().foo(new CX());
					        ^^^
				The method foo(AX<W>) in the type X is not applicable for the arguments (CX)
				----------
				2. ERROR in X.java (at line 16)
					class CX extends B<String, Thread> {
					                 ^
				B cannot be resolved to a type
				----------
				""");
	}
	// 57784: test generic method
	public void test0127() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					    public static void main(String[] args) {
					        java.util.Arrays.asList(new Object[] {"1"});
					        System.out.println("SUCCESS");
					    }
					}
					"""
			},
			"SUCCESS");
	}
	// 58666: special treatment for Object#getClass declared of type: Class<? extends Object>
	// but implicitly converted to Class<? extends X> for free.
	public void test0128() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {\s
					    public static void main(String[] args) {
							X x = new X();
							Class c1 = x.getClass();
							Class<? extends X> c2 = x.getClass();
							String s = "hello";
							Class<? extends X> c3 = s.getClass();
							System.out.println("SUCCESS");
					    }
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 4)
					Class c1 = x.getClass();
					^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				2. ERROR in X.java (at line 7)
					Class<? extends X> c3 = s.getClass();
					                        ^^^^^^^^^^^^
				Type mismatch: cannot convert from Class<capture#3-of ? extends String> to Class<? extends X>
				----------
				""");
	}
	// variation on test0128
	public void test0129() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {\s
					
					    public static void main(String[] args) {
							XY xy = new XY();
							Class c1 = xy.getClass();
							Class<? extends XY> c2 = xy.getClass();
							String s = "hello";
							Class<? extends XY> c3 = s.getClass();
							System.out.println("SUCCESS");
					    }
					}
					
					class XY extends X {
					    public Class <? extends Object> getClass() {
					        return super.getClass();
					    }
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 5)
					Class c1 = xy.getClass();
					^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				2. ERROR in X.java (at line 8)
					Class<? extends XY> c3 = s.getClass();
					                         ^^^^^^^^^^^^
				Type mismatch: cannot convert from Class<capture#3-of ? extends String> to Class<? extends XY>
				----------
				3. ERROR in X.java (at line 14)
					public Class <? extends Object> getClass() {
					                                ^^^^^^^^^^
				Cannot override the final method from Object
				----------
				4. WARNING in X.java (at line 14)
					public Class <? extends Object> getClass() {
					                                ^^^^^^^^^^
				The method getClass() of type XY should be tagged with @Override since it actually overrides a superclass method
				----------
				""");
	}
	// getClass on array type
	public void test0130() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {\s
					
					    public static void main(String[] args) {
							X[] x = new X[0];
							Class<? extends X[]> c = x.getClass();
							System.out.println("SUCCESS");
					    }
					}
					"""
			},
			"SUCCESS");
	}
	// 58979
	public void test0131() {
		this.runNegativeTest(
			new String[] {
				"ArrayList.java",
				"""
					 interface List<T> {
						 List<T> foo();
					}
					
					 class ArrayList<T> implements List<T> {
						public List<T> foo() {
							List<T> lt = this;
							lt.bar();
							return this;
						}
					}
					""",
			},
			"""
				----------
				1. ERROR in ArrayList.java (at line 8)
					lt.bar();
					   ^^^
				The method bar() is undefined for the type List<T>
				----------
				""");
	}
	public void test0132() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					  <T extends X<W>.Z> foo() {}
					}"""
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					<T extends X<W>.Z> foo() {}
					           ^
				The type X is not generic; it cannot be parameterized with arguments <W>
				----------
				2. ERROR in X.java (at line 2)
					<T extends X<W>.Z> foo() {}
					             ^
				W cannot be resolved to a type
				----------
				3. ERROR in X.java (at line 2)
					<T extends X<W>.Z> foo() {}
					                   ^^^^^
				Return type for the method is missing
				----------
				""");
	}
	// bridge method
	public void test0133() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
					    public static void main(String[] args) {
					        X x = new Y();
					        System.out.println(x.foo());
					    }
					   T foo() {return null;}
					   void foo(T t) {}
					}
					class Y extends X<Object> {
					    String foo() {return "SUCCESS";}
					    void foo(String s) {}
					}
					"""
			},
			"SUCCESS");
	}
	public void test0134() {
		this.runConformTest(
			new String[] {
				"Z.java",
				"""
					import java.util.ArrayList;
					import java.util.List;
					
					public class Z <T extends List> {\s
					    T t;
					    public static void main(String[] args) {
					        foo(new Z<ArrayList>().set(new ArrayList<String>()));
					        System.out.println("SUCCESS");
					    }
					    Z<T> set(T t) {
					        this.t = t;
					        return this;
					    }
					    T get() {\s
					        return this.t;\s
					    }
					   \s
					    static void foo(Z<? super ArrayList> za) {
					        za.get().isEmpty();
					    }
					}
					"""
			},
			"SUCCESS");
	}
	public void test0135() {
		this.runNegativeTest(
			new String[] {
				"Z.java",
				"""
					public class Z <T extends ZA> {\s
					    public static void main(String[] args) {
					        foo(new Z<ZA>());
					        System.out.println("SUCCESS");
					    }
					    static void foo(Z<? super String> zs) {
					    }
					}
					
					class ZA {
					    void foo() {}
					}
					
					class ZB extends ZA {
					}"""
			},
			"""
				----------
				1. ERROR in Z.java (at line 3)
					foo(new Z<ZA>());
					^^^
				The method foo(Z<? super String>) in the type Z<T> is not applicable for the arguments (Z<ZA>)
				----------
				2. ERROR in Z.java (at line 6)
					static void foo(Z<? super String> zs) {
					                  ^^^^^^^^^^^^^^
				Bound mismatch: The type ? super String is not a valid substitute for the bounded parameter <T extends ZA> of the type Z<T>
				----------
				""");
	}
	public void test0136() {
		this.runNegativeTest(
			new String[] {
				"Z.java",
				"""
					public class Z <T extends ZB> {\s
					    public static void main(String[] args) {
					        foo(new Z<ZB>());
					    }
					    static void foo(Z<? super ZA> zs) {
					        zs.foo();
					    }
					}
					class ZA {
					}
					class ZB extends ZA {
					    void foo() {}
					}"""
			},
			"""
				----------
				1. ERROR in Z.java (at line 3)
					foo(new Z<ZB>());
					^^^
				The method foo(Z<? super ZA>) in the type Z<T> is not applicable for the arguments (Z<ZB>)
				----------
				2. ERROR in Z.java (at line 5)
					static void foo(Z<? super ZA> zs) {
					                  ^^^^^^^^^^
				Bound mismatch: The type ? super ZA is not a valid substitute for the bounded parameter <T extends ZB> of the type Z<T>
				----------
				3. ERROR in Z.java (at line 6)
					zs.foo();
					   ^^^
				The method foo(Z<? super ZA>) in the type Z<capture#1-of ? super ZA> is not applicable for the arguments ()
				----------
				""");
	}
	public void test0137() {
		this.runConformTest(
			new String[] {
				"Z.java",
				"""
					import java.util.ArrayList;
					import java.util.List;
					
					public class Z <T extends List> {\s
					    T t;
					    public static void main(String[] args) {
					        foo(new Z<ArrayList>().set(new ArrayList<String>()));
					        System.out.println("SUCCESS");
					    }
					    Z<T> set(T t) {
					        this.t = t;
					        return this;
					    }
					    T get() {\s
					        return this.t;\s
					    }
					   \s
					    static void foo(Z<? extends ArrayList> za) {
					        za.get().isEmpty();
					    }
					}
					"""
			},
			"SUCCESS");
	}
	// unbound wildcard still remembers its variable bound: Z<?> behaves like Z<AX>
	public void test0138() {
		this.runConformTest(
			new String[] {
				"Z.java",
				"""
					public class Z <T extends AX> {
					    T t;
					    Z(T t){
					        this.t = t;
					    }
					    public static void main(String[] args) {
							 Z<AX<String>> zax = new Z<AX<String>>(new AX<String>());
					        System.out.println("SUCCESS");
						}
					    void baz(Z<?> zu){
					        zu.t.foo(null);
					    }
					}
					
					class AX<P> {
					   void foo(P p) {\s
							System.out.print(p);
					   }
					}
					"""
			},
			"SUCCESS");
	}
	// extending wildcard considers its bound prior to its corresponding variable
	public void test0139() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T extends AX> {
					    T t;
					    X(T t) {
					        this.t = t;
					    }
					    T get() {
					        return this.t;
					    }
					    void bar(X<? extends BX> x) {
					        x.get().afoo();
					        x.get().bfoo();
					    }
					}
					class AX {
					    void afoo() {}
					}
					class BX {
					    void bfoo() {}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 9)
					void bar(X<? extends BX> x) {
					           ^^^^^^^^^^^^
				Bound mismatch: The type ? extends BX is not a valid substitute for the bounded parameter <T extends AX> of the type X<T>
				----------
				2. ERROR in X.java (at line 10)
					x.get().afoo();
					        ^^^^
				The method afoo() is undefined for the type capture#1-of ? extends BX
				----------
				""");
	}
	// extending wildcard considers its bound prior to its corresponding variable
	public void test0140() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T extends AX> {
					    T t;
					    X(T t) {
					        this.t = t;
					    }
					    T get() {
					        return this.t;
					    }
					    void bar(X<? extends BX> x) {
					        x.get().afoo();
					        x.get().bfoo();
					    }
					    public static void main(String[] args) {
					        System.out.println("SUCCESS");
						}
					}
					class AX {
					    void afoo() {}
					}
					class BX extends AX {
					    void bfoo() {}
					}
					""",
			},
			"SUCCESS");
	}
	// super wildcard considers its variable for lookups
	public void test0141() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T extends AX> {
					    T t;
					    X(T t) {
					        this.t = t;
					    }
					    T get() {
					        return this.t;
					    }
					    void bar(X<? super BX> x) {
					        x.get().afoo();
					        x.get().bfoo();
					    }
					}
					class AX {
					    void afoo() {}
					}
					class BX extends AX {
					    void bfoo() {}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 11)
					x.get().bfoo();
					        ^^^^
				The method bfoo() is undefined for the type capture#2-of ? super BX
				----------
				""");
	}
	public void test0142() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T extends AX> {
					    T t;
					    X(T t) {
					        this.t = t;
					    }
					    T get() {
					        return this.t;
					    }
					    void bar(X<? extends X> x) {
					        x = identity(x);
					    }
					    <P extends AX> X<P> identity(X<P> x) {
					        return x;
					    }
					    public static void main(String[] args) {
					    }
					}
					class AX {
					    void afoo() {}
					}
					class BX extends AX {
					    void bfoo() {}
					}
					""",
			},
			this.complianceLevel < ClassFileConstants.JDK1_8 ?
			"""
				----------
				1. ERROR in X.java (at line 9)
					void bar(X<? extends X> x) {
					           ^^^^^^^^^^^
				Bound mismatch: The type ? extends X is not a valid substitute for the bounded parameter <T extends AX> of the type X<T>
				----------
				2. WARNING in X.java (at line 9)
					void bar(X<? extends X> x) {
					                     ^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				3. ERROR in X.java (at line 10)
					x = identity(x);
					    ^^^^^^^^
				Bound mismatch: The generic method identity(X<P>) of type X<T> is not applicable for the arguments (X<capture#2-of ? extends X>). The inferred type capture#2-of ? extends X is not a valid substitute for the bounded parameter <P extends AX>
				----------
				""" :
				"""
					----------
					1. ERROR in X.java (at line 9)
						void bar(X<? extends X> x) {
						           ^^^^^^^^^^^
					Bound mismatch: The type ? extends X is not a valid substitute for the bounded parameter <T extends AX> of the type X<T>
					----------
					2. WARNING in X.java (at line 9)
						void bar(X<? extends X> x) {
						                     ^
					X is a raw type. References to generic type X<T> should be parameterized
					----------
					3. ERROR in X.java (at line 10)
						x = identity(x);
						    ^^^^^^^^
					The method identity(X<P>) in the type X<T> is not applicable for the arguments (X<capture#2-of ? extends X>)
					----------
					""");
	}
	public void test0143() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					    public static void main(String[] args) {
					        Class<? extends X> xx = null;
					        Class<? extends Object> xo = xx;
					        Class<Object> xo2 = xx;
					    }
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 5)
					Class<Object> xo2 = xx;
					                    ^^
				Type mismatch: cannot convert from Class<capture#2-of ? extends X> to Class<Object>
				----------
				""");
	}
	public void test0144() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					    public static void main(String[] args) {
					        Class<? extends X> xx = null;
					        Class<? extends Object> xo = xx;
					        X x = get(xx);
					        System.out.println("SUCCESS");
					    }
					    static <P> P get(Class<P> cp) {
					        return null;
					    }
					}
					""",
			},
			"SUCCESS");
	}
	// 59641: check assign/invoke with wildcards
	public void test0145() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
						public static void main(String[] args) {
							XList<?> lx = new XList<X>();
							X x = lx.get();
							lx.add(null);
							lx.add(x);
							lx.slot = x;
							lx.addAll(lx);
					    }    \t
					}
					class XList<E extends X> {
					    E slot;
					    void add(E e) {}
					    E get() { return null;\s
					    }
					    void addAll(XList<E> le) {}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 6)
					lx.add(x);
					   ^^^
				The method add(capture#3-of ?) in the type XList<capture#3-of ?> is not applicable for the arguments (X)
				----------
				2. ERROR in X.java (at line 7)
					lx.slot = x;
					          ^
				Type mismatch: cannot convert from X to capture#4-of ?
				----------
				3. ERROR in X.java (at line 8)
					lx.addAll(lx);
					   ^^^^^^
				The method addAll(XList<capture#5-of ?>) in the type XList<capture#5-of ?> is not applicable for the arguments (XList<capture#6-of ?>)
				----------
				""");
	}
	// 59628
	public void test0146() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.AbstractList;
					public class X extends AbstractList {
					    public static void main(String[] args) {
					        System.out.println("SUCCESS");
					    }
					    public int size() { return 0; }
					    public Object get(int index) { return null; }
					}
					"""
			},
			"SUCCESS");
	}
	// 59723
	public void test0147() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.ArrayList;
					
					public class X {
						public static void main(String[] args) {
						    char[][] tokens = new char[0][];
						    ArrayList list = new ArrayList();
							list.toArray(tokens);
					      System.out.println("SUCCESS");
					    }    \t
					}
					"""
			},
			"SUCCESS");
	}
	// bridge method
	public void test0148() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X extends AX<String>{
					   \s
					    String foo(String s) {
					        System.out.println(s);
					        return s;
					    }
						public static void main(String[] args) {
						   new X().bar("SUCCESS");
					    }    \t
					}
					class AX<T> {
					    T foo(T t) {
					        return null;
					    }
					    void bar(T t) {
					        foo(t);
					    }
					}
					"""
			},
			"SUCCESS");
	}
	// method compatibility
	public void test0149() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public abstract class X implements java.util.Collection {
						public Object[] toArray(Object[] a) {
							return a;
						}
						public static void main(String[] args) {
						   System.out.println("SUCCESS");
					    }
					}
					"""
			},
			"SUCCESS");
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public abstract class X implements java.util.Collection<Object> {
						public Object[] toArray(Object[] a) {
							return a;
						}
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 2)
					public Object[] toArray(Object[] a) {
					       ^^^^^^^^
				Type safety: The return type Object[] for toArray(Object[]) from the type X needs unchecked conversion to conform to T[] from the type Collection<E>
				----------
				""");
	}
	public void test0150() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					public class X {
					   \s
					    <T extends X> void foo(T[] ta, List<T> lt) {
					    }
					   \s
					    public static void main(String[] args) {
							new X().foo(args, new ArrayList<String>());
						}
					}
					"""
			},
			this.complianceLevel < ClassFileConstants.JDK1_8 ?
			"""
				----------
				1. ERROR in X.java (at line 8)
					new X().foo(args, new ArrayList<String>());
					        ^^^
				Bound mismatch: The generic method foo(T[], List<T>) of type X is not applicable for the arguments (String[], ArrayList<String>). The inferred type String is not a valid substitute for the bounded parameter <T extends X>
				----------
				""" :
				"""
					----------
					1. ERROR in X.java (at line 8)
						new X().foo(args, new ArrayList<String>());
						        ^^^
					The method foo(T[], List<T>) in the type X is not applicable for the arguments (String[], ArrayList<String>)
					----------
					""");
	}
	public void test0151() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					public class X <E>{
					   \s
					    <T extends X> X(T[] ta, List<T> lt) {
					    }
					   \s
					    public static void main(String[] args) {
							new X<Object>(args, new ArrayList<String>());
						}
					}
					"""
			},
			this.complianceLevel < ClassFileConstants.JDK1_8 ?
			"""
				----------
				1. WARNING in X.java (at line 4)
					<T extends X> X(T[] ta, List<T> lt) {
					           ^
				X is a raw type. References to generic type X<E> should be parameterized
				----------
				2. ERROR in X.java (at line 8)
					new X<Object>(args, new ArrayList<String>());
					^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Bound mismatch: The generic constructor X(T[], List<T>) of type X<E> is not applicable for the arguments (String[], ArrayList<String>). The inferred type String is not a valid substitute for the bounded parameter <T extends X>
				----------
				""" :
				"""
					----------
					1. WARNING in X.java (at line 4)
						<T extends X> X(T[] ta, List<T> lt) {
						           ^
					X is a raw type. References to generic type X<E> should be parameterized
					----------
					2. ERROR in X.java (at line 8)
						new X<Object>(args, new ArrayList<String>());
						^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
					The constructor X<Object>(String[], ArrayList<String>) is undefined
					----------
					""");
	}
	// 60556
	public void test0152() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					public class X {
					   \s
					    public static void main(String[] args) {
					        System.out.println("SUCCESS");
						}
					    List<X> x(List<X> list) {
					        return Collections.unmodifiableList(list);
					    }
					}
					"""
			},
			"SUCCESS");
	}
	public void test0153() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					   \s
					    public static void main(String[] args) {
					        AX<X> ax = new AX<X>();
					        AX<X> a = bar(ax);
					        System.out.println("SUCCESS");
						}
					    public static <T> AX<T> bar(AX<? extends T> a) {
							return null;
					    }   \s
					}
					class AX<E> {
					}
					"""
			},
			"SUCCESS");
	}
	public void test0154() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					   \s
					    public static void main(String[] args) {
					        AX<X> ax = new AX<X>();
					        AX<X> a = bar(ax);
					        System.out.println("SUCCESS");
						}
					    public static <T> AX<T> bar(AX<? super T> a) {
							return null;
					    }   \s
					}
					class AX<E> {
					}
					"""
			},
			"SUCCESS");
	}
	public void test0155() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					   \s
					    public static void main(String[] args) {
					        AX<X> ax = new AX<X>();
					        AX<X> a = bar(ax);
					        System.out.println("SUCCESS");
						}
					    public static <T> AX<T> bar(AX<?> a) {
							return null;
					    }   \s
					}
					class AX<E> {
					}
					"""
			},
			"SUCCESS");
	}
	public void test0156() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					   \s
					    public static void main(String[] args) {
					        AX<X> ax = new AX<X>();
					        AX<X> a = bar(ax);
						}
					    public static <T> AX<T> bar(AX<?> a) {
							return null;
					    }   \s
					}
					class AX<E extends X> {
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 7)
					public static <T> AX<T> bar(AX<?> a) {
					                     ^
				Bound mismatch: The type T is not a valid substitute for the bounded parameter <E extends X> of the type AX<E>
				----------
				""");
	}
	public void test0157() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					   \s
					    public static void main(String[] args) {
					        AX<X> ax = new AX<X>();
					        AX<String> as = new AX<String>();
					        AX<X> a = bar(ax, as);
					        System.out.println("SUCCESS");
						}
					    public static <T,U> AX<T> bar(AX<? extends U> a, AX<? super U> b) {
							return null;
					    }   \s
					}
					class AX<E> {
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 6)
					AX<X> a = bar(ax, as);
					          ^^^
				The method bar(AX<? extends U>, AX<? super U>) in the type X is not applicable for the arguments (AX<X>, AX<String>)
				----------
				""");
	}
	public void test0158() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					   \s
					    public static void main(String[] args) {
					        AX<X> ax = new AX<X>();
					        AX<String> as = new AX<String>();
					        AX<X> a = bar(ax, as);
					        System.out.println("SUCCESS");
						}
					    public static <T,U> AX<T> bar(AX<?> a, AX<? super U> b) {
							return null;
					    }   \s
					}
					class AX<E> {
					}
					"""
			},
			"SUCCESS");
	}
	public void test0159() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					   \s
					    public static void main(String[] args) {
					        AX<X> ax = new AX<X>(new X());
					        AX<String> as = new AX<String>("SUCCESS");
					        AX<X> a = bar(ax, as);
						}
					    public static <T,U> T bar(AX<?> a, AX<? super U> b) {
							return a.get();
					    }   \s
					}
					class AX<E> {
						 E e;
					    AX(E e) { this.e = e; }
					    E get() { return this.e; }
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 9)
					return a.get();
					       ^^^^^^^
				Type mismatch: cannot convert from capture#1-of ? to T
				----------
				""");
	}
	public void test0160() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					   \s
					    public static void main(String[] args) {
					        String s = foo(new AX<String>("aaa"));
						}
					    static <V> V foo(AX<String> a) {
					        return a.get();
					    }
					}
					class AX<E> {
					    E e;
					    AX(E e) { this.e = e; }
					    E get() { return this.e; }
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 7)
					return a.get();
					       ^^^^^^^
				Type mismatch: cannot convert from String to V
				----------
				""");
	}
	public void test0161() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					   \s
					    public static void main(String[] args) {
					        boolean b = foo(new AX<String>("aaa")).equals(args);
						}
					    static <V> V foo(AX<String> a) {
					        return a.get();
					    }
					    String bar() {
					        return "bbb";
					    }
					}
					class AX<E> {
					    E e;
					    AX(E e) { this.e = e; }
					    E get() { return this.e; }
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 7)
					return a.get();
					       ^^^^^^^
				Type mismatch: cannot convert from String to V
				----------
				""");
	}
	public void test0162() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					   \s
					    public static void main(String[] args) {
					        String s = foo(new AX<String>("aaa")).bar();
						}
					    static <V> V foo(AX<String> a) {
					        return a.get();
					    }
					    String bar() {
					        return "bbb";
					    }
					}
					class AX<E> {
					    E e;
					    AX(E e) { this.e = e; }
					    E get() { return this.e; }
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					String s = foo(new AX<String>("aaa")).bar();
					                                      ^^^
				The method bar() is undefined for the type Object
				----------
				2. ERROR in X.java (at line 7)
					return a.get();
					       ^^^^^^^
				Type mismatch: cannot convert from String to V
				----------
				""");
	}
	public void test0163() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					   \s
					    public static void main(String[] args) {
					        String s = foo(new AX<String>("aaa")).bar();
						}
					    static <V> V foo(AX<String> a) {
					        return a.get();
					    }
					    String bar() {
					        return "bbb";
					    }
					}
					class AX<E> {
					    E e;
					    AX(E e) { this.e = e; }
					    E get() { return this.e; }
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					String s = foo(new AX<String>("aaa")).bar();
					                                      ^^^
				The method bar() is undefined for the type Object
				----------
				2. ERROR in X.java (at line 7)
					return a.get();
					       ^^^^^^^
				Type mismatch: cannot convert from String to V
				----------
				""");
	}
	public void test0164() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.List;
					public class X {
					    public static void main(String[] args) {
					        foo(new AX<String>("SUCCESS"));
						}
					    static <V> List<V> foo(AX<String> a) {
					        System.out.println(a.get());
					        List<V> v = null;
					        if (a == null) v = foo(a);\s
					        return v;
					    }
					}
					class AX<E> {
					    E e;
					    AX(E e) { this.e = e; }
					    E get() { return this.e; }
					}
					"""
			},
			"SUCCESS");
	}
	public void test0165() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					   \s
					    public static void main(String[] args) {
					        AX<X> ax = new AX<X>();
					        AX<String> a = bar(ax);
					        System.out.println("SUCCESS");
						}
					    public static <T> AX<T> bar(AX<?> a) {
							 if (a == null) {
					        	AX<String> as = bar(a);
					        	String s = as.get();
							}
							return null;
					    }   \s
					}
					class AX<E> {
					    E get() { return null; }
					}
					"""
			},
			"SUCCESS");
	}
	public void test0166() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					   \s
					    public static void main(String[] args) {
					        AX<X> ax = new AX<X>(new X());
					        AX<String> a = bar(ax, true);
					        String s = a.get();
					        System.out.println(s);
						}
					    public static <T> AX<T> bar(AX<?> a, boolean recurse) {
					        if (recurse) {
						        AX<String> as = bar(a, false);
								String s = as.get();
					        }
							return new AX("SUCCESS");
					    }   \s
					}
					class AX<E> {
					    E e;
					    AX(E e) { this.e = e; }
					    E get() { return this.e; }
					}
					"""
			},
			"SUCCESS");
	}
	public void test0167() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					   \s
					    public static void main(String[] args) {
					        AX<String, Thread> a = bar();
					        String s = a.get();
					        System.out.println(s);
						}
					    public static <T, U> AX<T, U> bar() {
							return new AX("SUCCESS");
					    }   \s
					}
					class AX<E, F> {
					    E e;
					    AX(E e) { this.e = e; }
					    E get() { return this.e; }
					}
					"""
			},
			"SUCCESS");
	}
	// FAIL ERRMSG (type display)
	public void test0168() {
		if (this.complianceLevel >= ClassFileConstants.JDK1_8)
			return;
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					   \s
					    public static void main(String[] args) {
					        AX<String, Thread> a = bar();
					        String s = a.get();
					        System.out.println(s);
						}
					    public static <T, U> AX<AX<T, T>, U> bar() {
							return new AX("SUCCESS");
					    }   \s
					}
					class AX<E, F> {
					    E e;
					    AX(E e) { this.e = e; }
					    E get() { return this.e; }
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					AX<String, Thread> a = bar();
					                       ^^^^^
				Type mismatch: cannot convert from AX<AX<Object,Object>,Thread> to AX<String,Thread>
				----------
				2. WARNING in X.java (at line 9)
					return new AX("SUCCESS");
					       ^^^^^^^^^^^^^^^^^
				Type safety: The constructor AX(Object) belongs to the raw type AX. References to generic type AX<E,F> should be parameterized
				----------
				3. WARNING in X.java (at line 9)
					return new AX("SUCCESS");
					       ^^^^^^^^^^^^^^^^^
				Type safety: The expression of type AX needs unchecked conversion to conform to AX<AX<T,T>,U>
				----------
				4. WARNING in X.java (at line 9)
					return new AX("SUCCESS");
					           ^^
				AX is a raw type. References to generic type AX<E,F> should be parameterized
				----------
				""");
	}
	public void test0169() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					   \s
					    public static void main(String[] args) {
					        AX<String> a = bar(new X());
					        String s = a.get();
					        System.out.println(s);
						}
					    public static <T> AX<T> bar(T t) {
							return new AX("SUCCESS");
					    }   \s
					}
					class AX<E> {
					    E e;
					    AX(E e) { this.e = e; }
					    E get() { return this.e; }
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					AX<String> a = bar(new X());
					               ^^^^^^^^^^^^
				Type mismatch: cannot convert from AX<X> to AX<String>
				----------
				2. WARNING in X.java (at line 9)
					return new AX("SUCCESS");
					       ^^^^^^^^^^^^^^^^^
				Type safety: The constructor AX(Object) belongs to the raw type AX. References to generic type AX<E> should be parameterized
				----------
				3. WARNING in X.java (at line 9)
					return new AX("SUCCESS");
					       ^^^^^^^^^^^^^^^^^
				Type safety: The expression of type AX needs unchecked conversion to conform to AX<T>
				----------
				4. WARNING in X.java (at line 9)
					return new AX("SUCCESS");
					           ^^
				AX is a raw type. References to generic type AX<E> should be parameterized
				----------
				""");
	}
	// Expected type inference for cast operation
	public void test0170() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"public class X {\n" +
				"    \n" +
				"    public static void main(String[] args) {\n" +
				"        AX<X> ax = new AX<X>(new X());\n" +
				"        AX<String> as = new AX<String>(\"\");\n" +
				"        ax = (AX)bar(ax);\n" + // shouldn't complain about unnecessary cast
				"	}\n" +
				"    public static <T> T bar(AX<?> a) {\n" +
				"		return a.get();\n" +
				"    }    \n" +
				"}\n" +
				"class AX<E> {\n" +
				"	 E e;\n" +
				"    AX(E e) { this.e = e; }\n" +
				"    E get() { return this.e; }\n" +
				"}\n"
			},
			"""
				----------
				1. WARNING in X.java (at line 6)
					ax = (AX)bar(ax);
					     ^^^^^^^^^^^
				Type safety: The expression of type AX needs unchecked conversion to conform to AX<X>
				----------
				2. WARNING in X.java (at line 6)
					ax = (AX)bar(ax);
					      ^^
				AX is a raw type. References to generic type AX<E> should be parameterized
				----------
				3. ERROR in X.java (at line 9)
					return a.get();
					       ^^^^^^^
				Type mismatch: cannot convert from capture#1-of ? to T
				----------
				""");
	}
	// Expected type inference for cast operation
	public void test0171() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"public class X {\n" +
				"    \n" +
				"    public static void main(String[] args) {\n" +
				"        AX<X> ax = new AX<X>(new X());\n" +
				"        AX<String> as = new AX<String>(\"\");\n" +
				"        ax = (AX<X>)bar(ax);\n" + // shouldn't complain about unnecessary cast as return type inference do not
				"	}\n" +                                         // work on cast conversion
				"    public static <T> T bar(AX<?> a) {\n" +
				"		return a.get();\n" +
				"    }    \n" +
				"}\n" +
				"class AX<E> {\n" +
				"	 E e;\n" +
				"    AX(E e) { this.e = e; }\n" +
				"    E get() { return this.e; }\n" +
				"}\n"
			},
			"""
				----------
				1. WARNING in X.java (at line 6)
					ax = (AX<X>)bar(ax);
					     ^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Object to AX<X>
				----------
				2. ERROR in X.java (at line 9)
					return a.get();
					       ^^^^^^^
				Type mismatch: cannot convert from capture#1-of ? to T
				----------
				""");
	}
	// Expected type inference for cast operation
	public void test0172() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"public class X {\n" +
				"    \n" +
				"    public static void main(String[] args) {\n" +
				"        AX<X> ax = new AX<X>(new X());\n" +
				"        AX<String> as = new AX<String>(\"SUCCESS\");\n" +
				"        ax = (AX<X>)bar(ax);\n" + // no warn for unsafe cast, since forbidden cast
				"	}\n" +
				"    public static <T> String bar(AX<?> a) {\n" +
				"		return null;\n" +
				"    }    \n" +
				"}\n" +
				"class AX<E> {\n" +
				"	 E e;\n" +
				"    AX(E e) { this.e = e; }\n" +
				"    E get() { return this.e; }\n" +
				"}\n"
			},
			"""
				----------
				1. ERROR in X.java (at line 6)
					ax = (AX<X>)bar(ax);
					     ^^^^^^^^^^^^^^
				Cannot cast from String to AX<X>
				----------
				""");
	}
	// Expected type inference for return statement
	public void test0173() {
		this.runConformTest(
			new String[] {
				"X.java",
				"public class X {\n" +
				"    \n" +
				"    public static void main(String[] args) {\n" +
				"    	foo();\n" +
				"    	System.out.println(\"SUCCESS\");\n" +
				"	}\n" +
				"    public static <T> T bar(AX<?> a) {\n" +
				"		return null;\n" +
				"    }    \n" +
				"    public static AX<X> foo() {\n" +
				"        AX<X> ax = new AX<X>(new X());\n" +
				"       return bar(ax);\n" + // use return type of enclosing method for type inference
				"    }\n" +
				"}\n" +
				"class AX<E> {\n" +
				"	 E e;\n" +
				"    AX(E e) { this.e = e; }\n" +
				"    E get() { return this.e; }\n" +
				"}\n" +
				"\n"
			},
			"SUCCESS");
	}
	// Expected type inference for field declaration
	public void test0174() {
		this.runConformTest(
			new String[] {
				"X.java",
				"public class X {\n" +
				"    \n" +
				"    public static void main(String[] args) {\n" +
				"    	Object o = foo;\n" +
				"    	System.out.println(\"SUCCESS\");\n" +
				"	}\n" +
				"    public static <T> T bar(AX<?> a) {\n" +
				"		return null;\n" +
				"    }    \n" +
				"    static AX<X> foo = bar(new AX<X>(new X()));\n" + // use field type for type inference
				"}\n" +
				"class AX<E> {\n" +
				"	 E e;\n" +
				"    AX(E e) { this.e = e; }\n" +
				"    E get() { return this.e; }\n" +
				"}\n" +
				"\n"
			},
			"SUCCESS");
	}
	// 60563
	public void test0175() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					    interface A<T> {
					        T[] m1(T x);                         \s
					    }
					    public class X {\s
					    	public static void main(String[] args) {
								new X().m2(new A<X>(){\s
									public X[] m1(X x) {\s
										System.out.println("SUCCESS");
										return null;
									}
								});
							}
					        void m2(A<X> x) {\s
					            m3(x.m1(new X()));\s
					        }
					        void m3(X[] x) {
					        }                   \s
					    }
					"""
			},
			"SUCCESS");
	}
	// unsafe raw return value
	public void test0176() {
		Map customOptions = getCompilerOptions();
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					
					public class X {
					    <T> Vector<T> valuesOf(Hashtable<?, T> h) {
					        return new Vector();
					    }
					    Vector<Object> data;
					   \s
					    public void t() {
					        Vector<Object> v = (Vector<Object>) data.elementAt(0);
					    }
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 5)
					return new Vector();
					       ^^^^^^^^^^^^
				Type safety: The expression of type Vector needs unchecked conversion to conform to Vector<T>
				----------
				2. WARNING in X.java (at line 5)
					return new Vector();
					           ^^^^^^
				Vector is a raw type. References to generic type Vector<E> should be parameterized
				----------
				3. WARNING in X.java (at line 10)
					Vector<Object> v = (Vector<Object>) data.elementAt(0);
					                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Object to Vector<Object>
				----------
				""",
			null,
			true,
			customOptions);
	}
	// cast to type variable allowed, can be diagnosed as unnecessary
	public void test0177() {
		Map options = getCompilerOptions();
		runConformTest(
	 		// test directory preparation
			true /* flush output directory */,
			new String[] { /* test files */
				"X.java",
				"""
					public class X <T> {
					\t
						T foo(T t) {
							return (T) t;
						}
					}
					""",
			},
			// compiler options
			null /* no class libraries */,
			options /* custom options - happen to be the default not changed by the test suite */,
			// compiler results
			"----------\n" + /* expected compiler log */
			"1. WARNING in X.java (at line 4)\n" +
			"	return (T) t;\n" +
			"	       ^^^^^\n" +
			"Unnecessary cast from T to T\n" +
			"----------\n",
			// runtime results
			null /* do not check output string */,
			null /* do not check error string */,
			// javac options
			JavacTestOptions.Excuse.EclipseHasSomeMoreWarnings /* javac test options */);
	}
	// reject instanceof type variable or parameterized type
	public void test0178() {
		if (this.complianceLevel >= ClassFileConstants.JDK16)
			return;
		Map customOptions = getCompilerOptions();
		this.runNegativeTest(
			new String[] {
				"X.java",
				"public class X <T> {\n" +
				"	\n" +
				"	T foo(T t) {\n" +
				"		if (t instanceof X<T>) {\n" +
				"			return t;\n" +
				"		} else if (t instanceof X<String>) {\n" +
				"			return t;\n" +
				"		} else if (t instanceof X<?>) {\n" +  // ok
				"			return t;\n" +
				"		} else 	if (t instanceof T) {\n" +
				"			return t;\n" +
				"		} else if (t instanceof X) {\n" +
				"			return t;\n" +
				"		}\n" +
				"		return null;\n" +
				"	}\n" +
				"}\n",
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					if (t instanceof X<T>) {
					    ^^^^^^^^^^^^^^
				Cannot perform instanceof check against parameterized type X<T>. Use the form X<?> instead since further generic type information will be erased at runtime
				----------
				2. ERROR in X.java (at line 6)
					} else if (t instanceof X<String>) {
					           ^^^^^^^^^^^^^^
				Cannot perform instanceof check against parameterized type X<String>. Use the form X<?> instead since further generic type information will be erased at runtime
				----------
				3. ERROR in X.java (at line 10)
					} else 	if (t instanceof T) {
					       	    ^^^^^^^^^^^^^^
				Cannot perform instanceof check against type parameter T. Use its erasure Object instead since further generic type information will be erased at runtime
				----------
				""",
			null,
			true,
			customOptions);
	}
	public void test0178a() {
		if (this.complianceLevel < ClassFileConstants.JDK17)
			return;
		Map customOptions = getCompilerOptions();
		customOptions.put(CompilerOptions.OPTION_ReportPreviewFeatures, CompilerOptions.WARNING);
		this.runNegativeTest(
			new String[] {
				"X.java",
				"public class X <T> {\n" +
				"	\n" +
				"	T foo(T t) {\n" +
				"		boolean b = false;\n" +
				"		if (t instanceof X<T>) {\n" +
				"			return t;\n" +
				"		} else if (t instanceof X<String>) {\n" +
				"			return t;\n" +
				"		} else if (t instanceof X<?>) {\n" +  // ok
				"			return t;\n" +
				"		} else 	if (t instanceof T) {\n" +
				"			return t;\n" +
				"		} else if (t instanceof X) { // this is allowed since Java 15 as preview feature\n" +
				"			return t;\n" +
				"		}\n" +
				"		return null;\n" +
				"	}\n" +
				"}\n",
			},
			"""
				----------
				1. ERROR in X.java (at line 5)
					if (t instanceof X<T>) {
					    ^
				Type T cannot be safely cast to X<T>
				----------
				2. ERROR in X.java (at line 7)
					} else if (t instanceof X<String>) {
					           ^
				Type T cannot be safely cast to X<String>
				----------
				3. WARNING in X.java (at line 11)
					} else 	if (t instanceof T) {
					       	    ^^^^^^^^^^^^^^
				The expression of type T is already an instance of type T
				----------
				""",
			null,
			true,
			customOptions);
	}
	// 61507
	public void test0179() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					class U {
					 static <T> T notNull(T t) { return t; }
					}
					public class X {
					 void t() {
					  String s = U.notNull(null);
					 }
					 public static void main(String[] args) {
						new X().t();
						System.out.println("SUCCESS");
					}
					}
					""",
			},
			"SUCCESS");
	}
	public void test0180() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					class U {
					 static <T> T notNull(T t) { return t; }
					}
					public class X {
					 void t() {
					  String s = U.notNull("");
					 }
					 public static void main(String[] args) {
						new X().t();
						System.out.println("SUCCESS");
					}
					}
					""",
			},
			"SUCCESS");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=61507 - variation computing most specific type with 'null'
	public void test0181() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					class U {
					 static <T> T notNull(T t, V<T> vt) { return t; }
					}
					class V<T> {}
					
					public class X {
					 void t() {
					  String s = U.notNull(null, new V<String>());
					 }
					 public static void main(String[] args) {
						new X().t();
						System.out.println("SUCCESS");
					}
					}
					""",
			},
			"SUCCESS");
	}
	public void test0182() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<E> {
					    X<E> foo() {
					    	return (X<E>) this;
					    }
					    X<String> bar() {
					    	return (AX<String>) new X<String>();
					    }
					    X<String> bar(Object o) {
					    	return (AX<String>) o;
					    }
					    X<E> foo(Object o) {
					    	return (AX<E>) o;
					    }   \s
					    X<E> baz(Object o) {
					    	return (AX<E>) null;
					    }
					    X<String> baz2(BX bx) {
					    	return (X<String>) bx;
					    }   \s
					}
					class AX<F> extends X<F> {}
					class BX extends AX<String> {}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 3)
					return (X<E>) this;
					       ^^^^^^^^^^^
				Unnecessary cast from X<E> to X<E>
				----------
				2. WARNING in X.java (at line 6)
					return (AX<String>) new X<String>();
					       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Unnecessary cast from X<String> to AX<String>
				----------
				3. WARNING in X.java (at line 9)
					return (AX<String>) o;
					       ^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Object to AX<String>
				----------
				4. WARNING in X.java (at line 12)
					return (AX<E>) o;
					       ^^^^^^^^^
				Type safety: Unchecked cast from Object to AX<E>
				----------
				5. WARNING in X.java (at line 15)
					return (AX<E>) null;
					       ^^^^^^^^^^^^
				Unnecessary cast from null to AX<E>
				----------
				6. WARNING in X.java (at line 18)
					return (X<String>) bx;
					       ^^^^^^^^^^^^^^
				Unnecessary cast from BX to X<String>
				----------
				""");
	}
	public void test0183() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					
					public class X {
					\t
						{
							Dictionary<String, Integer> d;
							Object o;
						\t
							Object a1 = (Hashtable<String,Integer>) d;
							Object a2 = (Hashtable) o;
					
							Object a3 = (Hashtable<Float, Double>) d;
							Object a4 = (Hashtable<String,Integer>) o;
						\t
							abstract class Z1 extends Hashtable<String,Integer> {
								private static final long serialVersionUID = 1L;
							}
							Z1 z1;
							Object a5 = (Hashtable<String,Integer>) z1;
					
							abstract class Z2 extends Z1 {
								private static final long serialVersionUID = 1L;
							}
							Object a6 = (Z2) z1;
					
							abstract class Z3 extends Hashtable {
								private static final long serialVersionUID = 1L;
							}
							Z3 z3;
							Object a7 = (Hashtable<String,Integer>) z3;
						}
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 9)
					Object a1 = (Hashtable<String,Integer>) d;
					            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Unnecessary cast from Dictionary<String,Integer> to Hashtable<String,Integer>
				----------
				2. WARNING in X.java (at line 10)
					Object a2 = (Hashtable) o;
					            ^^^^^^^^^^^^^
				Unnecessary cast from Object to Hashtable
				----------
				3. WARNING in X.java (at line 10)
					Object a2 = (Hashtable) o;
					             ^^^^^^^^^
				Hashtable is a raw type. References to generic type Hashtable<K,V> should be parameterized
				----------
				4. ERROR in X.java (at line 12)
					Object a3 = (Hashtable<Float, Double>) d;
					            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Cannot cast from Dictionary<String,Integer> to Hashtable<Float,Double>
				----------
				5. WARNING in X.java (at line 12)
					Object a3 = (Hashtable<Float, Double>) d;
					            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Unnecessary cast from Dictionary<String,Integer> to Hashtable<Float,Double>
				----------
				6. WARNING in X.java (at line 13)
					Object a4 = (Hashtable<String,Integer>) o;
					            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Object to Hashtable<String,Integer>
				----------
				7. WARNING in X.java (at line 13)
					Object a4 = (Hashtable<String,Integer>) o;
					            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Unnecessary cast from Object to Hashtable<String,Integer>
				----------
				8. WARNING in X.java (at line 19)
					Object a5 = (Hashtable<String,Integer>) z1;
					            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Unnecessary cast from Z1 to Hashtable<String,Integer>
				----------
				9. WARNING in X.java (at line 24)
					Object a6 = (Z2) z1;
					            ^^^^^^^
				Unnecessary cast from Z1 to Z2
				----------
				10. WARNING in X.java (at line 26)
					abstract class Z3 extends Hashtable {
					                          ^^^^^^^^^
				Hashtable is a raw type. References to generic type Hashtable<K,V> should be parameterized
				----------
				11. WARNING in X.java (at line 30)
					Object a7 = (Hashtable<String,Integer>) z3;
					            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Z3 to Hashtable<String,Integer>
				----------
				12. WARNING in X.java (at line 30)
					Object a7 = (Hashtable<String,Integer>) z3;
					            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Unnecessary cast from Z3 to Hashtable<String,Integer>
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=62292 - parameterized message send
	public void test0184() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					
						static <T, U> T foo(T t, U u) {
							return t;
						}
						public static void main(String[] args) {
							System.out.println(X.<String,X>foo("SUCCESS", null));
						}
					}
					""",
			},
			"SUCCESS");
	}
	// parameterized message send - variation on 184 with non-static generic method
	public void test0185() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					
						<T, U> T foo(T t, U u) {
							return t;
						}
						public static void main(String[] args) {
							System.out.println(new X().<String,X>foo("SUCCESS", null));
						}
					}
					""",
			},
			"SUCCESS");
	}
	// message send parameterized with type not matching parameter bounds
	public void test0186() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					
						<T, U extends String> T foo(T t, U u) {
							return t;
						}
						public static void main(String[] args) {
							System.out.println(new X().<String, X>foo("SUCCESS", null));
						}
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 3)
					<T, U extends String> T foo(T t, U u) {
					              ^^^^^^
				The type parameter U should not be bounded by the final type String. Final types cannot be further extended
				----------
				2. ERROR in X.java (at line 7)
					System.out.println(new X().<String, X>foo("SUCCESS", null));
					                                      ^^^
				Bound mismatch: The generic method foo(T, U) of type X is not applicable for the arguments (String, null). The inferred type X is not a valid substitute for the bounded parameter <U extends String>
				----------
				""");
	}
	// invalid type argument arity for parameterized message send
	public void test0187() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					
						<T, U extends String> T foo(T t, U u) {
							return t;
						}
						public static void main(String[] args) {
							System.out.println(new X().<String>foo("SUCCESS", null));
						}
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 3)
					<T, U extends String> T foo(T t, U u) {
					              ^^^^^^
				The type parameter U should not be bounded by the final type String. Final types cannot be further extended
				----------
				2. ERROR in X.java (at line 7)
					System.out.println(new X().<String>foo("SUCCESS", null));
					                                   ^^^
				Incorrect number of type arguments for generic method <T, U>foo(T, U) of type X; it cannot be parameterized with arguments <String>
				----------
				""");
	}
	// parameterized invocation of non generic method with incorrect argument count
	public void test0188() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					
						void foo() {
							return;
						}
						public static void main(String[] args) {
							System.out.println(new X().<String>foo("SUCCESS", null));
						}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 7)
					System.out.println(new X().<String>foo("SUCCESS", null));
					                                   ^^^
				The method foo() in the type X is not applicable for the arguments (String, null)
				----------
				""");
	}
	// parameterized invocation of non generic method
	public void test0189() {
		String expectedOutput = this.complianceLevel < ClassFileConstants.JDK1_7
			? 	"""
				----------
				1. ERROR in X.java (at line 7)
					System.out.println(new X().<String>foo());
					                                   ^^^
				The method foo() of type X is not generic; it cannot be parameterized with arguments <String>
				----------
				"""
			: 	"""
				----------
				1. ERROR in X.java (at line 7)
					System.out.println(new X().<String>foo());
					           ^^^^^^^
				The method println(boolean) in the type PrintStream is not applicable for the arguments (void)
				----------
				2. WARNING in X.java (at line 7)
					System.out.println(new X().<String>foo());
					                            ^^^^^^
				Unused type arguments for the non generic method foo() of type X; it should not be parameterized with arguments <String>
				----------
				""";

		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					
						void foo() {
							return;
						}
						public static void main(String[] args) {
							System.out.println(new X().<String>foo());
						}
					}
					""",
			},
			expectedOutput);
	}
	// parameterized allocation
	public void test0190() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
						public <T> X(T t){
							System.out.println(t);
						}
						public static void main(String[] args) {
							new <String>X("SUCCESS");
						}
					}
					""",
			},
			"SUCCESS");
	}
	// parameterized allocation - wrong arity
	public void test0191() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
						public <T> X(T t){
							System.out.println(t);
						}
						public static void main(String[] args) {
							new <String, String>X("FAILED");
						}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 6)
					new <String, String>X("FAILED");
					^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Incorrect number of type arguments for generic constructor <T>X(T) of type X; it cannot be parameterized with arguments <String, String>
				----------
				""");
	}
	// parameterized allocation - non generic target constructor
	// **
	public void test0192() {
		if (this.complianceLevel < ClassFileConstants.JDK1_7) {
			this.runNegativeTest(
				new String[] {
					"X.java",
					"""
						public class X {
							public X(String t){
								System.out.println(t);
							}
							public static void main(String[] args) {
								new <String>X("FAILED");
							}
						}
						""",
				},
				"""
					----------
					1. ERROR in X.java (at line 6)
						new <String>X("FAILED");
						^^^^^^^^^^^^^^^^^^^^^^^
					The constructor X(String) of type X is not generic; it cannot be parameterized with arguments <String>
					----------
					""");
			return;
		}
		this.runNegativeTest(
				new String[] {
					"X.java",
					"""
						public class X {
							public X(String t){
								System.out.println(t);
							}
							public static void main(String[] args) {
								new <String>X("FAILED");
								Zork z;
							}
						}
						""",
				},
				"""
					----------
					1. WARNING in X.java (at line 6)
						new <String>X("FAILED");
						     ^^^^^^
					Unused type arguments for the non generic constructor X(String) of type X; it should not be parameterized with arguments <String>
					----------
					2. ERROR in X.java (at line 7)
						Zork z;
						^^^^
					Zork cannot be resolved to a type
					----------
					""");
	}
	// parameterized allocation - argument type mismatch
	public void test0193() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
						public <T> X(T t){
							System.out.println(t);
						}
						public static void main(String[] args) {
							new <String>X(new X(null));
						}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 6)
					new <String>X(new X(null));
					^^^^^^^^^^^^^^^^^^^^^^^^^^
				The parameterized constructor <String>X(String) of type X is not applicable for the arguments (X)
				----------
				""");
	}
	// parameterized invocation - argument type mismatch
	public void test0194() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					
						<T> void foo(T t) {
							return;
						}
						public static void main(String[] args) {
							System.out.println(new X().<String>foo(new X()));
						}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 7)
					System.out.println(new X().<String>foo(new X()));
					                                   ^^^
				The parameterized method <String>foo(String) of type X is not applicable for the arguments (X)
				----------
				""");
	}
	// parameterized qualified allocation
	public void test0195() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
						public class MX {
							public <T> MX(T t){
								System.out.println(t);
							}
						}
						public static void main(String[] args) {
							new X().new <String>MX("SUCCESS");
						}
					}
					""",
			},
			"SUCCESS");
	}
	// parameterized qualified allocation - wrong arity
	public void test0196() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
						public class MX {
							public <T> MX(T t){
								System.out.println(t);
							}
						}
						public static void main(String[] args) {
							new X().new <String,String>MX("FAILED");
						}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 8)
					new X().new <String,String>MX("FAILED");
					^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Incorrect number of type arguments for generic constructor <T>MX(T) of type X.MX; it cannot be parameterized with arguments <String, String>
				----------
				""");
	}
	// parameterized qualified allocation - non generic target constructor
	// **
	public void test0197() {
		if (this.complianceLevel < ClassFileConstants.JDK1_7) {
			this.runNegativeTest(
				new String[] {
					"X.java",
					"""
						public class X {
							public class MX {
								public MX(String t){
									System.out.println(t);
								}
							}
							public static void main(String[] args) {
								new X().new <String>MX("FAILED");
							}
						}
						""",
				},
				"""
					----------
					1. ERROR in X.java (at line 8)
						new X().new <String>MX("FAILED");
						^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
					The constructor MX(String) of type X.MX is not generic; it cannot be parameterized with arguments <String>
					----------
					""");
			return;
		}
		this.runNegativeTest(
				new String[] {
					"X.java",
					"""
						public class X {
							public class MX {
								public MX(String t){
									System.out.println(t);
								}
							}
							public static void main(String[] args) {
								new X().new <String>MX("FAILED");
								Zork z;
							}
						}
						""",
				},
				"""
					----------
					1. WARNING in X.java (at line 8)
						new X().new <String>MX("FAILED");
						             ^^^^^^
					Unused type arguments for the non generic constructor X.MX(String) of type X.MX; it should not be parameterized with arguments <String>
					----------
					2. ERROR in X.java (at line 9)
						Zork z;
						^^^^
					Zork cannot be resolved to a type
					----------
					""");
	}
	// parameterized qualified allocation - argument type mismatch
	public void test0198() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
						public class MX {
							public <T>MX(T t){
								System.out.println(t);
							}
						}
						public static void main(String[] args) {
							new X().new <String>MX(new X());
						}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 8)
					new X().new <String>MX(new X());
					^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				The parameterized constructor <String>MX(String) of type X.MX is not applicable for the arguments (X)
				----------
				""");
	}
	// parameterized explicit constructor call
	public void test0199() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
						public <T> X(T t){
							System.out.println(t);
						}
						public static void main(String[] args) {
							class Local extends X {
								Local() {
									<String>super("SUCCESS");
								}
							};
							new Local();
						}
					}
					""",
			},
			"SUCCESS");
	}
	// parameterized explicit constructor call - wrong arity
	public void test0200() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
						public <T> X(T t){
							System.out.println(t);
						}
						public static void main(String[] args) {
							class Local extends X {
								Local() {
									<String,String>super("FAILED");
								}
							};
							new Local();
						}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 8)
					<String,String>super("FAILED");
					               ^^^^^^^^^^^^^^^^
				Incorrect number of type arguments for generic constructor <T>X(T) of type X; it cannot be parameterized with arguments <String, String>
				----------
				""");
	}
	// parameterized explicit constructor call - non generic target constructor
	// **
	public void test0201() {
		if (this.complianceLevel < ClassFileConstants.JDK1_7) {
			this.runNegativeTest(
				new String[] {
					"X.java",
					"""
						public class X {
							public X(String t){
								System.out.println(t);
							}
							public static void main(String[] args) {
								class Local extends X {
									Local() {
										<String>super("FAILED");
									}
								};
								new Local();
							}
						}
						""",
				},
				"""
					----------
					1. ERROR in X.java (at line 8)
						<String>super("FAILED");
						        ^^^^^^^^^^^^^^^^
					The constructor X(String) of type X is not generic; it cannot be parameterized with arguments <String>
					----------
					""");
			return;
		}
		this.runNegativeTest(
				new String[] {
					"X.java",
					"""
						public class X {
							public X(String t){
								System.out.println(t);
								Zork z;
							}
							public static void main(String[] args) {
								class Local extends X {
									Local() {
										<String>super("FAILED");
									}
								};
								new Local();
							}
						}
						""",
				},
				"""
					----------
					1. ERROR in X.java (at line 4)
						Zork z;
						^^^^
					Zork cannot be resolved to a type
					----------
					2. WARNING in X.java (at line 9)
						<String>super("FAILED");
						 ^^^^^^
					Unused type arguments for the non generic constructor X(String) of type X; it should not be parameterized with arguments <String>
					----------
					""");
	}
	// parameterized explicit constructor call - argument type mismatch
	public void test0202() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
						public <T> X(T t){
							System.out.println(t);
						}
						public static void main(String[] args) {
							class Local extends X {
								Local() {
									<String>super(new X(null));
								}
							};
							new Local();
						}
					}
					""", 			},
			"""
				----------
				1. ERROR in X.java (at line 8)
					<String>super(new X(null));
					        ^^^^^^^^^^^^^^^^^^^
				The parameterized constructor <String>X(String) of type X is not applicable for the arguments (X)
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=62822 - supertypes partially resolved during bound check
	public void test0203() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
						public static void main(String[] args) {
							demo.AD ad;
							System.out.println("SUCCESS");
						}
					}
					""",
				"demo/AD.java",
				"package demo;\n" +
				"public interface AD extends LIST<ADXP> {}\n",
				"demo/ADXP.java",
				"package demo;\n" +
				"public interface ADXP extends BIN {}\n",
				"demo/ANY.java",
				"package demo;\n" +
				"public interface ANY {}\n",
				"demo/BL.java",
				"package demo;\n" +
				"public interface BL extends ANY {}\n",
				"demo/LIST.java",
				"package demo;\n" +
				"public interface LIST<T extends ANY> extends ANY {}\n",
				"demo/BIN.java",
				"package demo;\n" +
				"public interface BIN extends LIST<BL> {}\n",
			},
			"SUCCESS");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=62806
	public void test0204() {
		this.runConformTest(
			new String[] {
				"Function.java",
				"""
					public abstract class Function<Y,X> {
					    public abstract Y eval(X x);
					
					}
					""",
				"FunctionMappedComparator.java",
				"""
					import java.util.*;
					public class FunctionMappedComparator<Y,X> implements Comparator<X> {
						/*
						 * 'Function' is highlighted as an error here - the message is:
						 * The type Function is not generic; it cannot be parameterized with arguments <Y, X>
						 */
					    protected Function<Y,X> function;
					    protected Comparator<Y> comparator;
					    public FunctionMappedComparator(Function<Y,X> function,Comparator<Y> comparator ) {
					        this.function=function;
					        this.comparator=comparator;
					    }
					
					    public int compare(X x1, X x2) {
					        return comparator.compare(function.eval(x1),function.eval(x2));
					    }
					}
					""",
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=63555 - reference to static type parameter allowed inside type itself
	public void test0205() {
		this.runConformTest(
			new String[] {
				"Alpha.java",
				"""
					public class Alpha {
						static class Beta<T> {
							T obj;
						}
					}
					""",
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=63555 - variation on static method type parameter
	public void test0206() {
		this.runConformTest(
			new String[] {
				"Alpha.java",
				"""
					public class Alpha {
						static <T> void Beta(T t) {
						}
					}
					""",
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=63590 - disallow parameterized type in catch/throws clause
	public void test0207() {
		this.runNegativeTest(
			new String[] {
				"Alpha.java",
				"""
					public class Alpha<T> extends RuntimeException {
						public static void main(String[] args) {
							new Object() {
								public void m() throws Alpha<String> {
									System.out.println("SUCCESS");
								}
							}.m();
						}
					}
					""",
			},
			"""
				----------
				1. WARNING in Alpha.java (at line 1)
					public class Alpha<T> extends RuntimeException {
					             ^^^^^
				The serializable class Alpha does not declare a static final serialVersionUID field of type long
				----------
				2. ERROR in Alpha.java (at line 1)
					public class Alpha<T> extends RuntimeException {
					                              ^^^^^^^^^^^^^^^^
				The generic class Alpha<T> may not subclass java.lang.Throwable
				----------
				3. ERROR in Alpha.java (at line 4)
					public void m() throws Alpha<String> {
					                       ^^^^^
				Cannot use the parameterized type Alpha<String> either in catch block or throws clause
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=63590 - disallow parameterized type in catch/throws clause
	public void test0208() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T> extends RuntimeException {
						public static void main(String[] args) {
							try {
								throw new X<String>();
							} catch(X<String> e) {
								System.out.println("X<String>");
							} catch(X<X<String>> e) {
								System.out.println("X<X<String>>");
							} catch(RuntimeException e) {
								System.out.println("RuntimeException");
							}
						}
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 1)
					public class X<T> extends RuntimeException {
					             ^
				The serializable class X does not declare a static final serialVersionUID field of type long
				----------
				2. ERROR in X.java (at line 1)
					public class X<T> extends RuntimeException {
					                          ^^^^^^^^^^^^^^^^
				The generic class X<T> may not subclass java.lang.Throwable
				----------
				3. ERROR in X.java (at line 5)
					} catch(X<String> e) {
					                  ^
				Cannot use the parameterized type X<String> either in catch block or throws clause
				----------
				4. ERROR in X.java (at line 7)
					} catch(X<X<String>> e) {
					                     ^
				Cannot use the parameterized type X<X<String>> either in catch block or throws clause
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=63556 - should resolve all occurrences of A to type variable
	public void test0209() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<A,B,C extends java.util.List<A>> {}
					class X2<A,C extends java.util.List<A>, B> {}
					class X3<B, A,C extends java.util.List<A>> {}
					""",
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=68006 - Invalid modifier after parse
	public void test0210() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
						void foo(Map<? super Object, ? extends String> m){
						}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					void foo(Map<? super Object, ? extends String> m){
					         ^^^
				Map cannot be resolved to a type
				----------
				""");
	}
	// test compilation against binaries
	public void test0211() {
		this.runConformTest(
			new String[] {
				"p/Top.java",
				"package p;\n" +
				"public interface Top<T> {}\n",
			},
			"");

		this.runConformTest(
			new String[] {
				"p/Super.java",
				"""
					package p;
					public class Super<T> implements Top<T>{
					    public static void main(String [] args) {
					        System.out.println("SUCCESS");
					    }
					}
					""",
			},
			"SUCCESS",
			null,
			false, // do not flush output
			null);
	}
	// check type variable equivalence
	public void test0212() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					
					public class X<T>{
					    public static void main(String [] args) {
					        System.out.println("SUCCESS");
					    }
						X<T> _recurse;\s
						public List<T> toList(){
							List<T> result = new ArrayList<T>();
							result.addAll(_recurse.toList()); // should be applicable
							return result;
						}
					}
					"""
			},
			"SUCCESS");
	}
	public void test0213() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<R,T extends Comparable<T>>{
						T test;
						public Comparable<? extends T> getThis(){
							return test;
						}
					    public static void main(String [] args) {
					        System.out.println("SUCCESS");
					    }
					}
					"""
			},
			"SUCCESS");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=68133 - verify error
	public void test0214() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.ArrayList;
					public class X {
					    public static void main(String[] args) {
					        ArrayList<Object> l;
					        switch (args.length) {
					        case 1:
					            l = new ArrayList<Object>();
					            System.out.println(l);
					            break;
					        default:
					            System.out.println("SUCCESS");
					            return;
					        }
					    }
					}
					"""
			},
			"SUCCESS");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=68133 variation
	public void test0215() throws Exception {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
						public static void main(String[] args) {
							java.util.ArrayList<Object> i;\t
							outer: {
								if (args == null) {
									i = null;
									break outer;
								}
								return;
							}
							System.out.println(i);\t
							System.out.println("SUCCESS");\t
						}
					}
					""",
			},
			"");

		String expectedOutput =
			"""
			  // Method descriptor #15 ([Ljava/lang/String;)V
			  // Stack: 2, Locals: 2
			  public static void main(java.lang.String[] args);
			     0  aload_0 [args]
			     1  ifnonnull 9
			     4  aconst_null
			     5  astore_1 [i]
			     6  goto 10
			     9  return
			    10  getstatic java.lang.System.out : java.io.PrintStream [16]
			    13  aload_1 [i]
			    14  invokevirtual java.io.PrintStream.println(java.lang.Object) : void [22]
			    17  getstatic java.lang.System.out : java.io.PrintStream [16]
			    20  ldc <String "SUCCESS"> [28]
			    22  invokevirtual java.io.PrintStream.println(java.lang.String) : void [30]
			    25  return
			      Line numbers:
			        [pc: 0, line: 5]
			        [pc: 4, line: 6]
			        [pc: 6, line: 7]
			        [pc: 9, line: 9]
			        [pc: 10, line: 11]
			        [pc: 17, line: 12]
			        [pc: 25, line: 13]
			      Local variable table:
			        [pc: 0, pc: 26] local: args index: 0 type: java.lang.String[]
			        [pc: 6, pc: 9] local: i index: 1 type: java.util.ArrayList
			        [pc: 10, pc: 26] local: i index: 1 type: java.util.ArrayList
			      Local variable type table:
			        [pc: 6, pc: 9] local: i index: 1 type: java.util.ArrayList<java.lang.Object>
			        [pc: 10, pc: 26] local: i index: 1 type: java.util.ArrayList<java.lang.Object>
			""";

		File f = new File(OUTPUT_DIR + File.separator + "X.class");
		byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
		ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
		String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
		int index = result.indexOf(expectedOutput);
		if (index == -1 || expectedOutput.length() == 0) {
			System.out.println(Util.displayString(result, 3));
		}
		if (index == -1) {
			assertEquals("Wrong contents", expectedOutput, result);
		}
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=68998 parameterized field constants
	public void test0216() {
		this.runConformTest(
			new String[] {
				"test/cheetah/NG.java",
				"""
					package test.cheetah;
					public class NG extends G {
							public static void main(String[] args) {
								System.out.println("SUCCESS");\t
							}
					    public boolean test() {
					        return o == null;
					    }
					}
					""",
				"test/cheetah/G.java",
				"""
					package test.cheetah;
					public class G<E> {
					    protected Object o;
					}
					""",
			},
			"SUCCESS");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69135 - unnecessary cast operation
	public void test0217() {
		Map customOptions = getCompilerOptions();
		runConformTest(
			// test directory preparation
			true /* flush output directory */,
			new String[] { /* test files */
				"X.java",
				"""
					import java.util.ArrayList;
					public class X {
					    public static void main(String [] args) {
							ArrayList<String> l= new ArrayList<String>();
							String string = (String) l.get(0);
					    }
					}
					""",
			},
			// compiler options
			null /* no class libraries */,
			customOptions /* custom options */,
			// compiler results
			"----------\n" + /* expected compiler log */
			"1. WARNING in X.java (at line 5)\n" +
			"	String string = (String) l.get(0);\n" +
			"	                ^^^^^^^^^^^^^^^^^\n" +
			"Unnecessary cast from String to String\n" +
			"----------\n",
			// runtime results
			null /* do not check output string */,
			"java.lang.IndexOutOfBoundsException" /* do not check error string */,
			// javac options
			JavacTestOptions.Excuse.EclipseHasSomeMoreWarnings /* javac test options */);
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=64154 visibility issue due to invalid use of parameterized binding
	public void test0218() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T>{
						private final T _data;
						private X(T data){
							_data = data;
						}
						public T getData(){
							return _data;
						}
						public static <E> X<E> create(E data) {
							return new X<E>(data);
						}
						public static void main(String[] args) {
							create(new Object());
							System.out.println("SUCCESS");
						}
					}
					""",
			},
			"SUCCESS");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=64154 variation
	public void test0219() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T>{
						private final T _data;
						private X(T data){
							_data = data;
						}
						public T getData(){
							return _data;
						}
						public static <E> E create(E data) {
							return new X<E>(data)._data;
						}
						public static void main(String[] args) {
							create(new Object());
							System.out.println("SUCCESS");
						}
					}
					""",
			},
			"SUCCESS");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69141 unsafe wildcard operation tolerates wildcard with lower bounds
	public void test0220() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.ArrayList;
					
					public class X {
						void foo() {
							ArrayList<? super Integer> al = new ArrayList<Object>();
							al.add(Integer.valueOf(1)); // (1)
							Integer i = al.get(0);  // (2)
						}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 7)
					Integer i = al.get(0);  // (2)
					            ^^^^^^^^^
				Type mismatch: cannot convert from capture#2-of ? super Integer to Integer
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69141 variation
	public void test0221() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.ArrayList;
					
					public class X {
						void foo() {
							ArrayList<? extends Integer> al = new ArrayList<Integer>();
							al.add(Integer.valueOf(1)); // (1)
						}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 6)
					al.add(Integer.valueOf(1)); // (1)
					   ^^^
				The method add(capture#1-of ? extends Integer) in the type ArrayList<capture#1-of ? extends Integer> is not applicable for the arguments (Integer)
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69141: variation
	public void test0222() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
						public static void main(String[] args) {
							XList<? super Integer> lx = new XList<Integer>();
							lx.slot = Integer.valueOf(1);
							Integer i = lx.slot;
					    }    \t
					}
					class XList<E> {
					    E slot;
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 5)
					Integer i = lx.slot;
					            ^^^^^^^
				Type mismatch: cannot convert from capture#2-of ? super Integer to Integer
				----------
				""");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69251- instantiating wildcards
	public void test0223() {
		Map customOptions = getCompilerOptions();
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.HashMap;
					import java.util.Map;
					public class X {
					    static final Map<String, Class<? extends Object>> classes\s
					            = new HashMap<String, Class<? extends Object>>();
					   \s
					    static final Map<String, Class<? extends Object>> classes2\s
					            = new HashMap<String, Class>();
					   \s
					    class MX<E> {
					    	E get() { return null; }
					    	void foo(E e) {}
					    }
					   \s
					    void foo() {
					    	MX<Class<? extends Object>> mx1 = new MX<Class<? extends Object>>();
					    	MX<Class> mx2 = new MX<Class>();
					    	mx1.foo(mx2.get());
					    }
					}
					"""	,
			},
			"""
				----------
				1. ERROR in X.java (at line 8)
					= new HashMap<String, Class>();
					  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from HashMap<String,Class> to Map<String,Class<? extends Object>>
				----------
				2. WARNING in X.java (at line 8)
					= new HashMap<String, Class>();
					                      ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				3. WARNING in X.java (at line 17)
					MX<Class> mx2 = new MX<Class>();
					   ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				4. WARNING in X.java (at line 17)
					MX<Class> mx2 = new MX<Class>();
					                       ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				5. WARNING in X.java (at line 18)
					mx1.foo(mx2.get());
					        ^^^^^^^^^
				Type safety: The expression of type Class needs unchecked conversion to conform to Class<? extends Object>
				----------
				""",
			null,
			true,
			customOptions);
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=68998 variation
	public void test0224() {
		this.runNegativeTest(
			new String[] {
				"test/cheetah/NG.java",
				"""
					package test.cheetah;
					public class NG extends G {
							public static void main(String[] args) {
								System.out.println("SUCCESS");\t
							}
					    public boolean test() {
					        return o == null;
					    }
					}
					""",
				"test/cheetah/G.java",
				"""
					package test.cheetah;
					public class G<E> {
					    protected final Object o;
					}
					""",
			},
			"""
				----------
				1. WARNING in test\\cheetah\\NG.java (at line 2)
					public class NG extends G {
					                        ^
				G is a raw type. References to generic type G<E> should be parameterized
				----------
				----------
				1. ERROR in test\\cheetah\\G.java (at line 3)
					protected final Object o;
					                       ^
				The blank final field o may not have been initialized
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69353 - prevent using type parameter in catch block
	public void test0225() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends Exception> {
					    String foo() throws T {
					        return "SUCCESS";
					    }
					    public static void main(String[] args) {
					        new X<EX>().baz(new EX());
					    }
					    void baz(final T t) {
					        new Object() {
					            void print() {
					                try {
						                System.out.println(foo());
					                } catch (T t) {
					                }
					            }
					        }.print();
					    }
					}
					class EX extends Exception {
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 13)
					} catch (T t) {
					           ^
				Cannot use the type parameter T in a catch block
				----------
				2. WARNING in X.java (at line 13)
					} catch (T t) {
					           ^
				The parameter t is hiding another local variable defined in an enclosing scope
				----------
				3. WARNING in X.java (at line 19)
					class EX extends Exception {
					      ^^
				The serializable class EX does not declare a static final serialVersionUID field of type long
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69170 - invalid generic array creation
	public void test0226() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T>{
						 Object x1= new T[0];
						 Object x2= new X<String>[0];	\s
						 Object x3= new X<T>[0];	\s
						 Object x4= new X[0];	\s
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					Object x1= new T[0];
					           ^^^^^^^^
				Cannot create a generic array of T
				----------
				2. ERROR in X.java (at line 3)
					Object x2= new X<String>[0];	\s
					           ^^^^^^^^^^^^^^^^
				Cannot create a generic array of X<String>
				----------
				3. ERROR in X.java (at line 4)
					Object x3= new X<T>[0];	\s
					           ^^^^^^^^^^^
				Cannot create a generic array of X<T>
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69359 - unsafe cast diagnosis
	public void test0227() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					 import java.util.*;
					 public class X {
					  List list() { return null; }
					  void m() { List<X> l = (List<X>)list(); } // unsafe cast
					  void m0() { List<X> l = list(); } // unsafe conversion
					  void m1() { for (X a : list()); } // type mismatch
					  void m2() { for (Iterator<X> i = list().iterator(); i.hasNext();); }  // unsafe conversion
					  void m3() { Collection c = null; List l = (List<X>)c; } // unsafe cast
					  void m4() { Collection c = null; List l = (List<?>)c; } // ok
					  void m5() { List c = null; List l = (Collection<X>)c; } // type mismatch
					  void m6() { List c = null; List l = (Collection<?>)c; } // type mismatch
					}
					"""	,
			},
			"""
				----------
				1. WARNING in X.java (at line 3)
					List list() { return null; }
					^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				2. WARNING in X.java (at line 4)
					void m() { List<X> l = (List<X>)list(); } // unsafe cast
					                       ^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from List to List<X>
				----------
				3. WARNING in X.java (at line 4)
					void m() { List<X> l = (List<X>)list(); } // unsafe cast
					                       ^^^^^^^^^^^^^^^
				Unnecessary cast from List to List<X>
				----------
				4. WARNING in X.java (at line 5)
					void m0() { List<X> l = list(); } // unsafe conversion
					                        ^^^^^^
				Type safety: The expression of type List needs unchecked conversion to conform to List<X>
				----------
				5. ERROR in X.java (at line 6)
					void m1() { for (X a : list()); } // type mismatch
					                       ^^^^^^
				Type mismatch: cannot convert from element type Object to X
				----------
				6. WARNING in X.java (at line 7)
					void m2() { for (Iterator<X> i = list().iterator(); i.hasNext();); }  // unsafe conversion
					                                 ^^^^^^^^^^^^^^^^^
				Type safety: The expression of type Iterator needs unchecked conversion to conform to Iterator<X>
				----------
				7. WARNING in X.java (at line 8)
					void m3() { Collection c = null; List l = (List<X>)c; } // unsafe cast
					            ^^^^^^^^^^
				Collection is a raw type. References to generic type Collection<E> should be parameterized
				----------
				8. WARNING in X.java (at line 8)
					void m3() { Collection c = null; List l = (List<X>)c; } // unsafe cast
					                                 ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				9. WARNING in X.java (at line 8)
					void m3() { Collection c = null; List l = (List<X>)c; } // unsafe cast
					                                          ^^^^^^^^^^
				Type safety: Unchecked cast from Collection to List<X>
				----------
				10. WARNING in X.java (at line 9)
					void m4() { Collection c = null; List l = (List<?>)c; } // ok
					            ^^^^^^^^^^
				Collection is a raw type. References to generic type Collection<E> should be parameterized
				----------
				11. WARNING in X.java (at line 9)
					void m4() { Collection c = null; List l = (List<?>)c; } // ok
					                                 ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				12. WARNING in X.java (at line 10)
					void m5() { List c = null; List l = (Collection<X>)c; } // type mismatch
					            ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				13. WARNING in X.java (at line 10)
					void m5() { List c = null; List l = (Collection<X>)c; } // type mismatch
					                           ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				14. WARNING in X.java (at line 10)
					void m5() { List c = null; List l = (Collection<X>)c; } // type mismatch
					                                    ^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from List to Collection<X>
				----------
				15. ERROR in X.java (at line 10)
					void m5() { List c = null; List l = (Collection<X>)c; } // type mismatch
					                                    ^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Collection<X> to List
				----------
				16. WARNING in X.java (at line 11)
					void m6() { List c = null; List l = (Collection<?>)c; } // type mismatch
					            ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				17. WARNING in X.java (at line 11)
					void m6() { List c = null; List l = (Collection<?>)c; } // type mismatch
					                           ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				18. ERROR in X.java (at line 11)
					void m6() { List c = null; List l = (Collection<?>)c; } // type mismatch
					                                    ^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Collection<capture#2-of ?> to List
				----------
				""");
	}
	// conversion from raw to X<?> is safe (no unsafe warning)
	public void test0228() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					 import java.util.*;
					 public class X {
					 	List<?> list = new ArrayList();
					 }
					""",
			},
			"");
	}
	// can resolve member through type variable
	public void test0229() {
		runConformTest(
			true,
			new String[] {
				"X.java",
				"""
					 public class X <T extends XC> {
					 	T.MXC f;
					 	public static void main(String[] args) {
							System.out.println("SUCCESS");
						}
					 }
					 class XC {
					 	class MXC {}
					 }
					""",
			},
			null,
			"SUCCESS",
			null,
			JavacTestOptions.JavacHasABug.JavacBug6569404);
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69375 - equivalence of wildcards
	public void test0230() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.List;
					
					public class X {
						void foo() {
							List<? extends Integer> li= null;
							List<? extends Number> ln= null;
							ln = li;
							li= ln;
						}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 8)
					li= ln;
					    ^^
				Type mismatch: cannot convert from List<capture#4-of ? extends Number> to List<? extends Integer>
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69170 - variation
	public void test0231() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T>{
						 Object x1= new X<?>[0];	\s
						 Object x2= new X<? super String>[0];	\s
						 Object x3= new X<? extends Thread>[0];	\s
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					Object x2= new X<? super String>[0];	\s
					           ^^^^^^^^^^^^^^^^^^^^^^^^
				Cannot create a generic array of X<? super String>
				----------
				2. ERROR in X.java (at line 4)
					Object x3= new X<? extends Thread>[0];	\s
					           ^^^^^^^^^^^^^^^^^^^^^^^^^^
				Cannot create a generic array of X<? extends Thread>
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69542 - generic cast should be less strict
	public void test0232() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					 	static class Container<T>{
						    private T val;
						    public T getVal() {
						        return val;
						    }
						    public void setVal(T val) {
						        this.val = val;
						    }
						}
						public static void badMethod(Container<?> param){
						    Container x=param;
						    x.setVal("BAD");
						}
						public static void main(String[] args) {
						    Container<Integer> cont=new Container<Integer>();
						    cont.setVal(new Integer(0));
						    badMethod(cont);
						    Object someVal = cont.getVal(); // no cast\s
						    System.out.println(cont.getVal()); // no cast\s
						}
					}
					""",
			},
			"BAD");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69542 - variation
	public void test0233() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					 	static class Container<T>{
						    private T val;
						    public T getVal() {
						        return val;
						    }
						    public void setVal(T val) {
						        this.val = val;
						    }
						}
						public static void badMethod(Container<?> param){
						    Container x=param;
						    x.setVal(new Long(0));
						}
						public static void main(String[] args) {
						    Container<Integer> cont=new Container<Integer>();
						    cont.setVal(new Integer(0));
						    badMethod(cont);
						    Number someVal = cont.getVal();// only cast to Number\s
						    System.out.println("SUCCESS");\s
						}
					}
					""",
			},
			"SUCCESS");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69542 - variation
	public void test0234() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					 	static class Container<T>{
						    public T val;
						    public T getVal() {
						        return val;
						    }
						    public void setVal(T val) {
						        this.val = val;
						    }
						}
						public static void badMethod(Container<?> param){
						    Container x=param;
						    x.setVal("BAD");
						}
						public static void main(String[] args) {
						    Container<Integer> cont=new Container<Integer>();
						    cont.setVal(new Integer(0));
						    badMethod(cont);
						    Object someVal = cont.val; // no cast\s
						    System.out.println(cont.val); // no cast\s
						}
					}
					""",
			},
			"BAD");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69542 - variation
	public void test0235() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					 	static class Container<T>{
						    public T val;
						    public T getVal() {
						        return val;
						    }
						    public void setVal(T val) {
						        this.val = val;
						    }
						}
						public static void badMethod(Container<?> param){
						    Container x=param;
						    x.setVal(new Long(0));
						}
						public static void main(String[] args) {
						    Container<Integer> cont=new Container<Integer>();
						    cont.setVal(new Integer(0));
						    badMethod(cont);
						    Number someVal = cont.val;// only cast to Number\s
						    System.out.println("SUCCESS");\s
						}
					}
					""",
			},
			"SUCCESS");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69542 - variation
	public void test0236() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					 	static class Container<T>{
						    public T val;
						    public T getVal() {
						        return val;
						    }
						    public void setVal(T val) {
						        this.val = val;
						    }
						}
						public static void badMethod(Container<?> param){
						    Container x=param;
						    x.setVal("BAD");
						}
						public static void main(String[] args) {
						    Container<Integer> cont=new Container<Integer>();
						    cont.setVal(new Integer(0));
						    badMethod(cont);
						    Object someVal = (cont).val; // no cast\s
						    System.out.println((cont).val); // no cast\s
						}
					}
					""",
			},
			"BAD");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69542 - variation
	public void test0237() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					 	static class Container<T>{
						    public T val;
						    public T getVal() {
						        return val;
						    }
						    public void setVal(T val) {
						        this.val = val;
						    }
						}
						public static void badMethod(Container<?> param){
						    Container x=param;
						    x.setVal(new Long(0));
						}
						public static void main(String[] args) {
						    Container<Integer> cont=new Container<Integer>();
						    cont.setVal(new Integer(0));
						    badMethod(cont);
						    Number someVal = (cont).val;// only cast to Number\s
						    System.out.println("SUCCESS");\s
						}
					}
					""",
			},
			"SUCCESS");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69542 - variation
	public void test0238() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					 	static class Container<T>{
						    public T val;
							Container<T> next;
						    public T getVal() {
						        return val;
						    }
						    public void setVal(T val) {
						        this.val = val;
						    }
						}
						public static void badMethod(Container<?> param){
						    Container x=param;
						    x.setVal("BAD");
						}
						public static void main(String[] args) {
						    Container<Integer> cont = new Container<Integer>();
							cont.next = new Container<Integer>();
						    cont.next.setVal(new Integer(0));
						    badMethod(cont.next);
						    Object someVal = cont.next.val; // no cast\s
						    System.out.println(cont.next.val); // no cast\s
						}
					}
					""",
			},
			"BAD");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69542 - variation
	public void test0239() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					 	static class Container<T>{
						    public T val;
							Container<T> next;
						    public T getVal() {
						        return val;
						    }
						    public void setVal(T val) {
						        this.val = val;
						    }
						}
						public static void badMethod(Container<?> param){
						    Container x=param;
						    x.setVal(new Long(0));
						}
						public static void main(String[] args) {
						    Container<Integer> cont = new Container<Integer>();
							cont.next = new Container<Integer>();
						    cont.next.setVal(new Integer(0));
						    badMethod(cont.next);
						    Number someVal = cont.next.val;// only cast to Number\s
						    System.out.println("SUCCESS");\s
						}
					}
					""",
			},
			"SUCCESS");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69713 NPE due to length pseudo field
	public void test0240() {
		this.runNegativeTest(
			new String[] {
				"X.java",
			"""
				public class X {
				    String[] elements = null;
				\t
				    public X() {
				        String s = "a, b, c, d";
				        elements = s.split(",");
				        if(elements.length = 3) {
				        }
				    }
				}
				"""
			},
			"""
				----------
				1. ERROR in X.java (at line 7)
					if(elements.length = 3) {
					   ^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from int to boolean
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69776 - missing checkcast on cast operation
	public void test0241() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.HashMap;
					import java.util.Map;
					public class X {
					    private static final Map<String, Class> classes = new HashMap<String, Class>();
					    public static void main(String[] args) throws Exception {
					    	classes.put("test", X.class);
					        final Class<? extends Object> clazz = (Class<? extends Object>) classes.get("test");
					        Object o = clazz.newInstance();
					        System.out.println("SUCCESS");
					    }
					}
					""",
			},
			"SUCCESS");
	}
	// 69776 - variation
	public void test0242() {
		Map<String,String> options = getCompilerOptions();
		options.put(CompilerOptions.OPTION_ReportDeprecation, CompilerOptions.IGNORE);
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.HashMap;
					import java.util.Map;
					@SuppressWarnings({"rawtypes"})
					public class X {
					    private static final Map<String, Class> classes = new HashMap<String, Class>();
					    public static void main(String[] args) throws Exception {
					    	classes.put("test", X.class);
					        final Class<? extends Object> clazz = (Class<? extends Object>) classes.get("test");
					        final Class<? extends String> clazz2 = (Class<? extends String>) classes.get("test");
					        final Class<String> clazz3 = (Class<String>) classes.get("test");
					        Object o = clazz.newInstance();
					    }
					}""", // =================
			},
			"""
				----------
				1. WARNING in X.java (at line 8)
					final Class<? extends Object> clazz = (Class<? extends Object>) classes.get("test");
					                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Class to Class<? extends Object>
				----------
				2. WARNING in X.java (at line 8)
					final Class<? extends Object> clazz = (Class<? extends Object>) classes.get("test");
					                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Unnecessary cast from Class to Class<? extends Object>
				----------
				3. WARNING in X.java (at line 9)
					final Class<? extends String> clazz2 = (Class<? extends String>) classes.get("test");
					                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Class to Class<? extends String>
				----------
				4. WARNING in X.java (at line 9)
					final Class<? extends String> clazz2 = (Class<? extends String>) classes.get("test");
					                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Unnecessary cast from Class to Class<? extends String>
				----------
				5. WARNING in X.java (at line 10)
					final Class<String> clazz3 = (Class<String>) classes.get("test");
					                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Class to Class<String>
				----------
				6. WARNING in X.java (at line 10)
					final Class<String> clazz3 = (Class<String>) classes.get("test");
					                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Unnecessary cast from Class to Class<String>
				----------
				""",
			null, true, options );
	}
	public void test0243() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					    public X foo() {
					        System.out.println("Did NOT add bridge method");
					        return this;
					    }
					    public static void main(String[] args) throws Exception {
					        X x = new A();
					        x.foo();
					        System.out.print(" + ");
					        I i = new A();
					        i.foo();
					    }
					}
					interface I {
					    public I foo();
					}
					class A extends X implements I {
					    public A foo() {
					        System.out.print("Added bridge method");
					        return this;
					    }
					}
					"""
			},
			"Added bridge method + Added bridge method");
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					    public X foo() { return this; }
					    public static void main(String[] args) throws Exception {
					        System.out.println("SUCCESS");
					    }
					}
					""",
				"SubTypes.java",
				"""
					class A extends X {
					    @Override public A foo() { return this; }
					}
					class B extends X {
					    @Override public X foo() { return new X(); }
					    @Override public B foo() { return this; }
					}
					class C extends A {
					    @Override public X foo() { return new X(); }
					}
					"""
			},
			"""
				----------
				1. ERROR in SubTypes.java (at line 5)
					@Override public X foo() { return new X(); }
					                   ^^^^^
				Duplicate method foo() in type B
				----------
				2. ERROR in SubTypes.java (at line 6)
					@Override public B foo() { return this; }
					                   ^^^^^
				Duplicate method foo() in type B
				----------
				3. ERROR in SubTypes.java (at line 9)
					@Override public X foo() { return new X(); }
					                 ^
				The return type is incompatible with A.foo()
				----------
				""");
	}
	// generic method of raw type
	public void test0244() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {\s
						<G> T foo(G g) {
							return null;
						}
					\t
						public static void main(String[] args) {
							X rx = new X();
							rx.foo("hello");
						}
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 7)
					X rx = new X();
					^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				2. WARNING in X.java (at line 7)
					X rx = new X();
					           ^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				3. WARNING in X.java (at line 8)
					rx.foo("hello");
					^^^^^^^^^^^^^^^
				Type safety: The method foo(Object) belongs to the raw type X. References to generic type X<T> should be parameterized
				----------
				""");
	}
	// generic method of raw type
	public void test0245() {
		if (this.complianceLevel < ClassFileConstants.JDK1_7) {
			this.runNegativeTest(
					new String[] {
						"X.java",
						"""
							public class X <T> {\s
							        <G> T foo(G g) {
							            return null;
							        }
							        T bar(T t) {
							        	return zork;
							        }
							
							        public static void main(String[] args) {
							                X rx = new X();
							                rx.<String>foo("hello"); // Eclipse error here
							                rx.<String>bar("hello"); // Eclipse error here
							        }
							}
							"""
					},
					"""
						----------
						1. ERROR in X.java (at line 6)
							return zork;
							       ^^^^
						zork cannot be resolved to a variable
						----------
						2. WARNING in X.java (at line 10)
							X rx = new X();
							^
						X is a raw type. References to generic type X<T> should be parameterized
						----------
						3. WARNING in X.java (at line 10)
							X rx = new X();
							           ^
						X is a raw type. References to generic type X<T> should be parameterized
						----------
						4. ERROR in X.java (at line 11)
							rx.<String>foo("hello"); // Eclipse error here
							           ^^^
						The method foo(Object) of raw type X is no longer generic; it cannot be parameterized with arguments <String>
						----------
						5. ERROR in X.java (at line 12)
							rx.<String>bar("hello"); // Eclipse error here
							           ^^^
						The method bar(Object) of type X is not generic; it cannot be parameterized with arguments <String>
						----------
						""",
					JavacTestOptions.EclipseHasABug.EclipseBug236242);
			return;
		}
		this.runNegativeTest(
				new String[] {
					"X.java",
					"""
						public class X <T> {\s
						        <G> T foo(G g) {
						            return null;
						        }
						        T bar(T t) {
						        	return zork;
						        }
						
						        public static void main(String[] args) {
						                X rx = new X();
						                rx.<String>foo("hello"); // Eclipse error here
						                rx.<String>bar("hello"); // Eclipse error here
						        }
						}
						"""
				},
				"""
					----------
					1. ERROR in X.java (at line 6)
						return zork;
						       ^^^^
					zork cannot be resolved to a variable
					----------
					2. WARNING in X.java (at line 10)
						X rx = new X();
						^
					X is a raw type. References to generic type X<T> should be parameterized
					----------
					3. WARNING in X.java (at line 10)
						X rx = new X();
						           ^
					X is a raw type. References to generic type X<T> should be parameterized
					----------
					4. WARNING in X.java (at line 11)
						rx.<String>foo("hello"); // Eclipse error here
						^^^^^^^^^^^^^^^^^^^^^^^
					Type safety: The method foo(Object) belongs to the raw type X. References to generic type X<T> should be parameterized
					----------
					5. WARNING in X.java (at line 12)
						rx.<String>bar("hello"); // Eclipse error here
						^^^^^^^^^^^^^^^^^^^^^^^
					Type safety: The method bar(Object) belongs to the raw type X. References to generic type X<T> should be parameterized
					----------
					6. WARNING in X.java (at line 12)
						rx.<String>bar("hello"); // Eclipse error here
						    ^^^^^^
					Unused type arguments for the non generic method bar(Object) of type X; it should not be parameterized with arguments <String>
					----------
					""",
				JavacTestOptions.EclipseHasABug.EclipseBug236242);
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69320 parameterized type compatibility
	public void test0246() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {\s
					    class MX<E> {
					    }
					    void foo() {
					      MX<Class<? extends Object>> mx2 = new MX<Class>();
					    }
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 5)
					MX<Class<? extends Object>> mx2 = new MX<Class>();
					                                  ^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from X.MX<Class> to X.MX<Class<? extends Object>>
				----------
				2. WARNING in X.java (at line 5)
					MX<Class<? extends Object>> mx2 = new MX<Class>();
					                                         ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69320 variation
	public void test0247() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {\s
					    void foo() {
					      MX<Class<? extends Object>> mx2 = new MX<Class>(); // wrong
					      MX<Class<? extends Object>> mx3 = new MX<Class<? extends String>>(); // wrong
					      MX<Class<? extends Object>> mx4 = new MX<Class<String>>(); // wrong
					      MX<? extends Class> mx5 = new MX<Class>(); // ok
					      MX<? super Class> mx6 = new MX<Class>(); // ok
					      MX<Class<? extends Class>> mx7 = new MX<Class<Class>>(); // wrong
					      MX<MX<? extends Class>> mx8 = new MX<MX<Class>>(); // wrong
					    }
					}
					
					class MX<E> {
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					MX<Class<? extends Object>> mx2 = new MX<Class>(); // wrong
					                                  ^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from MX<Class> to MX<Class<? extends Object>>
				----------
				2. WARNING in X.java (at line 3)
					MX<Class<? extends Object>> mx2 = new MX<Class>(); // wrong
					                                         ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				3. ERROR in X.java (at line 4)
					MX<Class<? extends Object>> mx3 = new MX<Class<? extends String>>(); // wrong
					                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from MX<Class<? extends String>> to MX<Class<? extends Object>>
				----------
				4. ERROR in X.java (at line 5)
					MX<Class<? extends Object>> mx4 = new MX<Class<String>>(); // wrong
					                                  ^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from MX<Class<String>> to MX<Class<? extends Object>>
				----------
				5. WARNING in X.java (at line 6)
					MX<? extends Class> mx5 = new MX<Class>(); // ok
					             ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				6. WARNING in X.java (at line 6)
					MX<? extends Class> mx5 = new MX<Class>(); // ok
					                                 ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				7. WARNING in X.java (at line 7)
					MX<? super Class> mx6 = new MX<Class>(); // ok
					           ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				8. WARNING in X.java (at line 7)
					MX<? super Class> mx6 = new MX<Class>(); // ok
					                               ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				9. WARNING in X.java (at line 8)
					MX<Class<? extends Class>> mx7 = new MX<Class<Class>>(); // wrong
					                   ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				10. ERROR in X.java (at line 8)
					MX<Class<? extends Class>> mx7 = new MX<Class<Class>>(); // wrong
					                                 ^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from MX<Class<Class>> to MX<Class<? extends Class>>
				----------
				11. WARNING in X.java (at line 8)
					MX<Class<? extends Class>> mx7 = new MX<Class<Class>>(); // wrong
					                                              ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				12. WARNING in X.java (at line 9)
					MX<MX<? extends Class>> mx8 = new MX<MX<Class>>(); // wrong
					                ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				13. ERROR in X.java (at line 9)
					MX<MX<? extends Class>> mx8 = new MX<MX<Class>>(); // wrong
					                              ^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from MX<MX<Class>> to MX<MX<? extends Class>>
				----------
				14. WARNING in X.java (at line 9)
					MX<MX<? extends Class>> mx8 = new MX<MX<Class>>(); // wrong
					                                        ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=70247 check type variable is bound during super type resolution
	public void test0248() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"import java.util.*;\n" +
				"public class X<T> extends Vector<? super X<int[]>>{}\n"			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					public class X<T> extends Vector<? super X<int[]>>{}
					                          ^^^^^^
				The type X cannot extend or implement Vector<? super X<int[]>>. A supertype may not specify any wildcard
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=70247 variation
	public void test0249() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"import java.util.*;\n" +
				"public class X<T> implements List<? super X<int[]>>{}\n"
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					public class X<T> implements List<? super X<int[]>>{}
					                             ^^^^
				The type X cannot extend or implement List<? super X<int[]>>. A supertype may not specify any wildcard
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=70295 Class<? extends Object> is compatible with Class<?>
	public void test0250() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					    void test(Object o) {
					        X.class.isAssignableFrom(o.getClass());
					    }
					}
					"""
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69800 '? extends Object' is not compatible with A
	public void test0251() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					@SuppressWarnings("deprecation")
					public class X {\s
					    static class A {
					    }
					    A test() throws Exception {
					        Class<? extends Object> clazz = null;
					        return clazz.newInstance(); // ? extends Object
					    }
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 7)
					return clazz.newInstance(); // ? extends Object
					       ^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from capture#1-of ? extends Object to X.A
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69799 NPE in foreach checkcast
	// effective result may change depending upon
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=148241
	// **
	public void test0252() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					public class X {
						public static void main(String[] args) {
							Set<X> channel = channels.get(0);
						    for (Iterator<X> iter = channel.iterator(); iter.hasNext();) {
						        Set<X> element;
						        element = (Set<X>) iter.next();
							}
						}
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					Set<X> channel = channels.get(0);
					                 ^^^^^^^^
				channels cannot be resolved
				----------
				2. WARNING in X.java (at line 7)
					element = (Set<X>) iter.next();
					          ^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from X to Set<X>
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=70243 unsafe cast when wildcards
	public void test0253() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					public class X {
					    public static void main(String[] args) {
					        List<Integer> li= new ArrayList<Integer>();
					        List<? extends Number> ls= li;      \s
					        List<Number> x2= (List<Number>)ls;//unsafe
					        x2.add(Float.valueOf(1.0f));
					       \s
					        Integer i= li.get(0);//ClassCastException!
					       \s
					        List<Number> ls2 = (List<? extends Number>)ls;
					        List<? extends Number> ls3 = (List<? extends Number>) li;
					    }
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 6)
					List<Number> x2= (List<Number>)ls;//unsafe
					                 ^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from List<capture#1-of ? extends Number> to List<Number>
				----------
				2. ERROR in X.java (at line 11)
					List<Number> ls2 = (List<? extends Number>)ls;
					                   ^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from List<capture#3-of ? extends Number> to List<Number>
				----------
				3. WARNING in X.java (at line 12)
					List<? extends Number> ls3 = (List<? extends Number>) li;
					                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Unnecessary cast from List<Integer> to List<? extends Number>
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=70053 missing checkcast in string concatenation
	public void test0254() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					public class X {
					 public static void main(String[] args) {
					  X x = new X();
					  System.out.print("S" + x.a() + "U" + x.b().get(0) + "C" + x.a() + "C");
					  System.out.println(new StringBuilder("E").append(x.a()).append("S").append(x.b().get(0)).append("S").append(x.a()).append("!")); \s
					 }
					 String a() { return ""; }
					 List<String> b() {\s
					  ArrayList<String> als = new ArrayList<String>(1);
					  als.add(a());
					  return als;
					 }
					}
					"""
			},
			"SUCCESS!");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69351 generic type cannot extend Throwable
	public void test0255() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"public class X<T, U> extends Throwable {\n" +
				"}\n"
			},
			"""
				----------
				1. WARNING in X.java (at line 1)
					public class X<T, U> extends Throwable {
					             ^
				The serializable class X does not declare a static final serialVersionUID field of type long
				----------
				2. ERROR in X.java (at line 1)
					public class X<T, U> extends Throwable {
					                             ^^^^^^^^^
				The generic class X<T,U> may not subclass java.lang.Throwable
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=70616 - reference to binary Enum
	public void test0256() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					\t
						public static void main(String[] args) {
					
							Enum<X> ex = null;
							String s = ex.name();
						}
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 5)
					Enum<X> ex = null;
					     ^
				Bound mismatch: The type X is not a valid substitute for the bounded parameter <E extends Enum<E>> of the type Enum<E>
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=70618 - reference to variable allowed in parameterized super type
	public void test0257() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
					    public abstract class M extends java.util.AbstractList<T> {}
					}
					class Y<T> extends T {}
					class Z<T> {
					    class M extends T {}
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					class Y<T> extends T {}
					                   ^
				Cannot refer to the type parameter T as a supertype
				----------
				2. ERROR in X.java (at line 6)
					class M extends T {}
					                ^
				Cannot refer to the type parameter T as a supertype
				----------
				""");
	}
	public void test0258() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					abstract class X<K,V> implements java.util.Map<K,V> {
					    static abstract class M<K,V> implements Entry<K,V> {}
					}
					"""
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=70767 - NPE compiling code with explicit constructor invocation
	public void test0259() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<E> {
					\t
						<E> X(E e) {
							<E> this();
						}
					\t
						<E> X() {
						}
					}
					"""
			},
			"");
	}
	public void test0260() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <E> {
						class MX <F> {
						}
					}
					
					class XC<G> extends X<G> {
						class MXC<H> extends MX<H> {
						}
					}
					"""
			},
			"");
	}
	public void test0261() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <E> {
						void foo(){
							X<Integer> xi = (X<Integer>) new X<String>();
						}
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					X<Integer> xi = (X<Integer>) new X<String>();
					                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Cannot cast from X<String> to X<Integer>
				----------
				""");
	}
	public void test0262() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <E,F> {
						void foo(){
							X<E,String> xe = (X<E,String>) new X<String,String>();
						}
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 3)
					X<E,String> xe = (X<E,String>) new X<String,String>();
					                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from X<String,String> to X<E,String>
				----------
				""");
	}
	public void test0263() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <E,F> {
						void foo(){
							XC<E,String> xe = (XC<E,String>) new X<String,String>();
						}
					}
					class XC<G,H> extends X<G,H> {
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 3)
					XC<E,String> xe = (XC<E,String>) new X<String,String>();
					                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from X<String,String> to XC<E,String>
				----------
				""");
	}
	public void test0264() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <E,F> {
						void foo(){
							XC<E,String> xe = (XC<E,String>) new X<String,Integer>();
						}
					}
					class XC<G,H> extends X<G,H> {
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					XC<E,String> xe = (XC<E,String>) new X<String,Integer>();
					                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Cannot cast from X<String,Integer> to XC<E,String>
				----------
				""");
	}
	public void test0265() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <E> {
						<U> void foo(){
								XC<U> xcu = (XC<U>) new X<E>();
								XC<U> xcu1 = (XC<?>) new X<E>();		\t
								XC<?> xcu2 = (XC<? extends X>) new X<E>();					\t
						}
					}
					class XC<G> extends X<G> {
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 3)
					XC<U> xcu = (XC<U>) new X<E>();
					            ^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from X<E> to XC<U>
				----------
				2. ERROR in X.java (at line 4)
					XC<U> xcu1 = (XC<?>) new X<E>();		\t
					             ^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from XC<capture#1-of ?> to XC<U>
				----------
				3. WARNING in X.java (at line 5)
					XC<?> xcu2 = (XC<? extends X>) new X<E>();					\t
					             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from X<E> to XC<? extends X>
				----------
				4. WARNING in X.java (at line 5)
					XC<?> xcu2 = (XC<? extends X>) new X<E>();					\t
					                           ^
				X is a raw type. References to generic type X<E> should be parameterized
				----------
				""");
	}
	public void test0266() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <E> {
						void bar() {
							X<? extends E> xe = new X<E>();
						}
					}
					"""
			},
			"");
	}
	public void test0267() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
						static void foo(X<?> xany) {\s
							System.out.println("SUCCESS");
						}
						public static void main(String[] args) {
							foo(new X<Object[]>());
						}
					}
					"""
			},
			"SUCCESS");
	}
	public void test0268() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.ArrayList;
					public class X <T> {
						X[] foo() {
							ArrayList<X> list = new ArrayList();
							return list.toArray(new X[list.size()]);
						}
						public static void main(String[] args) {
						}
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 3)
					X[] foo() {
					^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				2. WARNING in X.java (at line 4)
					ArrayList<X> list = new ArrayList();
					          ^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				3. WARNING in X.java (at line 4)
					ArrayList<X> list = new ArrayList();
					                    ^^^^^^^^^^^^^^^
				Type safety: The expression of type ArrayList needs unchecked conversion to conform to ArrayList<X>
				----------
				4. WARNING in X.java (at line 4)
					ArrayList<X> list = new ArrayList();
					                        ^^^^^^^^^
				ArrayList is a raw type. References to generic type ArrayList<E> should be parameterized
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=70975 - test compilation against binary generic method
	public void test0269() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
					
						<U> U[] bar(U[] u)  {\s
							System.out.println("SUCCESS");
							return null; }
					
						static String[] foo() {
							X<String> xs = new X<String>();
							return xs.bar(new String[0]);
						}
						public static void main(String[] args) {
							foo();
						}
					}
					""",
			},
			"SUCCESS");

		this.runConformTest(
			new String[] {
				"Y.java",
				"""
					public class Y {
					    public static void main(String [] args) {
							X<String> xs = new X<String>();
							String[] s = xs.bar(new String[0]);
					    }
					}
					""",
			},
			"SUCCESS",
			null,
			false, // do not flush output
			null);
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=70969 - lub(List<String>, List<Object>) --> List<? extends Object>
	public void test0270() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.ArrayList;
					
					public class X {
					    public void test(boolean param) {
					        ArrayList<?> ls = (param)\s
					        		? new ArrayList<String>()
					        		: new ArrayList<Object>();
					        	\t
					        X x = param ? new XY() : new XZ();
					        XY y = (XY) new XZ();
					    }
					}
					class XY extends X {}
					class XZ extends X {}
					"""
			},

			"""
				----------
				1. ERROR in X.java (at line 10)
					XY y = (XY) new XZ();
					       ^^^^^^^^^^^^^
				Cannot cast from XZ to XY
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=71080 - parameter bound <T extends Enum<T>> should be allowed
	public void test0271() {
		this.runConformTest(
			new String[] {
				"X.java",
				"public class X<T extends Enum<T>> {\n" +
				"}\n"
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=71080 - variation
	public void test0272() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T extends XY<T>> {
					}
					
					class XY<U extends Cloneable> implements Cloneable {
					}
					"""
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=71080 - variation
	public void test0273() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T extends XY<T> & Cloneable> {
					}
					
					class XY<U extends Cloneable> {
					}
					"""
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=71241
	public void test0274() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.List;
					public class X {
					    public List useList(List l) {
					        l.add("asdf");
					        return l;
					    }
					}
					class Y extends X {
					    public List<String> useList(List<String> l) {
					        l.add("asdf");
					        return l;
					    }
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 3)
					public List useList(List l) {
					       ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				2. WARNING in X.java (at line 3)
					public List useList(List l) {
					                    ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				3. WARNING in X.java (at line 4)
					l.add("asdf");
					^^^^^^^^^^^^^
				Type safety: The method add(Object) belongs to the raw type List. References to generic type List<E> should be parameterized
				----------
				4. ERROR in X.java (at line 9)
					public List<String> useList(List<String> l) {
					                    ^^^^^^^^^^^^^^^^^^^^^^^
				Name clash: The method useList(List<String>) of type Y has the same erasure as useList(List) of type X but does not override it
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=71241 - variation
	public void test0275() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.List;
					public class X {
					    public List<String> useList(List<String> l) {
					        l.add("asdf");
					        return l;
					    }
					}
					class Y extends X {
					    public List useList(List l) {
					        l.add("asdf");
					        return l;
					    }
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 9)
					public List useList(List l) {
					       ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				2. WARNING in X.java (at line 9)
					public List useList(List l) {
					       ^^^^
				Type safety: The return type List for useList(List) from the type Y needs unchecked conversion to conform to List<String> from the type X
				----------
				3. WARNING in X.java (at line 9)
					public List useList(List l) {
					            ^^^^^^^^^^^^^^^
				The method useList(List) of type Y should be tagged with @Override since it actually overrides a superclass method
				----------
				4. WARNING in X.java (at line 9)
					public List useList(List l) {
					                    ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				5. WARNING in X.java (at line 10)
					l.add("asdf");
					^^^^^^^^^^^^^
				Type safety: The method add(Object) belongs to the raw type List. References to generic type List<E> should be parameterized
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=71241 - variation
	public void test0276() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.List;
					public class X {
					    public void useList(List l) {}
					}
					class Y extends X {
					    public void useList(List<String> l) {
							super.useList(l);
						}
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 3)
					public void useList(List l) {}
					                    ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				2. ERROR in X.java (at line 6)
					public void useList(List<String> l) {
					            ^^^^^^^^^^^^^^^^^^^^^^^
				Name clash: The method useList(List<String>) of type Y has the same erasure as useList(List) of type X but does not override it
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=71241 - variation
	public void test0277() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.List;
					public class X {
					    public void useList(List<String> l) {}
					}
					class Y extends X {
					    public void useList(List l) {
							super.useList(l);
						}
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 6)
					public void useList(List l) {
					            ^^^^^^^^^^^^^^^
				The method useList(List) of type Y should be tagged with @Override since it actually overrides a superclass method
				----------
				2. WARNING in X.java (at line 6)
					public void useList(List l) {
					                    ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				3. WARNING in X.java (at line 7)
					super.useList(l);
					              ^
				Type safety: The expression of type List needs unchecked conversion to conform to List<String>
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=71241 - variation
	public void test0278() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T> implements I {
					    public Class<T> getDeclaringClass() { return null; }
					}
					class Y implements I {
					    public Class<?> getDeclaringClass() { return null; }
					}
					interface I {
						public Class getDeclaringClass();
					}
					"""
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=69901
	public void test0279() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X implements ISomething {
					    public Class getSomething() { return null; }
					}
					class Y {}
					interface ISomething {
					    public Class<? extends Y> getSomething();
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 2)
					public Class getSomething() { return null; }
					       ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				2. WARNING in X.java (at line 2)
					public Class getSomething() { return null; }
					       ^^^^^
				Type safety: The return type Class for getSomething() from the type X needs unchecked conversion to conform to Class<? extends Y> from the type ISomething
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=62822
	public void test0280() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					interface X<T1 extends Y<T2>, T2 extends Z> {}
					interface Y<T3 extends Z> {}
					interface Z {}
					"""
			},
			"");
	}
	public void test0281() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					interface X<T1 extends Y<T2>, T2 extends Z> {}
					interface Y<T3 extends Comparable> {}
					interface Z {}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 1)
					interface X<T1 extends Y<T2>, T2 extends Z> {}
					                         ^^
				Bound mismatch: The type T2 is not a valid substitute for the bounded parameter <T3 extends Comparable> of the type Y<T3>
				----------
				2. WARNING in X.java (at line 2)
					interface Y<T3 extends Comparable> {}
					                       ^^^^^^^^^^
				Comparable is a raw type. References to generic type Comparable<T> should be parameterized
				----------
				""");
	}
	public void test0282() {
		this.runConformTest(
			new String[] {
				"X.java",
				"public class X extends Y.Member<String> {}\n" +
				"class Y { static class Member<T> {} }\n"
			},
			"");
		this.runConformTest(
			new String[] {
				"p1/X.java",
				"""
					package p1;
					public class X extends p1.Y.Member<String> {}
					class Y { static class Member<T> {} }
					"""
			},
			"");
	}
	public void test0283() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"public class X extends Y.Missing<String> {}\n" +
				"class Y { static class Member<T> {} }\n"
			},
			"""
				----------
				1. ERROR in X.java (at line 1)
					public class X extends Y.Missing<String> {}
					                       ^^^^^^^^^
				Y.Missing cannot be resolved to a type
				----------
				""");
		this.runNegativeTest(
			new String[] {
				"p1/X.java",
				"""
					package p1;
					public class X extends Y.Missing<String> {}
					class Y { static class Member<T> {} }
					"""
			},
			"""
				----------
				1. ERROR in p1\\X.java (at line 2)
					public class X extends Y.Missing<String> {}
					                       ^^^^^^^^^
				Y.Missing cannot be resolved to a type
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=72083
	public void test0284() {
		this.runConformTest(
			new String[] {
				"p1/A.java",
				"""
					package p1;
					public class A <T1 extends A<T1, T2>, T2 extends B<T1, T2>> {
					    public static void main(String [] args) {
							System.out.println("SUCCESS");
					    }
					}
					""",
				"p1/B.java",
				"package p1;\n" +
				"public class B <T3 extends A<T3, T4>, T4 extends B<T3, T4>> {}\n"
			},
			"SUCCESS");
		this.runConformTest(
			new String[] {
				"p1/A.java",
				"""
					package p1;
					public class A <T1 extends B<T1, T2>, T2 extends A<T1, T2>> {
					    public static void main(String [] args) {
							System.out.println("SUCCESS");
					    }
					}
					""",
				"p1/B.java",
				"package p1;\n" +
				"public class B <T3 extends B<T3, T4>, T4 extends A<T3, T4>> {}\n"
			},
			"SUCCESS");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=73530
	public void test0285() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.Vector;
					public class X {
					  public static void main(String[] args){
					    Vector<Integer[]> v = new Vector<Integer[]>();
					    Integer[] array1 = new Integer[5];
					    array1[0] = new Integer(17);
					    array1[1] = new Integer(42);
					    v.add(array1);
					    Integer twentyfour = v.get(0)[1];  // responsible for the crash
					    System.out.println(twentyfour);
					  }
					}"""
			},
			"42");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=72644
	// TODO (philippe) we need a way to test these 2 methods & find them 'equivalent'... right isEquivalentTo return false
	public void test0286() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
						<T extends Object> T foo(Class<T> c) {return null;}
					}
					class Y extends X {
						<T extends Object> T foo(Class<T> c) {return null;}
					}"""
			},
			"");
	}
	public void test0287() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
					
						public class A <U> {
						\t
							public class B <V> {
							\t
							}
						}
						public static void main(String[] args) {
						\t
							X.A.B<String> bs;
						}
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 11)
					X.A.B<String> bs;
					^^^^^
				The member type X.A.B<String> must be qualified with a parameterized type, since it is not static
				----------
				""");
	}
	public void test0288() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
					
						public static class A <U> {
						\t
							public static class B <V> {
							\t
							}
						}
						public static void main(String[] args) {
						\t
							X.A.B<String> bs;
						}
					}
					"""
			},
			"");
	}
	public void test0289() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
					
						public class A <U> {
						\t
							public class B <V> {
							\t
							}
						}
						public static void main(String[] args) {
						\t
							X<String>.A.B<String> bs;
						}
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 11)
					X<String>.A.B<String> bs;
					^^^^^^^^^^^
				The member type X<String>.A must be parameterized, since it is qualified with a parameterized type
				----------
				""");
	}
	public void test0290() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
					
						public static class A <U> {
						\t
							public class B <V> {
							\t
							}
						}
						public static void main(String[] args) {
						\t
							X<String>.A.B<String> bs;
						}
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 11)
					X<String>.A.B<String> bs;
					^^^^^^^^^^^
				The member type X.A<U> cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X<String>
				----------
				""");
	}
	// ensure bound check deals with supertype (and their enclosing type)
	public void test0291() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends Iterable>{
						class MX<U extends Iterable> {
						}
					}
					class SX extends X<Thread>.MX<Object> {
						SX(X x){
							x.super();
						}
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 1)
					public class X <T extends Iterable>{
					                          ^^^^^^^^
				Iterable is a raw type. References to generic type Iterable<T> should be parameterized
				----------
				2. WARNING in X.java (at line 2)
					class MX<U extends Iterable> {
					                   ^^^^^^^^
				Iterable is a raw type. References to generic type Iterable<T> should be parameterized
				----------
				3. ERROR in X.java (at line 5)
					class SX extends X<Thread>.MX<Object> {
					                   ^^^^^^
				Bound mismatch: The type Thread is not a valid substitute for the bounded parameter <T extends Iterable> of the type X<T>
				----------
				4. ERROR in X.java (at line 5)
					class SX extends X<Thread>.MX<Object> {
					                              ^^^^^^
				Bound mismatch: The type Object is not a valid substitute for the bounded parameter <U extends Iterable> of the type X<T>.MX<U>
				----------
				5. WARNING in X.java (at line 6)
					SX(X x){
					   ^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				""");
	}
	public void test0292() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
						class Y {
							class Z<U> {
							}
						}
					    public static void main(String[] args) {
							X<Object>.Y.Z<Object> zo;
						}
					}
					"""
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=73837
	public void test0293() {
		this.runConformTest(
			new String[] {
				"B.java", //---------------------------
				"""
					public class B<X>{
					    public B(X str,D dValue){}
					    public static void main(String [] args) {
					        System.out.println("SUCCESS");
					    }
					}
					"""	,
				"D.java", //---------------------------
				"public class D<Y>{}\n",
			},
			"SUCCESS");

		this.runConformTest(
			new String[] {
				"C.java", //---------------------------
				"""
					public class C<Z,Y> {
					    public B<Z> test(Z zValue,D<Y> yValue){ return new B<Z>(zValue,yValue); }
					    public static void main(String [] args) {
					        System.out.println("SUCCESS");
					    }
					}
					""",
			},
			"SUCCESS",
			null,
			false, // do not flush output
			null);
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=73837 variation
	public void test0294() {
		this.runConformTest(
			new String[] {
				"B.java", //---------------------------
				"""
					public class B<X>{
					    public B(X str, B<D> dValue){}
					    public static void main(String [] args) {
					        System.out.println("SUCCESS");
					    }
					}
					"""	,
				"D.java", //---------------------------
				"public class D<Y>{}\n",
			},
			"SUCCESS");

		this.runNegativeTest(
			new String[] {
				"C.java", //---------------------------
				"""
					public class C<Z,Y> {
					    public B<Z> test(Z zValue,B<D<Y>> yValue){ return new B<Z>(zValue,yValue); }
					}
					""",
			},
			"""
				----------
				1. ERROR in C.java (at line 2)
					public B<Z> test(Z zValue,B<D<Y>> yValue){ return new B<Z>(zValue,yValue); }
					                                                  ^^^^^^^^^^^^^^^^^^^^^^^
				The constructor B<Z>(Z, B<D<Y>>) is undefined
				----------
				""",
			null,
			false, // do not flush output
			null);
	}
	// non-static method #start() gets its type substituted when accessed through raw type
	public void test0295() {
		this.runNegativeTest(
			new String[] {
				"C.java", //---------------------------
				"""
					public class C<U> {
					
						void bar() {
							new B().start().get(new B().start()).get(new B().start());
						}
					}
					""",
				"B.java", //---------------------------
				"""
					public class B<X>{
						X get(B<X> bx) { return null; }
						B<B<D>> start() { return null; }
					}""",
				"D.java", //---------------------------
				"public class D<Y>{}\n",
			},
			"""
				----------
				1. WARNING in C.java (at line 4)
					new B().start().get(new B().start()).get(new B().start());
					^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: The method get(B) belongs to the raw type B. References to generic type B<X> should be parameterized
				----------
				2. WARNING in C.java (at line 4)
					new B().start().get(new B().start()).get(new B().start());
					    ^
				B is a raw type. References to generic type B<X> should be parameterized
				----------
				3. WARNING in C.java (at line 4)
					new B().start().get(new B().start()).get(new B().start());
					                        ^
				B is a raw type. References to generic type B<X> should be parameterized
				----------
				4. ERROR in C.java (at line 4)
					new B().start().get(new B().start()).get(new B().start());
					                                     ^^^
				The method get(B) is undefined for the type Object
				----------
				5. WARNING in C.java (at line 4)
					new B().start().get(new B().start()).get(new B().start());
					                                             ^
				B is a raw type. References to generic type B<X> should be parameterized
				----------
				----------
				1. WARNING in B.java (at line 3)
					B<B<D>> start() { return null; }
					    ^
				D is a raw type. References to generic type D<Y> should be parameterized
				----------
				""");
	}
	// static method #start() gets its type does not get substituted when accessed through raw type
	public void test0296() {
		this.runNegativeTest(
			new String[] {
				"C.java", //---------------------------
				"""
					public class C<U> {
					
						void bar() {
							new B().start().get(new B().start()).get(new B().start());
						}
					}
					""",
				"B.java", //---------------------------
				"""
					public class B<X>{
						X get(B<X> bx) { return null; }
						static B<B<D>> start() { return null; }
					}""",
				"D.java", //---------------------------
				"public class D<Y>{}\n",
			},
			"""
				----------
				1. WARNING in C.java (at line 4)
					new B().start().get(new B().start()).get(new B().start());
					^^^^^^^^^^^^^^^
				The static method start() from the type B should be accessed in a static way
				----------
				2. WARNING in C.java (at line 4)
					new B().start().get(new B().start()).get(new B().start());
					    ^
				B is a raw type. References to generic type B<X> should be parameterized
				----------
				3. WARNING in C.java (at line 4)
					new B().start().get(new B().start()).get(new B().start());
					                    ^^^^^^^^^^^^^^^
				The static method start() from the type B should be accessed in a static way
				----------
				4. WARNING in C.java (at line 4)
					new B().start().get(new B().start()).get(new B().start());
					                        ^
				B is a raw type. References to generic type B<X> should be parameterized
				----------
				5. ERROR in C.java (at line 4)
					new B().start().get(new B().start()).get(new B().start());
					                                     ^^^
				The method get(B<D>) in the type B<D> is not applicable for the arguments (B<B<D>>)
				----------
				6. WARNING in C.java (at line 4)
					new B().start().get(new B().start()).get(new B().start());
					                                         ^^^^^^^^^^^^^^^
				The static method start() from the type B should be accessed in a static way
				----------
				7. WARNING in C.java (at line 4)
					new B().start().get(new B().start()).get(new B().start());
					                                             ^
				B is a raw type. References to generic type B<X> should be parameterized
				----------
				----------
				1. WARNING in B.java (at line 3)
					static B<B<D>> start() { return null; }
					           ^
				D is a raw type. References to generic type D<Y> should be parameterized
				----------
				""");
	}
	public void test0297() {
		this.runConformTest(
			new String[] {
				"X.java", //---------------------------
				"""
					import java.util.HashMap;
					import java.util.Iterator;
					import java.util.Map;
					
					public class X {
							 public static void main(String[] args) {
							 		 Map<String, String> map = new HashMap<String, String>();
							 		\s
							 		 map.put("foo", "bar");
							 		\s
							 		 // Error reported on the following line
							 		 Iterator<Map.Entry<String,String>> i = map.entrySet().iterator();
							 		 while (i.hasNext()) {
							 		 		 Map.Entry<String, String> entry = i.next();
							 		 		 System.out.println(entry.getKey() + ", " + entry.getValue());
							 		 }
							 }
					}
					""",
			},
			"foo, bar");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=72644
	public void test0298() {
		this.runNegativeTest(
			new String[] {
				"X.java", //---------------------------
				"""
					import java.util.Collection;
					import java.util.Map;
					import java.util.Set;
					
					public class X<V> implements Map<String, V> {
					   private Map<String, V> backingMap;
					   public int size() { return 0; }
					   public boolean isEmpty() { return false; }
					   public boolean containsKey(Object key) { return false; }
					   public boolean containsValue(Object value) { return false; }
					   public V get(Object key) { return null; }
					   public V put(String key, V value) { return null; }
					   public V remove(Object key) { return null; }
					   public void clear() { }
					   public Set<String> keySet() { return null; }
					   public Collection<V> values() { return null; }
					   public void putAll(Map<String, ? extends V> t) { }
					   public Set<Map.Entry<String, V>> entrySet() {
					      return this.backingMap.entrySet();
					   }
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 5)
					public class X<V> implements Map<String, V> {
					             ^
				The type X<V> must implement the inherited abstract method Map<String,V>.putAll(Map<? extends String,? extends V>)
				----------
				2. ERROR in X.java (at line 17)
					public void putAll(Map<String, ? extends V> t) { }
					            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Name clash: The method putAll(Map<String,? extends V>) of type X<V> has the same erasure as putAll(Map<? extends K,? extends V>) of type Map<K,V> but does not override it
				----------
				""");
		this.runConformTest(
			new String[] {
				"X.java", //---------------------------
				"""
					public abstract class X<S, V> implements java.util.Map<Object, Object> {
					   public void putAll(java.util.Map<?, ?> t) { }
					}
					""",
			},
			"");
		this.runNegativeTest(
			new String[] {
				"X.java", //---------------------------
				"""
					public abstract class X<S, V> implements java.util.Map<S, V> {
					   public void putAll(java.util.Map<? extends String, ? extends V> t) { }
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					public void putAll(java.util.Map<? extends String, ? extends V> t) { }
					            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Name clash: The method putAll(Map<? extends String,? extends V>) of type X<S,V> has the same erasure as putAll(Map<? extends K,? extends V>) of type Map<K,V> but does not override it
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=74244
	public void test0299() {
		this.runConformTest(
			new String[] {
				"X.java", //---------------------------
				"""
					public class X {
					 public static void main(String argv[]) {
					 	System.out.println(Boolean.class == boolean.class ? "FAILED" : "SUCCESS");
					 }
					}
					""",
			},
			"SUCCESS");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=74119
	public void test0300() {
		this.runConformTest(
			new String[] {
				"X.java", //---------------------------
				"""
					public class X {
					    static interface I extends Visitible<I> {
					    }
					    static interface Visitible<T> {
					        void acceptVisitor(Visitor<? super T> visitor);
					    }
					    static interface Visitor<T> {
					        void visit(T t);
					    }
					    static class C implements I {
					        public void acceptVisitor(Visitor<? super I> visitor) {
					            visitor.visit(this); // should be ok
					            visitor.visit((I) this); // (2) This is a workaround
					        }
					    }
					    public static void main(String [] args) {
					        System.out.println("SUCCESS");
					    }
					}
					""",
			},
			"SUCCESS");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=74320: check no complaint for unused private method
	public void test0301() {
		this.runNegativeTest(
			new String[] {
				"X.java", //---------------------------
				"""
					import java.util.List;
					public class X {
						public static void reverse(List<?> list) {\s
							rev(list);
						}
						private static <T> void rev(List<T> list) {
						}
						Zork foo() {
						}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 8)
					Zork foo() {
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=74514
	public void test0302() {
		this.runNegativeTest(
			new String[] {
				"X.java", //---------------------------
				"""
					import java.util.ArrayList;
					import java.util.Enumeration;
					import java.util.Iterator;
					import java.util.List;
					public class X {
						public void test02() {
							List<String> l= new ArrayList<String>();
							for (Iterator<String> i= l.iterator(); i.next(); ) {
							}
						}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 8)
					for (Iterator<String> i= l.iterator(); i.next(); ) {
					                                       ^^^^^^^^
				Type mismatch: cannot convert from String to boolean
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=74544
	public void test0303() {
		this.runConformTest(
			new String[] {
				"X.java", //---------------------------
				"""
					public  class X {
					  	public static void main(String[] args) {
					  		Y<String> ys = new Y<String>();
						    Y<String>.Member m = ys.new Member();
						    m.foo();
					  	}   \s
					  }
					  class Y<T> {
					    class Member {
					    	void foo(){
					    		System.out.println("SUCCESS");
					    	}
					    }
					  }
					
					""",
			},
			"SUCCESS");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=74592
	public void test0304() {
		this.runConformTest(
			new String[] {
				"X.java", //---------------------------
				"public class X<T extends Y> {}\n" +
				"class Y extends X {}"
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=74420
	public void test0305() {
		this.runConformTest(
			new String[] {
				"X.java", //---------------------------
				"""
					public class X<T> {
					  	T x;
					  	<U extends T> T foo(U u) { return u; }
					}
					"""
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=74096
	public void test0306() {
		this.runNegativeTest(
			new String[] {
				"X.java", //---------------------------
				"public class X<T extends X<T>> {\n" +
				"  	static int CONSTANT = 1;\n" +
				"  	private int i = 1;\n" +
				"  	private int i() {return i;}\n" +
				"  	private static class M { private static int j = 2; }\n" +
				"  	public int foo(T t) { return t.i + t.i() + T.M.j; }\n" +
				"  	public int foo2(T t) { return T.CONSTANT; }\n" + // why is this allowed?
				"}\n" +
				"class Y extends Zork {\n" +
				"}\n"
			},
			this.complianceLevel <= ClassFileConstants.JDK1_6 ?
			"""
				----------
				1. WARNING in X.java (at line 6)
					public int foo(T t) { return t.i + t.i() + T.M.j; }
					                                               ^
				Read access to enclosing field X.M.j is emulated by a synthetic accessor method
				----------
				2. ERROR in X.java (at line 9)
					class Y extends Zork {
					                ^^^^
				Zork cannot be resolved to a type
				----------
				"""
			:

			"""
				----------
				1. ERROR in X.java (at line 6)
					public int foo(T t) { return t.i + t.i() + T.M.j; }
					                               ^
				The field X<T>.i is not visible
				----------
				2. ERROR in X.java (at line 6)
					public int foo(T t) { return t.i + t.i() + T.M.j; }
					                                     ^
				The method i() from the type X<T> is not visible
				----------
				3. ERROR in X.java (at line 6)
					public int foo(T t) { return t.i + t.i() + T.M.j; }
					                                           ^^^
				The type T.M is not visible
				----------
				4. ERROR in X.java (at line 9)
					class Y extends Zork {
					                ^^^^
				Zork cannot be resolved to a type
				----------
				"""
		);
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=72583
	public void test0307() {
		this.runConformTest(
			new String[] {
				"X.java", //---------------------------
				"""
					public class X {
						static <T> T foo(T t1, T t2){ return t1; }
						public static void main(String[] args) {
							IX s = null;
							 foo(new Object(), s);
						}
					}
					interface IX {}
					"""
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=73696
	public void test0308() {
		this.runConformTest(
			new String[] {
				"p/X.java",
				"""
					package p;
					public class X<T> {
						class Member {}
					}
					""",
				"p/Y.java",
				"""
					package p;
					public class Y {
						p.X.Member m;
						p.X<String>.Member ms = m;
					}
					"""
			});
	}
	public void test0309() {
		this.runConformTest(
			new String[] {
				"p/X.java",
				"""
					package p;
					public class X<T> {
						class Member {
							class Sub {}
						}
					}
					""",
				"p/Y.java",
				"""
					package p;
					public class Y {
						p.X.Member.Sub s;
						p.X<Exception>.Member.Sub es = s;
					}
					"""
			});
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=75156 - should report name clash
	public void test0310() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.List;
					public class X extends X2 {
						void foo(List<X> lx) { }
					}
					
					abstract class X2 {
						void foo(List<Object> lo) { }
					}"""
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					void foo(List<X> lx) { }
					     ^^^^^^^^^^^^^^^
				Name clash: The method foo(List<X>) of type X has the same erasure as foo(List<Object>) of type X2 but does not override it
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=75156 variation - should report name clash and ambiguity
	public void test0311() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.List;
					public class X extends X2 {
						void foo(List<X> lx) { }
						void bar(){
							this.foo((List)null);
						}
					}
					
					abstract class X2 {
						void foo(List<Object> lo) { }
					}"""
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					void foo(List<X> lx) { }
					     ^^^^^^^^^^^^^^^
				Name clash: The method foo(List<X>) of type X has the same erasure as foo(List<Object>) of type X2 but does not override it
				----------
				2. ERROR in X.java (at line 5)
					this.foo((List)null);
					     ^^^
				The method foo(List<X>) is ambiguous for the type X
				----------
				3. WARNING in X.java (at line 5)
					this.foo((List)null);
					          ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				""");
	}
	// 75156 variation - should report name clash instead of final method override
	public void test0312() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.List;
					public class X extends X2 {
						void foo(List<X> lx) { }
					}
					
					abstract class X2 {
						final void foo(List<Object> lo) { }
					}"""
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					void foo(List<X> lx) { }
					     ^^^^^^^^^^^^^^^
				Name clash: The method foo(List<X>) of type X has the same erasure as foo(List<Object>) of type X2 but does not override it
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=73963
	public void test0313() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.net.Inet6Address;
					import java.net.InetAddress;
					import java.util.AbstractList;
					import java.util.ArrayList;
					import java.util.List;
					
					public class X {
					void takeAbstract(AbstractList<? extends InetAddress> arg) { }
					
					void takeList(List<? extends InetAddress> arg) { }
					
					void construct() {
						AbstractList<InetAddress> a= new ArrayList<InetAddress>();
						takeAbstract(a);
						takeAbstract(new ArrayList<InetAddress>()); // a inlined: error 1:
					//The method takeAbstract(AbstractList<? extends InetAddress>) in the type A
					// is not applicable for the arguments (ArrayList<InetAddress>)
					\t
						List<InetAddress> l= new ArrayList<InetAddress>();
						takeList(l);
						takeList(new ArrayList<InetAddress>()); // l inlined: ok
					\t
						ArrayList<? extends InetAddress> aw= new ArrayList<InetAddress>();
						takeAbstract(aw);
						takeAbstract(new ArrayList<Inet6Address>()); // aw inlined: error 2:
					//The method takeAbstract(AbstractList<? extends InetAddress>) in the type A
					// is not applicable for the arguments (ArrayList<Inet6Address>)
					
						takeList(aw);
						takeList(new ArrayList<Inet6Address>()); //aw inlined: ok
					}
					}"""
			},
			"");
	}
	public void test0314() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <E> {
						static class XMember<F> {}
					
						// with toplevel element type
						void foo() {
							XIter<XElement<E>> iter = fooSet().iterator();
						}
						XSet<XElement<E>> fooSet()	 { return null; }
					
						// with member element type
						void bar() {
							XIter<XMember<E>> iter = barSet().iterator();
						}
						XSet<XMember<E>> barSet()	 { return null; }
					
					\t
					}
					
					class XSet<G> {
						XIter<G> iterator() { return null; }
					}
					class XIter<H> {
					}
					class XElement<I> {
					}
					"""
			},
			"");
	}
	public void test0315() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <E> {
						static class XMember<F> {}
					
						// with member element type
						void bar() {
							XIter<X.XMember<E>> iter = barSet().iterator();
						}
						XSet<XMember<E>> barSet()	 { return null; }
					
					\t
					}
					
					class XSet<G> {
						XIter<G> iterator() { return null; }
					}
					class XIter<H> {
					}
					class XElement<I> {
					}
					"""
			},
			"");
	}
	public void test0316() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.List;
					
					public class X <E extends List & Runnable> {
					\t
						E element() { return null; }
					\t
						void bar(X<E> xe) {
							xe.element().add(this);
							xe.element().run();
						}
						void foo(X<?> xe) {
							xe.element().add(this);
							xe.element().run();
						}
						void baz(X<? extends XM> xe) {
							xe.element().add(this);
							xe.element().run();
						}
						abstract class XM implements List, Runnable {}
					  Zork z;
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 3)
					public class X <E extends List & Runnable> {
					                          ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				2. WARNING in X.java (at line 8)
					xe.element().add(this);
					^^^^^^^^^^^^^^^^^^^^^^
				Type safety: The method add(Object) belongs to the raw type List. References to generic type List<E> should be parameterized
				----------
				3. WARNING in X.java (at line 12)
					xe.element().add(this);
					^^^^^^^^^^^^^^^^^^^^^^
				Type safety: The method add(Object) belongs to the raw type List. References to generic type List<E> should be parameterized
				----------
				4. WARNING in X.java (at line 16)
					xe.element().add(this);
					^^^^^^^^^^^^^^^^^^^^^^
				Type safety: The method add(Object) belongs to the raw type List. References to generic type List<E> should be parameterized
				----------
				5. WARNING in X.java (at line 19)
					abstract class XM implements List, Runnable {}
					                             ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				6. ERROR in X.java (at line 20)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}
	public void test0317() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.List;
					
					public class X <E extends List & Runnable> {
					\t
						E element() { return null; }
					\t
						void foo(X<? extends XI> xe) {
							xe.element().add(this);
							xe.element().run();
						}
						void baz(X<? extends XM> xe) {
							xe.element().add(this);
							xe.element().run();
						}
						interface XI extends Runnable {}
					\t
						class XM {
							void foo() {}
						}
					  Zork z;
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 3)
					public class X <E extends List & Runnable> {
					                          ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				2. WARNING in X.java (at line 8)
					xe.element().add(this);
					^^^^^^^^^^^^^^^^^^^^^^
				Type safety: The method add(Object) belongs to the raw type List. References to generic type List<E> should be parameterized
				----------
				3. WARNING in X.java (at line 12)
					xe.element().add(this);
					^^^^^^^^^^^^^^^^^^^^^^
				Type safety: The method add(Object) belongs to the raw type List. References to generic type List<E> should be parameterized
				----------
				4. ERROR in X.java (at line 20)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=75548
	public void test0318() {
		this.runConformTest(
			new String[] {
				"MyCache.java",
				"""
					class Cache<K, V> {
					}
					
					class Index<K, V> {
					  public Index(Cache<?, V> parentCache) {
					  }
					}
					
					public class MyCache extends Cache<Integer, String> {
					  class AnIndex extends Index<String, String> {
					    public AnIndex() {
					      super(MyCache.this); // <-- Eclipse cannot find the constructor!
					    }
					  }
					}
					"""
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=76729
	public void test0319() {
		this.runConformTest(
			new String[] {
				"test/Test1.java",
				"""
					package test;
					
					class A<BB extends B>
					{}
					
					class B<AA extends A>
					{}
					
					public interface Test1<C extends B<?>, D extends A<?>>
					{}
					
					class AbstractA extends A<AbstractB> {};
					class AbstractB extends B<AbstractA> {};
					
					class Test2<E extends AbstractB, F extends AbstractA> implements Test1<E, F>
					{}"""
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=74032
	public void test0320() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.ArrayList;
					import java.util.List;
					class TestElement extends ArrayList implements Runnable {
					  public void run() {
					  }
					}
					public class X <E extends List & Runnable> {
					  public X(E element) {
					    element.run();
					  }
					  public static void main(String[] args) {
					    new X<TestElement>(new TestElement());
					    System.out.println("SUCCESS");
					  }
					}
					"""
			},
			"SUCCESS");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=74032 - variation with wildcard
	public void test0321() {
		this.runConformTest(
			new String[] {
				"X.java",
				"import java.util.ArrayList;\n" +
				"import java.util.List;\n" +
				"class TestElement extends ArrayList implements Runnable {\n" +
				"  static final long serialVersionUID = 1l;\n" +
				"  public void run() {\n" +
				"  	// empty\n" +
				"  }\n" +
				"}\n" +
				"public class X <E extends List & Runnable> {\n" +
				"	E element;\n" +
				"  public X(E element) {\n" +
				"  	this.element = element;\n" +
				"    element.run();\n" +
				"  }\n" +
				"  public X(X<?> x) {\n" +
				"    x.element.run();\n" + // should be able to bind to #run()
				"  }\n" +
				"  public static void main(String[] args) {\n" +
				"    new X<TestElement>(new TestElement());\n" +
				"    System.out.println(\"SUCCESS\");\n" +
				"  }\n" +
				"}\n"
			},
			"SUCCESS");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=75134
	public void test0322() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					public class X<A> {
					
					  A v2;
					  X(A a) { v2 = a; }
					 \s
					  void func() {
					    List<B<A>> l = new ArrayList<B<A>>();
					  }
					
					  class B<T> {
					    T v1;
					    B(T b) {  v1 = b; }
					  }
					 \s
					}
					"""
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=76359 - also check warnings for raw conversion
	public void test0323() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					class G<T> {
						class Member {}
					}
					public class X {
						G<String> g = new G();
						G<String>.Member gsm = g.new Member();
						G.Member gm = null;
						G<Thread>.Member gtm = gm;
						Zork z;
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 5)
					G<String> g = new G();
					              ^^^^^^^
				Type safety: The expression of type G needs unchecked conversion to conform to G<String>
				----------
				2. WARNING in X.java (at line 5)
					G<String> g = new G();
					                  ^
				G is a raw type. References to generic type G<T> should be parameterized
				----------
				3. WARNING in X.java (at line 7)
					G.Member gm = null;
					^^^^^^^^
				G.Member is a raw type. References to generic type G<T>.Member should be parameterized
				----------
				4. WARNING in X.java (at line 8)
					G<Thread>.Member gtm = gm;
					                       ^^
				Type safety: The expression of type G.Member needs unchecked conversion to conform to G<Thread>.Member
				----------
				5. ERROR in X.java (at line 9)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=72998
	public void test0324() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.Iterator;
					import java.util.Set;
					
					public class X<E> {
					   private TreeNode<E> root;
					
					   public void doSomething() {
					      for (TreeNode<E> child : root.children()) {
					         // root.children() should work??
					      }
					   }
					
					   public void doSomethingElse() {
					      for (Iterator<TreeNode<E>> it = root.children().iterator(); it.hasNext();) {
					         // this also should work
					      }
					   }
					}
					
					class TreeNode<E> {
					   private Set<TreeNode<E>> children;
					  \s
					   public Set<TreeNode<E>> children() {
					      return children;
					   }
					}
					"""
			},
			"");
	}
	public void test0325() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"public class X <T> {\n" +
				"	void foo1() {\n" +
				"		X<String>.Item<Thread> i = new X<Exception>().new Item<Thread>();\n" +
				"	}\n" +
				"	void foo2() {\n" +
				"		X<Exception>.Item<Thread> j = new X<Exception>.Item<Thread>();\n" + // allowed per grammar
				"	}\n" +
				"	void foo3() {\n" +
				"		X.Item k = new X.Item();\n" +
				"	}\n" +
				"	static void foo4() {\n" +
				"		X.Item k = new X.Item();\n" +
				"	}\n" +
				"	class Item <E> {}\n" +
				"}\n"
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					X<String>.Item<Thread> i = new X<Exception>().new Item<Thread>();
					                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from X<Exception>.Item<Thread> to X<String>.Item<Thread>
				----------
				2. ERROR in X.java (at line 6)
					X<Exception>.Item<Thread> j = new X<Exception>.Item<Thread>();
					                                  ^^^^^^^^^^^^^^^^^
				Cannot allocate the member type X<Exception>.Item<Thread> using a parameterized compound name; use its simple name and an enclosing instance of type X<Exception>
				----------
				3. WARNING in X.java (at line 9)
					X.Item k = new X.Item();
					^^^^^^
				X.Item is a raw type. References to generic type X<T>.Item<E> should be parameterized
				----------
				4. WARNING in X.java (at line 9)
					X.Item k = new X.Item();
					               ^^^^^^
				X.Item is a raw type. References to generic type X<T>.Item<E> should be parameterized
				----------
				5. WARNING in X.java (at line 12)
					X.Item k = new X.Item();
					^^^^^^
				X.Item is a raw type. References to generic type X<T>.Item<E> should be parameterized
				----------
				6. ERROR in X.java (at line 12)
					X.Item k = new X.Item();
					           ^^^^^^^^^^^^
				No enclosing instance of type X<T> is accessible. Must qualify the allocation with an enclosing instance of type X<T> (e.g. x.new A() where x is an instance of X<T>).
				----------
				7. WARNING in X.java (at line 12)
					X.Item k = new X.Item();
					               ^^^^^^
				X.Item is a raw type. References to generic type X<T>.Item<E> should be parameterized
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=75400
	public void test0326() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T> implements I<T> {
					    public I.A foo() {
					        return a;
					    }
					}   \s
					interface I<T> {
					    A a = new A();
					    class A {
					    }
					}
					
					class XM<T> {
					    A a = new A();
					    class A {
					    }
					}\t
					
					class XMSub<T> extends XM<T> {
					    public XM.A foo() {
					        return a;
					    }
					}   \s
					
					"""
			},
			"");
	}
	// wildcard captures bound and variable superinterfaces
	public void test0327() {
		this.runConformTest(
	 		// test directory preparation
			new String[] { /* test files */
				"X.java",
				"""
					public class X<T extends IFoo> {
					\t
						T element() { return null; }
						void baz(X<? extends IBar> x) {
							x.element().foo();
							x.element().bar();
						}
					}
					interface IFoo {
						void foo();
					}
					interface IBar {
						void bar();
					}
					"""
			},
			// javac options
			JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
	}
	// wildcard captures bound and variable superinterfaces
	public void test0328() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T extends IFoo> {
						T element;
						X(T element) {\s
							this.element = element;\s
						}
						static void baz(X<? extends IBar> x) {
							x.element.foo();
							x.element.bar();
						}
						public static void main(String[] args) {
							X<Foo> x1 = new X<Foo>(new Foo());
							baz(x1);
							X<Bar> x2 = new X<Bar>(new Bar());
							baz(x2);
							X<FooBar> x3 = new X<FooBar>(new FooBar());
							baz(x3);
						}
					}
					interface IFoo {
						void foo();
					}
					interface IBar {
						void bar();
					}
					class Foo implements IFoo {
						public void foo() {
							System.out.print("FOO");
						}
					}
					class Bar implements IBar {
						public void bar() {
							System.out.print("BAR");
						}
					}
					class FooBar extends Foo implements IBar {
						public void bar() {
							System.out.print("BAR");
						}
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 12)
					baz(x1);
					^^^
				The method baz(X<? extends IBar>) in the type X<T> is not applicable for the arguments (X<Foo>)
				----------
				2. ERROR in X.java (at line 13)
					X<Bar> x2 = new X<Bar>(new Bar());
					  ^^^
				Bound mismatch: The type Bar is not a valid substitute for the bounded parameter <T extends IFoo> of the type X<T>
				----------
				3. ERROR in X.java (at line 13)
					X<Bar> x2 = new X<Bar>(new Bar());
					                  ^^^
				Bound mismatch: The type Bar is not a valid substitute for the bounded parameter <T extends IFoo> of the type X<T>
				----------
				""");
	}
	// wildcard captures bound and variable superinterfaces
	public void test0329() {
		this.runConformTest(
			// test directory preparation
			true /* flush output directory */,
			new String[] { /* test files */
				"X.java",
				"""
					public class X<T extends IFoo> {
						T element;
						X(T element) {\s
							this.element = element;\s
						}
						static void baz(X<? extends IBar> x) {
							x.element.foo();
							x.element.bar();
						}
						public static void main(String[] args) {
							X<FooBar> x3 = new X<FooBar>(new FooBar());
							baz(x3);
						}
					}
					interface IFoo {
						void foo();
					}
					interface IBar {
						void bar();
					}
					class FooBar implements IFoo, IBar {
						public void foo() {
							System.out.print("FOO");
						}
						public void bar() {
							System.out.print("BAR");
						}
					}
					""",
			},
			// compiler results
			null /* do not check compiler log */,
			// runtime results
			"FOOBAR" /* expected output string */,
			null /* do not check error string */,
			// javac options
			JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
	}
	// wildcard captures bound superclass and variable superclass
	public void test0330() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T extends Foo> {
						T element;
						X(T element) {\s
							this.element = element;\s
						}
						static void baz(X<? extends FooBar> x) {
							x.element.foo();
							x.element.bar();
						}
						public static void main(String[] args) {
							X<FooBar> x3 = new X<FooBar>(new FooBar());
							baz(x3);
						}
					}
					interface IBar {
						void bar();
					}
					class Foo {
						public void foo() {
							System.out.print("FOO");
						}
					}
					class FooBar extends Foo implements IBar {
						public void bar() {
							System.out.print("BAR");
						}
					}
					""",
			},
			"FOOBAR");
	}
	// wildcard captures bound superclass and variable superclass
	public void test0331() {
		this.runConformTest(
			// test directory preparation
			true /* flush output directory */,
			new String[] { /* test files */
				"X.java",
				"""
					public class X<T extends Foo> {
						T element;
						X(T element) {\s
							this.element = element;\s
						}
						static void baz(X<? extends IBar> x) {
							x.element.foo();
							x.element.bar();
						}
						public static void main(String[] args) {
							X<FooBar> x3 = new X<FooBar>(new FooBar());
							baz(x3);
						}
					}
					interface IBar {
						void bar();
					}
					class Foo {
						public void foo() {
							System.out.print("FOO");
						}
					}
					class FooBar extends Foo implements IBar {
						public void bar() {
							System.out.print("BAR");
						}
					}
					""",
			},
			// compiler results
			null /* do not check compiler log */,
			// runtime results
			"FOOBAR" /* expected output string */,
			null /* do not check error string */,
			// javac options
			JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
	}
	// wildcard considers bound superclass or variable superclass
	public void test0332() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"public class X<T extends Foo> {\n" +
				"	T element;\n" +
				"	X(T element) { \n" +
				"		this.element = element; \n" +
				"	}\n" +
				"	static void baz(X<? extends IBar> x) {\n" + // captures Foo & IBar
				"		x.element.foo();\n" +
				"		x.element.bar();\n" +
				"	}\n" +
				"	public static void main(String[] args) {\n" +
				"		baz(new X<FooBar>(new FooBar()));\n" +
				"		baz(new X<Bar>(new Bar()));\n" +
				"	}\n" +
				"}\n" +
				"interface IBar {\n" +
				"	void bar();\n" +
				"}\n" +
				"\n" +
				"class Bar implements IBar {\n" +
				"	public void bar() {\n" +
				"		System.out.print(\"BAR\");\n" +
				"	}\n" +
				"}\n" +
				"\n" +
				"class Foo {\n" +
				"	public void foo() {\n" +
				"		System.out.print(\"FOO\");\n" +
				"	}\n" +
				"}\n" +
				"\n" +
				"class FooBar extends Foo implements IBar {\n" +
				"	public void bar() {\n" +
				"		System.out.print(\"BAR\");\n" +
				"	}\n" +
				"}\n"	,
			},
		"""
			----------
			1. ERROR in X.java (at line 12)
				baz(new X<Bar>(new Bar()));
				          ^^^
			Bound mismatch: The type Bar is not a valid substitute for the bounded parameter <T extends Foo> of the type X<T>
			----------
			""");
	}
	// receveir generic cast matches receiver type (not declaring class)
	public void test0333() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
						T element;
						X(T element) { this.element = element; }
						T element() { return this.element; }
						public static void main(String[] args) {
							new X<XB>(new XB()).element().afoo();
						}
					}
					
					class XA {
						void afoo() {
							System.out.println("SUCCESS");
					   }
					}
					class XB extends XA {
						void bfoo() {}
					}
					"""	,
			},
		"SUCCESS");
	}
	// check cannot allocate type parameters
	public void test0334() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <E> {
					  public X() {
					  	new E();
					  	new E() {
					  		void perform() {
					  			run();
					  		}
					  	}.perform();
					  }
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					new E();
					    ^
				Cannot instantiate the type E
				----------
				2. ERROR in X.java (at line 4)
					new E() {
				  		void perform() {
				  			run();
				  		}
				  	}.perform();
					^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Cannot refer to the type parameter E as a supertype
				----------
				""");
	}
	// variation - check cannot allocate type parameters
	public void test0335() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"public class X <E extends String> {\n" + // firstBound is class, still cannot be instantiated
				"  public X() {\n" +
				"  	new E();\n" +
				"  	new E() {\n" +
				"  		void perform() {\n" +
				"  			run();\n" +
				"  		}\n" +
				"  	}.perform();\n" +
				"  }\n" +
				"}\n",
			},
			"""
				----------
				1. WARNING in X.java (at line 1)
					public class X <E extends String> {
					                          ^^^^^^
				The type parameter E should not be bounded by the final type String. Final types cannot be further extended
				----------
				2. ERROR in X.java (at line 3)
					new E();
					    ^
				Cannot instantiate the type E
				----------
				3. ERROR in X.java (at line 4)
					new E() {
				  		void perform() {
				  			run();
				  		}
				  	}.perform();
					^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Cannot refer to the type parameter E as a supertype
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=74669
	public void test0336() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					interface IMyInterface {
					}
					class MyClass <Type> {
					
						public <Type> Type myMethod(Object obj, Class type) {
							return null;
						}
						public static <Type> Type myStaticMethod(Object obj, Class type) {
							return null;
						}
					}
					public class X {
					    public IMyInterface getThis() {
							if (true)
								return new MyClass().myMethod(this, IMyInterface.class);
							else
								return MyClass.myStaticMethod(this, IMyInterface.class);
					    }
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 5)
					public <Type> Type myMethod(Object obj, Class type) {
					        ^^^^
				The type parameter Type is hiding the type Type
				----------
				2. WARNING in X.java (at line 5)
					public <Type> Type myMethod(Object obj, Class type) {
					                                        ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				3. WARNING in X.java (at line 8)
					public static <Type> Type myStaticMethod(Object obj, Class type) {
					                                                     ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				4. ERROR in X.java (at line 15)
					return new MyClass().myMethod(this, IMyInterface.class);
					       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Object to IMyInterface
				----------
				5. WARNING in X.java (at line 15)
					return new MyClass().myMethod(this, IMyInterface.class);
					           ^^^^^^^
				MyClass is a raw type. References to generic type MyClass<Type> should be parameterized
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=77078
	public void test0337() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.Vector;
					public class X {
					    public void foo() {
					        Vector<Object> objectVector = new Vector<Object>() {
					            protected void bar() {
					                baz(this); /* ERROR */
					            }
					        };
					        baz(objectVector);
					        baz(new Vector<Object>());
					    }
					    public void baz(Vector<?> mysteryVector) { }
					}
					""",
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=77052
	public void test0338() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					interface M<X> { }
					
					class N<C> {\s
					  M<N<C>> pni = null;
					}
					
					public class X<I> {
					  N<I> var1 = null;
					
					  M<N<I>> var2 = var1.pni;
					  // Above line reports as error in Eclipse.\s
					  // "var2" is underlined and the error message is:\s
					  // Type mismatch: cannot convert from M<N<C>> to M<N<I>>
					}
					""",
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=77052 - variation
	public void test0339() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.Iterator;
					import java.util.Set;
					
					class X <K, V> {
						static class Entry<K, V> {}
						void foo() {
							Iterator<Entry<K,V>> i = entrySet().iterator();
						}
						Set<Entry<K,V>> entrySet()	 { return null; }
					}
					""",
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=76313
	public void test0340() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
						private T data;
						private X(T data){ this.data=data; }
						public static <S> X<S> createObject(S data){
							System.out.println(data);
							return new X<S>(data);
						}
						public static void main(String[] args) {
							X<String> res=X.createObject("Hallo");
						}
					}
					""",
			},
			"Hallo");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=77118
	public void test0341() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
						public Object getItem() { return null; }
					}
					""",
				"Y.java",
				"""
					public class Y extends X {
						public String getItem() { return null; }
					}
					""",
				"Z.java",
				"""
					public class Z extends X {
						public Comparable getItem() { return null; }
					}
					""",
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=77142 - check no raw unsafe warning is issued when accessing generic method from raw type
	public void test0342() {
		this.runNegativeTest(
			new String[] {
				"Test.java",
				"""
					class MyClass<T> {
							\s
							 private T thing;
					       { Zork z; }
							\s
							 public
							 MyClass(T thing) {
							 		 this.thing = thing;
							 }
							\s
							 public static <U> MyClass<U>
							 factoryMakeMyClass(U thing)		 {
							 		 return new MyClass<U>(thing);
							 }
					}
					
					class External {
					
							 public static <U> MyClass<U>
							 factoryMakeMyClass(U thing)		 {
							 		 return new MyClass<U>(thing);
							 }
					}
					
					public class Test {
							 public static void
							 test()
							 {
							 		 // No problem with this line:
							 		 MyClass<String> foo = External.factoryMakeMyClass("hi");
							 		\s
							 		 // This line gives me an error:
							 		 // Type mismatch: cannot convert from MyClass<Object> to MyClass<String>
							 		 MyClass<String> bar = MyClass.factoryMakeMyClass("hi");
							 		 MyClass<String> bar2 = MyClass.<String>factoryMakeMyClass("hi");
							 }
					}
					""",
			},
			"""
				----------
				1. ERROR in Test.java (at line 4)
					{ Zork z; }
					  ^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=74588
	public void test0343() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T extends Number> {
					    T m;
					
					    class Y<T> {
					        void test() {
					            new Y<Integer>() {
					                void test() {
					                    System.out.println(X.this.m);
					                }
					            }.test();
					        }
					    }
					}
					
					""",
			},
			"");
	}
	// checking scenario where generic type and method share the same type parameter name
	public void test0344() {
		if (this.complianceLevel < ClassFileConstants.JDK1_7) {
			this.runNegativeTest(
				new String[] {
					"X.java",
					"""
						import java.io.IOException;
						
						public abstract class X<T extends Runnable> {
						\t
							public abstract <T extends Exception> T bar(T t);
						
							static void foo(X x) {
								x.<Exception>bar(null);
							\t
								class R implements Runnable {
									public void run() {
									}
								}
								X<R> xr = new X<R>(){ \s
									public <T> T bar(T t) {\s
										return t;\s
									}
								};
								IOException e = xr.bar(new IOException());
							}
						}
						"""
				},
				"""
					----------
					1. WARNING in X.java (at line 5)
						public abstract <T extends Exception> T bar(T t);
						                 ^
					The type parameter T is hiding the type T
					----------
					2. WARNING in X.java (at line 7)
						static void foo(X x) {
						                ^
					X is a raw type. References to generic type X<T> should be parameterized
					----------
					3. ERROR in X.java (at line 8)
						x.<Exception>bar(null);
						             ^^^
					The method bar(Exception) of raw type X is no longer generic; it cannot be parameterized with arguments <Exception>
					----------
					4. ERROR in X.java (at line 14)
						X<R> xr = new X<R>(){ \s
						              ^^^^^^
					The type new X<R>(){} must implement the inherited abstract method X<R>.bar(T)
					----------
					""");
			return;
		}
		this.runNegativeTest(
				new String[] {
					"X.java",
					"""
						import java.io.IOException;
						
						public abstract class X<T extends Runnable> {
						\t
							public abstract <T extends Exception> T bar(T t);
						
							static void foo(X x) {
								x.<Exception>bar(null);
							\t
								class R implements Runnable {
									public void run() {
									}
								}
								X<R> xr = new X<R>(){ \s
									public <T> T bar(T t) {\s
										return t;\s
									}
								};
								IOException e = xr.bar(new IOException());
							}
						}
						"""
				},
				"""
					----------
					1. WARNING in X.java (at line 5)
						public abstract <T extends Exception> T bar(T t);
						                 ^
					The type parameter T is hiding the type T
					----------
					2. WARNING in X.java (at line 7)
						static void foo(X x) {
						                ^
					X is a raw type. References to generic type X<T> should be parameterized
					----------
					3. WARNING in X.java (at line 8)
						x.<Exception>bar(null);
						^^^^^^^^^^^^^^^^^^^^^^
					Type safety: The method bar(Exception) belongs to the raw type X. References to generic type X<T> should be parameterized
					----------
					4. ERROR in X.java (at line 14)
						X<R> xr = new X<R>(){ \s
						              ^^^^^^
					The type new X<R>(){} must implement the inherited abstract method X<R>.bar(T)
					----------
					""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=74594
	public void test0345() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					    public static void main(String argv[]) {
					       X1<Integer> o1 = new X1<Integer>();
					        ((J<Integer>)o1).get();
					    }
					}
					
					class X1<T> implements I<T> {
					    public X1 get() {
					    	System.out.println("SUCCESS");
					        return this;
					    }
					}
					
					interface I<T> extends J<T> {
					    I get();
					}
					
					interface J<T>  {
					    J get();
					}""",
			},
			"SUCCESS");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=74594
	public void test0346() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					    public static void main(String argv[]) {
					       X1<Integer> o1 = new X1<Integer>(new Integer(4));
					        System.out.println(o1.get().t);
					    }
					}
					
					class X1<T> implements I<T> {
					    T t;
					    X1(T arg) {
					        t = arg;
					    }
					    public X1 get() {
					        return this;
					    }
					}
					
					interface I<T> extends J<T> {
					    I get();
					}
					
					interface J<T>  {
					    J get();
					}"""
	,
			},
			"4");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=74594
	public void test0347() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					    public static void main(String argv[]) {
					        X1<Integer> o = new X1<Integer>(new Integer(4));
					        System.out.println(o.get().t);
					    }
					}
					
					class X1<T> implements I<T> {
					    T t;
					    X1(T arg) {
					        t = arg;
					    }
					    public X1 get() {
					        return this;
					    }
					}   \s
					
					interface I<T> extends K<T>, L<T> {
					    I get();
					}
					
					interface J<T>  {
					    J get();
					}
					
					interface K<T> extends J<T> {
					}
					
					interface L<T>  {
					    K get();
					}""",
			},
			"4");
	}
	// checking scenario where generic type and method share the same type parameter name
	public void test0348() {
		if (this.complianceLevel < ClassFileConstants.JDK1_7) {
			this.runNegativeTest(
				new String[] {
					"X.java",
					"""
						import java.io.IOException;
						public abstract class X<T extends Runnable> {
							public abstract <T extends Exception> T bar(T t);
							static void foo(X x) {
								x.<Exception>bar(null);
								class R implements Runnable {
									public void run() {}
								}
								X<R> xr = new X<R>(){ \s
									public <T extends Exception> T bar(T t) { return t; }
								};
								IOException e = xr.bar(new IOException());
							}
						}
						"""
				},
				"""
					----------
					1. WARNING in X.java (at line 3)
						public abstract <T extends Exception> T bar(T t);
						                 ^
					The type parameter T is hiding the type T
					----------
					2. WARNING in X.java (at line 4)
						static void foo(X x) {
						                ^
					X is a raw type. References to generic type X<T> should be parameterized
					----------
					3. ERROR in X.java (at line 5)
						x.<Exception>bar(null);
						             ^^^
					The method bar(Exception) of raw type X is no longer generic; it cannot be parameterized with arguments <Exception>
					----------
					4. WARNING in X.java (at line 10)
						public <T extends Exception> T bar(T t) { return t; }
						                               ^^^^^^^^
					The method bar(T) of type new X<R>(){} should be tagged with @Override since it actually overrides a superclass method
					----------
					""",
				JavacTestOptions.EclipseHasABug.EclipseBug236242);
			return;
		}
		this.runNegativeTest(
				new String[] {
					"X.java",
					"""
						import java.io.IOException;
						public abstract class X<T extends Runnable> {
							public abstract <T extends Exception> T bar(T t);
							static void foo(X x) {
								x.<Exception>bar(null);
								class R implements Runnable {
									public void run() { zork = 0; }
								}
								X<R> xr = new X<R>(){ \s
									public <T extends Exception> T bar(T t) { return t; }
								};
								IOException e = xr.bar(new IOException());
							}
						}
						"""
				},
				"""
					----------
					1. WARNING in X.java (at line 3)
						public abstract <T extends Exception> T bar(T t);
						                 ^
					The type parameter T is hiding the type T
					----------
					2. WARNING in X.java (at line 4)
						static void foo(X x) {
						                ^
					X is a raw type. References to generic type X<T> should be parameterized
					----------
					3. WARNING in X.java (at line 5)
						x.<Exception>bar(null);
						^^^^^^^^^^^^^^^^^^^^^^
					Type safety: The method bar(Exception) belongs to the raw type X. References to generic type X<T> should be parameterized
					----------
					4. ERROR in X.java (at line 7)
						public void run() { zork = 0; }
						                    ^^^^
					zork cannot be resolved to a variable
					----------
					5. WARNING in X.java (at line 10)
						public <T extends Exception> T bar(T t) { return t; }
						                               ^^^^^^^^
					The method bar(T) of type new X<R>(){} should be tagged with @Override since it actually overrides a superclass method
					----------
					""",
				JavacTestOptions.EclipseHasABug.EclipseBug236242);
	}
	// test wildcard compatibilities
	public void test0349() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
						T element;
						static void foo(X<? super Exception> out, X1<? extends Exception> in) {
							out.element = in.element;
						}
						public static void main(String[] args) {
							System.out.println("SUCCESS");
						}
					}
					class X1<U>{
						U element;
					}
					""",
			},
			"SUCCESS");
	}
	// test wildcard compatibilities
	public void test0350() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
						T element;
						static void foo(X<?> out, X1<?> in) {
							out.element = in.element;
						}
					}
					class X1<U>{
						U element;
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					out.element = in.element;
					              ^^^^^^^^^^
				Type mismatch: cannot convert from capture#2-of ? to capture#1-of ?
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=75328
	public void test0351() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					interface Intf<D extends Comparable<D>, I extends Comparable<D>> {\s
					  public void f(Intf<D,?> val);
					}
					
					public class X <M extends Comparable<M>, P extends Comparable<M>>  implements Intf<M,P> {
					
					  public void f(Intf<M,?> val) { }\s
					}
					""",
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=77051
	public void test0352() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					interface C<A> { }
					interface PC<X> extends C<X> { }\s
					interface PO<Y>  { \s
						  C<Y> proc1();
						  C<? super Y> proc2();
						  C<? extends Y> proc3();
					}
					abstract class X<Z> implements PO<Z> {
						  public C<Z> proc1() { return result1; }
						  private final PC<Z> result1 = null;
						  public C<? super Z> proc2() { return result2; }
						  private final PC<? super Z> result2 = null;
						  public C<? extends Z> proc3() { return result3; }
						  private final PC<? extends Z> result3 = null;
					}
					""",
			},
			"");
	}
	public void test0353() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X extends Y {
						<T> T foo(Class<T> c) { return null; }
					}
					class Y {
						<T> T foo(Class<T> c) { return null; }
					}"""
			},
			"");
	}
	public void test0354() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X extends Y {
						<T, S> S foo(Class<T> c) { return null; }
					}
					class Y {
						<S, T> T foo(Class<S> c) { return null; }
					}"""
			},
			"");
	}
	public void test0355() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X extends Y {
						<T, S> S foo(Class<S> c) { return null; }
					}
					class Y {
						<S, T> S foo(Class<S> c) { return null; }
					}"""
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					<T, S> S foo(Class<S> c) { return null; }
					         ^^^^^^^^^^^^^^^
				Name clash: The method foo(Class<S>) of type X has the same erasure as foo(Class<S>) of type Y but does not override it
				----------
				""");
	}
	public void test0356() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X extends Y {
						<T, S> T foo(Class<T> c) { return null; }
					}
					class Y {
						<T> T foo(Class<T> c) { return null; }
					}"""
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					<T, S> T foo(Class<T> c) { return null; }
					         ^^^^^^^^^^^^^^^
				Name clash: The method foo(Class<T>) of type X has the same erasure as foo(Class<T>) of type Y but does not override it
				----------
				""");
	}
	public void test0357() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X extends Y {
						<T> T foo(Class<T> c) { return null; }
					}
					class Y {
						<T, S> T foo(Class<T> c) { return null; }
					}"""
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					<T> T foo(Class<T> c) { return null; }
					      ^^^^^^^^^^^^^^^
				Name clash: The method foo(Class<T>) of type X has the same erasure as foo(Class<T>) of type Y but does not override it
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=76720
	public void test0358() {
		this.runConformTest(
			new String[] {
				"MyClass.java",
				"public class MyClass {}\n",
				"A.java",
				"public interface A<M extends MyClass> {}\n",
				"B.java",
				"public interface B<M extends MyClass> extends A<M> {}\n",
				"C.java",
				"public class C implements B<MyClass> {}\n", // compile against sources
				"D.java",
				"public class D implements A<MyClass>{}\n", // compile against sources
			},
			"");
		// compile against generated binaries
		this.runConformTest(
			new String[] {
				"C.java",
				"public class C implements B<MyClass> {}\n",
				"D.java",
				"public class D implements A<MyClass>{}\n",
			},
			"",
			null,
			false,
			null);
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=76790
	public void test0359() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					public class X {
					    class List1<E> extends LinkedList<E> {};
					    public static void main (String[] args) {
					        Map<String, List<Integer>> x = new HashMap<String, List<Integer>>();
					        Map<String, List1<Integer>> m = new HashMap<String, List1<Integer>>();
					    }
					}"""
			}
		);
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=76786
	public void test0360() {
		this.runConformTest(
			new String[] {
				"Test.java",
				"""
					import java.lang.Comparable;
					public class Test {
					    private static final class X<T1, T2> implements Comparable<X<T1, T2>> {
					        public int compareTo(X<T1, T2> arg0) { return 0; }
					    };
					    private static class Y<T1, T2> {};
					    private static final class Z<T1, T2> extends Y<T1, T2> implements Comparable<Z<T1, T2>> {
					        public int compareTo(Z<T1, T2> arg0) { return 0; }
					    };
					    public static <T> void doSomething(Comparable<? super T> a, Comparable<? super T> b) {}
					    public static <V1, V2> void doSomethingElse(Z<V1, V2> a, Z<V1, V2> b) {
					        doSomething(a, b);
					    }
					    private static final class W { };
					    public static void main(String[] args) {
					        doSomething(new X<Integer, String>(), new X<Integer, String>());
					        doSomething(new Z<Integer, String>(), new Z<Integer, String>());
					        doSomethingElse(new Z<Integer, String>(), new Z<Integer, String>());
					        doSomethingElse(new Z<W, String>(), new Z<W, String>());
					        // The next line won't compile.  It's the generic<generic which seems
					        // to be the problem
					        doSomethingElse(new Z<X<W, W>, String>(), new Z<X<W, W>, String>());
					    }
					}"""
			}
		);
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=75525
	public void test0361() {
		this.runConformTest(
			new String[] {
				"Test.java",
				"""
					import java.util.AbstractSet;
					import java.util.Iterator;
					import java.util.Map.Entry;
					public class Test extends AbstractSet<Entry<String,Integer>> {
						public Iterator<Entry<String, Integer>> iterator() {
							return new Iterator<Entry<String,Integer>>() {
								public boolean hasNext() {return false;}
								public Entry<String, Integer> next() {return null;}
								public void remove() {}\t
							};
						}
						public int size() {return 0;}
					}"""
			}
		);
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=72643
	public void test0362() {
		Map customOptions= getCompilerOptions();
		customOptions.put(CompilerOptions.OPTION_ReportUnusedPrivateMember, CompilerOptions.ERROR);
		this.runConformTest(
			new String[] {
				"Test.java",
				"""
					import java.util.ArrayList;
					import java.util.List;
					public class Test {
					   public void a() {
					      List<String> list1 = new ArrayList<String>();
					      List<String> list2 = new ArrayList<String>();
					      compare(list1, list2);
					   }
					   private <E> void compare(List<E> list1, List<E> list2) {
					      // do some comparing logic...
					   }
					}
					
					"""
			},
		"",
		null,
		true,
		null,
		customOptions,
		null/*no custom requestor*/);
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=76434
	public void test0363() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.Map;
					import java.util.Set;
					public class X {
					  Set<Map.Entry<Integer, ?>> m_values;
					  X(Map<Integer, ?> values) {
					    m_values = values.entrySet();
					  }
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 6)
					m_values = values.entrySet();
					           ^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Set<Map.Entry<Integer,capture#1-of ?>> to Set<Map.Entry<Integer,?>>
				----------
				""");
	}
	// check param type equivalences
	public void test0364() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"public class X { \n" +
				"	\n" +
				"	void bar1(MX<Class<? extends String>> mxcs, MX<Class<? extends Object>> mxco) {\n" +
				"		mxco = mxcs;\n" + // wrong
				"	}\n" +
				"	void bar1(Class<? extends String> cs, Class<? extends Object> co) {\n" +
				"		co = cs;\n" + // ok
				"	}\n" +
				"	\n" +
				"}\n" +
				"class MX<E> {\n" +
				"}\n"
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					mxco = mxcs;
					       ^^^^
				Type mismatch: cannot convert from MX<Class<? extends String>> to MX<Class<? extends Object>>
				----------
				""");
	}
	// check param type equivalences
	public void test0365() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T extends Runnable> {
					\t
						class MX <U> {
						}
					\t
						MX<T> createMX() { return new MX<T>(); }
					
						void foo(X<?> x, MX<?> mx) {
							mx = x.createMX();
						}
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 9)
					mx = x.createMX();
					     ^^^^^^^^^^^^
				Type mismatch: cannot convert from X<capture#2-of ?>.MX<capture#2-of ?> to X<T>.MX<?>
				----------
				""");
	}
	// check param type equivalences
	public void test0366() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {\s
					\t
						void foo1(MX<Class<? extends Object>> target, MX<Class> value) {
							target= value; // foo1 - wrong
						}
						void foo2(MX<Class<? extends Object>> target, MX<Class<? extends String>> value) {
							target= value; // foo2 - wrong
						}
						void foo3(MX<Class<? extends Object>> target, MX<Class<? extends String>> value) {
							target= value; // foo3 - wrong
						}
						void foo4(MX<Class<? extends Object>> target, MX<Class<String>> value) {
							target= value; // foo4 - wrong
						}
						void foo5(MX<? extends Class> target, MX<Class> value) {
							target= value; // foo5
						}
						void foo6(MX<? super Class> target, MX<Class> value) {
							target= value; // foo6
						}
						void foo7(MX<Class<? extends Class>> target, MX<Class<Class>> value) {
							target= value; // foo7 - wrong
						}
						void foo8(MX<MX<? extends Class>> target, MX<MX<Class>> value) {
							target= value; // foo8 - wrong
						}
						void foo9(MX<? extends Object> target, MX<? extends String> value) {
							target= value; // foo9
						}
						void foo10(MX<? extends String> target, MX<? extends Object> value) {
							target= value; // foo10 - wrong
						}
						void foo11(MX<? super Object> target, MX<? super String> value) {
							target= value; // foo11 - wrong
						}
						void foo12(MX<? super String> target, MX<? super Object> value) {
							target= value; // foo12
						}
					}
					
					class MX<E> {
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 3)
					void foo1(MX<Class<? extends Object>> target, MX<Class> value) {
					                                                 ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				2. ERROR in X.java (at line 4)
					target= value; // foo1 - wrong
					        ^^^^^
				Type mismatch: cannot convert from MX<Class> to MX<Class<? extends Object>>
				----------
				3. ERROR in X.java (at line 7)
					target= value; // foo2 - wrong
					        ^^^^^
				Type mismatch: cannot convert from MX<Class<? extends String>> to MX<Class<? extends Object>>
				----------
				4. ERROR in X.java (at line 10)
					target= value; // foo3 - wrong
					        ^^^^^
				Type mismatch: cannot convert from MX<Class<? extends String>> to MX<Class<? extends Object>>
				----------
				5. ERROR in X.java (at line 13)
					target= value; // foo4 - wrong
					        ^^^^^
				Type mismatch: cannot convert from MX<Class<String>> to MX<Class<? extends Object>>
				----------
				6. WARNING in X.java (at line 15)
					void foo5(MX<? extends Class> target, MX<Class> value) {
					                       ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				7. WARNING in X.java (at line 15)
					void foo5(MX<? extends Class> target, MX<Class> value) {
					                                         ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				8. WARNING in X.java (at line 18)
					void foo6(MX<? super Class> target, MX<Class> value) {
					                     ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				9. WARNING in X.java (at line 18)
					void foo6(MX<? super Class> target, MX<Class> value) {
					                                       ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				10. WARNING in X.java (at line 21)
					void foo7(MX<Class<? extends Class>> target, MX<Class<Class>> value) {
					                             ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				11. WARNING in X.java (at line 21)
					void foo7(MX<Class<? extends Class>> target, MX<Class<Class>> value) {
					                                                      ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				12. ERROR in X.java (at line 22)
					target= value; // foo7 - wrong
					        ^^^^^
				Type mismatch: cannot convert from MX<Class<Class>> to MX<Class<? extends Class>>
				----------
				13. WARNING in X.java (at line 24)
					void foo8(MX<MX<? extends Class>> target, MX<MX<Class>> value) {
					                          ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				14. WARNING in X.java (at line 24)
					void foo8(MX<MX<? extends Class>> target, MX<MX<Class>> value) {
					                                                ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				15. ERROR in X.java (at line 25)
					target= value; // foo8 - wrong
					        ^^^^^
				Type mismatch: cannot convert from MX<MX<Class>> to MX<MX<? extends Class>>
				----------
				16. ERROR in X.java (at line 31)
					target= value; // foo10 - wrong
					        ^^^^^
				Type mismatch: cannot convert from MX<capture#6-of ? extends Object> to MX<? extends String>
				----------
				17. ERROR in X.java (at line 34)
					target= value; // foo11 - wrong
					        ^^^^^
				Type mismatch: cannot convert from MX<capture#7-of ? super String> to MX<? super Object>
				----------
				""");
	}
	// check param type equivalences
	public void test0367() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {\s
					\t
						void foo1(MX<? extends MX> target, MX<MX<String>> value) {
							target= value; // foo1
						}
						void foo2(MX<?> target, MX<MX<String>> value) {
							target= value; // foo2
						}
						void foo3(MX<? super MX> target, MX<MX<String>> value) {
							target= value; // foo3
						}
					}
					
					class MX<E> {
					}
					"""	,
			},
			"""
				----------
				1. WARNING in X.java (at line 3)
					void foo1(MX<? extends MX> target, MX<MX<String>> value) {
					                       ^^
				MX is a raw type. References to generic type MX<E> should be parameterized
				----------
				2. WARNING in X.java (at line 9)
					void foo3(MX<? super MX> target, MX<MX<String>> value) {
					                     ^^
				MX is a raw type. References to generic type MX<E> should be parameterized
				----------
				3. ERROR in X.java (at line 10)
					target= value; // foo3
					        ^^^^^
				Type mismatch: cannot convert from MX<MX<String>> to MX<? super MX>
				----------
				""");
	}
	// check param type equivalences
	public void test0368() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T extends Runnable> {
					\t
						static class MX <U> {
						}
					\t
						MX<T> createMX() { return new MX<T>(); }
					
						void foo(X<?> x, MX<?> mx) {
							mx = x.createMX();
						}
					}
					"""	,
			},
			"");
	}
	// bound check for Enum<T>
	public void test0369() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					\t
						<T extends Enum<T>> T foo(T t) { return null; }
					}
					""",
			},
			"");
	}
	// decoding raw binary type
	public void test0370() {
		this.runConformTest(
    		new String[] {
				"p/B.java",
				"""
					package p;
					import java.util.Map;
					public class B {
						public static Map<Class, String> foo(byte[] byteArray, Object o, Class c) {
							return null;
						}
					}"""
    		},
			"");

		this.runConformTest(
    		new String[] {
    			"X.java",
				"""
					import java.util.Map;
					
					import p.B;
					
					public class X {
						{
							Map<Class, String> map = B.foo(null, null, null);
						}
					}
					""",
    		},
			"",
			null,
			false,
			null);
	}
	// X<? extends Y> is not compatible with X<Y>
	public void test0371() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					   	public void foo(XC<Runnable> target, XC<? extends Runnable> value) {
					   		target = value;
					   	}
					}
					class XC <E>{
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					target = value;
					         ^^^^^
				Type mismatch: cannot convert from XC<capture#1-of ? extends Runnable> to XC<Runnable>
				----------
				""");
	}
	public void test0372() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.Iterator;
					import java.util.Map;
					import java.util.Map.Entry;
					
					public class X <K, V> {
					
						void foo(Iterator<Map.Entry<K,V>> iter) {
							new XA.MXA<K,V>(iter.next());
						}
					}
					class XA <K, V> {
						static class MXA <K, V>  implements Entry<K,V> {
							MXA(Entry<K,V> e) {
							}
							public K getKey() {
								return null;
							}
							public V getValue() {
								return null;
							}
							public V setValue(V value) {
								return null;
							}
						}
					}
					"""	,
			},
			"");
	}
	public void test0373() {
		this.runConformTest(
			new String[] {
				"XA.java",
				"""
					import java.util.Map.Entry;
					
					public class XA <K, V> {
						static class MXA <K, V>  implements Entry<K,V> {
							MXA(Entry<K,V> e) {
							}
							public K getKey() {
								return null;
							}
							public V getValue() {
								return null;
							}
							public V setValue(V value) {
								return null;
							}
						}
					}
					"""	,
			},
			"");
		// compile against binaries
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.Iterator;
					import java.util.Map;
					import java.util.Map.Entry;
					
					public class X <K, V> {
					
						void foo(Iterator<Map.Entry<K,V>> iter) {
							new XA.MXA<K,V>(iter.next());
						}
					}
					"""	,
			},
			"",
			null,
			false,
			null);
	}
	// wildcard with no upper bound uses type variable as upper bound
	public void test0374() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends Exception> {
					
						void foo1(X <? extends Exception> target, X<?> value) {
							target = value; // foo1
						}
						void foo2(X <? extends Exception> target, X<? super RuntimeException> value) {
							target = value;  // foo2
						}\t
					}
					""",
			},
			"");
	}
	public void test0375() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
					
						void foo1(X <? super Exception> target, X<? extends Exception> value) {
							target = value; // foo1
						}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					target = value; // foo1
					         ^^^^^
				Type mismatch: cannot convert from X<capture#2-of ? extends Exception> to X<? super Exception>
				----------
				""");
	}
	public void test0376() {
		this.runConformTest(
			new String[] {
				"XA.java",
				"""
					import java.util.Map.Entry;
					
					public class XA <K, V> {
					   XA<K,V> self() { return this; }\s
						static class MXA <K, V>  implements Entry<K,V> {
							MXA(Entry<K,V> e) {
							}
							public K getKey() {
								return null;
							}
							public V getValue() {
								return null;
							}
							public V setValue(V value) {
								return null;
							}
						}
					}
					"""	,
			},
			"");
		// compile against binaries
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.Iterator;
					import java.util.Map;
					import java.util.Map.Entry;
					
					public class X <K, V> {
					
						void foo(Iterator<Map.Entry<K,V>> iter) {
							new XA.MXA<K,V>(iter.next());
						}
					}
					"""	,
			},
			"",
			null,
			false,
			null);
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=76601
	public void test0377() {
		this.runConformTest(
			new String[] {
				"Test.java",
				"""
					public class Test {
					 public static void main (String[] args) {
					  final String val = (args == null||args.length==0 ? "SUCC" : args[0]) + "ESS";
					  class AllegedBoundMismatch<E2 extends SuperI<E2>> {
					   String field = val;
					  }
					  System.out.println(new Object() {
					   AllegedBoundMismatch<SubI<Q>> trial = new AllegedBoundMismatch<SubI<Q>>();
					  }.trial.field);
					 }
					}
					class Q {}
					interface SubI<Q> extends SuperI<SubI<Q>> {}
					interface SuperI<Q> {}"""
			},
		"SUCCESS");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=76219
	public void test0378() {
		this.runConformTest(
			new String[] {
				"BB.java",
				"""
					interface AA<W, Z extends AA<W, Z>> {\s
					 public boolean m(AA<W, ?> that);\s
					 public Z z();\s
					 public boolean b();\s
					}
					abstract class BB<U, V extends AA<U, V>> implements AA<U,V> {\s
					 public boolean m(AA<U, ?> wht) { return wht.z().b(); }\s
					}
					"""}
		);
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=71612
	public void test0379() {
		this.runConformTest(
			new String[] {
				"Test.java",
				"""
					import java.util.AbstractSet;
					import java.util.Iterator;
					public class Test extends AbstractSet<Runnable>{
					    public static void main(String[] args) {
					        Test t=new Test();
					        t.add(null);
					    }
					    public boolean add(Runnable run) {
					        System.out.println("success");
					        return true;
					    }
					    public Iterator<Runnable> iterator() {return null;}
					    public int size() {return 0;}
					}"""
				}
		);
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=77327
	public void test0380() {
		this.runConformTest(
			new String[] {
				"Test.java",
				"""
					import java.util.List;
					public class Test {
						List<? super Number> wsn= null; // Contravariance
						List<? super Integer> wsi= wsn; // should work!
					}
					"""
				}
		);
	}

	public void test0381() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X extends Y {
						void foo(Class<? extends String> s) {}
					}
					class Y {
						void foo(Class<String> s) {}
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					void foo(Class<? extends String> s) {}
					     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Name clash: The method foo(Class<? extends String>) of type X has the same erasure as foo(Class<String>) of type Y but does not override it
				----------
				""");
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X extends Y {
						void foo(Class<String> s) {}
					}
					class Y {
						void foo(Class<? extends String> s) {}
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					void foo(Class<String> s) {}
					     ^^^^^^^^^^^^^^^^^^^^
				Name clash: The method foo(Class<String>) of type X has the same erasure as foo(Class<? extends String>) of type Y but does not override it
				----------
				""");
	}
	public void test0382() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X extends Y implements I {}
					interface I { void foo(Class<? extends String> s); }
					class Y { void foo(Class<String> s) {} }
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 1)
					public class X extends Y implements I {}
					             ^
				Name clash: The method foo(Class<String>) of type Y has the same erasure as foo(Class<? extends String>) of type I but does not override it
				----------
				2. ERROR in X.java (at line 1)
					public class X extends Y implements I {}
					             ^
				The type X must implement the inherited abstract method I.foo(Class<? extends String>)
				----------
				""");
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public abstract class X extends Y implements I {}
					interface I { void foo(Class<String> s); }
					class Y { void foo(Class<? extends String> s) {} }
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 1)
					public abstract class X extends Y implements I {}
					                      ^
				Name clash: The method foo(Class<? extends String>) of type Y has the same erasure as foo(Class<String>) of type I but does not override it
				----------
				""");
	}
	public void test0383() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X extends Y implements I { public <T> void foo(Class<T> s) {} }
					interface I { <T, S> void foo(Class<T> s); }
					class Y { public <T> void foo(Class<T> s) {} }
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 1)
					public class X extends Y implements I { public <T> void foo(Class<T> s) {} }
					             ^
				The type X must implement the inherited abstract method I.foo(Class<T>)
				----------
				2. ERROR in X.java (at line 1)
					public class X extends Y implements I { public <T> void foo(Class<T> s) {} }
					                                                        ^^^^^^^^^^^^^^^
				Name clash: The method foo(Class<T>) of type X has the same erasure as foo(Class<T>) of type I but does not override it
				----------
				3. WARNING in X.java (at line 1)
					public class X extends Y implements I { public <T> void foo(Class<T> s) {} }
					                                                        ^^^^^^^^^^^^^^^
				The method foo(Class<T>) of type X should be tagged with @Override since it actually overrides a superclass method
				----------
				""");
			/*
			X.java:1: X is not abstract and does not override abstract method <T,S>foo(java.lang.Class<T>) in I
			public class X extends Y implements I { public <T> void foo(Class<T> s) {} }
			       ^
       		*/
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X extends Y implements I {}
					interface I { <T, S> void foo(Class<T> s); }
					class Y { public <T> void foo(Class<T> s) {} }
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 1)
					public class X extends Y implements I {}
					             ^
				Name clash: The method foo(Class<T>) of type Y has the same erasure as foo(Class<T>) of type I but does not override it
				----------
				2. ERROR in X.java (at line 1)
					public class X extends Y implements I {}
					             ^
				The type X must implement the inherited abstract method I.foo(Class<T>)
				----------
				""");
			/*
			X.java:1: X is not abstract and does not override abstract method <T,S>foo(java.lang.Class<T>) in I
			public class X extends Y implements I {}
			       ^
			*/
		this.runNegativeTest(
			new String[] {
				"X.java",
				"public abstract class X extends Y implements I {}\n" + // NOTE: X is abstract
				"interface I { <T> void foo(Class<T> s); }\n" +
				"class Y { public <T, S> void foo(Class<T> s) {} }\n"
			},
			"""
				----------
				1. ERROR in X.java (at line 1)
					public abstract class X extends Y implements I {}
					                      ^
				Name clash: The method foo(Class<T>) of type Y has the same erasure as foo(Class<T>) of type I but does not override it
				----------
				""");
			/*
			X.java:1: name clash: <T,S>foo(java.lang.Class<T>) in Y and <T>foo(java.lang.Class<T>) in I have the same erasure, yet neither overrides the other
			public abstract class X extends Y implements I {}
			                ^
			 */
	}
	public void test0384a() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X extends Y {
						<T> java.util.List<T> foo3(java.util.List<T> t) { return t; }
						Class<String> foo4() { return null; }
						Class<String>[] foo5() { return null; }
					}
					class Y {
						<T> java.util.List<T> foo3(java.util.List<T> t) { return t; }
						Class<? extends String> foo4() { return null; }
						Class<? extends String>[] foo5() { return null; }
					}
					"""
			},
			"");
	}
	public void test0384b() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X extends Y {
						@Override Class<? extends String> foo() { return null; }
						@Override Class<? extends String>[] foo2() { return null; }
					}
					class Y {
						Class<String> foo() { return null; }
						Class<String>[] foo2() { return null; }
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					@Override Class<? extends String> foo() { return null; }
					          ^^^^^^^^^^^^^^^^^^^^^^^
				The return type is incompatible with Y.foo()
				----------
				2. ERROR in X.java (at line 3)
					@Override Class<? extends String>[] foo2() { return null; }
					          ^^^^^^^^^^^^^^^^^^^^^^^^^
				The return type is incompatible with Y.foo2()
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=77496
	public void test0385() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.List;
					interface IDoubles { List<Double> getList(); }
					class A implements IDoubles {
						public List<String> getList() { return null; }
					}
					class B {
						 public List<String> getList() { return null; }
					}
					class C extends B implements IDoubles {
						void use() { List<String> l= getList(); }
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					public List<String> getList() { return null; }
					       ^^^^^^^^^^^^
				The return type is incompatible with IDoubles.getList()
				----------
				2. ERROR in X.java (at line 9)
					class C extends B implements IDoubles {
					      ^
				The return types are incompatible for the inherited methods IDoubles.getList(), B.getList()
				----------
				""");
			/*
			X.java:3: A is not abstract and does not override abstract method getList() in IDoubles
			class A implements IDoubles {
			^
			X.java:4: getList() in A cannot implement getList() in IDoubles; attempting to use incompatible return type
			found   : java.util.List<java.lang.String>
			required: java.util.List<java.lang.Double>
				public List<String> getList() { return null; }
			                            ^
			X.java:9: C is not abstract and does not override abstract method getList() in IDoubles
			class C extends B implements IDoubles {
			 */
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=77325
	public void test0386() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					class X <R,U,V, T> {
						private U u;
						private V v;
						public X(U u,V v) { this.u= u; this.v= v; }
						public R getU() { return (R)u; } // Warning
						public R getV() { return (R)v; } // Warning
						Object o;
						public T getT() { return (T)o; } // Warning
					}"""
			},
			"""
				----------
				1. WARNING in X.java (at line 5)
					public R getU() { return (R)u; } // Warning
					                         ^^^^
				Type safety: Unchecked cast from U to R
				----------
				2. WARNING in X.java (at line 6)
					public R getV() { return (R)v; } // Warning
					                         ^^^^
				Type safety: Unchecked cast from V to R
				----------
				3. WARNING in X.java (at line 8)
					public T getT() { return (T)o; } // Warning
					                         ^^^^
				Type safety: Unchecked cast from Object to T
				----------
				""");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=77422 - generic varargs method
	public void test0387() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					
					public class X<T>
					{
					
						public boolean test1()
						{
								test2("test", null, 0);
						}
					
						public <F> List<F> test2(final List<F> list, final String... strings)
						{
							return null;
						}
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 8)
					test2("test", null, 0);
					^^^^^
				The method test2(List<F>, String...) in the type X<T> is not applicable for the arguments (String, null, int)
				----------
				""");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=77422 - variation
	public void test0388() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					
					public class X<T>
					{
					
						public boolean test01()
						{
								test02(null, null, "test");
								return false;
						}
					
						public <F> List<F> test02(final List<F> list, final String... strings)
						{
							return null;
						}
					}
					"""
			},
			""
		);
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=77422 - variation
	public void test0389() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					
						public boolean test01()	{
							String s = foo("hello");
							return s != null;
						}
					
						public <F> F foo(F f, F... others) {
							return f;
						}
					}
					"""
			},
			""
		);
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=77422 - variation
	public void test0390() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					
						public boolean test01()	{
							String s = foo(null, "hello");
							return s != null;
						}
					
						public <F> F foo(F f, F... others) {
							return f;
						}
					}
					"""
			},
			""
		);
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=77422 - variation
	public void test0391() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					
						public boolean test01()	{
							String[] s = foo(null, new String[]{ "hello" });
							return s != null;
						}
					
						public <F> F foo(F f, F... others) {
							return f;
						}
					}
					"""
			},
			this.complianceLevel < ClassFileConstants.JDK1_7 ?
			"""
				----------
				1. ERROR in X.java (at line 4)
					String[] s = foo(null, new String[]{ "hello" });
					             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from String to String[]
				----------
				""" :
				"""
					----------
					1. ERROR in X.java (at line 4)
						String[] s = foo(null, new String[]{ "hello" });
						             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
					Type mismatch: cannot convert from String to String[]
					----------
					2. WARNING in X.java (at line 8)
						public <F> F foo(F f, F... others) {
						                           ^^^^^^
					Type safety: Potential heap pollution via varargs parameter others
					----------
					"""
		);
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=77422 - variation
	public void test0392() {
		this.runConformTest(
			new String[] {
				"X.java",
				"public class X {\n" +
				"\n" +
				"	public boolean test01()	{\n" +
				"		foo(null, \"hello\");\n" + // no inference on expected type
				"		return true;\n" +
				"	}\n" +
				"\n" +
				"	public <F> F foo(F f, F... others) {\n" +
				"		return f;\n" +
				"	}\n" +
				"}\n"
			},
			""
		);
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=78049 - chech invalid array initializer
	public void test0393() {
		this.runConformTest(
			new String[] {
				"X.java",
				"public class X {\n" +
				"\n" +
				"	public boolean test01()	{\n" +
				"		foo(null, \"hello\");\n" + // no inference on expected type
				"		return true;\n" +
				"	}\n" +
				"\n" +
				"	public <F> F foo(F f, F... others) {\n" +
				"		return f;\n" +
				"	}\n" +
				"}\n"
			},
			""
		);
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=78027
	public void test0394() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X\s
					{
					}
					
					interface ITest<C extends X>
					{\s
					}
					
					abstract class Test<C extends X> implements ITest<C>
					{
					  protected Manager<C> m_manager;
					 \s
					  public ITest<C> get()
					  {
					    return m_manager.getById(getClass(), new Integer(1));
					  }
					   \s
					  public static class Manager<C extends X>
					  {
					    public <T extends ITest<C>> T getById(Class<T> cls, Integer id)
					    {
					      return null;
					    }
					  }
					}
					"""
			},
			""
		);
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=74119 - variation
	public void test0395() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T extends Exception> {
						T element;
					\t
						void foo(X<? super NullPointerException> xnpe) {
							xnpe.element = new java.io.IOException();
						}
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 5)
					xnpe.element = new java.io.IOException();
					               ^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from IOException to capture#1-of ? super NullPointerException
				----------
				""");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=78139 - downcast generic method inference
	public void test0396() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.Collection;
					import java.util.List;
					import java.util.ArrayList;
					
					public class X
					{
					    public static <T> List<T> emptyList() {
					        return new ArrayList<T>();
					    }
					    public static <T> Collection<T> emptyCollection() {
					        return new ArrayList<T>();
					    }
					    public static <T> Iterable<T> emptyIterable() {
					        return new ArrayList<T>();
					    }
					   \s
					    public static void main(String[] args) {
					    	 // generic inference using expected lhs type: T --> String
					        final List<String> lL = emptyList(); // 1
					       \s
					    	 // generic inference using expected cast type: T --> String
					        final Collection<String> cL = (Collection<String>)emptyList(); // 2
					       \s
					    	 // generic inference using expected cast type: T --> String
					        final Iterable<String> iL = (Iterable<String>)emptyList(); // 3
					       \s
					    	 // generic inference using expected lhs type: T --> String
					        final Collection<String> cC = emptyCollection(); // 4
					       \s
					    	 // generic inference using expected cast type: T --> String
					        final Iterable<String> iC = (Iterable<String>)emptyCollection(); // 5
					       \s
					    	 // generic inference using expected lhs type: T --> String
					        final Iterable<String> iI = emptyIterable(); // 6
					       \s
					    	 // generic inference using expected lhs type: T --> String
					        final Collection<String> cL2 = emptyList(); // 7
					       \s
					    	 // generic inference using expected lhs type: T --> String
					        final Iterable<String> iC2 = emptyCollection(); // 8
					    }
					}"""
			},
			"""
				----------
				1. ERROR in X.java (at line 22)
					final Collection<String> cL = (Collection<String>)emptyList(); // 2
					                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Cannot cast from List<Object> to Collection<String>
				----------
				2. ERROR in X.java (at line 25)
					final Iterable<String> iL = (Iterable<String>)emptyList(); // 3
					                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Cannot cast from List<Object> to Iterable<String>
				----------
				3. ERROR in X.java (at line 31)
					final Iterable<String> iC = (Iterable<String>)emptyCollection(); // 5
					                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Cannot cast from Collection<Object> to Iterable<String>
				----------
				""");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=76132
	public void test0397() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					interface K1<A> {\s
					        public <B extends A> void kk(K1<B> x);\s
					}\s
					\s
					class K2<C> implements K1<C> {\s
					        public <D extends C> void kk(K1<D> y) {\s
					                System.out.println("K2::kk(" + y.toString() + ")");\s
					        }\s
					}\s
					\s
					// ---------------------------------------------------\s
					\s
					interface L1<E> {\s
					        public void ll(L1<? extends E> a);\s
					}\s
					\s
					class L2<KK> implements L1<KK> {\s
					        public void ll(L1<? extends KK> b) {\s
					                ll2(b);\s
					        }\s
					\s
					        private <LL extends KK> void ll2(L1<LL> c) {\s
					                System.out.println("L2::ll2(" + c.toString() + ")");\s
					        }\s
					}\s
					\s
					// ---------------------------------------------------\s
					\s
					interface M1<H> {\s
					        public void mm(M1<? extends H> p);\s
					}\s
					\s
					class M2<I> implements M1<I> {\s
					        public <J extends I> void mm(M1<J> q) {\s
					                System.out.println("M2::mm(" + q.toString() + ")");\s
					        }\s
					}\s
					\s
					// ===================================================\s
					\s
					class XX            { public String toString() { return "XX"; } }\s
					class YY extends XX { public String toString() { return "YY"; } }\s
					class ZZ extends YY { public String toString() { return "ZZ"; } }\s
					\s
					// ---------------------------------------------------\s
					\s
					public class X {\s
					        public static void main(String arg[]) {\s
					                goK(new K2<YY>());\s
					                goL(new L2<YY>());\s
					                goM(new M2<YY>());\s
					        }\s
					\s
					\s
					        public static void goK(K1<YY> k) {\s
					                // k.kk(new K2<XX>()); // Would fail\s
					                k.kk(new K2<YY>());\s
					                k.kk(new K2<ZZ>());\s
					        }\s
					\s
					\s
					        public static void goL(L1<YY> l) {\s
					                // l.ll(new L2<XX>()); // Would fail\s
					                l.ll(new L2<YY>());\s
					                l.ll(new L2<ZZ>());\s
					        }\s
					\s
					\s
					        public static void goM(M1<YY> m) {\s
					                // m.mm(new M2<XX>()); // Would fail\s
					                m.mm(new M2<YY>());\s
					                m.mm(new M2<ZZ>());\s
					        }\s
					}"""
			},
			"""
				----------
				1. ERROR in X.java (at line 33)
					class M2<I> implements M1<I> {\s
					      ^^
				The type M2<I> must implement the inherited abstract method M1<I>.mm(M1<? extends I>)
				----------
				2. ERROR in X.java (at line 34)
					public <J extends I> void mm(M1<J> q) {\s
					                          ^^^^^^^^^^^
				Name clash: The method mm(M1<J>) of type M2<I> has the same erasure as mm(M1<? extends H>) of type M1<H> but does not override it
				----------
				3. WARNING in X.java (at line 41)
					class XX            { public String toString() { return "XX"; } }\s
					                                    ^^^^^^^^^^
				The method toString() of type XX should be tagged with @Override since it actually overrides a superclass method
				----------
				4. WARNING in X.java (at line 42)
					class YY extends XX { public String toString() { return "YY"; } }\s
					                                    ^^^^^^^^^^
				The method toString() of type YY should be tagged with @Override since it actually overrides a superclass method
				----------
				5. WARNING in X.java (at line 43)
					class ZZ extends YY { public String toString() { return "ZZ"; } }\s
					                                    ^^^^^^^^^^
				The method toString() of type ZZ should be tagged with @Override since it actually overrides a superclass method
				----------
				""");
	}
	// cannot allocate parameterized type with wildcards
	public void test0398() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
					    X(){
					    }
					    public static void main(String[] args) {
							new X<?>();
							new X<? extends String>();
							new X<?>(){};
							new X<? extends String>(){};
						}
					}
					"""	,
			},
			"""
				----------
				1. ERROR in X.java (at line 5)
					new X<?>();
					    ^
				Cannot instantiate the type X<?>
				----------
				2. ERROR in X.java (at line 6)
					new X<? extends String>();
					    ^
				Cannot instantiate the type X<? extends String>
				----------
				3. ERROR in X.java (at line 7)
					new X<?>(){};
					    ^
				The type new X(){} cannot extend or implement X<?>. A supertype may not specify any wildcard
				----------
				4. ERROR in X.java (at line 8)
					new X<? extends String>(){};
					    ^
				The type new X(){} cannot extend or implement X<? extends String>. A supertype may not specify any wildcard
				----------
				""");
	}

	public void test0399() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
					    T t;
					    X(T t){
					        this.t = t;
					    }
					    public static void main(String[] args) {
							X<? extends AX> x = new X<AX<Math>>(new AX<String>());
						}
					}
					
					class AX<P> {
					    P foo() { return null; }
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 7)
					X<? extends AX> x = new X<AX<Math>>(new AX<String>());
					            ^^
				AX is a raw type. References to generic type AX<P> should be parameterized
				----------
				2. ERROR in X.java (at line 7)
					X<? extends AX> x = new X<AX<Math>>(new AX<String>());
					                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				The constructor X<AX<Math>>(AX<String>) is undefined
				----------
				""");
	}

	public void test0400() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
					    T t;
					    X(X<? extends T> xt){
					        this.t = xt.t;
					    }
					    public static void main(String[] args) {
							X<? extends AX> x = new X<AX<Math>>(new X<AX<String>>(null));
						}
					}
					class AX<P> {
					    P foo() { return null; }
					}""",
			},
			"""
				----------
				1. WARNING in X.java (at line 7)
					X<? extends AX> x = new X<AX<Math>>(new X<AX<String>>(null));
					            ^^
				AX is a raw type. References to generic type AX<P> should be parameterized
				----------
				2. ERROR in X.java (at line 7)
					X<? extends AX> x = new X<AX<Math>>(new X<AX<String>>(null));
					                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				The constructor X<AX<Math>>(X<AX<String>>) is undefined
				----------
				""");
	}

	// legal to allocate/inherit from a type with wildcards, as long as non direct arguments
	public void test0401() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
						void foo() {
							new X<X<?>>();
							new X<X<? extends String>>();
							new X<X<?>>(){};
							new X<X<? extends String>>(){};
						}
					}""",
			},
			"");
	}

	// legal to inherit from a type with wildcards, as long as non direct arguments
	public void test0402() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X extends Y<Y<?>> {
					}
					class Y<T> {}""",
			},
			"");
	}
	// check cast between generic types
	public void test0403() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
					\t
						void foo(X<X<? extends String>> xs) {
							X<X<String>> x = (X<X<String>>) xs;
							Zork z;
						}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					X<X<String>> x = (X<X<String>>) xs;
					                 ^^^^^^^^^^^^^^^^^
				Cannot cast from X<X<? extends String>> to X<X<String>>
				----------
				2. ERROR in X.java (at line 5)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}

	// check cast between generic types
	public void test0404() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <T> {
					\t
						void foo(X<? extends String> xs) {
							X<String> x = (X<String>) xs;
							Zork z;
						}
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 4)
					X<String> x = (X<String>) xs;
					              ^^^^^^^^^^^^^^
				Type safety: Unchecked cast from X<capture#1-of ? extends String> to X<String>
				----------
				2. ERROR in X.java (at line 5)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}

	// check cast between generic types
	public void test0405() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X <E> {
					\t
						<T> void foo(X<X<T>> xs) {
							X<X<String>> x = (X<X<String>>) xs;
						}
						<T> void bar(X<T> xs) {
							X<String> x = (X<String>) xs;
						}\t
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					X<X<String>> x = (X<X<String>>) xs;
					                 ^^^^^^^^^^^^^^^^^
				Cannot cast from X<X<T>> to X<X<String>>
				----------
				2. WARNING in X.java (at line 7)
					X<String> x = (X<String>) xs;
					              ^^^^^^^^^^^^^^
				Type safety: Unchecked cast from X<T> to X<String>
				----------
				""");
	}

	public void test0406() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public abstract class X<K1,V1> implements M<K1,V1> {
						abstract M<K1,V1> other();
						public S<E<K1,V1>> entrySet() {
							return other().entrySet();
						}
					}
					interface M<K2,V2> {
						 interface E<K3,V3> { }
						 S<E<K2, V2>> entrySet();
					}
					interface S<T> {}""",
			},
			"");
	}

	public void test0407() {
		this.runConformTest(
			new String[] {
				"X.java",
				"public abstract class X<K1,V1> implements M<K1,V1> {\n" +
				"	abstract M<K1,V1> other();\n" +
				"	public S<M.E<K1,V1>> entrySet() {\n" + // qualified M.E...
				"		return other().entrySet();\n" +
				"	}\n" +
				"}\n" +
				"interface M<K2,V2> {\n" +
				"	 interface E<K3,V3> { }\n" +
				"	 S<E<K2, V2>> entrySet();\n" +
				"}\n" +
				"interface S<T> {}",
			},
			"");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=78008
	public void test0408() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					public class X {
					    public Integer[] getTypes() {
					        List<Integer> list = new ArrayList<Integer>();
					        return list == null\s
					            ? new Integer[0]\s
					            : list.toArray(new Integer[list.size()]);
					    }
					    public static void main(String[] args) {
					        Class clazz = null;
					        try {
					            clazz = Class.forName("X");
					    	     System.out.println("SUCCESS");
					        } catch (Throwable e) {
					            e.printStackTrace();
					        }
					    }
					}""",
			},
			"SUCCESS");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=78008
	public void test0409() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					public class X {
					    public Number getTypes() {
					        List<Integer> list = new ArrayList<Integer>();
					        return list == null\s
					            ? Float.valueOf(0)
					            : list.get(0);
					    }
					    public static void main(String[] args) {
					        Class clazz = null;
					        try {
					            clazz = Class.forName("X");
					    	     System.out.println("SUCCESS");
					        } catch (Throwable e) {
					            e.printStackTrace();
					        }
					    }
					}""",
			},
			"SUCCESS");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=74178
	public void test0410() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.List;
					
					public class X {
					
					public void write(List<? super Exception> list) {
					\t
					  list.add(new RuntimeException());             // works
					  list.add(new IllegalMonitorStateException()); // works
					  Exception exc = new Exception();
					  list.add(exc);                                // works
					  list.add(new Object());                       // should fail
					  list.add(new Throwable());                    // should fail
					  list.add(new Exception());                    // works
					}
					}""",
			},
			"""
				----------
				1. ERROR in X.java (at line 11)
					list.add(new Object());                       // should fail
					     ^^^
				The method add(capture#4-of ? super Exception) in the type List<capture#4-of ? super Exception> is not applicable for the arguments (Object)
				----------
				2. ERROR in X.java (at line 12)
					list.add(new Throwable());                    // should fail
					     ^^^
				The method add(capture#5-of ? super Exception) in the type List<capture#5-of ? super Exception> is not applicable for the arguments (Throwable)
				----------
				""");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=78015
	public void test0411() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					interface I<T> {
					    void m1(T t);
					    void m2(T t);
					}
					
					class A {};
					
					class B implements I<A> {
					    public void m1(A a) {
					    	System.out.println("SUCCESS");
					    }
					    public void m2(A a) {}
					}
					
					public class X {
					    public static void main(String[] args) {
					        m(new B());
					    }
					
					    public static void m(I<A> x) {
					        x.m1(null);
					    }
					}""",
			},
			"SUCCESS");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=78467
	public void test0412() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					
					    public static <T> T first(T... args) {
					        return args[0];
					    }
					   \s
					    public static void main(String[] args) {
					    	if (false) {\s
					    		String s = first();\s
					    		int i;\s
					    		i++;\s
					    	}
					        System.out.println(first("SUCCESS", "List"));
					    }
					   Zork z;
					}""",
			},
			this.complianceLevel < ClassFileConstants.JDK1_7 ?
			"""
				----------
				1. ERROR in X.java (at line 15)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""" :
				"""
					----------
					1. WARNING in X.java (at line 3)
						public static <T> T first(T... args) {
						                               ^^^^
					Type safety: Potential heap pollution via varargs parameter args
					----------
					2. ERROR in X.java (at line 15)
						Zork z;
						^^^^
					Zork cannot be resolved to a type
					----------
					""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=78467 - variation
	public void test0412a() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					public class X {
					
					    public static <T> T first(T... args) {
					        return args[0];
					    }
					   \s
					    public static void main(String[] args) {
					    	if (false) {\s
					    		List<String> ls = first();\s
					    		int i;\s
					    		i++;\s
					    	}
					        System.out.println(first("SUCCESS", "List"));
					    }
					   Zork z;
					}""",
			},
			this.complianceLevel < ClassFileConstants.JDK1_7 ?
			"""
				----------
				1. WARNING in X.java (at line 10)
					List<String> ls = first();\s
					                  ^^^^^^^
				Type safety: A generic array of List<String> is created for a varargs parameter
				----------
				2. ERROR in X.java (at line 16)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""" :
				"""
					----------
					1. WARNING in X.java (at line 4)
						public static <T> T first(T... args) {
						                               ^^^^
					Type safety: Potential heap pollution via varargs parameter args
					----------
					2. WARNING in X.java (at line 10)
						List<String> ls = first();\s
						                  ^^^^^^^
					Type safety: A generic array of List<String> is created for a varargs parameter
					----------
					3. ERROR in X.java (at line 16)
						Zork z;
						^^^^
					Zork cannot be resolved to a type
					----------
					""");
	}

	public void test0413() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
						static class TLM {
						}
					    TLM getMap(TL t) {
					        return t.tls;
					    }
					    static TLM createInheritedMap(TLM parentMap) {
					        return new TLM();
					    } \s
					}
					
					class TL {
					   X.TLM tls = null;
					}""",
			},
			"");
	}

	public void test0414() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
						void foo(L l, C<? super X> c) {
							bar(l, c);
						}
						<T> void bar(L<T> l, C<? super T> c) {\s
						}\t
					}
					class C<E> {}
					class L<E> {}""",
			},
			"");
	}

	public void test0415() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					    public S<M.E<Object,Object>> foo(HM hm) {
							return C.bar(hm).foo();
					    }
					}
					class C {
					    public static <K,V> M<K,V> bar(M<? extends K,? extends V> m) {
							return null;
					    }
					}
					class S<E> {
					}
					abstract class HM<U,V> implements M<U,V>{
					}
					interface M<A,B> {
						static class E<S,T> {}
						S<E<A,B>> foo();\t
					}""",
			},
			"");
	}

	public void test0416() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					    public S<M.E<Object,String>> foo(HM hm) {
					    	M<Object, String> m = C.bar(hm);
					    	if (false) return m.foo();
							return C.bar(hm).foo();
					    }
					}
					class C {
					    public static <K,V> M<K,V> bar(M<? extends K,? extends V> m) {
							return null;
					    }
					}
					class S<E> {
					}
					abstract class HM<U,V> implements M<U,V>{
					}
					interface M<A,B> {
						static class E<S,T> {}
						S<E<A,B>> foo();\t
					}""",
			},
			"");
	}

	public void test0417() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<E> {
					\t
						<T> X<T> foo(X<T> xt) {
							return null;
						}
						X<E> identity() {
							return this;
						}
						void bar(X x) {
							X<String> xs = foo(x).identity();
						}
					}
					""",
			},
			"");
	}

	public void test0418() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<E> {
					\t
						<T> X<T> foo(X<T> xt, X<T> xt2) {
							return null;
						}
						X<E> identity() {
							return this;
						}
						void bar(X x, X<String> xs) {
							X<String> xs2 = foo(x, xs).identity();
						}
					}
					""",
			},
			"");
	}

	public void test0419() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<E> {
					\t
						<T,U> X<T> foo(X<T> xt, X<U> xt2) {
							return null;
						}
						X<E> identity() {
							return this;
						}
						void bar(X x, X<String> xs) {
							X<String> xs2 = foo(x, xs).identity();
						}
					}
					""",
			},
			"");
	}

	public void test0420() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<E> {
					\t
						<T,U> X<U> foo(X<T> xt, X<U> xt2) {
							return null;
						}
						X<E> identity() {
							return this;
						}
						void bar(X x, X<String> xs) {
							X<String> xs2 = foo(x, xs).identity();
						}
					}
					""",
			},
			"");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=78863
	public void test0421() {
		this.runConformTest(
			new String[] {
				"Test.java",
				"""
					import java.util.HashMap;
					import java.util.List;
					import java.util.Map;
					
					public class Test
					{
					  protected Map<Class<? extends Object>, List<Object>> m_test
					    = new HashMap<Class<? extends Object>, List<Object>>();
					}
					""",
				"Test2.java",
				"""
					import java.util.List;
					import java.util.Map;
					
					public class Test2 extends Test
					{
					  public Map<Class<? extends Object>, List<Object>> test()
					  {
					    return m_test;
					  }
					}
					""",
			},
			"");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=78704
	public void test0422() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
						String foo() {
							return new X();
						}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					return new X();
					       ^^^^^^^
				Type mismatch: cannot convert from X to String
				----------
				2. WARNING in X.java (at line 3)
					return new X();
					           ^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				""");
	}

	public void test0423() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					
					    static <T extends X> T bar() {
					        return null;
					    }
					    static <U extends X&Runnable> U foo() {
					        return null;
					    }
					
					    public static void main(String argv[]) {
					    	bar();
					        foo();
					    }
					
					}""",
			},
			"");
	}

	public void test0424() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					\t
						<T extends A> T foo(T t) {
							return t;
						}
						public static void main(String[] args) {
							new X().bar();
						}
						void bar() {
							B b = foo(new B());
						}
					}
					
					class A {}
					class B extends A {}
					
					""",
			},
		"");
	}

	// check tiebreak eliminates related generic methods which are less specific
	public void test0425() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.io.IOException;
					
					public class X {
					    static <E extends A> void m(E e) { System.out.println("A:"+e.getClass()); }
					    static <F extends B> void m(F f) throws Exception { System.out.println("B:"+f.getClass()); }
					    static <G extends C> void m(G g) throws IOException { System.out.println("C:"+g.getClass()); }
					
					    public static void main(String[] args) {
					        m(new A());
					        m(new B());
					        m(new C());
					    }
					}
					
					class A {}
					class B extends A {}
					class C extends A {}
					
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 10)
					m(new B());
					^^^^^^^^^^
				Unhandled exception type Exception
				----------
				2. ERROR in X.java (at line 11)
					m(new C());
					^^^^^^^^^^
				Unhandled exception type IOException
				----------
				""");
	}

	// check inferred return types are truly based on arguments, and not on parameter erasures
	public void test0426() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					    static <E extends A> E m(E e) { System.out.print("[A:"+e.getClass()+"]"); return e; }
					
					    public static void main(String[] args) {
					        A a = m(new A());
					        B b = m(new B());
					        C c = m(new C());
					    }
					}
					
					class A {}
					class B extends A {}
					class C extends A {}
					""",
			},
			"[A:class A][A:class B][A:class C]");
	}

	// check inferred return types are truly based on arguments, and not on parameter erasures
	public void test0427() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					    static <E extends A> E m(E e, E... e2) { System.out.print("[A:"+e.getClass()+"]"); return e; }
					    static <F extends B> F m(F f, F... f2) { System.out.print("[B:"+f.getClass()+"]"); return f; }
					    static <G extends C> G m(G g, G... g2) { System.out.print("[C:"+g.getClass()+"]"); return g; }
					
					    public static void main(String[] args) {
					        A a = m(new A(), new A());
					        B b = m(new B(), new B());
					        C c = m(new C(), new C());
					    }
					}
					
					class A {}
					class B extends A {}
					class C extends A {}
					""",
			},
			"[A:class A][B:class B][C:class C]");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=79390
	public void test0428() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					   Zork z;
						public static void foo() {
							class A<T extends Number> {
								T t = null;
								T get() {
									return t;
								}
							}
							A<Long> a = new A<Long>() {
								@Override
								Long get() {
									return Long.valueOf(5);
								}
							};
						}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=78293
	public void test0429() {
		this.runConformTest(
			new String[] {
				"X1.java",
				"class X1 <T extends Y & Comparable<Y>> {}\n" +
				"abstract class Y implements Comparable<Y> {}",
			},
			""
		);
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=78293
	public void test0429a() {
		this.runConformTest(
			new String[] {
				"X2.java",
				"""
					class X2 <T extends Y & Comparable<Y>> {}
					abstract class Y extends Z {}
					abstract class Z implements Comparable<Y> {}""",
			},
			""
		);
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=78293
	public void test0429b() {
		this.runConformTest(
			new String[] {
				"X3.java",
				"""
					class X3 <T extends Y & Comparable<Z>> {}
					abstract class Y extends Z {}
					abstract class Z implements Comparable<Z> {}""",
			},
			""
		);
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=78293
	public void test0429c() {
		runNegativeTest(
			// test directory preparation
			new String[] { /* test files */
				"X4.java",
				"""
					class X4 <T extends Comparable<Z> & Comparable<Z>> {}
					abstract class Y extends Z {}
					abstract class Z implements Comparable<Z> {}""",
			},
			// compiler results
			"----------\n" + /* expected compiler log */
			"1. ERROR in X4.java (at line 1)\n" +
			"	class X4 <T extends Comparable<Z> & Comparable<Z>> {}\n" +
			"	                                    ^^^^^^^^^^\n" +
			"Duplicate bound Comparable<Z>\n" +
			"----------\n",
				// no complaints about duplicates if they are both parameterized with same args
				// but you cannot extend Comparable & Comparable so we'll report an error
			// javac options
			JavacTestOptions.JavacHasABug.JavacBugFixed_7 /* javac test options */);
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=78293
	public void test0429d() {
		this.runNegativeTest(
			new String[] {
				"X5.java",
				"class X5 <T extends Y & Comparable<X5>> {}\n" +
				"abstract class Y implements Comparable<Y> {}",
			},
			"""
				----------
				1. ERROR in X5.java (at line 1)
					class X5 <T extends Y & Comparable<X5>> {}
					                        ^^^^^^^^^^
				The interface Comparable cannot be implemented more than once with different arguments: Comparable<X5> and Comparable<Y>
				----------
				2. WARNING in X5.java (at line 1)
					class X5 <T extends Y & Comparable<X5>> {}
					                                   ^^
				X5 is a raw type. References to generic type X5<T> should be parameterized
				----------
				"""
		);
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=78293
	public void test0429e() {
		this.runNegativeTest(
			new String[] {
				"X6.java",
				"""
					class X6 <T extends Y & Comparable<X6>> {}
					abstract class Y extends Z {}
					abstract class Z implements Comparable<Z> {}""",
			},
			"""
				----------
				1. ERROR in X6.java (at line 1)
					class X6 <T extends Y & Comparable<X6>> {}
					                        ^^^^^^^^^^
				The interface Comparable cannot be implemented more than once with different arguments: Comparable<X6> and Comparable<Z>
				----------
				2. WARNING in X6.java (at line 1)
					class X6 <T extends Y & Comparable<X6>> {}
					                                   ^^
				X6 is a raw type. References to generic type X6<T> should be parameterized
				----------
				"""
		);
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=78293
	public void test0429f() {
		this.runNegativeTest(
			new String[] {
				"X7.java",
				"""
					class X7 <T extends Comparable<Z> & Comparable<X7>> {}
					abstract class Y extends Z {}
					abstract class Z implements Comparable<Z> {}""",
			},
			"""
				----------
				1. ERROR in X7.java (at line 1)
					class X7 <T extends Comparable<Z> & Comparable<X7>> {}
					                                    ^^^^^^^^^^
				The interface Comparable cannot be implemented more than once with different arguments: Comparable<X7> and Comparable<Z>
				----------
				2. WARNING in X7.java (at line 1)
					class X7 <T extends Comparable<Z> & Comparable<X7>> {}
					                                               ^^
				X7 is a raw type. References to generic type X7<T> should be parameterized
				----------
				"""
		);
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=78293
	public void test0429g() {
		this.runNegativeTest(new String[] {
				"X.java",
				"""
					interface I<T> {}
					
					class A implements I<A>, I<A> {}
					public class X<E extends A & I<E> & I<E>>  {
					}"""
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					class A implements I<A>, I<A> {}
					                         ^
				Duplicate interface I<A> for the type A
				----------
				2. ERROR in X.java (at line 4)
					public class X<E extends A & I<E> & I<E>>  {
					                             ^
				The interface I cannot be implemented more than once with different arguments: I<E> and I<A>
				----------
				3. ERROR in X.java (at line 4)
					public class X<E extends A & I<E> & I<E>>  {
					                                    ^
				Duplicate bound I<E>
				----------
				""");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=79797
	public void test0430() {
		this.runConformTest(
			new String[] {
				"p/MMM.java",
				"package p;\n" +
				"public interface MMM< F extends MMM<F,G>, G extends NNN> { } \n",
				"p/NNN.java",
				"package p;\n" +
				"public interface NNN { } \n",
			},
			"");

		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import p.MMM;
					import p.NNN;
					
					interface RRR< A extends MMM<A, B>, B extends NNN> {}
					
					class J1 implements MMM<J1, J2> { }
					class J2 implements NNN { }
					
					class J3 implements RRR<J1,J2> {}\s
					
					public class X {
					  public static void main(String[] args) {
					    J3 thing = null;
					  }
					}
					""",
			},
			"",
			null,
			false, // do not flush output
			null);
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=79891
	public void test0431() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<Type> {
					  private class Element {
					  }
					  public X() {
					    Element[] eArray = new Element[10];
					  }
					}
					""",
			},
		"""
			----------
			1. ERROR in X.java (at line 5)
				Element[] eArray = new Element[10];
				                   ^^^^^^^^^^^^^^^
			Cannot create a generic array of X<Type>.Element
			----------
			""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=79891
	public void test0432() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<Type> {
					  private static class Element {
					  }
					  public X() {
					    Element[] eArray = new Element[10];
					  }
					}
					""",
			},
		"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=80144
	public void test0433() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					
					interface Alpha<
						A1 extends Alpha<A1, B1>,\s
						B1 extends Beta<A1, B1>> {
					}
					interface Beta<
						A2 extends Alpha<A2, B2>,\s
						B2 extends Beta<A2, B2>> {
					}
					interface Phi<
						A3 extends Alpha<A3, B3>,\s
						B3 extends Beta<A3, B3>> {
					\t
						public void latinize(A3 s);
					}
					
					public class X<
						A extends Alpha<A, B>,\s
						B extends Beta<A, B>,\s
						P extends Phi<A, B>> extends ArrayList<P> implements Phi<A, B> {
					\t
						public final void latinize(A a) {
							frenchify(this, a); // (X<A,B,P>, A)
						}
						// -----------------------------------------------------------------
						public static final <AA extends Alpha<AA, BB>, BB extends Beta<AA, BB>>\s
						void frenchify(Collection< ? extends Phi<AA, BB>> phis, AA aa) {
							for (final Phi<AA, BB> phi : phis)
								phi.latinize(aa);
						}
					}
					""",
			},
		"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=80083
	public void test0434() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.ArrayList;
					
					public class X
					{
					
					  public static void main(String[] args)
					  {
					    ArrayList<String> l = new ArrayList<String>();
					    l.add("x");
					    String s = "";
					    s += l.get(0); // X
					    System.out.println("SUCCESS");
					  }
					
					}
					""",
			},
		"SUCCESS");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=80765
	public void test0435() {
		this.runNegativeTest(
			new String[] {
				"Test.java",//===============================
				"""
					import java.lang.reflect.InvocationTargetException;
					import java.lang.reflect.Method;
					
					import orders.DiscreteOrder;
					import orders.impl.IntegerOrder;
					import orders.impl.IntegerOrder2;
					
					public class Test {
					
					    public static void main(String[] args) throws SecurityException,
					            NoSuchMethodException, IllegalArgumentException,
					            IllegalAccessException {
					        Test test = new Test();
					
					        for (String method : new String[] { "test01", "test02", "test03", "test04" }) {
					            Method m = test.getClass().getMethod(method);
					            try {
					                m.invoke(test);
					                System.out.print("*** " + m + ": success");
					            } catch (InvocationTargetException e) {
					                System.out.print("*** " + m + ": failed, stacktrace follows");
					                e.getCause().printStackTrace(System.out);
					            }
					        }
					    }
					
					    public void test01() { // works
					        new IntegerOrder().next(Integer.valueOf(0)); // works
					    }
					
					    public void test02() { // doesn't work
					        final DiscreteOrder<Integer> order = new IntegerOrder();
					        order.next(Integer.valueOf(0));
					    }
					
					    public void test03() { // works
					        new IntegerOrder2().next(Integer.valueOf(0)); // works
					    }
					
					    public void test04() { // doesn't work
					        final DiscreteOrder<Integer> order = new IntegerOrder2();
					        order.next(Integer.valueOf(0));
					    }
					}
					""",
				"orders/DiscreteOrder.java",//===============================
				"""
					package orders;
					public interface DiscreteOrder<E extends Comparable<E>> {
					    /**
					     * @return The element immediately before <code>element</code> in the
					     *         discrete ordered space.
					     */
					    public E previous(E element);
					    /**
					     * @return The element immediately after <code>element</code> in the
					     *         discrete ordered space.
					     */
					    public E next(E element);
					}
					""",
				"orders/impl/IntegerOrder.java",//===============================
				"""
					package orders.impl;
					import orders.DiscreteOrder;
					
					public class IntegerOrder implements DiscreteOrder<Integer> {
					
					    public IntegerOrder() {
					        super();
					    }
					
					    public Integer previous(Integer arg0) {
					        return Integer.valueOf(arg0.intValue() - 1);
					    }
					
					    public Integer next(Integer arg0) {
					        return Integer.valueOf(arg0.intValue() + 1);
					    }
					}
					""",
				"orders/impl/IntegerOrder2.java",//===============================
				"""
					package orders.impl;
					
					
					public class IntegerOrder2 extends IntegerOrder {
					
					    public IntegerOrder2() {
					        super();
					    }
					
					    public Comparable previous(Comparable arg0) {
					        return previous((Integer) arg0);
					    }
					
					    public Comparable next(Comparable arg0) {
					        return next((Integer) arg0);
					    }
					
					}
					""",
			},
			"""
				----------
				1. WARNING in orders\\impl\\IntegerOrder2.java (at line 10)
					public Comparable previous(Comparable arg0) {
					       ^^^^^^^^^^
				Comparable is a raw type. References to generic type Comparable<T> should be parameterized
				----------
				2. ERROR in orders\\impl\\IntegerOrder2.java (at line 10)
					public Comparable previous(Comparable arg0) {
					                  ^^^^^^^^^^^^^^^^^^^^^^^^^
				Name clash: The method previous(Comparable) of type IntegerOrder2 has the same erasure as previous(E) of type DiscreteOrder<E> but does not override it
				----------
				3. WARNING in orders\\impl\\IntegerOrder2.java (at line 10)
					public Comparable previous(Comparable arg0) {
					                           ^^^^^^^^^^
				Comparable is a raw type. References to generic type Comparable<T> should be parameterized
				----------
				4. WARNING in orders\\impl\\IntegerOrder2.java (at line 14)
					public Comparable next(Comparable arg0) {
					       ^^^^^^^^^^
				Comparable is a raw type. References to generic type Comparable<T> should be parameterized
				----------
				5. ERROR in orders\\impl\\IntegerOrder2.java (at line 14)
					public Comparable next(Comparable arg0) {
					                  ^^^^^^^^^^^^^^^^^^^^^
				Name clash: The method next(Comparable) of type IntegerOrder2 has the same erasure as next(E) of type DiscreteOrder<E> but does not override it
				----------
				6. WARNING in orders\\impl\\IntegerOrder2.java (at line 14)
					public Comparable next(Comparable arg0) {
					                       ^^^^^^^^^^
				Comparable is a raw type. References to generic type Comparable<T> should be parameterized
				----------
				"""
		);
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=80028
	public void test0436() {
		this.runConformTest(
			new String[] {
				"A.java",
				"""
					public class A {
						public static void main(String[] args) {
							Number n= new Integer(1);
							X x = new X<Number>();
							x.m(n);
							x.m(new Integer(2));
							Y y= new Y();
							y.m(n);
							y.m(new Integer(2));
						}
					}
					""",
				"X.java",
				"""
					class X<T> {
						public void m(Number num) { System.out.print("X.m(Number) = " + num + ','); }
						public void m(T t) { System.out.print("X.m(T) = " + t + ','); }
					}
					""",
				"Y.java",
				"""
					class Y extends X<Number> {
						public void m(Number num) { System.out.print("Y.m(Number) = " + num + ','); }
					}
					""",
			},
		"X.m(Number) = 1,X.m(Number) = 2,Y.m(Number) = 1,Y.m(Number) = 2,");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=80028
	public void test0437() {
		this.runConformTest(
			new String[] {
				"A.java",
				"""
					public class A {
						public static void main(String[] args) {
							Number n= new Integer(1);
							X x = new X<Number>();
							x.m(n);
							x.m(new Integer(2));
							Y y= new Y();
							y.m(n);
							y.m(new Integer(2));
						}
					}
					""",
				"X.java",
				"""
					class X<T> {
						public void m(Number num) { System.out.print("X.m(Number) = " + num + ','); }
						public void m(T t) { System.out.print("X.m(T) = " + t + ','); }
					}
					""",
				"Y.java",
				"""
					class Y extends X<Number> {
						public void m(Number num) { System.out.print("Y.m(Number) = " + num + ','); }
					}
					""",
			},
		"X.m(Number) = 1,X.m(Number) = 2,Y.m(Number) = 1,Y.m(Number) = 2,");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=78591
	public void test0438() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.List;
					public class X<T> {
					    Zork z;
					    List<T> list;
					    void add(Object abs) {
					        list.add((T) list.get(0)); // checked cast
					        list.add((T) abs); // unchecked cast
					    }
					    void bar(List<? extends T> other) {
					    	list.add((T) other.get(0)); // checked cast
					    }
					    void baz(List<? super T> other) {
					    	list.add((T) other.get(0)); // unchecked cast
					    }
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				2. WARNING in X.java (at line 6)
					list.add((T) list.get(0)); // checked cast
					         ^^^^^^^^^^^^^^^
				Unnecessary cast from T to T
				----------
				3. WARNING in X.java (at line 7)
					list.add((T) abs); // unchecked cast
					         ^^^^^^^
				Type safety: Unchecked cast from Object to T
				----------
				4. WARNING in X.java (at line 10)
					list.add((T) other.get(0)); // checked cast
					         ^^^^^^^^^^^^^^^^
				Unnecessary cast from capture#1-of ? extends T to T
				----------
				5. WARNING in X.java (at line 13)
					list.add((T) other.get(0)); // unchecked cast
					         ^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from capture#2-of ? super T to T
				----------
				""");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=78592
	public void test0439() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					class Node {
					}
					class Composite<E> {
					}
					class Concrete extends Composite {
					}
					public class X {
					    Composite<Node> comp = new Concrete(); // unchecked cast
					    Zork z;
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 5)
					class Concrete extends Composite {
					                       ^^^^^^^^^
				Composite is a raw type. References to generic type Composite<E> should be parameterized
				----------
				2. WARNING in X.java (at line 8)
					Composite<Node> comp = new Concrete(); // unchecked cast
					                       ^^^^^^^^^^^^^^
				Type safety: The expression of type Concrete needs unchecked conversion to conform to Composite<Node>
				----------
				3. ERROR in X.java (at line 9)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}

	public void test0440() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
						class Y<U> {
							public void foo(X<T> xt) {
								U u = (U) xt;
							}
						}
					  Zork z;
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 4)
					U u = (U) xt;
					      ^^^^^^
				Type safety: Unchecked cast from X<T> to U
				----------
				2. ERROR in X.java (at line 7)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}

	public void test0441() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T extends Number> {
					    T[] array;
					    X(int s) {
					        array = (T[]) new Number[s];   // Unnecessary cast from Number[] to T[]
					        array = new Number[s];   // Type mismatch: cannot convert from Number[] to T[]
					     }
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 4)
					array = (T[]) new Number[s];   // Unnecessary cast from Number[] to T[]
					        ^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Number[] to T[]
				----------
				2. ERROR in X.java (at line 5)
					array = new Number[s];   // Type mismatch: cannot convert from Number[] to T[]
					        ^^^^^^^^^^^^^
				Type mismatch: cannot convert from Number[] to T[]
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=82053
	public void test0442() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					class Foo {
						public interface Model {
						}
						public interface View<M extends Model> {
							M getTarget() ;
						}
					}
					class Bar {
						public interface Model extends Foo.Model {
						}
						public interface View<M extends Model> extends Foo.View<M> {
						}
					}
					public class X {
						public void baz() {
							Bar.View<?> bv = null ;
							Bar.Model m = bv.getTarget() ;
						}
					}
					""",
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=81757
	public void test0443() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.Iterator;
					public class X implements Iterator<String> {
					    public boolean hasNext() { return false; }
					    public String next() { return null; }
					    public void remove() {}
					}
					""",
			},
			"");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=81824
	public void test0444() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"public class X implements I<Integer>, I<String> {}\n" +
				"interface I<T> {}\n"
			},
			"""
				----------
				1. ERROR in X.java (at line 1)
					public class X implements I<Integer>, I<String> {}
					             ^
				The interface I cannot be implemented more than once with different arguments: I<String> and I<Integer>
				----------
				""");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=78810
	public void test0445() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public abstract class X {
					    public abstract Object getProperty(final Object src, final String name);
					    Zork z;
					    public <T> T getTheProperty(final Object src, final String name)
					    {
					        final T val = (T) getProperty(src, name); // this gives erroneous cast warning
					        return val;
					    }
					}
					"""	,
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				2. WARNING in X.java (at line 6)
					final T val = (T) getProperty(src, name); // this gives erroneous cast warning
					              ^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Object to T
				----------
				""");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=82159
	public void test0446() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<A> {
					  class Inner<B> { }
					
					  void method() {
					    X<String>.Inner<Integer> a= new X<String>().new Inner<Integer>();
					    Inner<Integer> b= new X<A>().new Inner<Integer>();
					    Inner<Integer> c= new Inner<Integer>();
					    // OK
					
					    X<String>.Inner<Integer> d= new X<String>.Inner<Integer>();
					    //eclipse: OK
					    //other: error: '(' or '[' expected
					
					    X<A>.Inner<Integer> e= new X<A>().new Inner<Integer>();
					    X<A>.Inner<Integer> f= new Inner<Integer>();
					    e= b;
					    f= c;
					    //other: OK
					    //eclipse: Type mismatch: cannot convert from X<A>.Inner<Integer> to X<A>.Inner<Integer>
					
					  }
					}
					
					class External {
					  void m() {
					    X<String>.Inner<Integer> x= new X<String>().new Inner<Integer>();
					    // OK
					  }
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 10)
					X<String>.Inner<Integer> d= new X<String>.Inner<Integer>();
					                                ^^^^^^^^^^^^^^^
				Cannot allocate the member type X<String>.Inner<Integer> using a parameterized compound name; use its simple name and an enclosing instance of type X<String>
				----------
				""",
			JavacTestOptions.EclipseHasABug.EclipseBug236243);
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=82159 - variation
	public void test0447() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<A> {
					  class Inner<B> { }
					
					  void method() {
					    X<String>.Inner<Integer> d1 = new X<String>.Inner<Integer>();
					    X.Inner d2 = new X.Inner();
					    X.Inner<Integer> d3 = new X.Inner<Integer>();
					    d1 = d2;
					    d2 = d1;
					    d1 = d3;
					    d3 = d1;
					    d2 = d3;
					    d3 = d2;
					
					  }
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 5)
					X<String>.Inner<Integer> d1 = new X<String>.Inner<Integer>();
					                                  ^^^^^^^^^^^^^^^
				Cannot allocate the member type X<String>.Inner<Integer> using a parameterized compound name; use its simple name and an enclosing instance of type X<String>
				----------
				2. WARNING in X.java (at line 6)
					X.Inner d2 = new X.Inner();
					^^^^^^^
				X.Inner is a raw type. References to generic type X<A>.Inner<B> should be parameterized
				----------
				3. WARNING in X.java (at line 6)
					X.Inner d2 = new X.Inner();
					                 ^^^^^^^
				X.Inner is a raw type. References to generic type X<A>.Inner<B> should be parameterized
				----------
				4. ERROR in X.java (at line 7)
					X.Inner<Integer> d3 = new X.Inner<Integer>();
					^^^^^^^
				The member type X.Inner<Integer> must be qualified with a parameterized type, since it is not static
				----------
				5. ERROR in X.java (at line 7)
					X.Inner<Integer> d3 = new X.Inner<Integer>();
					                          ^^^^^^^
				The member type X.Inner<Integer> must be qualified with a parameterized type, since it is not static
				----------
				6. WARNING in X.java (at line 8)
					d1 = d2;
					     ^^
				Type safety: The expression of type X.Inner needs unchecked conversion to conform to X<String>.Inner<Integer>
				----------
				7. ERROR in X.java (at line 10)
					d1 = d3;
					     ^^
				Type mismatch: cannot convert from X.Inner<Integer> to X<String>.Inner<Integer>
				----------
				8. ERROR in X.java (at line 11)
					d3 = d1;
					     ^^
				Type mismatch: cannot convert from X<String>.Inner<Integer> to X.Inner<Integer>
				----------
				9. WARNING in X.java (at line 13)
					d3 = d2;
					     ^^
				Type safety: The expression of type X.Inner needs unchecked conversion to conform to X.Inner<Integer>
				----------
				""");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=82159 - variation
	public void test0448() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<A> {
					  static class Inner<B> { }
					
					  void method() {
					    X.Inner<Integer> d = new X.Inner<Integer>();   \s
					  }
					}
					""",
			},
			"");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=82159 - variation
	public void test0448a() {
		runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				public class X<T> {
					class Y {}
					X<?>.Y[] tab = new X<?>.Y[] {};
				}"""
		},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_7 /* javac test options */);
	}


	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=82159 - variation
	public void test0449() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<A> {
					  class Inner<B> {\s
					  }
					
					  void method() {
					    X<String>.Inner<Integer> d4 = new X.Inner<Integer>();
					  }
					}
					""" ,
			},
			"""
				----------
				1. ERROR in X.java (at line 6)
					X<String>.Inner<Integer> d4 = new X.Inner<Integer>();
					                              ^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from X.Inner<Integer> to X<String>.Inner<Integer>
				----------
				2. ERROR in X.java (at line 6)
					X<String>.Inner<Integer> d4 = new X.Inner<Integer>();
					                                  ^^^^^^^
				The member type X.Inner<Integer> must be qualified with a parameterized type, since it is not static
				----------
				""");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=82159 - variation
	public void test0450() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<A> {
					  static class Inner<B> {\s
					  }
					
					  void method() {
					    X<String>.Inner<Integer> d4 = new X<String>.Inner<Integer>();
					  }
					}
					""" ,
			},
			"""
				----------
				1. ERROR in X.java (at line 6)
					X<String>.Inner<Integer> d4 = new X<String>.Inner<Integer>();
					^^^^^^^^^^^^^^^
				The member type X.Inner<B> cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X<String>
				----------
				2. ERROR in X.java (at line 6)
					X<String>.Inner<Integer> d4 = new X<String>.Inner<Integer>();
					                                  ^^^^^^^^^^^^^^^
				The member type X.Inner<B> cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X<String>
				----------
				""");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=82159 - variation
	public void test0451() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<A> {
					  class Inner<B> {\s
					  }
					
					  void method() {
					    X<String>.Inner<Integer> d4 = new X<String>.Inner<Integer>() {};
					  }
					}
					""" ,
			},
			"""
				----------
				1. ERROR in X.java (at line 6)
					X<String>.Inner<Integer> d4 = new X<String>.Inner<Integer>() {};
					                                  ^^^^^^^^^^^^^^^
				Cannot allocate the member type X<String>.Inner<Integer> using a parameterized compound name; use its simple name and an enclosing instance of type X<String>
				----------
				""",
			JavacTestOptions.EclipseHasABug.EclipseBug236243);
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=82187
	public void test0452() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					
					public class X {
					\t
						 public <E extends Object, S extends Collection<E>> S test01(S param){
						 	System.out.println("SUCCESS");
						 	return null;
						 }
						\s
						 public void test02() {
						 	test01(new Vector<String>());
						 }
					
						 public static void main(String[] args) {
							new X().test02();
						}
					}
					""" ,
			},
			"SUCCESS");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=82250
	public void test0453() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"public class X<T extends I & I> {}\n" +
				"interface I {}\n" ,
			},
			"""
				----------
				1. ERROR in X.java (at line 1)
					public class X<T extends I & I> {}
					                             ^
				Duplicate bound I
				----------
				"""
		);
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=82504
	public void test0454() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T, U extends X> {
						Object[] objectArr;
						void foo(T t) {
							T x1= (T) objectArr;
							U x2= (U) objectArr;
							int[] x= (int[]) t;
						}
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 1)
					public class X<T, U extends X> {
					                            ^
				X is a raw type. References to generic type X<T,U> should be parameterized
				----------
				2. WARNING in X.java (at line 4)
					T x1= (T) objectArr;
					      ^^^^^^^^^^^^^
				Type safety: Unchecked cast from Object[] to T
				----------
				3. ERROR in X.java (at line 5)
					U x2= (U) objectArr;
					      ^^^^^^^^^^^^^
				Cannot cast from Object[] to U
				----------
				""");
	}


	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=81719
	public void test0455() {
		this.runConformTest(
			new String[] {
				"AbstractTest.java",
				"""
					public abstract class AbstractTest<T> {
					  abstract void array(T[] a);
					  abstract void type(T a);
					  abstract T[] foo();
					}
					""",
			},
			"");

		this.runConformTest(
			new String[] {
				"Test.java",
				"""
					public class Test<T> extends AbstractTest<T> {
					  void array(T[] a) {}
					  void type(T a) {}
					  T[] foo() { return null; }
					}
					""",
			},
			"",
			null,
			false, // do not flush output
			null);
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=81721
	public void test0456() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					interface I<T> {
						<S extends T> void doTest(S[] a);
					}
					
					abstract class AbstractTest<U> implements I<U> {
						public <V extends U> void doTest(V[] a) {}
					}
					
					public class X<M> extends AbstractTest<M> {}
					""",
			},
			"");
	}

	public void test0457() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.List;
					
					public class X {
					\t
					 void add(List<? super X> l) {\s
					 	l.add(new X());\s
					 }
					 void add2(List<? extends X> l) {\s
					 	l.add(new X());\s
					 }
					\s
					 static <T> void add3(List<T> l, List<T> l2) {\s
					 }
					 public static void main(String[] args) {
						List<X> lx = null;
						List<String> ls = null;
						add3(lx, ls);
					 }\s
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 9)
					l.add(new X());\s
					  ^^^
				The method add(capture#2-of ? extends X) in the type List<capture#2-of ? extends X> is not applicable for the arguments (X)
				----------
				2. ERROR in X.java (at line 17)
					add3(lx, ls);
					^^^^
				The method add3(List<T>, List<T>) in the type X is not applicable for the arguments (List<X>, List<String>)
				----------
				""");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=82243
	public void test0458() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					interface A<E>{
						E getOne();
					}
					
					
					abstract class B<T extends Number> implements A<T> {
						Number getTwo() {
							return getOne(); // succeeds
						}
					}
					
					abstract class C extends B<Integer> {
					}
					
					public class X {
						void foo(A a, B b, C c){
							Object o= a.getOne();
							Number n1= b.getOne(); // fails
							Number n2= b.getTwo(); // succeeds, but inlining fails
							Integer i = c.getOne(); // succeeds
						}
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 16)
					void foo(A a, B b, C c){
					         ^
				A is a raw type. References to generic type A<E> should be parameterized
				----------
				2. WARNING in X.java (at line 16)
					void foo(A a, B b, C c){
					              ^
				B is a raw type. References to generic type B<T> should be parameterized
				----------
				3. ERROR in X.java (at line 18)
					Number n1= b.getOne(); // fails
					           ^^^^^^^^^^
				Type mismatch: cannot convert from Object to Number
				----------
				""");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=78027 - variation (check unchecked warnings)
	public void test0459() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X\s
					{
					Zork z;
					}
					
					interface ITest<C extends X>
					{\s
					}
					
					abstract class Test<C extends X> implements ITest<C>
					{
					  protected Manager<C> m_manager;
					 \s
					  public ITest<C> get()
					  {
					    return m_manager.getById(getClass(), Integer.valueOf(1));
					  }
					   \s
					  public static class Manager<C extends X>
					  {
					    public <T extends ITest<C>> T getById(Class<T> cls, Integer id)
					    {
					      return null;
					    }
					  }
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				2. WARNING in X.java (at line 16)
					return m_manager.getById(getClass(), Integer.valueOf(1));
					       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked invocation getById(Class<capture#1-of ? extends Test>, Integer) of the generic method getById(Class<T>, Integer) of type Test.Manager<C>
				----------
				3. WARNING in X.java (at line 16)
					return m_manager.getById(getClass(), Integer.valueOf(1));
					       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: The expression of type Test needs unchecked conversion to conform to ITest<C>
				----------
				""");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=82439
	public void test0460() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					
					public class X {
					
						public <E extends Object, S extends Collection<E>> S test(S param) {
						\t
							Class<? extends Collection> c = param.getClass(); // ok
							Class<? extends Collection> d = getClazz(); // ko
							return null;
						}
						Class<? extends Object> getClazz() {
							return null;
						}
					}
					abstract class Z implements Collection<String> {
						void foo() {
							Class<? extends Collection> c = getClass(); // ok
						}
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 7)
					Class<? extends Collection> c = param.getClass(); // ok
					                ^^^^^^^^^^
				Collection is a raw type. References to generic type Collection<E> should be parameterized
				----------
				2. WARNING in X.java (at line 8)
					Class<? extends Collection> d = getClazz(); // ko
					                ^^^^^^^^^^
				Collection is a raw type. References to generic type Collection<E> should be parameterized
				----------
				3. ERROR in X.java (at line 8)
					Class<? extends Collection> d = getClazz(); // ko
					                                ^^^^^^^^^^
				Type mismatch: cannot convert from Class<capture#2-of ? extends Object> to Class<? extends Collection>
				----------
				4. WARNING in X.java (at line 17)
					Class<? extends Collection> c = getClass(); // ok
					                ^^^^^^^^^^
				Collection is a raw type. References to generic type Collection<E> should be parameterized
				----------
				""");
	}

	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=82844
	public void test0461() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"public class X<T extends int[]> {\n" +
				"}\n"
			},
			"""
				----------
				1. ERROR in X.java (at line 1)
					public class X<T extends int[]> {
					                         ^^^^^
				The array type int[] cannot be used as a type parameter bound
				----------
				""");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=79628
	public void test0462() {
		this.runConformTest(
			new String[] {
				"PropertiedObject.java",
				"""
					interface PropertiedObject<B extends PropertiedObject<B>> {}
					interface Model extends PropertiedObject<Model> {}
					interface View<T extends Model,U> extends PropertiedObject<View<?,?>> {}
					"""
			},
			"");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=79144
	public void test0463() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.Set;
					public class X {
					   Zork z;
						public Set<String>[] test() {
						   Set[] sets = new Set[10];
						   return sets;
						}
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				2. WARNING in X.java (at line 5)
					Set[] sets = new Set[10];
					^^^
				Set is a raw type. References to generic type Set<E> should be parameterized
				----------
				3. WARNING in X.java (at line 6)
					return sets;
					       ^^^^
				Type safety: The expression of type Set[] needs unchecked conversion to conform to Set<String>[]
				----------
				""");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=79144
	// SHOULD FAIL AT 1.8 (RET): Type mismatch: cannot convert from List<String> to List
	public void test0464() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					
					public class X {
					    Zork z;
					    public static void main(String[] args) {
					        List<Integer>[] nums = new List[] {Collections.singletonList("Uh oh")};
					        System.out.println(nums[0].get(0).intValue());
					    }\s
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				2. WARNING in X.java (at line 6)
					List<Integer>[] nums = new List[] {Collections.singletonList("Uh oh")};
					                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: The expression of type List[] needs unchecked conversion to conform to List<Integer>[]
				----------
				""");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=82547
	public void test0465() {
		this.runNegativeTest(
			new String[] {
				"Cla.java",
				"""
					class Cla<T> {
					    T getT() {
					        return null;
					    }
					   \s
					    void m() {
					        String s= new Cla<String>.getT();
					    }
					}
					"""
			},
			"""
				----------
				1. ERROR in Cla.java (at line 7)
					String s= new Cla<String>.getT();
					              ^^^^^^^^^^^^^^^^
				Cla.getT cannot be resolved to a type
				----------
				""");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=83096
	public void test0466() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"public class X<A, A> { }\n"
			},
			"""
				----------
				1. ERROR in X.java (at line 1)
					public class X<A, A> { }
					                  ^
				Duplicate type parameter A
				----------
				"""
		);
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=82671
	public void test0467() {
		this.runConformTest(
			new String[] {
				"test/Foo.java",
				"""
					package test;\s
					public class Foo {\s
					   protected String s;\s
					   protected String dosomething(){ return "done"; }\s
					   protected class Bar {}\s
					}\s
					""",
				"test02/FooBar.java",
				"""
					package test02;\s
					import test.Foo;\s
					public class FooBar<R> extends Foo {\s
					   void fail() {\s
					      FooBar f = new FooBar();\s
					      f.s = "foo";\s
					      this.s = "foo";
					      f.dosomething();\s
					      this.dosomething(); \s
					      Bar b1;\s
					      FooBar.Bar b2;\s
					      Foo.Bar b3;\s
					   }\s
					}
					"""
			},
			""
		);
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=82671 - variation
	public void test0468() {
		this.runConformTest(
			new String[] {
				"test/Foo.java",
				"""
					package test;\s
					public class Foo {\s
					   String s;\s
					   String dosomething(){ return "done"; }\s
					   class Bar {}\s
					}\s
					""",
				"test/FooBar.java",
				"""
					package test;\s
					import test.Foo;\s
					public class FooBar<R> extends Foo {\s
					   void fail() {\s
					      FooBar f = new FooBar();\s
					      f.s = "foo";\s
					      this.s = "foo";
					      f.dosomething();\s
					      this.dosomething(); \s
					      Bar b1;\s
					      FooBar.Bar b2;\s
					      Foo.Bar b3;\s
					   }\s
					}
					"""
			},
			""
		);
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=83083
	public void test0469() {
		this.runConformTest(
			new String[] {
				"a/C.java",
				"""
					package a;\s
					import p.B;\s
					public class C extends B {\s
						public void foo(Object obj) {}\s
					}\s
					""",
				"p/B.java",
				"package p; \n" +
				"public class B<E> extends A<E> {} \n",
				"p/A.java",
				"""
					package p;\s
					public class A<E> {\s
						public void foo(E e) {}\s
					}
					""",
			},
			""
		);
		this.runConformTest(
			new String[] {
				"a/C.java",
				"""
					package a;\s
					import p.B;\s
					public class C extends B {\s
						public void foo(Object obj) {}\s
					}\s
					""",
				"p/A.java",
				"""
					package p;\s
					public class A<E> {\s
						public void foo(E e) {}\s
					}
					""",
			},
			"",
			null,
			false, // do not flush output
			null);
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=83225
	public void test0470() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
						public static <T> T choose(boolean b, T t1, T t2) {
							if (b)
								return t1;
							return t2;
						}
					
						public static void foo() {
							Comparable s1 = choose(true, "string", Integer.valueOf(1));
							Number s2 = choose(true, Integer.valueOf(1), Float.valueOf(2));
							Comparable s3 = choose(true, Integer.valueOf(1), Float.valueOf(2));
							Cloneable s4 = choose(true, Integer.valueOf(1), Float.valueOf(2));
							Cloneable s5 = choose(true, "string", Integer.valueOf(1));
						}
					}
					"""
			},
			"----------\n" +
			"1. WARNING in X.java (at line 9)\n" +
			"	Comparable s1 = choose(true, \"string\", Integer.valueOf(1));\n" +
			"	^^^^^^^^^^\n" +
			"Comparable is a raw type. References to generic type Comparable<T> should be parameterized\n" +
			"----------\n" +
			"2. WARNING in X.java (at line 11)\n" +
			"	Comparable s3 = choose(true, Integer.valueOf(1), Float.valueOf(2));\n" +
			"	^^^^^^^^^^\n" +
			"Comparable is a raw type. References to generic type Comparable<T> should be parameterized\n" +
			"----------\n" +
			"3. ERROR in X.java (at line 12)\n" +
			"	Cloneable s4 = choose(true, Integer.valueOf(1), Float.valueOf(2));\n" +
			"	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Type mismatch: cannot convert from "+intersection("Number","Comparable<?>")+" to Cloneable\n" +
			"----------\n" +
			"4. ERROR in X.java (at line 13)\n" +
			"	Cloneable s5 = choose(true, \"string\", Integer.valueOf(1));\n" +
			"	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Type mismatch: cannot convert from "+intersection("Object","Serializable","Comparable<?>")+" to Cloneable\n" +
			"----------\n");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=82671 - variation
	public void test0471() {
		this.runNegativeTest(
			new String[] {
				"test/Foo.java",
				"""
					package test;\s
					public class Foo<R> {\s
					   protected R s;\s
					   protected R dosomething(){ return s; }\s
					   protected class Bar {}\s
					}\s
					""",
				"test02/FooBar.java",
				"""
					package test02;\s
					import test.Foo;\s
					public class FooBar<R> extends Foo<R> {\s
					   void fail() {\s
					      FooBar<String> f = new FooBar<String>();\s
					      f.s = "foo";\s
					      this.s = "foo";
					      f.dosomething();\s
					      this.dosomething(); \s
					      Bar b1;\s
					      FooBar<String>.Bar b2;\s
					      Foo<String>.Bar b3;\s
					   }\s
					}
					"""
			},
			"""
				----------
				1. ERROR in test02\\FooBar.java (at line 7)
					this.s = "foo";
					         ^^^^^
				Type mismatch: cannot convert from String to R
				----------
				"""	);
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=82671 - variation
	public void test0472() {
		this.runNegativeTest(
			new String[] {
				"test/Foo.java",
				"""
					package test;\s
					public class Foo<R> {\s
					   private R s;\s
					   private R dosomething(){ return s; }\s
					   private class Bar {}\s
					}\s
					""",
				"test02/FooBar.java",
				"""
					package test02;\s
					import test.Foo;\s
					public class FooBar<R> extends Foo<R> {\s
					   void fail() {\s
					      FooBar<String> f = new FooBar<String>();\s
					      f.s = "foo";\s
					      this.s = "foo";
					      f.dosomething();\s
					      this.dosomething(); \s
					      Bar b1;\s
					      FooBar<String>.Bar b2;\s
					      Foo<String>.Bar b3;\s
					   }\s
					}
					"""
			},
			"""
				----------
				1. ERROR in test02\\FooBar.java (at line 6)
					f.s = "foo";\s
					  ^
				The field Foo<String>.s is not visible
				----------
				2. ERROR in test02\\FooBar.java (at line 7)
					this.s = "foo";
					     ^
				The field Foo<R>.s is not visible
				----------
				3. ERROR in test02\\FooBar.java (at line 7)
					this.s = "foo";
					         ^^^^^
				Type mismatch: cannot convert from String to R
				----------
				4. ERROR in test02\\FooBar.java (at line 8)
					f.dosomething();\s
					  ^^^^^^^^^^^
				The method dosomething() from the type Foo<String> is not visible
				----------
				5. ERROR in test02\\FooBar.java (at line 9)
					this.dosomething(); \s
					     ^^^^^^^^^^^
				The method dosomething() from the type Foo<R> is not visible
				----------
				6. ERROR in test02\\FooBar.java (at line 10)
					Bar b1;\s
					^^^
				The type Bar is not visible
				----------
				7. ERROR in test02\\FooBar.java (at line 11)
					FooBar<String>.Bar b2;\s
					^^^^^^^^^^^^^^^^^^
				The type FooBar.Bar is not visible
				----------
				8. ERROR in test02\\FooBar.java (at line 12)
					Foo<String>.Bar b3;\s
					^^^^^^^^^^^^^^^
				The type Foo.Bar is not visible
				----------
				""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=81594
	public void test0473() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					public class X
					{
						List<B> itsList;
						B itsB;
						MyTyped itsTyped;
					\t
					\t
						public void test()
						{
							method (itsList, itsB, itsTyped);
						}
					\t
						public <T> void method (List<? extends T> arg1, T arg2, Typed<? super T> arg3)
						{
						}
					\t
						interface A{}
						class B implements A{}
						class Typed<T>{}
						class MyTyped extends Typed<A>{}
					
					}
					"""
			},
			"");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=81594 - variation
	public void test0474() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
						Typed<B> itsList;
						Typed<A> itsTyped;
						public void test() {
							method(itsList, itsTyped);
						}
						public <T> void method(Typed<? extends T> arg1, Typed<? super T> arg3) {
						}
						interface A {
						}
						class B implements A {
						}
						class Typed<T> {
						}
					}
					"""
			},
			"");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=83398
	public void test0475() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.List;
					
					public class X {
					    void method(List<? super Number> list) {
					        list.add(new Object());   // should fail
					        list.add(Integer.valueOf(3)); // correct
					    }
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 5)
					list.add(new Object());   // should fail
					     ^^^
				The method add(capture#1-of ? super Number) in the type List<capture#1-of ? super Number> is not applicable for the arguments (Object)
				----------
				""");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=83398 - variation
	public void test0476() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.List;
					
					public class X {
					    void method(List<? super Number> list, List<Object> lo) {
					    	list = lo;
					    	lo = list;
					    }
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 6)
					lo = list;
					     ^^^^
				Type mismatch: cannot convert from List<capture#2-of ? super Number> to List<Object>
				----------
				""");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=83398 - variation
	public void test0477() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					public class X<T extends Number> {
						List<? super T> lhs;
						List<? extends Number> rhs;
						{
							lhs.add(rhs.get(0));
						}
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 6)
					lhs.add(rhs.get(0));
					    ^^^
				The method add(capture#1-of ? super T) in the type List<capture#1-of ? super T> is not applicable for the arguments (capture#2-of ? extends Number)
				----------
				""");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=83398 - variation
	public void test0478() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					public class X<U extends Number> {
						List<? super Number> lhs;
						List<? super U> rhs;
						{
							lhs.add(rhs.get(0));
						}
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 6)
					lhs.add(rhs.get(0));
					    ^^^
				The method add(capture#1-of ? super Number) in the type List<capture#1-of ? super Number> is not applicable for the arguments (capture#2-of ? super U)
				----------
				""");
	}


	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=83398 - variation
	public void test0479() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					public class X<U extends Number> {
						List<? super Number> lhs;
						List<? extends U> rhs;
						{
							lhs.add(rhs.get(0));
						}
					}
					"""
			},
			"");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=83398 - variation
	public void test0480() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					public class X<U extends Number> {
						List<? super Integer> lhs;
						List<? extends Number> rhs;
						{
							lhs.add(rhs.get(0));
						}
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 6)
					lhs.add(rhs.get(0));
					    ^^^
				The method add(capture#1-of ? super Integer) in the type List<capture#1-of ? super Integer> is not applicable for the arguments (capture#2-of ? extends Number)
				----------
				""");
	}


	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=83398 - variation
	public void test0481() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					public class X<U extends Number> {
						List<? super Number> lhs;
						List<? super Integer> rhs;
						{
							lhs.add(rhs.get(0));
						}
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 6)
					lhs.add(rhs.get(0));
					    ^^^
				The method add(capture#1-of ? super Number) in the type List<capture#1-of ? super Number> is not applicable for the arguments (capture#2-of ? super Integer)
				----------
				""");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=83799
	public void test0482() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public final class X {
						public <T> void testEquals(final String x, T one, T two) {
						}
					
						public <T1, T2> void testEqualsAlt(final String x, T1 one, T2 two) {
						}
					
						public interface Fooey {
						}
					
						public interface Bar extends Fooey {
						}
					
						public interface GenericFooey<T> {
						}
					
						public interface GenericBar<T> extends GenericFooey<T> {
						}
					
						public void testGeneric() {
							testEquals("Should work", new GenericBar<Long>() {
							}, new GenericBar<Long>() {
							});
							final GenericBar<Long> child = new GenericBar<Long>() {
							};
							final GenericFooey<Long> parent = child;
							testEquals("Doesn't work but should", child, parent); // this
							// fails
							// but should work it's identical to next line.
							testEquals("Doesn't work but should", (GenericFooey<Long>) child, parent);
							testEqualsAlt("Should work", child, parent);
						}
						public void test() {
							testEquals("Should work", new Bar() {
							}, new Bar() {
							});
							final Bar child = new Bar() {
							};
							final Fooey parent = child;
							testEquals("Doesn't work but should", child, parent);
							testEquals("Doesn't work but should", (Fooey) child, parent);
							testEqualsAlt("Should work", child, parent);
						}
					}
					"""
			},
			"");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=83904
	public void test0483() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					class Y<T extends Number> {
					}
					
					public class X {
					    public static void main(String argv[]) {
					        m(new Y<Short>(), new Y<Integer>());
					    }
					
					    public static <T extends Number> void m(Y<T> x, Y<T> y) {
					    }
					}
					
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 6)
					m(new Y<Short>(), new Y<Integer>());
					^
				The method m(Y<T>, Y<T>) in the type X is not applicable for the arguments (Y<Short>, Y<Integer>)
				----------
				""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=82349
	public void test0484() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					class Base<T> {
						public class Inner {
						}
						Inner a;
					}
					
					public class X extends Base<Integer> {
						class DerivedInner extends Inner {
						}
						X() {
							a = new DerivedInner();
						}
					}
					"""
			},
			"");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=82349 - variation
	public void test0485() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					class Base<T> {
						public class Inner<U> {
						}
						Inner a;
					}
					
					public class X extends Base<Integer> {
						class DerivedInner extends Inner {
						}
						X() {
							a = new DerivedInner();
						}
					}
					"""
			},
			"");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=82349 - variation
	public void test0486() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					class Base<T> {
						public class Inner<U> {
						}
						Inner a;
					}
					
					public class X extends Base<Integer> {
						class DerivedInner extends Inner<Float> {
						}
						X() {
							a = new DerivedInner();
						}
					}
					"""
			},
			"");
	}
	public void test0487() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					
					public class X {
						void foo(List<String> ls) {
							List<?> l = ls;
							bar(l, "");\s
						}
						<T> void bar(List<? super T> l, T t) {
						}
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 6)
					bar(l, "");\s
					^^^
				The method bar(List<? super T>, T) in the type X is not applicable for the arguments (List<capture#1-of ?>, String)
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=84496
	public void test0488() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					    public static void main(String[] args) {
					        Foo<?> f1 = new Foo<Integer>();
					        Foo<?> f2 = new Foo<String>();
					        f1.bar = f2.bar;
					    }
					    static class Foo<T> {
					       Bar<T> bar = new Bar<T>();
					    }
					    static class Bar<T> {
					        T t;
					    }
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 5)
					f1.bar = f2.bar;
					         ^^^^^^
				Type mismatch: cannot convert from X.Bar<capture#2-of ?> to X.Bar<capture#1-of ?>
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=84496
	public void test0489() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					    public static void main(String[] args) {
					        Foo<?> f1 = new Foo<Integer>();
					        f1.bar = f1.bar;
					    }
					    static class Foo<T> {
					       Bar<T> bar = new Bar<T>();
					    }
					    static class Bar<T> {
					        T t;
					    }
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					f1.bar = f1.bar;
					         ^^^^^^
				Type mismatch: cannot convert from X.Bar<capture#2-of ?> to X.Bar<capture#1-of ?>
				----------
				""");
	}
	public void test0490() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
						T t;
						void foo(X<?> lhs, X<?> rhs) {
							lhs = rhs;
							lhs.t = rhs.t;
						}
						void bar(X<X<?>> lhs, X<X<?>> rhs) {
							lhs = rhs;
							lhs.t = rhs.t;
						}}
					
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 5)
					lhs.t = rhs.t;
					        ^^^^^
				Type mismatch: cannot convert from capture#4-of ? to capture#3-of ?
				----------
				""");
	}

	public void test0491() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
						T t;
						void foo(X<?> lhs, X<?> rhs) {
							lhs = rhs;
							lhs.t = rhs.t;
						}
						void bar(X<X<?>> lhs, X<X<?>> rhs) {
							lhs = rhs;
							lhs.t = rhs.t;
						}
						void baz(X<? super Number> lhs, X<? extends Number> rhs) {
							lhs = rhs;
							lhs.t = rhs.t;
						}
						void baz2(X<? extends Number> lhs, X<? extends Number> rhs) {
							lhs = rhs;
							lhs.t = rhs.t;
						}
						void baz3(X<? extends Number> lhs, X<? super Number> rhs) {
							lhs = rhs;
							lhs.t = rhs.t;
						}
						void baz4(X<? super Number> lhs, X<? super Number> rhs) {
							lhs = rhs;
							lhs.t = rhs.t;
						}
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 5)
					lhs.t = rhs.t;
					        ^^^^^
				Type mismatch: cannot convert from capture#4-of ? to capture#3-of ?
				----------
				2. ERROR in X.java (at line 12)
					lhs = rhs;
					      ^^^
				Type mismatch: cannot convert from X<capture#8-of ? extends Number> to X<? super Number>
				----------
				3. ERROR in X.java (at line 17)
					lhs.t = rhs.t;
					        ^^^^^
				Type mismatch: cannot convert from capture#14-of ? extends Number to capture#13-of ? extends Number
				----------
				4. ERROR in X.java (at line 20)
					lhs = rhs;
					      ^^^
				Type mismatch: cannot convert from X<capture#16-of ? super Number> to X<? extends Number>
				----------
				5. ERROR in X.java (at line 21)
					lhs.t = rhs.t;
					        ^^^^^
				Type mismatch: cannot convert from capture#18-of ? super Number to capture#17-of ? extends Number
				----------
				6. ERROR in X.java (at line 25)
					lhs.t = rhs.t;
					        ^^^^^
				Type mismatch: cannot convert from capture#22-of ? super Number to capture#21-of ? super Number
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=81576
	public void test0492() {
		this.runConformTest(
			new String[] {
				"SuperType.java",//====================================
				"""
					public class SuperType<T> {
						protected InnerType valueWrapper;
						protected class InnerType {
							private T value;
							protected InnerType(T value) {
								this.value = value;
							}
						}
						public SuperType(T value) {
							/*
							 * This constructor exists only to show that the usage of the inner
							 * class within its enclosing class makes no problems
							 */
							this.valueWrapper = new InnerType(value);
						}
						protected SuperType() {
							// Provided for the convenience of subclasses
						}
					}
					""",
				"SubType.java",//====================================
				"""
					public class SubType<T> extends SuperType<T> {
					
						public SubType(T value) {
					
							/* The constructor SuperType <T>.InnerType(T) is undefined */
							InnerType localValueWrapper = new InnerType(value);
					
							/*
							 * Type mismatch: cannot convert from SuperType <T>.InnerType to
							 * SuperType <T>.InnerType
							 *\s
							 * Type safety: The expression of raw type SuperType.InnerType is
							 * converted to SuperType <T>.InnerType. References to generic type
							 * SuperType <T>.InnerType should be parametrized.
							 */
							localValueWrapper = super.valueWrapper;
						}
					
					}
					"""
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=83611
	public void test0493() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
						public class M<T> { M(Class<T> templateClass) {} }
					}
					""",
				"Y.java",
				"""
					public class Y extends X {
						void test() { M<X> m = new M<X>(X.class); }
					}
					"""
			},
			""
		);
		this.runConformTest(
			new String[] {
				"Y.java",
				"""
					public class Y extends X {
						void test() { M<X> m = new M<X>(X.class); }
					}
					"""
			},
			"",
			null,
			false,
			null
		);
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=83615
	public void test0494() {
		String xSource =
				"""
			public class X {
			
				public static void main(String[] args) {
					Number n= null;
					Integer i= null;
					new X().nextTry(i, n);
					new X().nextTry2(n, i);
				}\t
			\t
				<I, N extends I> void nextTry(I i, N n) {}
			\t
				<N, I extends N> void nextTry2(N n, I i) {}\t
			}
			""";
		if (this.complianceLevel < ClassFileConstants.JDK1_8) {
			this.runNegativeTest(
				new String[] {
					"X.java",
					xSource
				},
				"""
					----------
					1. ERROR in X.java (at line 6)
						new X().nextTry(i, n);
						        ^^^^^^^
					Bound mismatch: The generic method nextTry(I, N) of type X is not applicable for the arguments (Integer, Number). The inferred type Number is not a valid substitute for the bounded parameter <N extends I>
					----------
					""");
		} else {
			runConformTest(new String[] { "X.java", xSource });
		}
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=84422
	public void test0495() {
		this.runConformTest(
			new String[] {
				"X.java",//====================================
				"""
					import java.util.*;
					
					public class X {
						List l= null;\s
					
						void add(String s) {
							l.add(s);
						}
					\t
						void addAll(String[] ss) {
							l.addAll(Arrays.asList(ss));
						}
					\t
						String[] get() {
							return (String[])l.toArray(new String[l.size()]);
						}
					}
					"""
			},
			"");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=84593
	public void test0496() {
		this.runConformTest(
			new String[] {
				"X.java",//====================================
				"""
					class Super<S> {
						class A<E> { }
						<T> void take(A<S> o) {
							System.out.println("SUCCESS");
						}
					}
					class Sub extends Super<Double> {
						void test() {
							take(new A());
						}
					}
					public class X {
						public static void main(String[] args) {
							new Sub().test();
						}
					}
					"""
			},
			"SUCCESS");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=84593 - variation - uncheck warnings
	public void test0497() {
		this.runNegativeTest(
			new String[] {
				"X.java",//====================================
				"""
					class Super<S> {
						class A<E> { }
						<T> void take(A<S> o) {
						}
					}
					class Sub extends Super<Double> {
						void test() {
							take(new A());
						}
					}
					public class X {
						public static void main(String[] args) {
							new Sub().test();
							Zork z;
						}
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 8)
					take(new A());
					^^^^^^^^^^^^^
				Type safety: Unchecked invocation take(Super.A) of the generic method take(Super<S>.A<S>) of type Super<Double>
				----------
				2. WARNING in X.java (at line 8)
					take(new A());
					     ^^^^^^^
				Type safety: The expression of type Super.A needs unchecked conversion to conform to Super<Double>.A<Double>
				----------
				3. WARNING in X.java (at line 8)
					take(new A());
					         ^
				Super.A is a raw type. References to generic type Super<S>.A<E> should be parameterized
				----------
				4. ERROR in X.java (at line 14)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}

// https://bugs.eclipse.org/bugs/show_bug.cgi?id=84743 - variation in -source 1.4 mode but 1.5 compliance (ignore covariance)
public void test0498(){
	Map customOptions = getCompilerOptions();
	customOptions.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_4);
	runNegativeTest(
		// test directory preparation
		true /* flush output directory */,
		new String[] { /* test files */
			"X.java",
			"""
				interface I {
				   String foo();
				}
				interface J {
				   Object foo();
				}
				\s
				public class X implements I {
				   public String foo() {
				 	return "";
				   }
				   public static void main(String[] args) {
				         I i = new X();
				         try {
					        J j = (J) i;
				         } catch(ClassCastException e) {
					        System.out.println("SUCCESS");
				         }
				  }
				}
				"""
		},
		// compiler options
		null /* no class libraries */,
		customOptions /* custom options */,
		// compiler results
		"----------\n" + /* expected compiler log */
		"1. ERROR in X.java (at line 15)\n" +
		"	J j = (J) i;\n" +
		"	      ^^^^^\n" +
		"Cannot cast from I to J\n" +
		"----------\n",
		// javac options
		RUN_JAVAC ? /* javac test options */
			new JavacTestOptions("-source 1.4") :
			JavacTestOptions.DEFAULT );
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=85157
public void test0499(){
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
						 public static void main(String argv[]) {
						 		 String[] tab1 = new String[0];
						 		 Integer[] tab2 = new Integer[0];
						 		 boolean cond = true;
						 		 Integer[] var = cond ? tab1 : tab2;
						 		 System.out.println(var);
						 }
				}
				"""
		},
		this.complianceLevel < ClassFileConstants.JDK1_8 ?
			"----------\n" +
			"1. ERROR in X.java (at line 6)\n" +
			"	Integer[] var = cond ? tab1 : tab2;\n" +
			"	                ^^^^^^^^^^^^^^^^^^\n" +
			"Type mismatch: cannot convert from Object&Serializable&" +
			"" + intersection("Comparable<? extends Object&Serializable&" + intersection("Comparable<?>") + ">") +
			"[] to Integer[]\n" +
			"----------\n":
				"""
					----------
					1. ERROR in X.java (at line 6)
						Integer[] var = cond ? tab1 : tab2;
						                       ^^^^
					Type mismatch: cannot convert from String[] to Integer[]
					----------
					""");
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=84251
public void test0500(){
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.ArrayList;
				import java.util.Collection;
				
				interface Sink<T> {\s
					void flush(T t);
				}
				class SimpleSinkImpl<T> implements Sink<T> {
					public void flush(T t) {}
				}
				public class X {
				
				    private <T> T writeAll(Collection<T> coll, Sink<? super T> snk) {\s
				        T last = null;
				        for (T t : coll) {\s
				            last = t;
				            snk.flush(last);
				        }
				        return last;
				    }
				
				    public void test01() {
				        Sink<Object> s = new SimpleSinkImpl<Object>();
				        Collection<String> cs = new ArrayList<String>();
				        cs.add("hello!");
				        cs.add("goodbye");
				        cs.add("see you");
				       \s
				        String str = this.writeAll(cs, s); \s
				    }
				
				    public static void main(String[] args) {
				        X test = new X();
				       \s
				        test.test01();
				    }
				}
				"""
		},
		"");
}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=85303 - variation
	public void test0501() throws Exception {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends AX> {
					    T t;
					    X(T t){
					        this.t = t;
					    }
					    public static void main(String[] args) {
							X<? extends BX> x = new X<BX<String>>(new BX<String>());
							System.out.print(x.t.ax);
							System.out.print(x.t.bx);
						}
					}
					
					class AX<P> {
						P ax;
					}
					
					class BX<Q> extends AX<Q> {
						Q bx;
					}
					""",
			},
			"nullnull");
		String expectedOutput =
			"""
			  // Method descriptor #25 ([Ljava/lang/String;)V
			  // Stack: 4, Locals: 2
			  public static void main(java.lang.String[] args);
			     0  new X [1]
			     3  dup
			     4  new BX [26]
			     7  dup
			     8  invokespecial BX() [28]
			    11  invokespecial X(AX) [29]
			    14  astore_1 [x]
			    15  getstatic java.lang.System.out : java.io.PrintStream [31]
			    18  aload_1 [x]
			    19  getfield X.t : AX [16]
			    22  checkcast BX [26]
			    25  getfield BX.ax : java.lang.Object [37]
			    28  invokevirtual java.io.PrintStream.print(java.lang.Object) : void [41]
			    31  getstatic java.lang.System.out : java.io.PrintStream [31]
			    34  aload_1 [x]
			    35  getfield X.t : AX [16]
			    38  checkcast BX [26]
			    41  getfield BX.bx : java.lang.Object [47]
			    44  invokevirtual java.io.PrintStream.print(java.lang.Object) : void [41]
			    47  return
			      Line numbers:
			        [pc: 0, line: 7]
			        [pc: 15, line: 8]
			        [pc: 31, line: 9]
			        [pc: 47, line: 10]
			      Local variable table:
			        [pc: 0, pc: 48] local: args index: 0 type: java.lang.String[]
			        [pc: 15, pc: 48] local: x index: 1 type: X
			      Local variable type table:
			        [pc: 15, pc: 48] local: x index: 1 type: X<? extends BX>
			""";

		File f = new File(OUTPUT_DIR + File.separator + "X.class");
		byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
		ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
		String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
		int index = result.indexOf(expectedOutput);
		if (index == -1 || expectedOutput.length() == 0) {
			System.out.println(Util.displayString(result, 3));
		}
		if (index == -1) {
			assertEquals("Wrong contents", expectedOutput, result);
		}
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=85303 - variation
	public void test0502() throws Exception {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X <T extends AX> {
					    T t;
					    X(T t){
					        this.t = t;
					    }
					    public static void main(String[] args) {
							X<? extends BX> x = new X<BX<String>>(new BX<String>());
							System.out.print(x.self().t.ax);
							System.out.print(x.self().t.bx);
						}
						X<T> self() {
							return this;
						}
					}
					
					class AX<P> {
						P ax;
					}
					
					class BX<Q> extends AX<Q> {
						Q bx;
					}
					""",
			},
			"nullnull");
		String expectedOutput =
			"""
			  // Method descriptor #25 ([Ljava/lang/String;)V
			  // Stack: 4, Locals: 2
			  public static void main(java.lang.String[] args);
			     0  new X [1]
			     3  dup
			     4  new BX [26]
			     7  dup
			     8  invokespecial BX() [28]
			    11  invokespecial X(AX) [29]
			    14  astore_1 [x]
			    15  getstatic java.lang.System.out : java.io.PrintStream [31]
			    18  aload_1 [x]
			    19  invokevirtual X.self() : X [37]
			    22  getfield X.t : AX [16]
			    25  checkcast BX [26]
			    28  getfield BX.ax : java.lang.Object [41]
			    31  invokevirtual java.io.PrintStream.print(java.lang.Object) : void [45]
			    34  getstatic java.lang.System.out : java.io.PrintStream [31]
			    37  aload_1 [x]
			    38  invokevirtual X.self() : X [37]
			    41  getfield X.t : AX [16]
			    44  checkcast BX [26]
			    47  getfield BX.bx : java.lang.Object [51]
			    50  invokevirtual java.io.PrintStream.print(java.lang.Object) : void [45]
			    53  return
			      Line numbers:
			        [pc: 0, line: 7]
			        [pc: 15, line: 8]
			        [pc: 34, line: 9]
			        [pc: 53, line: 10]
			      Local variable table:
			        [pc: 0, pc: 54] local: args index: 0 type: java.lang.String[]
			        [pc: 15, pc: 54] local: x index: 1 type: X
			      Local variable type table:
			        [pc: 15, pc: 54] local: x index: 1 type: X<? extends BX>
			""";

		File f = new File(OUTPUT_DIR + File.separator + "X.class");
		byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
		ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
		String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
		int index = result.indexOf(expectedOutput);
		if (index == -1 || expectedOutput.length() == 0) {
			System.out.println(Util.displayString(result, 3));
		}
		if (index == -1) {
			assertEquals("Wrong contents", expectedOutput, result);
		}
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=85303 - variation
	public void test0503() throws Exception {
		this.runConformTest(
				new String[] {
					"X.java",
					"""
						class XA {}
						interface XB {
							XB CONST = new XB(){ public String toString() { return "SUCCESS"; }};
						}
						class XAB extends XA implements XB {}
						
						public class X <E extends XA&XB> {
							E e;
						  public static void main(String[] args) {
							  System.out.print(new X<XAB>().e.CONST);
							  new X<XAB>().foo();
						  }
						  public void foo() {
						    System.out.print(this.e.CONST);
						  }
						}
						""",
				},
				"SUCCESSSUCCESS");
			String expectedOutput =
				"""
				// Signature: <E:LXA;:LXB;>Ljava/lang/Object;
				public class X {
				 \s
				  // Field descriptor #6 LXA;
				  // Signature: TE;
				  XA e;
				 \s
				  // Method descriptor #10 ()V
				  // Stack: 1, Locals: 1
				  public X();
				    0  aload_0 [this]
				    1  invokespecial java.lang.Object() [12]
				    4  return
				      Line numbers:
				        [pc: 0, line: 7]
				      Local variable table:
				        [pc: 0, pc: 5] local: this index: 0 type: X
				      Local variable type table:
				        [pc: 0, pc: 5] local: this index: 0 type: X<E>
				 \s
				  // Method descriptor #21 ([Ljava/lang/String;)V
				  // Stack: 3, Locals: 1
				  public static void main(java.lang.String[] args);
				     0  getstatic java.lang.System.out : java.io.PrintStream [22]
				     3  new X [1]
				     6  dup
				     7  invokespecial X() [28]
				    10  getfield X.e : XA [29]
				    13  checkcast XAB [31]
				    16  pop
				    17  getstatic XAB.CONST : XB [33]
				    20  invokevirtual java.io.PrintStream.print(java.lang.Object) : void [37]
				    23  new X [1]
				    26  dup
				    27  invokespecial X() [28]
				    30  invokevirtual X.foo() : void [43]
				    33  return
				      Line numbers:
				        [pc: 0, line: 10]
				        [pc: 23, line: 11]
				        [pc: 33, line: 12]
				      Local variable table:
				        [pc: 0, pc: 34] local: args index: 0 type: java.lang.String[]
				 \s
				  // Method descriptor #10 ()V
				  // Stack: 2, Locals: 1
				  public void foo();
				     0  getstatic java.lang.System.out : java.io.PrintStream [22]
				     3  aload_0 [this]
				     4  getfield X.e : XA [29]
				     7  checkcast XB [48]
				    10  pop
				    11  getstatic XB.CONST : XB [50]
				    14  invokevirtual java.io.PrintStream.print(java.lang.Object) : void [37]
				    17  return
				      Line numbers:
				        [pc: 0, line: 14]
				        [pc: 17, line: 15]
				      Local variable table:
				        [pc: 0, pc: 18] local: this index: 0 type: X
				      Local variable type table:
				        [pc: 0, pc: 18] local: this index: 0 type: X<E>
				""";

			File f = new File(OUTPUT_DIR + File.separator + "X.class");
			byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
			ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
			String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
			int index = result.indexOf(expectedOutput);
			if (index == -1 || expectedOutput.length() == 0) {
				System.out.println(Util.displayString(result, 3));
			}
			if (index == -1) {
				assertEquals("Wrong contents", expectedOutput, result);
			}
		}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=85303 - variation
	public void test0504() throws Exception {
		this.runConformTest(
				new String[] {
					"X.java",
					"""
						class XA {}
						interface XB {
							XB CONST = new XB(){ public String toString() { return "SUCCESS"; }};
						}
						class XAB extends XA implements XB {}
						
						public class X <E extends XA&XB> {
						  E e() { return null; }
						  public static void main(String[] args) {
							  System.out.print(new X<XAB>().e().CONST);
							  new X<XAB>().foo();
						  }
						  public void foo() {
						    System.out.print(this.e().CONST);
						  }
						}
						""",
				},
				"SUCCESSSUCCESS");
			String expectedOutput =
				"""
				// Signature: <E:LXA;:LXB;>Ljava/lang/Object;
				public class X {
				 \s
				  // Method descriptor #6 ()V
				  // Stack: 1, Locals: 1
				  public X();
				    0  aload_0 [this]
				    1  invokespecial java.lang.Object() [8]
				    4  return
				      Line numbers:
				        [pc: 0, line: 7]
				      Local variable table:
				        [pc: 0, pc: 5] local: this index: 0 type: X
				      Local variable type table:
				        [pc: 0, pc: 5] local: this index: 0 type: X<E>
				 \s
				  // Method descriptor #17 ()LXA;
				  // Signature: ()TE;
				  // Stack: 1, Locals: 1
				  XA e();
				    0  aconst_null
				    1  areturn
				      Line numbers:
				        [pc: 0, line: 8]
				      Local variable table:
				        [pc: 0, pc: 2] local: this index: 0 type: X
				      Local variable type table:
				        [pc: 0, pc: 2] local: this index: 0 type: X<E>
				 \s
				  // Method descriptor #21 ([Ljava/lang/String;)V
				  // Stack: 3, Locals: 1
				  public static void main(java.lang.String[] args);
				     0  getstatic java.lang.System.out : java.io.PrintStream [22]
				     3  new X [1]
				     6  dup
				     7  invokespecial X() [28]
				    10  invokevirtual X.e() : XA [29]
				    13  checkcast XAB [31]
				    16  pop
				    17  getstatic XAB.CONST : XB [33]
				    20  invokevirtual java.io.PrintStream.print(java.lang.Object) : void [37]
				    23  new X [1]
				    26  dup
				    27  invokespecial X() [28]
				    30  invokevirtual X.foo() : void [43]
				    33  return
				      Line numbers:
				        [pc: 0, line: 10]
				        [pc: 23, line: 11]
				        [pc: 33, line: 12]
				      Local variable table:
				        [pc: 0, pc: 34] local: args index: 0 type: java.lang.String[]
				 \s
				  // Method descriptor #6 ()V
				  // Stack: 2, Locals: 1
				  public void foo();
				     0  getstatic java.lang.System.out : java.io.PrintStream [22]
				     3  aload_0 [this]
				     4  invokevirtual X.e() : XA [29]
				     7  checkcast XB [48]
				    10  pop
				    11  getstatic XB.CONST : XB [50]
				    14  invokevirtual java.io.PrintStream.print(java.lang.Object) : void [37]
				    17  return
				      Line numbers:
				        [pc: 0, line: 14]
				        [pc: 17, line: 15]
				      Local variable table:
				        [pc: 0, pc: 18] local: this index: 0 type: X
				      Local variable type table:
				        [pc: 0, pc: 18] local: this index: 0 type: X<E>
				""";

			File f = new File(OUTPUT_DIR + File.separator + "X.class");
			byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
			ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
			String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
			int index = result.indexOf(expectedOutput);
			if (index == -1 || expectedOutput.length() == 0) {
				System.out.println(Util.displayString(result, 3));
			}
			if (index == -1) {
				assertEquals("Wrong contents", expectedOutput, result);
			}
		}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=85303 - variation
	public void test0505() throws Exception {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					class XA {}
					interface XB {
						XB CONST = new XB(){ public String toString() { return "SUCCESS"; }};
					}
					class XAB extends XA implements XB {}
					
					public class X <E extends XA&XB> {
					  E e;
					  public static void main(String[] args) {
						  new X<XAB>().foo();
					  }
					  public void foo() {
						new Object() {
							void run() {
								System.out.print(e.CONST);
							}
						}.run();
					    System.out.print(e.CONST);
					  }
					}
					""",
			},
			"SUCCESSSUCCESS");
		String expectedOutput =
			"""
			// Signature: <E:LXA;:LXB;>Ljava/lang/Object;
			public class X {
			 \s
			  // Field descriptor #6 LXA;
			  // Signature: TE;
			  XA e;
			 \s
			  // Method descriptor #10 ()V
			  // Stack: 1, Locals: 1
			  public X();
			    0  aload_0 [this]
			    1  invokespecial java.lang.Object() [12]
			    4  return
			      Line numbers:
			        [pc: 0, line: 7]
			      Local variable table:
			        [pc: 0, pc: 5] local: this index: 0 type: X
			      Local variable type table:
			        [pc: 0, pc: 5] local: this index: 0 type: X<E>
			 \s
			  // Method descriptor #21 ([Ljava/lang/String;)V
			  // Stack: 2, Locals: 1
			  public static void main(java.lang.String[] args);
			     0  new X [1]
			     3  dup
			     4  invokespecial X() [22]
			     7  invokevirtual X.foo() : void [23]
			    10  return
			      Line numbers:
			        [pc: 0, line: 10]
			        [pc: 10, line: 11]
			      Local variable table:
			        [pc: 0, pc: 11] local: args index: 0 type: java.lang.String[]
			 \s
			  // Method descriptor #10 ()V
			  // Stack: 3, Locals: 1
			  public void foo();
			     0  new X$1 [28]
			     3  dup
			     4  aload_0 [this]
			     5  invokespecial X$1(X) [30]
			     8  invokevirtual X$1.run() : void [33]
			    11  getstatic java.lang.System.out : java.io.PrintStream [36]
			    14  aload_0 [this]
			    15  getfield X.e : XA [42]
			    18  checkcast XB [44]
			    21  pop
			    22  getstatic XB.CONST : XB [46]
			    25  invokevirtual java.io.PrintStream.print(java.lang.Object) : void [50]
			    28  return
			      Line numbers:
			        [pc: 0, line: 13]
			        [pc: 8, line: 17]
			        [pc: 11, line: 18]
			        [pc: 28, line: 19]
			      Local variable table:
			        [pc: 0, pc: 29] local: this index: 0 type: X
			      Local variable type table:
			        [pc: 0, pc: 29] local: this index: 0 type: X<E>
			""";

		File f = new File(OUTPUT_DIR + File.separator + "X.class");
		byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
		ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
		String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
		int index = result.indexOf(expectedOutput);
		if (index == -1 || expectedOutput.length() == 0) {
			System.out.println(Util.displayString(result, 3));
		}
		if (index == -1) {
			assertEquals("Wrong contents", expectedOutput, result);
		}
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=85477
	public void test0506() {
		this.runNegativeTest(
			new String[] {
				"X.java",//====================================
				"""
					import java.util.Collections;
					import java.util.Comparator;
					import java.util.List;
					
					public final class X<E> {
						public void test(List list,final Comparator comparator, X x) {
							foo(list, comparator);
							bar(list, comparator);
						\t
							x.foo(list, comparator);
							x.bar(list, comparator);
						}
					
						<T> void foo(List<T> lt, Comparator<? super T> ct) {
						}
						static <T> void bar(List<T> lt, Comparator<? super T> ct) {
						}
					 Zork z;
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 6)
					public void test(List list,final Comparator comparator, X x) {
					                 ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				2. WARNING in X.java (at line 6)
					public void test(List list,final Comparator comparator, X x) {
					                                 ^^^^^^^^^^
				Comparator is a raw type. References to generic type Comparator<T> should be parameterized
				----------
				3. WARNING in X.java (at line 6)
					public void test(List list,final Comparator comparator, X x) {
					                                                        ^
				X is a raw type. References to generic type X<E> should be parameterized
				----------
				4. WARNING in X.java (at line 7)
					foo(list, comparator);
					^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked invocation foo(List, Comparator) of the generic method foo(List<T>, Comparator<? super T>) of type X<E>
				----------
				5. WARNING in X.java (at line 7)
					foo(list, comparator);
					    ^^^^
				Type safety: The expression of type List needs unchecked conversion to conform to List<Object>
				----------
				6. WARNING in X.java (at line 7)
					foo(list, comparator);
					          ^^^^^^^^^^
				Type safety: The expression of type Comparator needs unchecked conversion to conform to Comparator<? super Object>
				----------
				7. WARNING in X.java (at line 8)
					bar(list, comparator);
					^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked invocation bar(List, Comparator) of the generic method bar(List<T>, Comparator<? super T>) of type X<E>
				----------
				8. WARNING in X.java (at line 8)
					bar(list, comparator);
					    ^^^^
				Type safety: The expression of type List needs unchecked conversion to conform to List<Object>
				----------
				9. WARNING in X.java (at line 8)
					bar(list, comparator);
					          ^^^^^^^^^^
				Type safety: The expression of type Comparator needs unchecked conversion to conform to Comparator<? super Object>
				----------
				10. WARNING in X.java (at line 10)
					x.foo(list, comparator);
					^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: The method foo(List, Comparator) belongs to the raw type X. References to generic type X<E> should be parameterized
				----------
				11. WARNING in X.java (at line 11)
					x.bar(list, comparator);
					^^^^^^^^^^^^^^^^^^^^^^^
				The static method bar(List<Object>, Comparator<? super Object>) from the type X should be accessed in a static way
				----------
				12. WARNING in X.java (at line 11)
					x.bar(list, comparator);
					^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked invocation bar(List, Comparator) of the generic method bar(List<T>, Comparator<? super T>) of type X
				----------
				13. WARNING in X.java (at line 11)
					x.bar(list, comparator);
					      ^^^^
				Type safety: The expression of type List needs unchecked conversion to conform to List<Object>
				----------
				14. WARNING in X.java (at line 11)
					x.bar(list, comparator);
					            ^^^^^^^^^^
				Type safety: The expression of type Comparator needs unchecked conversion to conform to Comparator<? super Object>
				----------
				15. ERROR in X.java (at line 18)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}
	// array bound for wildcard
	public void test0507() {
		this.runConformTest(
			new String[] {
				"X.java",//====================================
				"""
					import java.io.Serializable;
					import java.util.List;
					
					public class X {
						void foo1(List<? extends int[]> l) {
							int i = l.get(0).length;
						}
						void foo2(List<? extends int[]> l) {
							Object o = l.get(0).toString();
						}
						void foo3(List<? extends int[]> l, Serializable s) {
							boolean b = true;
							Serializable s2 = b ? l.get(0) : s;
						}
					}
					"""
			},
			"");
	}
	// array bound for wildcard
	public void test0508() {
		this.runNegativeTest(
			new String[] {
				"X.java",//====================================
				"""
					import java.io.Serializable;
					import java.util.List;
					
					public class X {
						void foo1(List<? super int[]> l) {
							int i = l.get(0).length;
						}
						void foo2(List<? super int[]> l) {
							Object o = l.get(0).toString();
						}
						void foo3(List<? super int[]> l, Serializable s) {
							boolean b = true;
							Serializable s2 = b ? l.get(0) : s;
						}
					}
					"""
			},
			this.complianceLevel < ClassFileConstants.JDK1_8 ?
			"""
				----------
				1. ERROR in X.java (at line 6)
					int i = l.get(0).length;
					                 ^^^^^^
				length cannot be resolved or is not a field
				----------
				2. ERROR in X.java (at line 13)
					Serializable s2 = b ? l.get(0) : s;
					                  ^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Object to Serializable
				----------
				""" :
				"""
					----------
					1. ERROR in X.java (at line 6)
						int i = l.get(0).length;
						                 ^^^^^^
					length cannot be resolved or is not a field
					----------
					2. ERROR in X.java (at line 13)
						Serializable s2 = b ? l.get(0) : s;
						                      ^^^^^^^^
					Type mismatch: cannot convert from capture#3-of ? super int[] to Serializable
					----------
					""");
	}
	// type parameter hiding
	public void test0509() {
		this.runNegativeTest(
			new String[] {
				"X.java",//====================================
				"""
					import java.util.*;
					public class X {
						public static void main(String[] args) {
					        List<MyTigerSimpleObject> list = new ArrayList<MyTigerSimpleObject>();
					        list.add(new MyTigerSimpleObject("a"));
					        list.add(new MyTigerSimpleObject("b"));
					       \s
					        for (MyTigerSimpleObject so : list)
					            System.out.println(so.getSomeAttribute());	\t
						}
					}
					class MyTigerSimpleObject<E> {
						MyTigerSimpleObject(String s) {}
						E getSomeAttribute() { return null; }
					}
					
					class TigerList<MyTigerSimpleObject> extends ArrayList<MyTigerSimpleObject> {
					    public void listAll() {
					        for (MyTigerSimpleObject so : this)
					            System.out.println(so.getSomeAttribute());
					    }
					\t
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 4)
					List<MyTigerSimpleObject> list = new ArrayList<MyTigerSimpleObject>();
					     ^^^^^^^^^^^^^^^^^^^
				MyTigerSimpleObject is a raw type. References to generic type MyTigerSimpleObject<E> should be parameterized
				----------
				2. WARNING in X.java (at line 4)
					List<MyTigerSimpleObject> list = new ArrayList<MyTigerSimpleObject>();
					                                               ^^^^^^^^^^^^^^^^^^^
				MyTigerSimpleObject is a raw type. References to generic type MyTigerSimpleObject<E> should be parameterized
				----------
				3. WARNING in X.java (at line 5)
					list.add(new MyTigerSimpleObject("a"));
					             ^^^^^^^^^^^^^^^^^^^
				MyTigerSimpleObject is a raw type. References to generic type MyTigerSimpleObject<E> should be parameterized
				----------
				4. WARNING in X.java (at line 6)
					list.add(new MyTigerSimpleObject("b"));
					             ^^^^^^^^^^^^^^^^^^^
				MyTigerSimpleObject is a raw type. References to generic type MyTigerSimpleObject<E> should be parameterized
				----------
				5. WARNING in X.java (at line 8)
					for (MyTigerSimpleObject so : list)
					     ^^^^^^^^^^^^^^^^^^^
				MyTigerSimpleObject is a raw type. References to generic type MyTigerSimpleObject<E> should be parameterized
				----------
				6. WARNING in X.java (at line 17)
					class TigerList<MyTigerSimpleObject> extends ArrayList<MyTigerSimpleObject> {
					      ^^^^^^^^^
				The serializable class TigerList does not declare a static final serialVersionUID field of type long
				----------
				7. WARNING in X.java (at line 17)
					class TigerList<MyTigerSimpleObject> extends ArrayList<MyTigerSimpleObject> {
					                ^^^^^^^^^^^^^^^^^^^
				The type parameter MyTigerSimpleObject is hiding the type MyTigerSimpleObject<E>
				----------
				8. ERROR in X.java (at line 20)
					System.out.println(so.getSomeAttribute());
					                      ^^^^^^^^^^^^^^^^
				The method getSomeAttribute() is undefined for the type MyTigerSimpleObject
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=84355
	public void test0510() {
		this.runConformTest(
			new String[] {
				"X.java",//====================================
				"""
					import java.io.Serializable;
					
					public class X {
						public X() {
							String[] strings = new String[]{"test"};
					
							// this fails
							Object obj = ClassB.doSomething((String) strings[0]);
					
							// this works fine
							String intermediate = ClassB.doSomething((String) strings[0]);
							Object obj1 = intermediate;
						}
					}
					
					class ClassB {
						public static <T extends Serializable> T doSomething(String value) {
							return (T) value;
						}
					}
					"""
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=82407
	public void test0511() {
		this.runConformTest(
			new String[] {
				"X.java",//====================================
				"""
					import java.util.HashMap;
					
					public class X {
					
						static HashMap<Character, Character> substitutionList(String s1, String s2) {
					
							HashMap<Character, Character> subst = new HashMap<Character, Character>();
					
							for (int i = 0; i < s1.length(); i++) {
								char key = s1.charAt(i);
								char value = s2.charAt(i);
								if (subst.containsKey(key)) {
									if (value != subst.get(key)) {
										return null;
									}
								} else if (subst.containsValue(value)) {
									return null;
								} else {
									subst.put(key, value);
								}
							}
					
							return subst;
						}
					
						public static void main(String[] args) {
							System.out.println("SUCCESS");
						}
					}
					"""
			},
			"SUCCESS");
	}
	public void test0512() {
		this.runConformTest(
			new String[] {
				"X.java",//====================================
				"""
					public class X {\s
					    public static void main(String argv[]) {
						\t
							new X().new M<Exception>(null) {
								void run() {
									Exception e = ex;
									System.out.println("SUCCESS");
								}
							}.run();
					    }
					    class M<E extends Throwable> {
					        E ex;
					        M(E ex) {
					            this.ex = ex;
					        }
					    }
					}
					"""
			},
			"SUCCESS");
	}
	public void test0513() {
		this.runNegativeTest(
			new String[] {
				"X.java",//====================================
				"""
					public class X {\s
					    public static void main(String argv[]) {
						\t
							new X().new M(null) {
								void run() {
									Exception e = ex;
									System.out.println("SUCCESS");
								}
							}.run();
					    }
					    class M<E extends Throwable> {
					        E ex;
					        M(E ex) {
					            this.ex = ex;
					        }
					    }
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 4)
					new X().new M(null) {
							void run() {
								Exception e = ex;
								System.out.println("SUCCESS");
							}
						}.run();
					^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: The constructor X.M(Throwable) belongs to the raw type X.M. References to generic type X.M<E> should be parameterized
				----------
				2. WARNING in X.java (at line 4)
					new X().new M(null) {
					            ^
				X.M is a raw type. References to generic type X.M<E> should be parameterized
				----------
				3. WARNING in X.java (at line 4)
					new X().new M(null) {
					            ^^^^^^^
				Type safety: The constructor X.M(Throwable) belongs to the raw type X.M. References to generic type X.M<E> should be parameterized
				----------
				4. ERROR in X.java (at line 6)
					Exception e = ex;
					              ^^
				Type mismatch: cannot convert from Throwable to Exception
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=82955
	public void test0514(){
		runConformTest(
			new String[] {
				"Test.java",
				"""
					public class Test {
						static <T extends Base> T infer( T t1, T t2 ) { return null; }
						public static void main( String [] args ) {
							Base base = infer( new Sub1(), new Sub2() );
							// Note: Eclipse 3.1 says this is an error, but it's not
							Runnable runnable = infer( new Sub1(), new Sub2() );
						}
					}
					class Base { }
					class Sub1 extends Base implements Runnable { public void run() { } }
					class Sub2 extends Base implements Runnable { public void run() { } }
					"""
			}
		);
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=84348
	public void test0515(){
		runConformTest(
			new String[] {
				"Test.java",
				"""
					public class Test {
						public static <T> void myMethod(final List<? extends File> fileList) {
							Collections.sort(fileList, new Comparator<File>(){
								public int compare(File f1, File f2) { return 0; }
							});
						}
					}
					
					class List<T> {}
					class File {}
					interface Comparator<T> {}
					class Collections {
						static <T> void sort(List<T> list, Comparator<? super T> c) {}
					}"""
			}
		);
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=84944
	public void test0516(){
		runConformTest(
			new String[] {
				"parser/AbstractParser.java",
				"""
					package parser;
					public abstract class AbstractParser<T> implements ValueParser<T> {
						public T parse( final String string ) {
							return valueOf(string);\s
						}
						protected abstract T valueOf(final String string);\t
					}
					interface ValueParser<T> {
						T parse(final String string);
					}
					""",
				"parser/BooleanParser.java",
				"""
					package parser;
					public class BooleanParser extends AbstractParser<Boolean> {
						protected Boolean valueOf(final String string ) {
							return Boolean.valueOf(string); 	\t
						}
					}
					"""
			}
		);
		runConformTest(
			new String[] {
				"test/BooleanParserTest.java",
				"""
					package test;
					import parser.BooleanParser;
					public class BooleanParserTest {
						static final boolean getBoolean(final String value) {
							return new BooleanParser().parse(value).booleanValue(); // The type Boolean is not visible
						}
					}
					"""
			},
			null,
			null,
			false, // do not flush output directory
			null
		);
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=84944 - check no warning for using raw member
	public void test0517(){
		runNegativeTest(
			new String[] {
				"X.java",
				"""
					class Base<T> {
						class InnerBase {
							java.util.List<String> list;
						}
					  Zork z;
					}
					
					public class X extends Base<Integer> {
						class InnerDerived extends InnerBase {
							void method() {
								list.add("Hi"); // Warning on this method call
							}
						}
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 5)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=85930 - check no warning for using raw member
	public void test0518(){
		runNegativeTest(
			new String[] {
				"X.java",
				"""
					interface Callable<T> {
						public enum Result {
							GOOD, BAD
						};
						public Result call(T arg);
					}
					
					public class X implements Callable<String> {
						public Result call(String arg) {
							return Result.GOOD;
						}
					  Zork z;
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 12)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=85262
	public void test0519(){
		runConformTest(
			new String[] {
				"FooImpl.java",
				"""
					interface Bar<R extends Foo<R>>  {}\s
					\s
					class BarImpl<S extends Foo<S>> implements Bar<S> {}\s
					\s
					interface Foo<T extends Foo<T>> extends Bar<T> {}\s
					\s
					public class FooImpl<U extends Foo<U>> extends BarImpl<U> implements Foo<U> {}
					
					"""
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=85262 - variation
	public void test0520(){
		runConformTest(
			new String[] {
				"Bar.java",
				"public interface Bar<R extends Foo<R>>  {} \n",
				"BarImpl.java",
				"public class BarImpl<S extends Foo<S>> implements Bar<S> {} \n",
				"Foo.java",
				"public interface Foo<T extends Foo<T>> extends Bar<T> {} \n",
			},
			"");
		runConformTest(
			new String[] {
				"FooImpl.java",
				"public class FooImpl<U extends Foo<U>> extends BarImpl<U> implements Foo<U> {}\n",
			},
			"",
			null,
			false, // do not flush output directory
			null);
	}
	public void test0521(){
		runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					
					public class X {
						static public <T extends Collection> void addAll(T a, T b) {
							a.addAll(b);
						}
						static public void main(String[] args) {
							Collection<Integer> a = new ArrayList<Integer>();
							Collection<String> b = new ArrayList<String>();
							b.add("string");
							addAll(a, b);
							try {
								System.out.println(a.iterator().next().intValue()); // ClassCastException
							} catch(ClassCastException e) {
								System.out.println("SUCCESS");
							}
						}
					}
					"""
			},
			"SUCCESS");
	}
	// variation on test0521, check issuing of unchecked warning **
	public void test0522(){
		runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					
					public class X {
						static public <T extends Collection> void addAll(T a, T b) {
							a.addAll(b);
						}
						static public void main(String[] args) {
							Collection<Integer> a = new ArrayList<Integer>();
							Collection<String> b = new ArrayList<String>();
							b.add("string");
							addAll(a, b);
							try {
								System.out.println(a.iterator().next().intValue()); // ClassCastException
							} catch(ClassCastException e) {
								System.out.println("SUCCESS");
							}
						}
					  Zork z;
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 4)
					static public <T extends Collection> void addAll(T a, T b) {
					                         ^^^^^^^^^^
				Collection is a raw type. References to generic type Collection<E> should be parameterized
				----------
				2. WARNING in X.java (at line 5)
					a.addAll(b);
					^^^^^^^^^^^
				Type safety: The method addAll(Collection) belongs to the raw type Collection. References to generic type Collection<E> should be parameterized
				----------
				3. ERROR in X.java (at line 18)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}
	public void test0523(){
		runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					public class X {
						public X() {
							M m = new M();
							List<String> ls = m.list(); // rawified even though wasn't using T parameter
						}
						Zork z;
						static class M<T> {
							List<String> list() {
								return null;
							}
						}
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 4)
					M m = new M();
					^
				X.M is a raw type. References to generic type X.M<T> should be parameterized
				----------
				2. WARNING in X.java (at line 4)
					M m = new M();
					          ^
				X.M is a raw type. References to generic type X.M<T> should be parameterized
				----------
				3. WARNING in X.java (at line 5)
					List<String> ls = m.list(); // rawified even though wasn't using T parameter
					                  ^^^^^^^^
				Type safety: The expression of type List needs unchecked conversion to conform to List<String>
				----------
				4. ERROR in X.java (at line 7)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}
	// ensure there is no unchecked warning **
	public void test0524(){
		runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					class MyList extends ArrayList<String> {
					}
					
					public class X {
					    public static void main(String[] args) {
					        List<? extends String> a = new MyList();
					        List<String> b = (MyList) a;    \s
					    }
						Zork z;
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 2)
					class MyList extends ArrayList<String> {
					      ^^^^^^
				The serializable class MyList does not declare a static final serialVersionUID field of type long
				----------
				2. ERROR in X.java (at line 10)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}
	public void test0525(){
		runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					
					public class X {
						public static void main(String[] args) {
							try {
								List list = new ArrayList();
								String s = "this shouldn't work";
								list.add(s);
								List<Integer> listInt = list;
								int i = listInt.get(0);
							} catch(ClassCastException e) {
								System.out.println("SUCCESS");
							}
						}
					}
					"""
			},
			"SUCCESS");
	}
	public void test0526(){
		runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					    Zork z;
					    <T> T f(Object o) {
						return (T) o; // OK
					    }
					
					    <U, T extends U> T g(Object o) {
						return (T) o; // bug???
					    }
					
					    <U, T extends U> T h(Object o) {
						return X.<T>castTo(o); // workaround
					    }
					
					    private static <T> T castTo(Object o) {
						return (T) o;
					    }
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				2. WARNING in X.java (at line 4)
					return (T) o; // OK
					       ^^^^^
				Type safety: Unchecked cast from Object to T
				----------
				3. WARNING in X.java (at line 8)
					return (T) o; // bug???
					       ^^^^^
				Type safety: Unchecked cast from Object to T
				----------
				4. WARNING in X.java (at line 16)
					return (T) o;
					       ^^^^^
				Type safety: Unchecked cast from Object to T
				----------
				""");
	}
	// should not produce unchecked errors **
	public void test0527(){
		runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
						<T, U extends T, V extends T> T foo(U u, V v) {
							return this == null ? (T) u : (T)v;
						}
						Zork z;
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 5)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=86217
	public void test0528() {
		this.runConformTest(
			new String[] {
				"X.java",
				"public class X<T extends X.M> extends Y {}\n" +
				"class Y { static class M {} }\n",
			},
			""
		);
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=86463
	public void test0529() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					public class X<T extends List> {
						void bar() {
							T t = new ArrayList(); // BUG!!!
						}
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 2)
					public class X<T extends List> {
					                         ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				2. ERROR in X.java (at line 4)
					T t = new ArrayList(); // BUG!!!
					      ^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from ArrayList to T
				----------
				3. WARNING in X.java (at line 4)
					T t = new ArrayList(); // BUG!!!
					          ^^^^^^^^^
				ArrayList is a raw type. References to generic type ArrayList<E> should be parameterized
				----------
				""");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=86463
	public void test0530() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					
					abstract class Foo<T extends List>
					 {
					  abstract void foo(T t);
					  void foo2()
					  {
					    List l = new LinkedList();
					    foo(l); // BUG!!!
					  }
					}
					
					public class X extends Foo<ArrayList>
					{
					  void foo(ArrayList l)
					  {
					    System.out.println(l);
					  }
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 3)
					abstract class Foo<T extends List>
					                             ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				2. WARNING in X.java (at line 8)
					List l = new LinkedList();
					^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				3. WARNING in X.java (at line 8)
					List l = new LinkedList();
					             ^^^^^^^^^^
				LinkedList is a raw type. References to generic type LinkedList<E> should be parameterized
				----------
				4. ERROR in X.java (at line 9)
					foo(l); // BUG!!!
					^^^
				The method foo(T) in the type Foo<T> is not applicable for the arguments (List)
				----------
				5. WARNING in X.java (at line 13)
					public class X extends Foo<ArrayList>
					                           ^^^^^^^^^
				ArrayList is a raw type. References to generic type ArrayList<E> should be parameterized
				----------
				6. WARNING in X.java (at line 15)
					void foo(ArrayList l)
					     ^^^^^^^^^^^^^^^^
				The method foo(ArrayList) of type X should be tagged with @Override since it actually overrides a superclass method
				----------
				7. WARNING in X.java (at line 15)
					void foo(ArrayList l)
					         ^^^^^^^^^
				ArrayList is a raw type. References to generic type ArrayList<E> should be parameterized
				----------
				""");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=86646
	public void test0531() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.Vector;
					
					public class X<T> {
						public T f1(T l) {
							Vector<T> v = new Vector<T>();
							v.add(l);
							return (T) v.get(0); // Expect warning here
						}
					  Zork z;
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 7)
					return (T) v.get(0); // Expect warning here
					       ^^^^^^^^^^^^
				Unnecessary cast from T to T
				----------
				2. ERROR in X.java (at line 9)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=84944
	public void test0532() {
		this.runConformTest(
			new String[] {
				"p/X.java",
				"""
					package p;
					public class X extends Z<Boolean> {
						@Override public Boolean value() { return true; }
					}
					abstract class Z<T> {
						public T foo() { return value(); }
						public abstract T value();
					}
					""",
			},
			""
		);
		this.runConformTest(
			new String[] {
				"Y.java",
				"import p.X;\n" +
				"public class Y { boolean test() { return new X().foo().booleanValue(); } }\n",
			},
			"",
			null,
			false, // do not flush output
			null
		);
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=86838
	public void test0533() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.EnumSet;
					
					enum Foo {
						blargh, baz, boz;
					}
					
					public class X {
						public static void main(String[] args) {
							Class c = Foo.class;
							EnumSet<Enum> eSet = EnumSet.allOf(c);
						}
					}
					""",
			},
			"----------\n" +
			"1. WARNING in X.java (at line 9)\n" +
			"	Class c = Foo.class;\n" +
			"	^^^^^\n" +
			"Class is a raw type. References to generic type Class<T> should be parameterized\n" +
			"----------\n" +
			"2. WARNING in X.java (at line 10)\n" +
			"	EnumSet<Enum> eSet = EnumSet.allOf(c);\n" +
			"	        ^^^^\n" +
			"Enum is a raw type. References to generic type Enum<E> should be parameterized\n" +
			"----------\n" +
			"3. ERROR in X.java (at line 10)\n" +
			"	EnumSet<Enum> eSet = EnumSet.allOf(c);\n" +
			"	        ^^^^\n" +
			"Bound mismatch: The type Enum is not a valid substitute for the bounded parameter <E extends Enum<E>> of the type EnumSet<E>\n" +
			"----------\n" +
			"4. WARNING in X.java (at line 10)\n" +
			"	EnumSet<Enum> eSet = EnumSet.allOf(c);\n" +
			"	                     ^^^^^^^^^^^^^^^^\n" +
			"Type safety: Unchecked invocation allOf(Class) of the generic method allOf(Class<E>) of type EnumSet\n" +
			"----------\n" +
			"5. WARNING in X.java (at line 10)\n" +
			"	EnumSet<Enum> eSet = EnumSet.allOf(c);\n" +
			"	                     ^^^^^^^^^^^^^^^^\n" +
			"Type safety: The expression of type EnumSet needs unchecked conversion to conform to EnumSet<Enum>\n" +
			"----------\n" +
			"6. WARNING in X.java (at line 10)\n" +
			"	EnumSet<Enum> eSet = EnumSet.allOf(c);\n" +
			"	                                   ^\n" +
			(this.complianceLevel < ClassFileConstants.JDK1_8
			? "Type safety: The expression of type Class needs unchecked conversion to conform to Class<Enum>\n"
			: "Type safety: The expression of type Class needs unchecked conversion to conform to Class<Enum<Enum<E>>>\n") +
			"----------\n");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=86838 - variation
	public void test0534() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.EnumSet;
					
					enum Foo {
						blargh, baz, boz;
					}
					
					public class X {
						public static void main(String[] args) {
							Class c = Foo.class;
							EnumSet<Foo> eSet = EnumSet.allOf(c);
						}
					}
					""",
			},
			""
		);
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=86838 - variation
	public void test0535() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.EnumSet;
					
					enum Foo {
						blargh, baz, boz;
					}
					
					public class X {
						public static void main(String[] args) {
							Class c = Foo.class;
							EnumSet<? extends Enum> eSet = EnumSet.allOf(c);
						}
					}
					""",
			},
			""
		);
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=86838 - variation
	public void test0536() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.EnumSet;
					
					enum Foo {
						blargh, baz, boz;
					}
					
					public class X {
						public static void main(String[] args) {
							Class c = Foo.class;
							EnumSet<?> eSet = (EnumSet<?>) EnumSet.allOf(c);
						}
					  Zork z;
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 9)
					Class c = Foo.class;
					^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				2. WARNING in X.java (at line 10)
					EnumSet<?> eSet = (EnumSet<?>) EnumSet.allOf(c);
					                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Unnecessary cast from EnumSet to EnumSet<?>
				----------
				3. WARNING in X.java (at line 10)
					EnumSet<?> eSet = (EnumSet<?>) EnumSet.allOf(c);
					                               ^^^^^^^^^^^^^^^^
				Type safety: Unchecked invocation allOf(Class) of the generic method allOf(Class<E>) of type EnumSet
				----------
				4. WARNING in X.java (at line 10)
					EnumSet<?> eSet = (EnumSet<?>) EnumSet.allOf(c);
					                                             ^
				Type safety: The expression of type Class needs unchecked conversion to conform to Class<Enum<Enum<E>>>
				----------
				5. ERROR in X.java (at line 12)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				"""
		);
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=86838 - variation
	public void test0537() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.EnumSet;
					
					enum Foo {
						blargh, baz, boz;
					}
					
					public class X {
						public static void main(String[] args) {
							Class c = Foo.class;
							EnumSet<?> eSet = EnumSet.allOf(c);
						}
					  Zork z;
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 9)
					Class c = Foo.class;
					^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				2. WARNING in X.java (at line 10)
					EnumSet<?> eSet = EnumSet.allOf(c);
					                  ^^^^^^^^^^^^^^^^
				Type safety: Unchecked invocation allOf(Class) of the generic method allOf(Class<E>) of type EnumSet
				----------
				3. WARNING in X.java (at line 10)
					EnumSet<?> eSet = EnumSet.allOf(c);
					                                ^
				Type safety: The expression of type Class needs unchecked conversion to conform to Class<Enum<Enum<E>>>
				----------
				4. ERROR in X.java (at line 12)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=86838 - variation
	public void test0538() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.EnumSet;
					
					enum Foo {
						blargh, baz, boz;
					}
					
					public class X {
						public static void main(String[] args) {
							Class c = Foo.class;
							EnumSet<Enum<?>> eSet = EnumSet.allOf(c);
						}
					}
					""",
			},
			this.complianceLevel < ClassFileConstants.JDK1_8 ?
			"""
				----------
				1. WARNING in X.java (at line 9)
					Class c = Foo.class;
					^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				2. ERROR in X.java (at line 10)
					EnumSet<Enum<?>> eSet = EnumSet.allOf(c);
					        ^^^^
				Bound mismatch: The type Enum<?> is not a valid substitute for the bounded parameter <E extends Enum<E>> of the type EnumSet<E>
				----------
				3. WARNING in X.java (at line 10)
					EnumSet<Enum<?>> eSet = EnumSet.allOf(c);
					                        ^^^^^^^^^^^^^^^^
				Type safety: Unchecked invocation allOf(Class) of the generic method allOf(Class<E>) of type EnumSet
				----------
				4. WARNING in X.java (at line 10)
					EnumSet<Enum<?>> eSet = EnumSet.allOf(c);
					                        ^^^^^^^^^^^^^^^^
				Type safety: The expression of type EnumSet needs unchecked conversion to conform to EnumSet<Enum<?>>
				----------
				5. WARNING in X.java (at line 10)
					EnumSet<Enum<?>> eSet = EnumSet.allOf(c);
					                                      ^
				Type safety: The expression of type Class needs unchecked conversion to conform to Class<Enum<?>>
				----------
				""" :
				"""
					----------
					1. WARNING in X.java (at line 9)
						Class c = Foo.class;
						^^^^^
					Class is a raw type. References to generic type Class<T> should be parameterized
					----------
					2. ERROR in X.java (at line 10)
						EnumSet<Enum<?>> eSet = EnumSet.allOf(c);
						        ^^^^
					Bound mismatch: The type Enum<?> is not a valid substitute for the bounded parameter <E extends Enum<E>> of the type EnumSet<E>
					----------
					3. WARNING in X.java (at line 10)
						EnumSet<Enum<?>> eSet = EnumSet.allOf(c);
						                        ^^^^^^^^^^^^^^^^
					Type safety: Unchecked invocation allOf(Class) of the generic method allOf(Class<E>) of type EnumSet
					----------
					4. WARNING in X.java (at line 10)
						EnumSet<Enum<?>> eSet = EnumSet.allOf(c);
						                        ^^^^^^^^^^^^^^^^
					Type safety: The expression of type EnumSet needs unchecked conversion to conform to EnumSet<Enum<?>>
					----------
					5. WARNING in X.java (at line 10)
						EnumSet<Enum<?>> eSet = EnumSet.allOf(c);
						                                      ^
					Type safety: The expression of type Class needs unchecked conversion to conform to Class<Enum<Enum<E>>>
					----------
					""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=86838 - variation
	public void test0539() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
							 static class B<C> {
							 		 public <T extends I1> T willBe(Class<T> c) {
							 		 		 return (T)null;
							 		 }
							 }
							 interface I1  {
							 }
							 interface I2  extends I1 {
							 }
							\s
							 public static void m1(String[] args) {
							 		 B b = new B();
							 		 I2 v = b.willBe(I2.class);
							 }
							 public static void m2(String[] args) {
							 		 B<Void> b = new B<Void>();
							 		 I2 v = b.willBe(I2.class);
							 }
					
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 4)
					return (T)null;
					       ^^^^^^^
				Unnecessary cast from null to T
				----------
				2. WARNING in X.java (at line 13)
					B b = new B();
					^
				X.B is a raw type. References to generic type X.B<C> should be parameterized
				----------
				3. WARNING in X.java (at line 13)
					B b = new B();
					          ^
				X.B is a raw type. References to generic type X.B<C> should be parameterized
				----------
				4. WARNING in X.java (at line 14)
					I2 v = b.willBe(I2.class);
					       ^^^^^^^^^^^^^^^^^^
				Type safety: The method willBe(Class) belongs to the raw type X.B. References to generic type X.B<C> should be parameterized
				----------
				5. ERROR in X.java (at line 14)
					I2 v = b.willBe(I2.class);
					       ^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from X.I1 to X.I2
				----------
				""");
	}
	// test paramtype argument compatibility
	public void test0540() {
		this.runNegativeTest(
			new String[] {
				"Baz.java",
				"""
					import java.util.*;
					interface Foo<X> {}
					interface Bar extends Foo {
					}
					public class Baz<R,D>  {
					    public R visit(Collection<? extends Foo<?>> trees, D d) {
						return null;
					    }
					    R test(Collection<Bar> c, D d) {
						return visit(c, d);
					    }
					}
					""",
			},
			"""
				----------
				1. WARNING in Baz.java (at line 3)
					interface Bar extends Foo {
					                      ^^^
				Foo is a raw type. References to generic type Foo<X> should be parameterized
				----------
				2. ERROR in Baz.java (at line 10)
					return visit(c, d);
					       ^^^^^
				The method visit(Collection<? extends Foo<?>>, D) in the type Baz<R,D> is not applicable for the arguments (Collection<Bar>, D)
				----------
				""");
	}
	public void test0541() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.Map;
					public class X {
					   public static void main(String[] args) {
					     Map m = null;
						 try {
						     Map m2 = m.getClass().newInstance();
						 } catch(Exception e) {
						 }
					   }
					}
					""",
			},
			"");
	}
	public void test0542() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
						static <T> boolean isOK(T x) {
							return isOK(x);
						}
					
						static <T> boolean isStillOK(T x) {
							return true && isOK(x);
						}
					
						static <T> boolean isNoMoreOK(T x) {
							return true && isNoMoreOK(x);
						}
					
						static <T> boolean isOKAgain(T x) {
							boolean res;
							return true && (res = isOKAgain(x));
						}
					}
					""",
			},
			"");
	}
	public void test0543() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.List;
					
					public class X {
						public static void main(String[] args) {
							Object obj = null;
							List<String> ls = (List<String>) obj;
						}
					  Zork z;
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 6)
					List<String> ls = (List<String>) obj;
					                  ^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Object to List<String>
				----------
				2. ERROR in X.java (at line 8)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}
	public void test0544() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.Vector;
					
					public class X {
						public static void main(String[] args) {
							Vector<Integer> a = new Vector<Integer>();
							Vector b = new Vector();
							b.add(new Object());
							a = b;
							Zork z;
						}
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 6)
					Vector b = new Vector();
					^^^^^^
				Vector is a raw type. References to generic type Vector<E> should be parameterized
				----------
				2. WARNING in X.java (at line 6)
					Vector b = new Vector();
					               ^^^^^^
				Vector is a raw type. References to generic type Vector<E> should be parameterized
				----------
				3. WARNING in X.java (at line 7)
					b.add(new Object());
					^^^^^^^^^^^^^^^^^^^
				Type safety: The method add(Object) belongs to the raw type Vector. References to generic type Vector<E> should be parameterized
				----------
				4. WARNING in X.java (at line 8)
					a = b;
					    ^
				Type safety: The expression of type Vector needs unchecked conversion to conform to Vector<Integer>
				----------
				5. ERROR in X.java (at line 9)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=86898
	public void test0545() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					class B extends A<Object> {
						void m2() {
							m3((X2) m());  // A<Object>.m() --> X<? extends Object> - cannot cast to X2
						}
						void m3(X2 i) {}
					}
					class A<T> {
						X<? extends T> m() {
							return null;
						}
					}
					
					class X2 extends X<String> {
					}
					
					public class X<T> {
						void foo(X<String> lhs, X<? extends Object> rhs) {
							lhs = rhs; // cannot convert
						}
						void bar(X2 lhs, X<? extends Object> rhs) {
							lhs = rhs; // cannot convert
						}
					}
					class C {
						void foo(X<? extends Object> xo) {}
						void bar(X<String> xs) {}
					}
					class D extends C {
						void foo(X<String> xs) {}
						void bar(X<? extends Object> xo) {}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 18)
					lhs = rhs; // cannot convert
					      ^^^
				Type mismatch: cannot convert from X<capture#2-of ? extends Object> to X<String>
				----------
				2. ERROR in X.java (at line 21)
					lhs = rhs; // cannot convert
					      ^^^
				Type mismatch: cannot convert from X<capture#3-of ? extends Object> to X2
				----------
				3. ERROR in X.java (at line 29)
					void foo(X<String> xs) {}
					     ^^^^^^^^^^^^^^^^^
				Name clash: The method foo(X<String>) of type D has the same erasure as foo(X<? extends Object>) of type C but does not override it
				----------
				4. ERROR in X.java (at line 30)
					void bar(X<? extends Object> xo) {}
					     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Name clash: The method bar(X<? extends Object>) of type D has the same erasure as bar(X<String>) of type C but does not override it
				----------
				""");
	}
	// ensure no unsafe cast warning **
	public void test0546() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					class StringList extends java.util.LinkedList<String> {
					}
					
					public class X {
					    public static void main(String[] args) {
					        java.util.List<? extends String> a = new StringList();
					        java.util.List<String> b = (StringList) a;      // warned but safe.
					    }
					   Zork z;
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 1)
					class StringList extends java.util.LinkedList<String> {
					      ^^^^^^^^^^
				The serializable class StringList does not declare a static final serialVersionUID field of type long
				----------
				2. ERROR in X.java (at line 9)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}
	public void test0547() {
		runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				import java.util.*;
				public class X {
					public <K> TreeMap<K,K> essai(K type) {
						TreeMap<K,K> treeMap = new TreeMap<K,K>();
						return treeMap;
					}
					public static void main(String args[]) {
						X x = new X();
						TreeMap<?,?> treeMap = x.essai(null);
					}
				}
				""",
		},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
	}
	public void test0548() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					interface DA<T> {
					}
					interface DB<T> extends DA<T> {
					}
					interface DC<T> extends DA<Integer> {
					}
					
					public class X {
						Object o = (DC<?>) (DA<?>) null;
					  Zork z;
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 9)
					Object o = (DC<?>) (DA<?>) null;
					           ^^^^^^^^^^^^^^^^^^^^
				Unnecessary cast from DA<capture#1-of ?> to DC<?>
				----------
				2. WARNING in X.java (at line 9)
					Object o = (DC<?>) (DA<?>) null;
					                   ^^^^^^^^^^^^
				Unnecessary cast from null to DA<?>
				----------
				3. ERROR in X.java (at line 10)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}
	// **
	public void test0549() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X<T> {
						boolean DEBUG = this instanceof Special;
					
						public static class Special extends X<String> {
						}
					}
					""",
			},
			"");
	}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=148046
	public void test0550() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					class A {}
					class B extends A {}
					
					public class X<T> {
					    public <U extends B> void foo(X<? super A> param) {
					        X<U> foo = (X<U>)param;
					    }
					   Zork z;
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 6)
					X<U> foo = (X<U>)param;
					           ^^^^^^^^^^^
				Cannot cast from X<capture#1-of ? super A> to X<U>
				----------
				2. ERROR in X.java (at line 8)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}
	// ensure no unchecked warning
	public void test0551() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					    <T, U extends T, V extends T> T cond1(boolean z, U x1, V x2) {
					        return (z? (T) x1: x2);
					    }
					    Zork z;
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 2)
					<T, U extends T, V extends T> T cond1(boolean z, U x1, V x2) {
					                                              ^
				The parameter z is hiding a field from type X
				----------
				2. ERROR in X.java (at line 5)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}
	public void test0552() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					
						Comparable<?> x;
					
						void put(Comparable<?> c) {
							this.x = c;
						}
					
						Comparable<?> get() {
							return x;
						}
					
						void test() {
							X ci = new X();
							ci.put(new Integer(3));
							Integer i = (Integer) ci.get();
						}
					
					}
					""",
			},
			"");
	}
	public void test0553() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					   public static void main(String args[]) throws Exception {
					      doIt();
					      System.out.println("SUCCESS");
					   }
					   public static void doIt() {
					      Holder<Integer> association = new Holder<Integer>(new Integer(0));
					      Integer sizeHolder = (Integer)(association.getValue()); //Cast to Integer is redundant!!!
					      System.out.print(sizeHolder.intValue());
					   }
					   static class Holder<V> {
					      V value;
					      Holder(V value) {
					         this.value = value;
					      }
					      V getValue() {
					         return value;
					      }
					   }
					}
					"""	,
			},
			"0SUCCESS");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=86898 - variation
	public void test0554() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					 import java.util.*;
					 public class X<T> {
					 public static void main(String[] args) {
							X<? extends Object> xo = null;
							X<String> xs = null;
							X2 x2 = null;
						\t
							Object o1 = (X<String>) xo;
							Object o2 = (X<? extends Object>) xs;
							Object o3 = (X2) xo;
							Object o4 = (X<? extends Object>) x2;
							Object o5 = (X3<String>) xo;
						}
					}
					class X2 extends X<String> {
					}
					class X3<U> extends X<U> {
					   Zork z;
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 8)
					Object o1 = (X<String>) xo;
					            ^^^^^^^^^^^^^^
				Type safety: Unchecked cast from X<capture#1-of ? extends Object> to X<String>
				----------
				2. WARNING in X.java (at line 8)
					Object o1 = (X<String>) xo;
					            ^^^^^^^^^^^^^^
				Unnecessary cast from X<capture#1-of ? extends Object> to X<String>
				----------
				3. WARNING in X.java (at line 9)
					Object o2 = (X<? extends Object>) xs;
					            ^^^^^^^^^^^^^^^^^^^^^^^^
				Unnecessary cast from X<String> to X<? extends Object>
				----------
				4. WARNING in X.java (at line 10)
					Object o3 = (X2) xo;
					            ^^^^^^^
				Unnecessary cast from X<capture#3-of ? extends Object> to X2
				----------
				5. WARNING in X.java (at line 11)
					Object o4 = (X<? extends Object>) x2;
					            ^^^^^^^^^^^^^^^^^^^^^^^^
				Unnecessary cast from X2 to X<? extends Object>
				----------
				6. WARNING in X.java (at line 12)
					Object o5 = (X3<String>) xo;
					            ^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from X<capture#5-of ? extends Object> to X3<String>
				----------
				7. WARNING in X.java (at line 12)
					Object o5 = (X3<String>) xo;
					            ^^^^^^^^^^^^^^^
				Unnecessary cast from X<capture#5-of ? extends Object> to X3<String>
				----------
				8. ERROR in X.java (at line 18)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}
	public void test0555() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					 import java.util.List;
					 public class X<U extends Number> {
					 U u;
					 void foo(X<? extends Number> xn, X<? extends U> xu) {
							xn = xu;
							xu = xn;
							xu.u = xn.u; // ko
							xn.u = xu.u; // ko
						}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 6)
					xu = xn;
					     ^^
				Type mismatch: cannot convert from X<capture#4-of ? extends Number> to X<? extends U>
				----------
				2. ERROR in X.java (at line 7)
					xu.u = xn.u; // ko
					       ^^^^
				Type mismatch: cannot convert from capture#6-of ? extends Number to capture#5-of ? extends U
				----------
				3. ERROR in X.java (at line 8)
					xn.u = xu.u; // ko
					       ^^^^
				Type mismatch: cannot convert from capture#8-of ? extends U to capture#7-of ? extends Number
				----------
				""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=87273
	public void test0556() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					interface Foo {
						Object get();
					}
					
					interface MyList<F> extends Foo {
						public F get();
					}
					
					class MyListImpl<G> implements MyList<G> {
						public G get() {
							System.out.println("SUCCESS");
							return null;
						}
					}
					
					interface StringList extends MyList<String> {
					}
					
					class StringListImpl extends MyListImpl<String> implements StringList {
					}
					
					public class X {
						public static void main(String[] args) {
							Foo f = new StringListImpl();
							f.get();
						}
					}
					""",
			},
			"SUCCESS");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=83002
	public void test0557() {
		this.runConformTest(
			new String[] {
				"X.java",
				"public class X {\n" +
				"	static <T extends Exception> void foo(T t) throws T {\n" + // ensure exception is properly encoded (...^ex)
				"	}\n" +
				"}\n",
			},
			"");
		this.runConformTest(
			new String[] {
				"Y.java",
				"""
					import java.io.*;
					public class Y {
						void foo() {
							try {
								X.foo(new IOException());
							} catch(IOException e){
							}
						}
					}
					""",
			},
			"",
			null,
			false,
			null);
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=83002
	public void test0558() {
		this.runConformTest(
			new String[] {
				"X.java",
				"public class X {\n" +
				"	static <T extends Exception, U extends Exception> void foo(T t, U u) throws T, U {\n" + // ensure exception is properly encoded (...^ex)
				"	}\n" +
				"}\n",
			},
			"");
		this.runConformTest(
			new String[] {
				"Y.java",
				"""
					import java.io.*;
					public class Y {
						void foo() {
							try {
								X.foo(new IOException(), new ClassNotFoundException());
							} catch(IOException e){
							} catch(ClassNotFoundException e){
							}
						}
					}
					""",
			},
			"",
			null,
			false,
			null);
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=86902
	// **
	public void test0559() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					class Cell<T> {
						T t;
						public void setT(T t) {
							this.t= t;
						}
						public T getT() {
							return t;
						}
					}
					
					public class X {
					  Zork z;
						public static void main(String[] args) {
							Cell c= new Cell();
							c.setT(Boolean.FALSE); // other: warning: [unchecked] unchecked
								// call to setT(T) as a member of the raw type p.Cell
							c.t= Boolean.TRUE; // other: warning: [unchecked] unchecked call
								// to setT(T) as a member of the raw type p.Cell
							boolean b1= (Boolean) c.getT();
							boolean b2= (Boolean) c.t;
						}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 12)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				2. WARNING in X.java (at line 14)
					Cell c= new Cell();
					^^^^
				Cell is a raw type. References to generic type Cell<T> should be parameterized
				----------
				3. WARNING in X.java (at line 14)
					Cell c= new Cell();
					            ^^^^
				Cell is a raw type. References to generic type Cell<T> should be parameterized
				----------
				4. WARNING in X.java (at line 15)
					c.setT(Boolean.FALSE); // other: warning: [unchecked] unchecked
					^^^^^^^^^^^^^^^^^^^^^
				Type safety: The method setT(Object) belongs to the raw type Cell. References to generic type Cell<T> should be parameterized
				----------
				5. WARNING in X.java (at line 17)
					c.t= Boolean.TRUE; // other: warning: [unchecked] unchecked call
					  ^
				Type safety: The field t from the raw type Cell is assigned a value of type Boolean. References to generic type Cell<T> should be parameterized
				----------
				""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=85924
	public void test0560() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					interface IController<U extends IView<?>>  {
					    public U getView() ;
					}
					interface IView<U>  {
					}
					class MatGroup   {
						public abstract static class View implements IView<String> {
							public void setTempAppearance() {
								System.out.println("SUCCESS");
							}
						}
					\t
						public abstract static class Ctrl<U extends View> implements IController<U>  {
						}
					}
					public class X {
						public static void main(String []args) {
							MatGroup.Ctrl<?>children[] = {\s
									new MatGroup.Ctrl<MatGroup.View>(){
										public MatGroup.View getView() { return new MatGroup.View(){}; }\t
									}} ;
						    for(MatGroup.Ctrl<?> glmat: children) {
								glmat.getView().setTempAppearance() ;
						    }
						}
					}
					""",
			},
			"SUCCESS");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=87956
	public void test0561() {
		// http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6182950
		String expectedCompilerLog = (this.complianceLevel == ClassFileConstants.JDK1_6)?
				"""
					----------
					1. WARNING in X.java (at line 2)
						void foo(A<String> a) {}
						     ^^^^^^^^^^^^^^^^
					Erasure of method foo(A<String>) is the same as another method in type X
					----------
					2. WARNING in X.java (at line 3)
						Object foo(A<Integer> a) { return null; }
						       ^^^^^^^^^^^^^^^^^
					Erasure of method foo(A<Integer>) is the same as another method in type X
					----------
					""":
					"""
						----------
						1. ERROR in X.java (at line 2)
							void foo(A<String> a) {}
							     ^^^^^^^^^^^^^^^^
						Erasure of method foo(A<String>) is the same as another method in type X
						----------
						2. ERROR in X.java (at line 3)
							Object foo(A<Integer> a) { return null; }
							       ^^^^^^^^^^^^^^^^^
						Erasure of method foo(A<Integer>) is the same as another method in type X
						----------
						3. ERROR in X.java (at line 4)
							void test(A<Integer> a) { foo(a); }
							                          ^^^
						The method foo(A<String>) in the type X is not applicable for the arguments (A<Integer>)
						----------
						""";
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
						void foo(A<String> a) {}
						Object foo(A<Integer> a) { return null; }
						 void test(A<Integer> a) { foo(a); }
					}
					class A<T> {}
					""",
			},
			expectedCompilerLog
		);
/* javac 7
X.java:3: name clash: foo(A<Integer>) and foo(A<String>) have the same erasure
        Object foo(A<Integer> a) { return null; }
               ^
X.java:4: method foo in class X cannot be applied to given types
        void test(A<Integer> a) { foo(a); }
                                  ^
  required: A<String>
  found: A<Integer>
2 errors
 */
		String expectedCompilerLog2 = (this.complianceLevel == ClassFileConstants.JDK1_6)?
				"""
					----------
					1. WARNING in X.java (at line 2)
						Number foo(A<String> a) { return null; }
						       ^^^^^^^^^^^^^^^^
					Erasure of method foo(A<String>) is the same as another method in type X
					----------
					2. WARNING in X.java (at line 3)
						Integer foo(A<Integer> a) { return null; }
						        ^^^^^^^^^^^^^^^^^
					Erasure of method foo(A<Integer>) is the same as another method in type X
					----------
					""":
					"""
						----------
						1. ERROR in X.java (at line 2)
							Number foo(A<String> a) { return null; }
							       ^^^^^^^^^^^^^^^^
						Erasure of method foo(A<String>) is the same as another method in type X
						----------
						2. ERROR in X.java (at line 3)
							Integer foo(A<Integer> a) { return null; }
							        ^^^^^^^^^^^^^^^^^
						Erasure of method foo(A<Integer>) is the same as another method in type X
						----------
						3. ERROR in X.java (at line 4)
							void test(A<Integer> a) { foo(a); }
							                          ^^^
						The method foo(A<String>) in the type X is not applicable for the arguments (A<Integer>)
						----------
						""";
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
						Number foo(A<String> a) { return null; }
						Integer foo(A<Integer> a) { return null; }
						void test(A<Integer> a) { foo(a); }
					}
					class A<T> {}
					""",
			},
			expectedCompilerLog2
/* javac 7
X.java:3: name clash: foo(A<Integer>) and foo(A<String>) have the same erasure
        Integer foo(A<Integer> a) { return null; }
                ^
X.java:4: method foo in class X cannot be applied to given types
        void test(A<Integer> a) { foo(a); }
                                  ^
  required: A<String>
  found: A<Integer>
2 errors
 */
		);
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=87550
	public void test0562() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					interface Inter<A, B> {}
					public class X<T, U, V extends X<T, U, V>> extends ArrayList<V> implements Inter<T, U> {
						public final void foo(U u) {
							X.bar(this, u);
						}
						public static final <P, Q> void bar(Collection<? extends Inter<P, Q>> c, Q q) {}
					}
					""",
			},
			"");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=87550 - variation
	public void test0563() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					interface Inter<A, B> {}
					public class X<T, U, V extends X<T, U, V>> extends ArrayList<V> implements Inter<T, U> {
						public final void foo(U u) {
							X.bar(this, u);
						}
						public static final <P, Q, R> void bar(Collection<R> c, Q q) {}
					}
					""",
			},
			"");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=87550 - variation
	// Awaiting clarification on http://mail.openjdk.java.net/pipermail/lambda-spec-experts/2013-November/000428.html
	public void test0564() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					interface Inter<A, B> {}
					public class X<T, U, V extends X<T, U, V>> extends ArrayList<V> implements Inter<T, U> {
						public final void foo(U u) {
							X.bar(this, u);
						}
						public static final <P, Q> void bar(Collection<? extends Inter<P, Q>> c, Q q) {}
					}
					""",
			},
			"");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=87995	- check no warning
	public void test0565() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					interface IFoo<T> {
					    public T get(Class<T> clazz);
					   Zork z;
					}
					
					class Bar implements IFoo<Integer> {
					    public Integer get(Class<Integer> arg0) {
					        return Integer.valueOf(3);
					    }
					}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}
	public void test0566() {
		String xSource =
				"""
			import java.util.*;
			
			public class X {
			
				void bar2() {
					List<X1> le = new ArrayList<X1>(5);
					le = fill(le, new X2());
				}
				<T> List<T> fill(List<? super T> lt, T t) { return null; }
			}
			class X1 {}
			class X2 extends X1 {
				void foo(){}
			}
			""";
		if (this.complianceLevel < ClassFileConstants.JDK1_8) {
			this.runNegativeTest(
				new String[] {
					"X.java",
					xSource,
				},
				"""
					----------
					1. ERROR in X.java (at line 7)
						le = fill(le, new X2());
						     ^^^^^^^^^^^^^^^^^^
					Type mismatch: cannot convert from List<X2> to List<X1>
					----------
					""");
		} else {
			runConformTest(new String[]{ "X.java", xSource });
		}
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=89454
	public void test0567() {
		this.runConformTest(
			new String[] {
				"Thrower.java",
				"""
					public interface Thrower<E extends Exception> {
					    public void throwIt() throws E;
					}
					""",
			},
			"");
		this.runConformTest(
			new String[] {
				"GenericsTest.java",
				"""
					public class GenericsTest {
					    public static void main(String[] args) throws MyException {
					        Thrower<MyException> thrower = new Thrower<MyException>() {
					            public void throwIt() throws MyException {
					                throw new MyException();
					            }
					        };
					        try {
					           thrower.throwIt();
					        } catch(Exception e) {
					          System.out.println("SUCCESS");
					        }
					    }
					}
					class MyException extends Exception {
					}
					""",
			},
			"SUCCESS",
			null,
			false,
			null);
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=89448
	public void test0568() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.ArrayList;
					import java.util.List;
					
					public class X {
					
					    public static void main(String[] args) {
					
					        ArrayList<ArrayList<Long>> n = new ArrayList<ArrayList<Long>>();
					        ArrayList<Long> arr = new ArrayList<Long>();
					        arr.add(new Long(5));
					        n.add(arr);
					       \s
					        List<? extends List<Long>> m = n; // Whoa!
					       \s
					        for(Long l : m.get(0)) {
					            System.out.println(l);
					        }
					    }
					
					}
					""",
			},
			"5");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=89778
	public void test0569() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X
					{
					    protected static <T extends Exception> void foo() throws T, Exce {
					    }
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					protected static <T extends Exception> void foo() throws T, Exce {
					                                                            ^^^^
				Exce cannot be resolved to a type
				----------
				""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=90147
	public void test0570() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<T extends Object> {
					  public class InnerClass implements Comparable<T> {
					    public int compareTo(T other) {
					      return -1;
					    }
					  }
					 \s
					  public void foo() {
					    InnerClass a = new InnerClass();
					    InnerClass b = new InnerClass();
					    // The following line does not compile (anymore):
					    a.compareTo(b);
					  }
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 12)
					a.compareTo(b);
					  ^^^^^^^^^
				The method compareTo(T) in the type X<T>.InnerClass is not applicable for the arguments (X<T>.InnerClass)
				----------
				""");
	}
	public void test0571() {
		runConformTest(
			// test directory preparation
			true /* flush output directory */,
			new String[] { /* test files */
				"X.java",
				"""
					interface IFoo {
						void foo();
					}
					class Box<T extends IFoo> {
						T value() {
							return null;
						}
					}
					
					interface IBar {
						void bar();
					}
					
					public class X {
						void test01(Box<?> box) {
							box.value().foo();
						}
						void test02(Box<? extends IBar> box) {
							box.value().foo();
							box.value().bar();
						}
						public static void main(String[] args) {
							System.out.println("SUCCESS");
						}
					}
					""",
			},
			// compiler options
			null /* no class libraries */,
			null /* no custom options */,
			// compiler results
			null /* do not check compiler log */,
			// runtime results
			"SUCCESS" /* expected output string */,
			null /* do not check error string */,
			// javac options
			JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=90430
	// SHOULD FAIL AT 1.8 (18.2.3): The method doWithEnumClass(Class<T>) in the type X is not applicable for the arguments (Class<Enum>)
	public void test0572() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
						public <T extends Enum<T>> void doWithEnumClass(Class<T> enumClass) {
						}
					
						public void f() {
							Class<?> cl = null; // Returned by Class.forName("xyz");
							doWithEnumClass((Class<Enum>) cl);
						}
					}
					""",
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=90430 - check unchecked warnings
	// SHOULD FAIL AT 1.8 (18.2.3): The method doWithEnumClass(Class<T>) in the type X is not applicable for the arguments (Class<Enum>)
	public void test0573() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
						public <T extends Enum<T>> void doWithEnumClass(Class<T> enumClass) {
							Zork z;
						}
					
						public void f() {
							Class<?> cl = null; // Returned by Class.forName("xyz");
							doWithEnumClass((Class<Enum>) cl);
						}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				2. WARNING in X.java (at line 8)
					doWithEnumClass((Class<Enum>) cl);
					^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked invocation doWithEnumClass(Class<Enum>) of the generic method doWithEnumClass(Class<T>) of type X
				----------
				3. WARNING in X.java (at line 8)
					doWithEnumClass((Class<Enum>) cl);
					                ^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Class<capture#1-of ?> to Class<Enum>
				----------
				4. WARNING in X.java (at line 8)
					doWithEnumClass((Class<Enum>) cl);
					                       ^^^^
				Enum is a raw type. References to generic type Enum<E> should be parameterized
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=90423 - variation
	public void test0574() {
		// http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6182950
		String expectedCompilerLog = (this.complianceLevel == ClassFileConstants.JDK1_6)?
				"""
					----------
					1. WARNING in X.java (at line 6)
						<T extends Integer> T foo(Object o) {  return null; } // ok
						           ^^^^^^^
					The type parameter T should not be bounded by the final type Integer. Final types cannot be further extended
					----------
					2. WARNING in X.java (at line 6)
						<T extends Integer> T foo(Object o) {  return null; } // ok
						                      ^^^^^^^^^^^^^
					Duplicate method foo(Object) in type X.C2
					----------
					3. WARNING in X.java (at line 7)
						<T extends String> T foo(Object o) {  return null; } // ok
						           ^^^^^^
					The type parameter T should not be bounded by the final type String. Final types cannot be further extended
					----------
					4. WARNING in X.java (at line 7)
						<T extends String> T foo(Object o) {  return null; } // ok
						                     ^^^^^^^^^^^^^
					Duplicate method foo(Object) in type X.C2
					----------
					5. ERROR in X.java (at line 10)
						new X().new C2().foo((List<String>) null);
						                 ^^^
					The method foo(Object) is ambiguous for the type X.C2
					----------
					""":
					"""
						----------
						1. WARNING in X.java (at line 6)
							<T extends Integer> T foo(Object o) {  return null; } // ok
							           ^^^^^^^
						The type parameter T should not be bounded by the final type Integer. Final types cannot be further extended
						----------
						2. ERROR in X.java (at line 6)
							<T extends Integer> T foo(Object o) {  return null; } // ok
							                      ^^^^^^^^^^^^^
						Duplicate method foo(Object) in type X.C2
						----------
						3. WARNING in X.java (at line 7)
							<T extends String> T foo(Object o) {  return null; } // ok
							           ^^^^^^
						The type parameter T should not be bounded by the final type String. Final types cannot be further extended
						----------
						4. ERROR in X.java (at line 7)
							<T extends String> T foo(Object o) {  return null; } // ok
							                     ^^^^^^^^^^^^^
						Duplicate method foo(Object) in type X.C2
						----------
						""";
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.List;
					
					public class X {
					
						class C2 {
							<T extends Integer> T foo(Object o) {  return null; } // ok
							<T extends String> T foo(Object o) {  return null; } // ok
						}
						public static void main(String[] args) {
							new X().new C2().foo((List<String>) null);
						}
					}
					"""
			},
			expectedCompilerLog
		);
/*
X.java:6: name clash: <T#1>foo(Object) and <T#2>foo(Object) have the same erasure
                <T extends String> T foo(Object o) {  return null; } // ok
                                     ^
  where T#1,T#2 are type-variables:
    T#1 extends String declared in method <T#1>foo(Object)
    T#2 extends Integer declared in method <T#2>foo(Object)
1 error
 */
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=84496 - variation with field ref
	public void test0575() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					    public static void main(String[] args) {
					        Foo<?> f1 = new Foo<Integer>();
					        (f1).bar = (f1).bar;
					    }
					    static class Foo<T> {
					       Bar<T> bar = new Bar<T>();
					    }
					    static class Bar<T> {
					        T t;
					    }
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					(f1).bar = (f1).bar;
					           ^^^^^^^^
				Type mismatch: cannot convert from X.Bar<capture#2-of ?> to X.Bar<capture#1-of ?>
				----------
				""");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=84496 - variation with single ref
	public void test0576() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
					    public static void main(String[] args) {
					        Foo<?> f1 = new Foo<Integer>();
					        Foo<?> f2 = new Foo<String>();
							f1 = f1;
							f1 = f2;
					    }
					    static class Foo<T> {
					    }
					}
					"""
			},
			"");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=84496 - variation with qualified name ref
	public void test0577() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
					    public static void main(String[] args) {
					        Foo<?> f1 = new Foo<Integer>();
					        (f1).bar = f1.bar;
					    }
					    static class Foo<T> {
					       Bar<T> bar = new Bar<T>();
					    }
					    static class Bar<T> {
					        T t;
					    }
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					(f1).bar = f1.bar;
					           ^^^^^^
				Type mismatch: cannot convert from X.Bar<capture#2-of ?> to X.Bar<capture#1-of ?>
				----------
				""");
	}
	// check array bound for wildcard
	public void test0578() {
		this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X {
						void foo(Box<? extends int[]> box) {
							int[] ints = box.get();
						}
					}
					class Box<T> {
						T get() { return null; }
					}
					"""
			},
			"");
	}
	// check array bound for wildcard
	public void test0579() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
						void foo(Box<? super int[]> box) {
							int[] ints = box.get();
						}
					}
					class Box<T> {
						T get() { return null; }
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					int[] ints = box.get();
					             ^^^^^^^^^
				Type mismatch: cannot convert from capture#1-of ? super int[] to int[]
				----------
				""");
	}
	// check array bound for wildcard
	public void test0580() {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
						void foo(Box<?> box) {
							int[] ints = box.get();
						}
					}
					class Box<T> {
						T get() { return null; }
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					int[] ints = box.get();
					             ^^^^^^^^^
				Type mismatch: cannot convert from capture#1-of ? to int[]
				----------
				""");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=84496 - variation
	public void test0581() {
	    this.runNegativeTest(
			new String[] {
	            "X.java",
	            """
					class X {\
					  public static void main(String[] args) {
					    Foo<?> f1 = new Foo<Integer>();
					    f1.bar = f1.bar;
					   }
					 }
					class Foo<T> {
					  Bar<T> bar = new Bar<T>();
					}
					class Bar<T> {
					  T t;
					}
					"""
	   		},
			"""
				----------
				1. ERROR in X.java (at line 3)
					f1.bar = f1.bar;
					         ^^^^^^
				Type mismatch: cannot convert from Bar<capture#2-of ?> to Bar<capture#1-of ?>
				----------
				""");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=84496
	public void test0582() {
	    this.runConformTest(
            new String[] {
                "X.java",
                """
					import java.util.List;
					class X {
					  void foo(List<? extends I1> l1) {
					    C1 c1 = (C1)l1.get(0);
					  }
					}
					interface I1{}
					class C1{}
					"""
            },
            "");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=91021
	public void test0583() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					class D<U> {
							 public D (D<U> anotherD) {
							 }
					}
					
					public class X<S> {
							 public static class C<T> {
							 		 public C(C<T> anotherC) {
							 		 }
							 }
					
							 public void mD(D<S> d) {
							 		 //the following line is OK (no warning reported)
							 		 new D<S>(d);
							 }
							\s
							 public void mC(C<S> c) {
							 		 /* type safety warning
							 		  * (The expression of type X.C<S>
							 		  * needs unchecked conversion to conform to
							 		  * XSB<S>.C<S>)
							 		  */
							 		 new C<S>(c);
							 }
							Zork z;
					}
					"""
            },
			"""
				----------
				1. ERROR in X.java (at line 25)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=91017
	public void test0584() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					import java.util.ArrayList;
					import java.util.List;
					
					public class X {
							 public static void main(String[] args) {
							 		 List<String> stringList = new ArrayList<String>();
							 		 stringList.add("foo");
							 		 List<Integer> intList = new ArrayList<Integer>();
							 		 intList.add(1);
					
							 		 List<?> untypedList = stringList;
							 		 List<?> untypedList2 = intList;
					
							 		 //correctly flagged as error: untypedList.add(new Object());
							 		 //ditto: untypedList.add(untypedList2.get(0));
					
							 		 //but this is not flagged at all by eclipse:
							 		 untypedList.addAll(untypedList2);
					
							 		 for(String s : stringList){
							 		 		 //next line generates runtime ClassCastException
							 		 		 Logger.log("Test_Lists.main: s: " + s);
							 		 }
							 }
					}
					"""
            },
    		"""
				----------
				1. ERROR in X.java (at line 18)
					untypedList.addAll(untypedList2);
					            ^^^^^^
				The method addAll(Collection<? extends capture#1-of ?>) in the type List<capture#1-of ?> is not applicable for the arguments (List<capture#2-of ?>)
				----------
				2. ERROR in X.java (at line 22)
					Logger.log("Test_Lists.main: s: " + s);
					^^^^^^
				Logger cannot be resolved
				----------
				""");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=90881
	public void test0585() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					import java.util.*;
					
					public class X {
					        public static void main(String[] args) {
					                Outer.Comparator<String> i = new Outer.Comparator<String>() {
					
					                        public boolean equals(String a, String b) {
					                                return false;
					                        }
					
					                        public int hashCode(String a) {
					                                return 0;
					                        }
					                };
					
					        }
					}
					
					class Outer {}
					""",
            },
			"""
				----------
				1. ERROR in X.java (at line 5)
					Outer.Comparator<String> i = new Outer.Comparator<String>() {
					^^^^^^^^^^^^^^^^
				Outer.Comparator cannot be resolved to a type
				----------
				2. ERROR in X.java (at line 5)
					Outer.Comparator<String> i = new Outer.Comparator<String>() {
					                                 ^^^^^^^^^^^^^^^^
				Outer.Comparator cannot be resolved to a type
				----------
				""");
	}

	// **
	// note: the test does not show the needed unchecked warning, since it is
	//       a conform test
	public void test0586() {
	    this.runConformTest(
            new String[] {
                "X.java",
				"""
					public class X {
					    static class BB<T, S> { }
					    static class BD<T> extends BB<T, T> { }
					    void f() {
					        BB<? extends Number, ? super Integer> bb = null;
					        Object o = (BD<Number>) bb;
					    }
					}
					""",
            },
			"");
	}

	public void test0587() {
	    this.runConformTest(
            new String[] {
                "X.java",
				"""
					interface DA<T> {
					}
					interface DB<T> extends DA<T> {
					}
					interface DC<T> extends DA<Integer> {
					}
					
					public class X {
						Object o = (DC<?>) (DA<?>) null;
					}
					""",
            },
			"");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=90433
	// **
	public void test0588() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
    			"""
					public class X<S extends Comparable<S>> {
						public void f() {
							Class<? extends Comparable<?>> cc = Long.class;
							Class<S> currentClass = null;
							boolean b = currentClass == Long.class;
							boolean c = X.class == Long.class;
					    }
					}
					""",
            },
    		"""
				----------
				1. ERROR in X.java (at line 6)
					boolean c = X.class == Long.class;
					            ^^^^^^^^^^^^^^^^^^^^^
				Incompatible operand types Class<X> and Class<Long>
				----------
				""");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=85281
	public void test0589() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					import java.util.ArrayList;
					import java.util.List;
					
					public class X {
					
						void addAll(List<? extends Number> target, List<? extends Number> source) {
							target.addAll(source);
						}
					
						public static void main(String... args) {
							List<Integer> ints = new ArrayList<Integer>();
							ints.add(3);
					
							List<Float> floats = new ArrayList<Float>();
							floats.add(3f);
					
							new X().addAll(ints, floats);
					
							for (Integer integer : ints) {
								System.out.println(integer.intValue());
							}
						}
					}
					""",
            },
    		"""
				----------
				1. ERROR in X.java (at line 7)
					target.addAll(source);
					       ^^^^^^
				The method addAll(Collection<? extends capture#1-of ? extends Number>) in the type List<capture#1-of ? extends Number> is not applicable for the arguments (List<capture#2-of ? extends Number>)
				----------
				""");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=85281 - variation
	public void test0590() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					import java.util.ArrayList;
					import java.util.List;
					
					public class X {
					
						void assignAll(Class<? super Number> sup, Class<? extends Number> ext) {
							Class<? super Number> superSup = sup.getSuperclass();
							Class<?> superExt = ext.getSuperclass();
							Class<? super Number> superSup2 = ext.getSuperclass();
						}\t
					}
					""",
            },
    		"""
				----------
				1. ERROR in X.java (at line 9)
					Class<? super Number> superSup2 = ext.getSuperclass();
					                                  ^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Class<capture#6-of ? super capture#5-of ? extends Number> to Class<? super Number>
				----------
				""");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=85281 - variation
	public void test0591() {
	    this.runConformTest(
            new String[] {
                "X.java",
				"""
					public class X<U> {
					
						public Values<U> foo(Box<? extends U> box) {
							return selectedValues(box.getValues());
						}
						public static <G> Values<G> selectedValues(Values<? extends G> v) {
							return null;
						}
					}
					
					abstract class Box<V> {
						  abstract Values<V> getValues();
					}
					abstract class Values<T> {
					}
					""",
            },
			"");
	}
	public void test0592() {
	    this.runConformTest(
            new String[] {
                "X.java",
				"""
					import java.util.*;
					public class X {
					    List<?> l;
					    void m() {
						m2(l);
					    }
					    <T> void m2(List<T> l2) {
						l2.add(l2.remove(0));
					    }
					}
					""",
            },
			"");
	}
	public void test0593() {
		Map options = getCompilerOptions();
		options.put(JavaCore.COMPILER_PB_UNCHECKED_TYPE_OPERATION, JavaCore.IGNORE);
		String bounds = isJRE15Plus ? "Object&Serializable&Comparable<?>&Constable" : "Object&Serializable&Comparable<?>";
	    String xSource =
				"""
			import java.util.*;
			public class X {
				    List<Class<?>> classes1 = Arrays.asList(String.class, Boolean.class);
				    List<? extends Class<?>> classes2 = Arrays.asList(String.class, Boolean.class);
			}
			""";
	    if (this.complianceLevel < ClassFileConstants.JDK1_8) {
	    	this.runNegativeTest(
    			new String[] {
    				"X.java",
    				xSource,
    			},
    			"----------\n" +
				"1. ERROR in X.java (at line 3)\n" +
				"	List<Class<?>> classes1 = Arrays.asList(String.class, Boolean.class);\n" +
				"	                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
				"Type mismatch: cannot convert from List<Class<? extends " + bounds + ">> to List<Class<?>>\n" +
				"----------\n",
				null,
				true,
				options);
	    } else {
	    	runConformTest(new String[] { "X.java", xSource }, options);
	    }
	}
	public void test0594() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					 import java.util.*;
					import static java.util.Map.*;
					
					abstract class MyIterator<E> implements Iterator<E> {
						Set<E> iteratedSet;
					}
					public class X {
					\t
						void foo() {
							Map<String, ?> map;
							Iterator<Entry<String, ?>> it = map.entrySet().iterator();
					
							Entry<String, Number> unrelatedEntry;
							MyIterator<Entry<String, ?>> mit = (MyIterator<Entry<String, ?>>) it;
							mit.iteratedSet.add(unrelatedEntry);
						}
					}
					""",
            },
    		"""
				----------
				1. ERROR in X.java (at line 11)
					Iterator<Entry<String, ?>> it = map.entrySet().iterator();
					                                ^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Iterator<Map.Entry<String,capture#1-of ?>> to Iterator<Map.Entry<String,?>>
				----------
				""");
	}
	public void test0595() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					 import java.util.*;
					import static java.util.Map.*;
					
					abstract class MyIterator<E> implements Iterator<E> {
						Set<E> iteratedSet;
					}
					public class X {
					\t
						void bar() {
							Map<? extends String, ?> map;
							Iterator<Entry<? extends String, ?>> it = map.entrySet().iterator();
					
							Entry<String, Number> unrelatedEntry;
							MyIterator<Entry<? extends String, ?>> mit = (MyIterator<Entry<? extends String, ?>>) it;
							mit.iteratedSet.add(unrelatedEntry);
						}
					}
					""",
            },
    		"""
				----------
				1. ERROR in X.java (at line 11)
					Iterator<Entry<? extends String, ?>> it = map.entrySet().iterator();
					                                          ^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Iterator<Map.Entry<capture#1-of ? extends String,capture#2-of ?>> to Iterator<Map.Entry<? extends String,?>>
				----------
				""");
	}
	public void test0596() {
	    this.runConformTest(
            new String[] {
                "X.java",
				"""
					import java.util.*;
					
					public class X {
						<T> Set<T> unmodifiableSet(Set<T> set) {
							return set;
						}
						public void foo(Set<?> s) {
							Set<?> s2 = unmodifiableSet(s);
						}
					}
					""",
            },
			"");
	}
	public void test0597() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					public class X<U> {
						Pair<U,U> m() {\s
							return null;\s
						}
						void foo(X<?> x) {
							x.m().first = x.m().second;
						}
					}
					\t
					class Pair<E, F> {
						E first;
						F second;
					}
					""",
            },
    		"""
				----------
				1. ERROR in X.java (at line 6)
					x.m().first = x.m().second;
					              ^^^^^^^^^^^^
				Type mismatch: cannot convert from capture#2-of ? to capture#1-of ?
				----------
				""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=90879
	// SHOULD FAIL AT 1.8 (18.2.3): The method sort(List<T>) in the type Collections is not applicable for the arguments (List<X>)
	public void test0598() {
	    this.runConformTest(
            new String[] {
                "X.java",
				"""
					import java.util.*;
					
					class X implements Comparable {
					
						public int compareTo(Object o) {
							return 0;
						}
					
					}
					
					class Y {
						public static void main(String[] args) {
							List<X> lx = null;
							Collections.sort(lx);
						}
					}
					""",
			},
			"");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=90879 - variation
	// SHOULD FAIL AT 1.8 (18.2.3): The method sort1(List<T>) in the type X is not applicable for the arguments (List<X>)
	public void test0599() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					import java.util.*;
					
					public class X implements Comparable {
						public static void main(String[] args) {
							Zork z;
						\t
							List<X> lx = null;
							sort1(lx);
							sort2(lx);
							sort3(lx);
							sort4(lx);
							sort5(lx);
						}
						public int compareTo(Object o) {
							return 0;
						}
						static <T extends Comparable<? super T>> void sort1(List<T> list) {}
						static <T extends Comparable<? extends T>> void sort2(List<T> list) {}
						static <T extends Comparable<?>> void sort3(List<T> list) {}
						static <T extends Comparable<T>> void sort4(List<T> list) {}
						static <T extends Comparable> void sort5(List<T> list) {}
					}
					""",
			},
			"""
				----------
				1. WARNING in X.java (at line 3)
					public class X implements Comparable {
					                          ^^^^^^^^^^
				Comparable is a raw type. References to generic type Comparable<T> should be parameterized
				----------
				2. ERROR in X.java (at line 5)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				3. WARNING in X.java (at line 8)
					sort1(lx);
					^^^^^^^^^
				Type safety: Unchecked invocation sort1(List<X>) of the generic method sort1(List<T>) of type X
				----------
				4. WARNING in X.java (at line 9)
					sort2(lx);
					^^^^^^^^^
				Type safety: Unchecked invocation sort2(List<X>) of the generic method sort2(List<T>) of type X
				----------
				5. WARNING in X.java (at line 11)
					sort4(lx);
					^^^^^^^^^
				Type safety: Unchecked invocation sort4(List<X>) of the generic method sort4(List<T>) of type X
				----------
				6. WARNING in X.java (at line 21)
					static <T extends Comparable> void sort5(List<T> list) {}
					                  ^^^^^^^^^^
				Comparable is a raw type. References to generic type Comparable<T> should be parameterized
				----------
				""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=90879 - variation
	// SHOULD FAIL AT 1.8 (18.2.3): The method sort6(List<T>) in the type X is not applicable for the arguments (List<MyEnum>)
	public void test0600() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					import java.util.*;
					
					public class X implements Comparable {
						public static void main(String[] args) {
							Zork z;
						\t
							List<MyEnum> le = null;
							sort6(le);
							sort7(le);
							sort8(le);
							sort9(le);
							sort10(le);
						}
						public int compareTo(Object o) {
							return 0;
						}
						static <T extends MyEnum<? super T>> void sort6(List<T> list) {}
						static <T extends MyEnum<? extends T>> void sort7(List<T> list) {}
						static <T extends MyEnum<?>> void sort8(List<T> list) {}
						static <T extends MyEnum<T>> void sort9(List<T> list) {}
						static <T extends MyEnum> void sort10(List<T> list) {}
					}
					class MyEnum<E extends MyEnum<E>> {}
					""",
            },
            """
				----------
				1. WARNING in X.java (at line 3)
					public class X implements Comparable {
					                          ^^^^^^^^^^
				Comparable is a raw type. References to generic type Comparable<T> should be parameterized
				----------
				2. ERROR in X.java (at line 5)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				3. WARNING in X.java (at line 7)
					List<MyEnum> le = null;
					     ^^^^^^
				MyEnum is a raw type. References to generic type MyEnum<E> should be parameterized
				----------
				4. WARNING in X.java (at line 8)
					sort6(le);
					^^^^^^^^^
				Type safety: Unchecked invocation sort6(List<MyEnum>) of the generic method sort6(List<T>) of type X
				----------
				5. WARNING in X.java (at line 9)
					sort7(le);
					^^^^^^^^^
				Type safety: Unchecked invocation sort7(List<MyEnum>) of the generic method sort7(List<T>) of type X
				----------
				6. WARNING in X.java (at line 11)
					sort9(le);
					^^^^^^^^^
				Type safety: Unchecked invocation sort9(List<MyEnum>) of the generic method sort9(List<T>) of type X
				----------
				7. WARNING in X.java (at line 21)
					static <T extends MyEnum> void sort10(List<T> list) {}
					                  ^^^^^^
				MyEnum is a raw type. References to generic type MyEnum<E> should be parameterized
				----------
				""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=85281 - variation
	public void test0601() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					public class X<U> {
					
						public Values<U> foo(Box<? extends U> box) {
							return selectedValues(box.getValues());
						}
						public static <G> Values<G> selectedValues(Values<G> v) {
							return null;
						}
					}
					
					abstract class Box<V> {
						  abstract Values<V> getValues();
					}
					abstract class Values<T> {
					}
					""",
            },
    		"""
				----------
				1. ERROR in X.java (at line 4)
					return selectedValues(box.getValues());
					       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Values<capture#1-of ? extends U> to Values<U>
				----------
				""");
	}
	public void test0602() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					public class X<U> {
					
						public void foo(Box<? extends U> box) {
							box.getValues()[0] = box.getValues()[1];
						}
					}
					
					abstract class Box<V> {
						  abstract Values<V>[] getValues();
					}
					abstract class Values<T> {
					}
					""",
            },
    		"""
				----------
				1. ERROR in X.java (at line 4)
					box.getValues()[0] = box.getValues()[1];
					                     ^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Values<capture#2-of ? extends U> to Values<capture#1-of ? extends U>
				----------
				""");
	}
	public void test0603() {
	    this.runConformTest(
            new String[] {
                "X.java",
				"""
					public class X<U> {
					
						public void foo(Box<? extends U>[] boxes) {
							boxes[0] = boxes[1];
						}
					}
					
					abstract class Box<V> {
						  abstract Values<V>[] getValues();
					}
					abstract class Values<T> {
					}
					""",
            },
			"");
	}
	// capture on array ref
	public void test0604() {
	    this.runConformTest(
            new String[] {
                "X.java",
				"""
					public class X<U> {
					
						public void foo(Box<? extends U>[] boxes) {
							bar(boxes[0], boxes[1]);
						}
						<V> void bar(V v1, V v2) {}
					}
					
					abstract class Box<V> {
						  abstract Values<V>[] getValues();
					}
					abstract class Values<T> {
					}
					""",
            },
			"");
	}
	// capture on array ref
	public void test0605() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					public class X<U> {
					
						public void foo(Box<? extends U> box) {
							box.getValues()[1] = box.getValues()[2];
						}
					}
					
					abstract class Box<V> {
						  abstract Values<V>[] getValues();
					}
					abstract class Values<T> {
					}
					""",
            },
    		"""
				----------
				1. ERROR in X.java (at line 4)
					box.getValues()[1] = box.getValues()[2];
					                     ^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Values<capture#2-of ? extends U> to Values<capture#1-of ? extends U>
				----------
				""");
	}
	public void test0606() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					public class X<U> {
					
						public void foo(Box<? extends U> box) {
							box.getValues()[1] = (Values<? extends U>) box.getValues()[2];
						}
						<V> void bar(V v1, V v2) {}
					}
					
					abstract class Box<V> {
						  abstract Values<V>[] getValues();
					}
					abstract class Values<T> {
					}
					""",
            },
    		"""
				----------
				1. ERROR in X.java (at line 4)
					box.getValues()[1] = (Values<? extends U>) box.getValues()[2];
					                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Values<capture#3-of ? extends U> to Values<capture#1-of ? extends U>
				----------
				""");
	}
	public void test0607() {
		this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					import java.util.*;
					
					public class X {
					
						void test01() {
							List<Comparable<Object>> lObj = new ArrayList<Comparable<Object>> ();
							Collections.sort (lObj);\t
						}
						void test02() {
							List<Comparable> lComp = new ArrayList<Comparable> ();
							Collections.sort (lComp);	\t
						}
						void test03() {
							List<Comparable<String>> lStr = new ArrayList<Comparable<String>> ();
							Collections.sort (lStr);
						}
					 }
					""",
            },
            "----------\n" +
    		"1. WARNING in X.java (at line 10)\n" +
    		"	List<Comparable> lComp = new ArrayList<Comparable> ();\n" +
    		"	     ^^^^^^^^^^\n" +
    		"Comparable is a raw type. References to generic type Comparable<T> should be parameterized\n" +
    		"----------\n" +
    		"2. WARNING in X.java (at line 10)\n" +
    		"	List<Comparable> lComp = new ArrayList<Comparable> ();\n" +
    		"	                                       ^^^^^^^^^^\n" +
    		"Comparable is a raw type. References to generic type Comparable<T> should be parameterized\n" +
    		"----------\n" +
    		"3. WARNING in X.java (at line 11)\n" +
    		"	Collections.sort (lComp);		\n" +
    		"	^^^^^^^^^^^^^^^^^^^^^^^^\n" +
    		"Type safety: Unchecked invocation sort(List<Comparable>) of the generic method sort(List<T>) of type Collections\n" +
    		(this.complianceLevel < ClassFileConstants.JDK1_8 ?
    		"----------\n" +
    		"4. ERROR in X.java (at line 15)\n" +
    		"	Collections.sort (lStr);\n" +
    		"	            ^^^^\n" +
    		"Bound mismatch: The generic method sort(List<T>) of type Collections is not applicable for the arguments (List<Comparable<String>>). The inferred type Comparable<String> is not a valid substitute for the bounded parameter <T extends Comparable<? super T>>\n" +
    		"----------\n" :
    			"----------\n" +
    			"4. ERROR in X.java (at line 15)\n" +
    			"	Collections.sort (lStr);\n" +
    			"	            ^^^^\n" +
    			"The method sort(List<T>) in the type Collections is not applicable for the arguments (List<Comparable<String>>)\n" +
    			"----------\n"));
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=84284 - check warnings
	// SHOULD FAIL AT 1.8 (18.2.3): The method sort(List<T>) in the type Collections is not applicable for the arguments (LinkedList<Ball>)
	public void test0608() {
	    this.runNegativeTest(
            new String[] {
                "Ball.java",
				"""
					import java.util.*;
					class Ball implements Comparable {
					
					    public int compareTo(Object o) {
					    	return 0;
					    }
					   \s
					    public static void main(String[] args) {
					    	LinkedList<Ball> foo = new LinkedList<Ball>();
					    	Collections.sort(foo);
					    }
						Zork z;
					}
					""",
            },
    		"""
				----------
				1. WARNING in Ball.java (at line 2)
					class Ball implements Comparable {
					                      ^^^^^^^^^^
				Comparable is a raw type. References to generic type Comparable<T> should be parameterized
				----------
				2. WARNING in Ball.java (at line 10)
					Collections.sort(foo);
					^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked invocation sort(LinkedList<Ball>) of the generic method sort(List<T>) of type Collections
				----------
				3. ERROR in Ball.java (at line 12)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=81831
	public void test0609() {
	    this.runConformTest(
            new String[] {
                "I.java",
				"interface I<T extends I<? super T>> {}\n",
            },
			"");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=89940
	public void test0610() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					 import java.util.List;
					
					public class X {
						void foo(List<Object> objects, List raw) {
					
						    List<Number> numbers;
						    List<? extends Number> ext;
						   \s
						    numbers= (List<Number>) objects; // correct - cast error
						    ext= (List<? extends Number>) objects; // wrong, should fail
					
						    ext= raw; // correct - raw conversion warning issued
						    numbers= raw; // correct - raw conversion warning issued
						}
					}
					""",
            },
    		"""
				----------
				1. WARNING in X.java (at line 4)
					void foo(List<Object> objects, List raw) {
					                               ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				2. ERROR in X.java (at line 9)
					numbers= (List<Number>) objects; // correct - cast error
					         ^^^^^^^^^^^^^^^^^^^^^^
				Cannot cast from List<Object> to List<Number>
				----------
				3. ERROR in X.java (at line 10)
					ext= (List<? extends Number>) objects; // wrong, should fail
					     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Cannot cast from List<Object> to List<? extends Number>
				----------
				4. WARNING in X.java (at line 12)
					ext= raw; // correct - raw conversion warning issued
					     ^^^
				Type safety: The expression of type List needs unchecked conversion to conform to List<? extends Number>
				----------
				5. WARNING in X.java (at line 13)
					numbers= raw; // correct - raw conversion warning issued
					         ^^^
				Type safety: The expression of type List needs unchecked conversion to conform to List<Number>
				----------
				""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=91696
	public void test0611() {
	    this.runConformTest(
            new String[] {
                "C.java",
				"""
					import java.io.Serializable;
					
					interface A<K extends A.BK<S>, S extends A.BS> {
						public interface BS extends Serializable {
						}
						public interface BK<SS> extends Serializable {
							public void put(SS a);
						}
					
						public P<K, S> getP();
					}
					
					class P<K extends A.BK<S>, S extends A.BS> {
						K k;
						S s;
					
						public void put() {
							k.put(s);
						}
					}
					
					public class C<T> implements A<C.K, C.S> {
						public static class K implements A.BK<C.S> {
							public void put(S a) {
							}
						}
						protected static class S implements A.BS {
						}
					
						public P<K, S> getP() {
							return null;
						}
					}
					""",
            },
			"");
	}
	public void test0612() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					import java.util.*;
					
					class MPair<A,B> {}
					
					public class X<K,V> {
					    private static class Bucket extends LinkedList<MPair<K,V>> {}
					    private Bucket[] buckets = new X.Bucket[100];
					}
					""",
            },
    		"""
				----------
				1. ERROR in X.java (at line 6)
					private static class Bucket extends LinkedList<MPair<K,V>> {}
					                                                     ^
				Cannot make a static reference to the non-static type K
				----------
				2. ERROR in X.java (at line 6)
					private static class Bucket extends LinkedList<MPair<K,V>> {}
					                                                       ^
				Cannot make a static reference to the non-static type V
				----------
				""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=84973
	public void test0613() {
	    this.runNegativeTest(
            new String[] {
                "Map.java",
				"""
					package xy;
					import xy.Map.Entry;
					
					class Map<M> {
					    class Entry<E> { }
					}
					class User {
					    void a(Entry<String> e) { } // Entry<String> is illegal (eclipse accepts)
					    void c(Map.Entry<String> e) { } // illegal (correctly flagged)
					    void b(Entry e) { } // OK
					    void d(Map<Integer>.Entry<String> e) { } // OK
					}
					""",
            },
            """
				----------
				1. ERROR in Map.java (at line 8)
					void a(Entry<String> e) { } // Entry<String> is illegal (eclipse accepts)
					       ^^^^^
				The member type Map.Entry<String> must be qualified with a parameterized type, since it is not static
				----------
				2. ERROR in Map.java (at line 9)
					void c(Map.Entry<String> e) { } // illegal (correctly flagged)
					       ^^^^^^^^^
				The member type Map.Entry<String> must be qualified with a parameterized type, since it is not static
				----------
				3. WARNING in Map.java (at line 10)
					void b(Entry e) { } // OK
					       ^^^^^
				Map.Entry is a raw type. References to generic type Map<M>.Entry<E> should be parameterized
				----------
				""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=84973 - variation
	public void test0614() {
	    this.runNegativeTest(
            new String[] {
                "X1.java",
				"""
					class X1 {
						static class X2<T> {
							class X3<U> {
							}
						}
					}
					class Y1 {
						class Y2 extends X1.X2<Exception> {
							void foo() {
								X3<String> x;
							}
						}
						Zork z;
					}
					""",
            },
			"""
				----------
				1. ERROR in X1.java (at line 13)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=84973 - variation
	public void test0615() {
	    this.runNegativeTest(
            new String[] {
                "X1.java",
				"""
					class X1 {
						static class X2<T> {
							class X3<U> {
							}
						}
					}
					class Y1 {
						class Y2 extends X1.X2 {
							void foo() {
								X3<String> x;
							}
						}
					}
					""",
            },
            """
				----------
				1. WARNING in X1.java (at line 8)
					class Y2 extends X1.X2 {
					                 ^^^^^
				X1.X2 is a raw type. References to generic type X1.X2<T> should be parameterized
				----------
				2. ERROR in X1.java (at line 10)
					X3<String> x;
					^^
				The member type X1.X2.X3<String> must be qualified with a parameterized type, since it is not static
				----------
				""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=84973 - variation
	public void test0616() {
	    this.runNegativeTest(
            new String[] {
                "Map.java",
				"""
					package xy;
					import xy.Map.Entry;
					
					class Map<M> {
					    class Entry<E> { }
					}
					class User extends Map<String> {
					    void a(Entry<String> e) { } // Entry<String> is illegal (eclipse accepts)
					    void c(Map.Entry<String> e) { } // illegal (correctly flagged)
					    void b(Entry e) { } // OK
					    void d(Map<Integer>.Entry<String> e) { } // OK
					}
					""",
            },
            """
				----------
				1. ERROR in Map.java (at line 9)
					void c(Map.Entry<String> e) { } // illegal (correctly flagged)
					       ^^^^^^^^^
				The member type Map.Entry<String> must be qualified with a parameterized type, since it is not static
				----------
				2. WARNING in Map.java (at line 10)
					void b(Entry e) { } // OK
					       ^^^^^
				Map.Entry is a raw type. References to generic type Map<M>.Entry<E> should be parameterized
				----------
				""");
	}
public void test0617() {
        this.runNegativeTest(
            new String[] {
                "X.java",
                """
					public class X {
					
					   public void foo() {
					       String s = null;
					       ZZZ1<?>.ZZZ2<?>.ZZZ3<?> var = null;
					       s = var;
					   }
					}
					
					class ZZZ1<T1> {
					  class ZZZ2<T2> {
					    class ZZZ3<T3> {}
					  }
					}
					""",
            },
    		"""
				----------
				1. ERROR in X.java (at line 6)
					s = var;
					    ^^^
				Type mismatch: cannot convert from ZZZ1<?>.ZZZ2<?>.ZZZ3<capture#1-of ?> to String
				----------
				""");
    }
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=84973 - variation
	public void test0618() {
		String expectedError = 	this.complianceLevel < ClassFileConstants.JDK16 ?
	            """
					----------
					1. ERROR in Map.java (at line 5)
						static void foo(Entry<String> e) { } // invalid static ref
						            ^^^^^^^^^^^^^^^^^^^^
					The method foo cannot be declared static; static methods can only be declared in a static or top level type
					----------
					2. ERROR in Map.java (at line 5)
						static void foo(Entry<String> e) { } // invalid static ref
						                ^^^^^
					Cannot make a static reference to the non-static type Entry
					----------
					3. ERROR in Map.java (at line 8)
						Entry<String> entry; // invalid static ref
						^^^^^
					Cannot make a static reference to the non-static type Entry
					----------
					4. ERROR in Map.java (at line 11)
						void c(Map.Entry<String> e) { } // illegal\s
						       ^^^^^^^^^
					The member type Map.Entry<String> must be qualified with a parameterized type, since it is not static
					----------
					5. WARNING in Map.java (at line 12)
						void b(Entry e) { } // OK
						       ^^^^^
					Map.Entry is a raw type. References to generic type Map<M>.Entry<E> should be parameterized
					----------
					"""
	    		:
	            """
					----------
					1. ERROR in Map.java (at line 5)
						static void foo(Entry<String> e) { } // invalid static ref
						                ^^^^^
					Cannot make a static reference to the non-static type Entry
					----------
					2. ERROR in Map.java (at line 8)
						Entry<String> entry; // invalid static ref
						^^^^^
					Cannot make a static reference to the non-static type Entry
					----------
					3. ERROR in Map.java (at line 11)
						void c(Map.Entry<String> e) { } // illegal\s
						       ^^^^^^^^^
					The member type Map.Entry<String> must be qualified with a parameterized type, since it is not static
					----------
					4. WARNING in Map.java (at line 12)
						void b(Entry e) { } // OK
						       ^^^^^
					Map.Entry is a raw type. References to generic type Map<M>.Entry<E> should be parameterized
					----------
					""";
	        	this.runNegativeTest(
            new String[] {
                "Map.java",
				"""
					class Map<M> {
					    class Entry<E> { }
					    class Foo {
					    	Entry<String> entry;
					    	static void foo(Entry<String> e) { } // invalid static ref
					    }
					    static class Bar {
					    	Entry<String> entry; // invalid static ref
					    }
					    void a(Entry<String> e) { } // OK
					    void c(Map.Entry<String> e) { } // illegal\s
					    void b(Entry e) { } // OK
					    void d(Map<Integer>.Entry<String> e) { } // OK
					}
					""",
            },
	    	expectedError);
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=89440
	public void test0619() {
	    this.runConformTest(
            new String[] {
                "X.java",
				"""
					interface ISample<V> {
						public static enum Stuff {
							FIRST, SECOND, THIRD
						};
					}
					
					class SampleClass {
						public void doSomething(ISample.Stuff thing) {
					
						}
					}
					
					public class X {
						public void doSomething() {
							SampleClass sample = new SampleClass();
							sample.doSomething(ISample.Stuff.FIRST);
						}
					}
					""",
            },
			"");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=84551
	public void test0620() {
	    this.runNegativeTest(
            new String[] {
                "Outer.java",
				"""
					public class Outer<O> {
						class Inner { }
					\t
						static void test(Inner i) { }
					}
					""",
            },
			"""
				----------
				1. ERROR in Outer.java (at line 4)
					static void test(Inner i) { }
					                 ^^^^^
				Cannot make a static reference to the non-static type Inner
				----------
				""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=84551- variation
	public void test0621() {
	    this.runConformTest(
            new String[] {
                "Outer.java",
				"""
					public class Outer {
						class Inner { }
					\t
						static void test(Inner i) { }
					}
					""",
            },
			"");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=84551 - variation
	public void test0622() {
	    this.runConformTest(
            new String[] {
                "Outer.java",
				"""
					public class Outer<O> {
						static class Inner { }
					\t
						static void test(Inner i) { }
					}
					""",
            },
			"");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=84551 - variation
	public void test0623() {
	    this.runConformTest(
            new String[] {
                "X.java",
				"""
					public class X<T> {
						static class Outer {
							class Inner { }
							static void test(Inner i) { }
						}
					}
					""",
            },
			"");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=83034
	public void test0624() {
	    this.runConformTest(
            new String[] {
                "X.java",
				"""
					 interface IFoo<U, V extends X<U, V>> {
						V bar(int i);
					}
					
					public class X<E, F extends X<E, F>> {
					\t
						public boolean foo(X<E, ?> x) {
							return false;
						}
						public boolean baz(IFoo<E, ?> f) {
							return foo(f.bar(0));
						}
					}
					""",
            },
			"");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=83034 - variation
	public void test0625() {
	    this.runConformTest(
            new String[] {
                "Foo.java",
				"""
					public class Foo<K> {
						public enum Mode {
							A
						};
						public void test(Mode mode) {
						}
					}\s
					""",
            },
			"");
	    this.runConformTest(
            new String[] {
                "X.java",
				"""
					public class X {
						enum Keys {
							B
						};
						public void test() {
							Foo<Keys> foo = new Foo<Keys>();
							foo.test(Foo.Mode.A); // error
						}
					}\s
					""",
            },
			"",
			null,
			false,
			null);
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=92037
	public void test0626() {
		String errMessage = isMinimumCompliant(ClassFileConstants.JDK11) ?
				"""
					----------
					1. WARNING in X.java (at line 7)
						private static class B<A> {
						                       ^
					The type parameter A is hiding the type X.A
					----------
					2. ERROR in X.java (at line 21)
						System.out.println(b instanceof C);
						                   ^^^^^^^^^^^^^^
					Incompatible conditional operand types X.B<X.A> and X.C
					----------
					"""
	    		:
	    		"""
					----------
					1. WARNING in X.java (at line 7)
						private static class B<A> {
						                       ^
					The type parameter A is hiding the type X.A
					----------
					2. WARNING in X.java (at line 11)
						private static class AA extends A {
						                     ^^
					Access to enclosing constructor X.A() is emulated by a synthetic accessor method
					----------
					3. WARNING in X.java (at line 15)
						private static class C extends B<AA> {
						                     ^
					Access to enclosing constructor X.B<A>() is emulated by a synthetic accessor method
					----------
					4. ERROR in X.java (at line 21)
						System.out.println(b instanceof C);
						                   ^^^^^^^^^^^^^^
					Incompatible conditional operand types X.B<X.A> and X.C
					----------
					""";
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					public class X {
					
						private static class A {
					
						}
					
						private static class B<A> {
					
						}
					
						private static class AA extends A {
					
						}
					
						private static class C extends B<AA> {
					
						}
					
						public static void main(String[] args) {
							B<A> b = new B<A>();
							System.out.println(b instanceof C);
						}
					}
					""",
            }, errMessage);
	}

	public void test0627() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					import java.util.List;
					
					public class X {
					
						<T> List<? extends T> foo(List<? extends T> l1, List<? extends T> l2) {
							return l1;
						}
						void bar(List<String> l1, List<Integer> l2) {
							String s = foo(l1, l2);
						}
					}
					""",
            },
    		"----------\n" +
    		"1. ERROR in X.java (at line 9)\n" +
    		"	String s = foo(l1, l2);\n" +
    		"	           ^^^^^^^^^^^\n" +
    		"Type mismatch: cannot convert from List<capture#2-of ? extends "+intersection("Object","Serializable","Comparable<?>")+"> to String\n" +
    		"----------\n");
	}
	// check capture for conditional operator
	public void test0628() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					import java.util.List;
					
					public class X {
					
						<T> List<? extends T> foo(List<? extends T> l1, List<? extends T> l2) {
							return l1;
						}
						void bar(List<Float> l1, List<Integer> l2) {
							List<?> l3 = null;
							String s = l1 != null ? foo(l1, l2) : l3;
						}
					}
					""",
            },
            this.complianceLevel < ClassFileConstants.JDK1_8 ?
	    		"""
					----------
					1. ERROR in X.java (at line 10)
						String s = l1 != null ? foo(l1, l2) : l3;
						           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
					Type mismatch: cannot convert from List<capture#4-of ? extends Object> to String
					----------
					""" :
	    			"----------\n" +
	    			"1. ERROR in X.java (at line 10)\n" +
	    			"	String s = l1 != null ? foo(l1, l2) : l3;\n" +
		    		"	                        ^^^^^^^^^^^\n" +
		    		"Type mismatch: cannot convert from List<capture#2-of ? extends Number & "+intersection("Comparable<?>")+"> to String\n" +
	    			"----------\n");
	}
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=92556
	public void test0629() {
	    this.runConformTest(
            new String[] {
                "X.java",
				"""
					public class X {
						public abstract class Context<N extends Number> {
							private Strategy<N, ? super Context<N>> strategy;
							public void setStrategy(Strategy<N, ? super Context<N>> strategy) {
								this.strategy = strategy;
							}
							// m?thode qui utilise la strat?gie
							public N call() throws Exception {
								return this.strategy.call(this);
							}
						}
						public interface Strategy<N extends Number, C extends Context<N>> {
							public abstract N call(C context);
						}
					
					}\s
					""",
            },
			"");
	}
	public void test0630() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					import java.util.ArrayList;
					import java.util.List;
					
					@SuppressWarnings("null")
					public class X {
					
						void test0() {
							List<? super Number[]> arrays= new ArrayList<Number[]>();
							Number[] a= null;
							arrays.add(null);
							arrays.add(a); // Error: The method add(capture-of ? super Number[]) in the type List<capture-of ? super Number[]> is not applicable for the arguments (Number[])
						}
					
						void test01() {
							List<? extends Number[]> arrays= new ArrayList<Number[]>();
							Number[] a= null;
							arrays.add(null);
							arrays.add(a); // Error: The method add(capture-of ? extends Number[]) in the type List<capture-of ? super Number[]> is not applicable for the arguments (Number[])
						}
					\t
						void test02() {
							List<? super Number> nums= null;
							Number n= null;
							nums.add(null);
							nums.add(n);
						}
					
						void test3() {
							List<? super List<Number>> nums= null;
							List<Number> n= null;
							nums.add(null);
							nums.add(n);
						}
					}
					""",
	        },
			"""
				----------
				1. ERROR in X.java (at line 18)
					arrays.add(a); // Error: The method add(capture-of ? extends Number[]) in the type List<capture-of ? super Number[]> is not applicable for the arguments (Number[])
					       ^^^
				The method add(capture#4-of ? extends Number[]) in the type List<capture#4-of ? extends Number[]> is not applicable for the arguments (Number[])
				----------
				""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=93044
	public void test0631() {
		this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					import java.lang.annotation.RetentionPolicy;
					
					public class X
					{
							 public static void main(String[] args)
							 {
							 		 Class<? extends Enum<?>> c = RetentionPolicy.class;
							 		 System.out.println(Enum.valueOf(c, "CLASS"));
							 }
					}
					""",
	        },
	        this.complianceLevel < ClassFileConstants.JDK1_8 ?
	        """
				----------
				1. ERROR in X.java (at line 8)
					System.out.println(Enum.valueOf(c, "CLASS"));
					                        ^^^^^^^
				Bound mismatch: The generic method valueOf(Class<T>, String) of type Enum<E> is not applicable for the arguments (Class<capture#1-of ? extends Enum<?>>, String). The inferred type capture#1-of ? extends Enum<?> is not a valid substitute for the bounded parameter <T extends Enum<T>>
				----------
				""" :
				"""
					----------
					1. ERROR in X.java (at line 8)
						System.out.println(Enum.valueOf(c, "CLASS"));
						                        ^^^^^^^
					The method valueOf(Class<T>, String) in the type Enum is not applicable for the arguments (Class<capture#1-of ? extends Enum<?>>, String)
					----------
					""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=92982
	public void test0632() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					import java.util.Vector;
					
					@SuppressWarnings("null")
					public class X {
						void test01() {
							Vector<? super java.lang.Object[]> lhs = null;
							Vector<? extends java.lang.Object[]> rhs = null;
							lhs.add(rhs.get(0));
						}
						void test02() {
							Vector<? extends java.lang.Object[]> lhs = null;
							Vector<? extends java.lang.Object[]> rhs = null;
							lhs.add(rhs.get(0));
						}
						void test3() {
							Vector<? super java.lang.Object[]> lhs = null;
							Vector<? super java.lang.Object[]> rhs = null;
							lhs.add(rhs.get(0));
						}
						void test4() {
							Vector<?  extends java.lang.Object[]> lhs = null;
							Vector<? super java.lang.Object[]> rhs = null;
							lhs.add(rhs.get(0));
						}
					}
					""",
	        },
			"""
				----------
				1. ERROR in X.java (at line 13)
					lhs.add(rhs.get(0));
					    ^^^
				The method add(capture#3-of ? extends Object[]) in the type Vector<capture#3-of ? extends Object[]> is not applicable for the arguments (capture#4-of ? extends Object[])
				----------
				2. ERROR in X.java (at line 18)
					lhs.add(rhs.get(0));
					    ^^^
				The method add(capture#5-of ? super Object[]) in the type Vector<capture#5-of ? super Object[]> is not applicable for the arguments (capture#6-of ? super Object[])
				----------
				3. ERROR in X.java (at line 23)
					lhs.add(rhs.get(0));
					    ^^^
				The method add(capture#7-of ? extends Object[]) in the type Vector<capture#7-of ? extends Object[]> is not applicable for the arguments (capture#8-of ? super Object[])
				----------
				""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=92982 - variation
	public void test0633() {
	    runConformTest(
    		// test directory preparation
    		true /* flush output directory */,
    		new String[] { /* test files */
                "X.java",
				"""
					import java.util.Vector;
					
					public class X {
						void test1() {
							Vector<? super Object[]> lhs = null;
							Vector<Object[]> rhs = null;
							lhs.add(rhs.get(0));\s
							foo(rhs.get(0)); // ok #foo(Object[])
						}
						void foo(Object[] objs) {
						}
					}
					""",
	        },
			// compiler results
			null /* do not check compiler log */,
			// runtime results
			"" /* expected output string */,
			null /* do not check error string */,
			// javac options
			JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=90775
	public void test0634() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					import java.lang.reflect.Array;
					
					public class X<T> {
					
						T[] theArray;
					
						public X(Class<T> clazz) {
							theArray = (T[]) Array.newInstance(clazz, 10); // Compiler warning
						}
					
						public T get(int i) {
							return theArray[i];
						}
					
						public static void main(String[] args) {
							X<Integer> t = new X<Integer>(Integer.class);
							// GenericsArray1<Integer> t = new GenericsArray1<Integer>( int.class );
							Object[] o = t.theArray;
						}
					  Zork z;
					}
					""",
	        },
	        """
				----------
				1. WARNING in X.java (at line 8)
					theArray = (T[]) Array.newInstance(clazz, 10); // Compiler warning
					           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Object to T[]
				----------
				2. ERROR in X.java (at line 20)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=93298
	public void test0635() {
	    this.runConformTest(
            new String[] {
                "X.java",
				"""
					import java.util.Iterator;
					public class X {
						public static class Indexed <U>  {
							public Iterator<U> foo() {
								return new IndexedIter();
							}
							class IndexedIter implements Iterator<U> {
								public boolean hasNext() {
									return false;
								}
								public U next() {
									return null;
								}
								public void remove() {
								}
							}
						}
					}
					""",
	        },
			"");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=78084
	public void test0636() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
			"""
				public abstract class X<T> {
				  public final T element() {
				    T result = (T) customElement(); // reports unnecessary cast
				    return result;
				  }
				  protected abstract Object customElement();
				  Zork z;
				}
				""",
	        },
	        """
				----------
				1. WARNING in X.java (at line 3)
					T result = (T) customElement(); // reports unnecessary cast
					           ^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Object to T
				----------
				2. ERROR in X.java (at line 7)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=84968
	public void test0637() {
	    this.runConformTest(
            new String[] {
                "X.java",
				"""
					public class X<E> {
						public static final class Ex1 extends Exception {
							private static final long serialVersionUID = 1;
						}
					
						private void a1() {
							try {
								a1_1();
							} catch (Ex1 si) {
								assert si != null;
							}
						}
					
						protected Object a1_1() throws Ex1 {
							return null;
						}
					
						private void a2() {
							try {
								a2_1();
							} catch (Ex2 si) {
								assert si != null;
							}
						}
					
						protected Object a2_1() throws Ex2 {
							return null;
						}
					
						public final static class Ex3 extends Exception {
							private static final long serialVersionUID = 1;
						}
					
						private void a3() {
							try {
								a3_1();
							} catch (Ex3 si) {
								assert si != null;
							}
						}
					
						protected Object a3_1() throws Ex3 {
							return null;
						}
					
					}
					
					final class Ex2 extends Exception {
						private static final long serialVersionUID = 1;
					}
					""",
	        },
			"");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=93478
	public void test0638() {
	    this.runConformTest(
            new String[] {
                "X.java",
				"""
					import java.util.concurrent.BlockingQueue;
					
					public class X {
						static interface IMX<S, L> {
							void call(L a, S b);
						}
						static interface Y<S, L> {
							void addX(final IMX<S, L> a);
							void removeX(final IMX<S, L> a);
						}
						static final class Pair<T, V> {
							T first;
					
							V second;
						}
						static class Bar<P> {
							Bar(final BlockingQueue<P> a) {
					
							}
						}
					}
					
					final class Foo<S, L> extends X.Bar<X.Pair<L[], S>> implements X.IMX<S, L> {
						Foo(final BlockingQueue<X.Pair<L[], S>> in) {
							super(in);
						}
						public void call(L a, S b) {
						}
					}
					""",
	        },
			"");
	}
	public void test0639() {
	    this.runConformTest(
            new String[] {
                "X.java",
				"""
					import java.lang.annotation.Annotation;
					import java.lang.reflect.*;
					
					@interface MyAnnotation {
					}
					public class X {
						void test() throws Exception {
							Class type = X.class;
							Method method = type.getMethod("test");
							Constructor constructor = type.getConstructor();
							Field field = type.getField("field");
							Package packge = type.getPackage();
							MyAnnotation typeAnnot = getAnnotation(MyAnnotation.class);
							MyAnnotation methodAnnot = getAnnotation(MyAnnotation.class);
							MyAnnotation constrAnnot = getAnnotation(MyAnnotation.class);
							MyAnnotation fieldAnnot = getAnnotation(MyAnnotation.class);
							MyAnnotation packgeAnnot = getAnnotation(MyAnnotation.class);
						}
					
						int field;
					\t
						<U extends Annotation> U getAnnotation(Class<U> annotatedType) {
							return null;
						}
					}
					""",
	        },
			"");
	}
	public void test0640() {
	    this.runConformTest(
            new String[] {
                "X.java",
				"""
					import java.lang.annotation.Annotation;
					import java.lang.reflect.*;
					
					@interface MyAnnotation {
					}
					public class X {
						void test() throws Exception {
							Class<?> type = X.class;
							Method method = type.getMethod("test");
							Constructor constructor = type.getConstructor();
							Field field = type.getField("field");
							Package packge = type.getPackage();
							MyAnnotation typeAnnot = getAnnotation(MyAnnotation.class);
							MyAnnotation methodAnnot = getAnnotation(MyAnnotation.class);
							MyAnnotation constrAnnot = getAnnotation(MyAnnotation.class);
							MyAnnotation fieldAnnot = getAnnotation(MyAnnotation.class);
							MyAnnotation packgeAnnot = getAnnotation(MyAnnotation.class);
						}
					
						int field;
					\t
						<U extends Annotation> U getAnnotation(Class<U> annotatedType) {
							return null;
						}
					}
					""",
	        },
			"");
	}
	public void test0641() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					import java.lang.reflect.*;
					
					@interface MyAnnotation {
					}
					@SuppressWarnings("all")
					public class X {
						void test() throws Exception {
							Class type = X.class;
							Method method = type.getMethod("test");
							Constructor constructor = type.getConstructor();
							Field field = type.getField("field");
							Package packge = type.getPackage();
							MyAnnotation typeAnnot = type.getAnnotation(MyAnnotation.class);
							MyAnnotation methodAnnot = method.getAnnotation(MyAnnotation.class);
							MyAnnotation constrAnnot = constructor.getAnnotation(MyAnnotation.class);
							MyAnnotation fieldAnnot = field.getAnnotation(MyAnnotation.class);
							MyAnnotation packgeAnnot = packge.getAnnotation(MyAnnotation.class);
						}
					
						int field;
					}
					""",
	        },
	        """
				----------
				1. ERROR in X.java (at line 13)
					MyAnnotation typeAnnot = type.getAnnotation(MyAnnotation.class);
					                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Annotation to MyAnnotation
				----------
				2. ERROR in X.java (at line 15)
					MyAnnotation constrAnnot = constructor.getAnnotation(MyAnnotation.class);
					                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Annotation to MyAnnotation
				----------
				""");
	}
	public void test0642() {
	    this.runConformTest(
            new String[] {
                "X.java",
				"""
					import java.lang.reflect.*;
					
					@interface MyAnnotation {
					}
					@SuppressWarnings("all")
					public class X {
						void test() throws Exception {
							Class<?> type = X.class;
							Method method = type.getMethod("test");
							Constructor<?> constructor = type.getConstructor();
							Field field = type.getField("field");
							Package packge = type.getPackage();
							MyAnnotation typeAnnot = type.getAnnotation(MyAnnotation.class);
							MyAnnotation methodAnnot = method.getAnnotation(MyAnnotation.class);
							MyAnnotation constrAnnot = constructor.getAnnotation(MyAnnotation.class);
							MyAnnotation fieldAnnot = field.getAnnotation(MyAnnotation.class);
							MyAnnotation packgeAnnot = packge.getAnnotation(MyAnnotation.class);
						}
					
						int field;
					}
					""",
	        },
			"");
	}
	public void test0643() {
	    this.runConformTest(
            new String[] {
                "X.java",
				"""
					public class X<T> {
					\t
						static <U> U foo(U u) {
							return u;
						}
					\t
						void bar(X x) {
							String str = x.foo("hello");
						}
					}
					""",
	        },
			"");
	}
	public void test0644() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					public class X<T> {
					\t
						<U> U foo(U u) {
							return u;
						}
					\t
						void bar(X x) {
							String str = x.foo("hello");
						}
					}
					""",
	        },
	        """
				----------
				1. WARNING in X.java (at line 7)
					void bar(X x) {
					         ^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				2. WARNING in X.java (at line 8)
					String str = x.foo("hello");
					             ^^^^^^^^^^^^^^
				Type safety: The method foo(Object) belongs to the raw type X. References to generic type X<T> should be parameterized
				----------
				3. ERROR in X.java (at line 8)
					String str = x.foo("hello");
					             ^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Object to String
				----------
				""");
	}
	public void test0645() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					import java.lang.annotation.Annotation;
					
					@interface MyAnnotation {
					}
					
					class X {
						void bar(XClass<String> arg) {
							XClass xc = new XClass();
							String str = xc.getConstructor().getAnnotation(arg);
						}
					}
					
					class XClass<U> {
						XConstructor<U> getConstructor() {
							return null;
						}
					}
					class XConstructor<V> {
						<W extends Annotation> W getAnnotation(XClass<W> cl) {
							return null;
						}
					}
					""",
	        },
			"""
				----------
				1. WARNING in X.java (at line 8)
					XClass xc = new XClass();
					^^^^^^
				XClass is a raw type. References to generic type XClass<U> should be parameterized
				----------
				2. WARNING in X.java (at line 8)
					XClass xc = new XClass();
					                ^^^^^^
				XClass is a raw type. References to generic type XClass<U> should be parameterized
				----------
				3. WARNING in X.java (at line 9)
					String str = xc.getConstructor().getAnnotation(arg);
					             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: The method getAnnotation(XClass) belongs to the raw type XConstructor. References to generic type XConstructor<V> should be parameterized
				----------
				4. ERROR in X.java (at line 9)
					String str = xc.getConstructor().getAnnotation(arg);
					             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Annotation to String
				----------
				""");
	}
	public void test0646() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					public class X {
						public static void main(String[] args) {
							Outer.Inner inner = new Outer().new Inner();
							X x = inner.setOuterT(new X());
						\t
							Outer<String>.Inner innerS = inner;
						}
					}
					
					class Outer<T> {
						T t;
						class Inner {
							T setOuterT(T t1) {
								t = t1;
								return t;
							}
						}
					}
					""",
	        },
	        """
				----------
				1. WARNING in X.java (at line 3)
					Outer.Inner inner = new Outer().new Inner();
					^^^^^^^^^^^
				Outer.Inner is a raw type. References to generic type Outer<T>.Inner should be parameterized
				----------
				2. WARNING in X.java (at line 3)
					Outer.Inner inner = new Outer().new Inner();
					                        ^^^^^
				Outer is a raw type. References to generic type Outer<T> should be parameterized
				----------
				3. WARNING in X.java (at line 3)
					Outer.Inner inner = new Outer().new Inner();
					                                    ^^^^^
				Outer.Inner is a raw type. References to generic type Outer<T>.Inner should be parameterized
				----------
				4. WARNING in X.java (at line 4)
					X x = inner.setOuterT(new X());
					      ^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: The method setOuterT(Object) belongs to the raw type Outer.Inner. References to generic type Outer<T>.Inner should be parameterized
				----------
				5. ERROR in X.java (at line 4)
					X x = inner.setOuterT(new X());
					      ^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Object to X
				----------
				6. WARNING in X.java (at line 6)
					Outer<String>.Inner innerS = inner;
					                             ^^^^^
				Type safety: The expression of type Outer.Inner needs unchecked conversion to conform to Outer<String>.Inner
				----------
				""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=94644
	public void test0647() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					public class X {
						public static void main(String[] args) {
							Outer.Inner inner = new Outer().new Inner();
							X x = inner.set(new X());
						\t
							Outer<String>.Inner innerS = inner;
						}
					}
					
					class Outer<T> {
						T t;
						static class Inner<U> {
							U set(U u) {
								return u;
							}
						}
					}
					""",
	        },
            """
				----------
				1. WARNING in X.java (at line 3)
					Outer.Inner inner = new Outer().new Inner();
					^^^^^^^^^^^
				Outer.Inner is a raw type. References to generic type Outer.Inner<U> should be parameterized
				----------
				2. ERROR in X.java (at line 3)
					Outer.Inner inner = new Outer().new Inner();
					                    ^^^^^^^^^^^
				Illegal enclosing instance specification for type Outer.Inner
				----------
				3. WARNING in X.java (at line 3)
					Outer.Inner inner = new Outer().new Inner();
					                        ^^^^^
				Outer is a raw type. References to generic type Outer<T> should be parameterized
				----------
				4. WARNING in X.java (at line 3)
					Outer.Inner inner = new Outer().new Inner();
					                                    ^^^^^
				Outer.Inner is a raw type. References to generic type Outer.Inner<U> should be parameterized
				----------
				5. WARNING in X.java (at line 4)
					X x = inner.set(new X());
					      ^^^^^^^^^^^^^^^^^^
				Type safety: The method set(Object) belongs to the raw type Outer.Inner. References to generic type Outer.Inner<U> should be parameterized
				----------
				6. ERROR in X.java (at line 4)
					X x = inner.set(new X());
					      ^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Object to X
				----------
				7. ERROR in X.java (at line 6)
					Outer<String>.Inner innerS = inner;
					^^^^^^^^^^^^^^^^^^^
				The member type Outer.Inner<U> cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type Outer<String>
				----------
				""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=94644 - variation
	public void test0648() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					public class X {
						void foo() {
							Outer.Inner inner = new Sub().get();
						}
						Zork z;
					}
					class Outer<T> {
						class Inner<U> {
						}
					}
					class Sub extends Outer {
						Inner get() { return null; }
					}
					""",
	        },
	        """
				----------
				1. WARNING in X.java (at line 3)
					Outer.Inner inner = new Sub().get();
					^^^^^^^^^^^
				Outer.Inner is a raw type. References to generic type Outer<T>.Inner<U> should be parameterized
				----------
				2. ERROR in X.java (at line 5)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				3. WARNING in X.java (at line 11)
					class Sub extends Outer {
					                  ^^^^^
				Outer is a raw type. References to generic type Outer<T> should be parameterized
				----------
				4. WARNING in X.java (at line 12)
					Inner get() { return null; }
					^^^^^
				Outer.Inner is a raw type. References to generic type Outer<T>.Inner<U> should be parameterized
				----------
				""");
	}
	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=94644 - variation
	public void test0649() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					public class X {
						void foo() {
							Outer<String>.Inner inner = new Sub().get();
						}
						Zork z;
					}
					class Outer<T> {
						class Inner {
						}
					}
					class Sub extends Outer {
						Inner get() { return null; }
					}
					""",
	        },
	        """
				----------
				1. WARNING in X.java (at line 3)
					Outer<String>.Inner inner = new Sub().get();
					                            ^^^^^^^^^^^^^^^
				Type safety: The expression of type Outer.Inner needs unchecked conversion to conform to Outer<String>.Inner
				----------
				2. ERROR in X.java (at line 5)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				3. WARNING in X.java (at line 11)
					class Sub extends Outer {
					                  ^^^^^
				Outer is a raw type. References to generic type Outer<T> should be parameterized
				----------
				4. WARNING in X.java (at line 12)
					Inner get() { return null; }
					^^^^^
				Outer.Inner is a raw type. References to generic type Outer<T>.Inner should be parameterized
				----------
				""");
	}

	//https://bugs.eclipse.org/bugs/show_bug.cgi?id=89440
	public void test0650() {
	    this.runConformTest(
            new String[] {
				"p/A.java",
				"""
					package p;
					
					public interface A<V> {
						public static enum Stuff {
							FIRST, SECOND, THIRD
						};
					}""",
            },
            "");
	    this.runConformTest(
	    	new String[] {
				"q/SampleClass2.java",
				"""
					package q;
					
					import p.A.Stuff;
					
					public class SampleClass2 {
					  public void doSomething(Stuff thing) {
					   \s
					  }
					}"""
            },
			"",
			null,
			false,
			null);
		this.runConformTest(
			new String[] {
				"q/SampleClass3.java",
				"""
					package q;
					
					import p.A;
					
					public class SampleClass3 {
						public void doSomething() {
							SampleClass2 sample = new SampleClass2();
							sample.doSomething(A.Stuff.FIRST);
						}
					}""",
			},
			"",
			null,
			false,
			null);
	}
	public void test0651() {
	    runConformTest(
            new String[] {
                "X.java",
				"""
					public class X<U> {
					
						int field;
						static int FIELD;
					
						{
							field = 1;
						}
						static {
							FIELD = 1;
						}
					
						public Values<U> foo(Box<? extends U> box) {
							return selectedValues(box.getValues()); // 1
						}
						public static <G> Values<G> selectedValues(Values<? extends G> v) {
							return null;
						}
					}
					abstract class Box<V extends java.io.Serializable> { // Added bound for V
						abstract Values<V> getValues();
					}
					abstract class Values<T> {
					}
					""",
	        },
			JavacTestOptions.EclipseHasABug.EclipseBug236217);
	}
	public void test0652() {
	    this.runConformTest(
            new String[] {
                "X.java",
				"""
					import java.util.*;
					
					public class X {
					    public static void main(String[] args) {
					        Collection<?> c = new HashSet<String>();
					        Set<?> s = (Set<?>)c;
					    }
					}
					""",
	        },
			"");
	}
	public void test0653() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					import java.util.*;
					
					public class X {
						static public <T extends Collection> void workaround(T a, T b) {
							a.addAll(b);
						}
						Zork z;
					}
					""",
	        },
	        """
				----------
				1. WARNING in X.java (at line 4)
					static public <T extends Collection> void workaround(T a, T b) {
					                         ^^^^^^^^^^
				Collection is a raw type. References to generic type Collection<E> should be parameterized
				----------
				2. WARNING in X.java (at line 5)
					a.addAll(b);
					^^^^^^^^^^^
				Type safety: The method addAll(Collection) belongs to the raw type Collection. References to generic type Collection<E> should be parameterized
				----------
				3. ERROR in X.java (at line 7)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}
	public void test0654() {
	    this.runNegativeTest(
            new String[] {
                "X.java",
				"""
					import java.util.*;
					
					public class X {
						public static void main(String[] args) {
							Map myMap = new HashMap();
							myMap.put("key1", "1");
					
							for (Map.Entry e : myMap.entrySet())
								System.out.println("Key = " + e.getKey() + " Value = " + e.getValue());
							Set<Map.Entry> set = myMap.entrySet();
							for (Map.Entry e : set)
								System.out.println("Key = " + e.getKey() + " Value = " + e.getValue());
						}
					}
					""",
	        },
	        """
				----------
				1. WARNING in X.java (at line 5)
					Map myMap = new HashMap();
					^^^
				Map is a raw type. References to generic type Map<K,V> should be parameterized
				----------
				2. WARNING in X.java (at line 5)
					Map myMap = new HashMap();
					                ^^^^^^^
				HashMap is a raw type. References to generic type HashMap<K,V> should be parameterized
				----------
				3. WARNING in X.java (at line 6)
					myMap.put("key1", "1");
					^^^^^^^^^^^^^^^^^^^^^^
				Type safety: The method put(Object, Object) belongs to the raw type Map. References to generic type Map<K,V> should be parameterized
				----------
				4. WARNING in X.java (at line 8)
					for (Map.Entry e : myMap.entrySet())
					     ^^^^^^^^^
				Map.Entry is a raw type. References to generic type Map.Entry<K,V> should be parameterized
				----------
				5. ERROR in X.java (at line 8)
					for (Map.Entry e : myMap.entrySet())
					                   ^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from element type Object to Map.Entry
				----------
				6. WARNING in X.java (at line 10)
					Set<Map.Entry> set = myMap.entrySet();
					    ^^^^^^^^^
				Map.Entry is a raw type. References to generic type Map.Entry<K,V> should be parameterized
				----------
				7. WARNING in X.java (at line 10)
					Set<Map.Entry> set = myMap.entrySet();
					                     ^^^^^^^^^^^^^^^^
				Type safety: The expression of type Set needs unchecked conversion to conform to Set<Map.Entry>
				----------
				8. WARNING in X.java (at line 11)
					for (Map.Entry e : set)
					     ^^^^^^^^^
				Map.Entry is a raw type. References to generic type Map.Entry<K,V> should be parameterized
				----------
				""");
	}
// **
public void test0655() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
				    static class BB<T, S> { }
				    static class BD<T> extends BB<T, T> { }
				    void f() {
				        BB<? extends Number, ? super Integer> bb = null;
				        Object o = (BD<Number>) bb;
				    }
				    Zork z;
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 6)
				Object o = (BD<Number>) bb;
				           ^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from X.BB<capture#1-of ? extends Number,capture#2-of ? super Integer> to X.BD<Number>
			----------
			2. WARNING in X.java (at line 6)
				Object o = (BD<Number>) bb;
				           ^^^^^^^^^^^^^^^
			Unnecessary cast from X.BB<capture#1-of ? extends Number,capture#2-of ? super Integer> to X.BD<Number>
			----------
			3. ERROR in X.java (at line 8)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
public void test0656() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				
				public class X {
					protected Vector<String> v = null;
				
					public void f() {
						((String) (v.elementAt(0))).charAt(0);
					}
				
					public static void main(String[] args) {
						System.out.println("SUCCESS");
					}
				}
				""",
		},
		"SUCCESS");
}
public void test0657() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X{
				\t
					private static class GenericWrapper<Elem>  {
						private Elem theObject;
						public GenericWrapper(Elem arg) {
							theObject = arg;
						}
						public <T extends Elem> GenericWrapper (GenericWrapper<T> other) {
							this.theObject = other.theObject;
						}
						public String toString() {
							return theObject.toString();
						}
					}
					private static GenericWrapper<String> method (Object wrappedString) {
						return (GenericWrapper<String>) wrappedString;
					}
				
					public static void main(String[] args) {
						System.out.print(method(new GenericWrapper<String>("abc")));
						System.out.println(method(new GenericWrapper<Exception>(new Exception())));
					}
				}
				""",
		},
		"abcjava.lang.Exception");
}
public void test0658() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X{
				\t
					private static class GenericWrapper<Elem>  {
						Zork z;
						private Elem theObject;
						public GenericWrapper(Elem arg) {
							theObject = arg;
						}
						public <T extends Elem> GenericWrapper (GenericWrapper<T> other) {
							this.theObject = other.theObject;
						}
						public String toString() {
							return theObject.toString();
						}
					}
					private static GenericWrapper<String> method (Object wrappedString) {
						return (GenericWrapper<String>) wrappedString;
					}
				
					public static void main(String[] args) {
						System.out.print(method(new GenericWrapper<String>("abc")));
						System.out.println(method(new GenericWrapper<Exception>(new Exception())));
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 4)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			2. WARNING in X.java (at line 12)
				public String toString() {
				              ^^^^^^^^^^
			The method toString() of type X.GenericWrapper<Elem> should be tagged with @Override since it actually overrides a superclass method
			----------
			3. WARNING in X.java (at line 17)
				return (GenericWrapper<String>) wrappedString;
				       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from Object to X.GenericWrapper<String>
			----------
			""");
}
public void test0659() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.lang.ref.*;
				
				@SuppressWarnings("unused")
				public class X<K, V> extends WeakReference<V> {
					Zork z;
					static ReferenceQueue<Integer> queue = new ReferenceQueue<Integer>();
				
					private K key;
				
					public X(K key, V value, ReferenceQueue<V> queue) {
						super(value, queue);
					}
				
					public K getKey() {
						return key;
					}
					@Override
					public String toString() {
						return "key:" + key;
					}
				
					public static void main(String[] arg) throws Exception {
						X<String, Integer> ref = new X<String, Integer>("Dummy Key", Integer.valueOf(5), queue);
						new Thread() {
							@Override
							public void run() {
								for (;;) {
									// force ref to be cleared
									System.gc();
								}
							}
						}.start();
				
						X<String, Integer> fromQueue = (X<String, Integer>) queue.remove();
						System.out.println(fromQueue);
						System.exit(0);
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 5)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			2. WARNING in X.java (at line 34)
				X<String, Integer> fromQueue = (X<String, Integer>) queue.remove();
				                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from Reference<capture#1-of ? extends Integer> to X<String,Integer>
			----------
			""");
}
public void test0660() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X {
				
					boolean run(X x) {
						return false;
					}
					<T> void run(Class<T> ct) {
					}
				
					public static void main(String[] args) {
						boolean b = new X().run(new X(){});
						System.out.println("SUCCESS");
					}
				}
				""",
		},
		"SUCCESS");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=95066
public void test0661() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<S extends Comparable<S>> {
				   public X() {
				       S a = (S)(Integer)3;
				   }
					Zork z;
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 3)
				S a = (S)(Integer)3;
				      ^^^^^^^^^^^^^
			Type safety: Unchecked cast from Integer to S
			----------
			2. ERROR in X.java (at line 5)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=95066 - variation
public void test0662() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<S extends Comparable<String>> {
				   public X() {
				       S a = (S)(Integer)3; // this should fail
				   }
					Zork z;
				}""",
		},
		"""
			----------
			1. ERROR in X.java (at line 3)
				S a = (S)(Integer)3; // this should fail
				      ^^^^^^^^^^^^^
			Cannot cast from Integer to S
			----------
			2. ERROR in X.java (at line 5)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=95066 - variation
public void test0663() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.List;
				
				public class X {
				   Object foo(Comparable<Integer> c) {
					   return (Comparable<S>) c;
				   }
				   <U extends Throwable, V extends Runnable> void foo(List<V> lv) {
					   List l = (List<U>) lv;
				   }
				   <U extends Throwable, V extends Runnable> void foo2(List<List<V>> lv) {
					   List l = (List<List<U>>) lv;
				   }
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 5)
				return (Comparable<S>) c;
				                   ^
			S cannot be resolved to a type
			----------
			2. WARNING in X.java (at line 8)
				List l = (List<U>) lv;
				^^^^
			List is a raw type. References to generic type List<E> should be parameterized
			----------
			3. WARNING in X.java (at line 8)
				List l = (List<U>) lv;
				         ^^^^^^^^^^^^
			Type safety: Unchecked cast from List<V> to List<U>
			----------
			4. WARNING in X.java (at line 8)
				List l = (List<U>) lv;
				         ^^^^^^^^^^^^
			Unnecessary cast from List<V> to List<U>
			----------
			5. WARNING in X.java (at line 11)
				List l = (List<List<U>>) lv;
				^^^^
			List is a raw type. References to generic type List<E> should be parameterized
			----------
			6. ERROR in X.java (at line 11)
				List l = (List<List<U>>) lv;
				         ^^^^^^^^^^^^^^^^^^
			Cannot cast from List<List<V>> to List<List<U>>
			----------
			7. WARNING in X.java (at line 11)
				List l = (List<List<U>>) lv;
				         ^^^^^^^^^^^^^^^^^^
			Unnecessary cast from List<List<V>> to List<List<U>>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=95066 - variation
public void test0664() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<S extends Comparable<String>> {
				   public X(X2 x2) {
				       S a = (S)x2;
				   }
				}
				abstract class X2 implements Comparable<X2> {
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 3)
				S a = (S)x2;
				      ^^^^^
			Cannot cast from X2 to S
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=95066 - variation
public void test0665() {
	this.runNegativeTest(
		new String[] {
			"Test.java",
			"""
				public class Test<S> {
					void foo() {
						A a = new A();
						Comparable<Object> c = (Comparable<Object>) a; // Fails as expected
						Comparable<S> c2 = (Comparable<S>) a; // Should fail?
					}
				
				}
				
				final class A implements Comparable<A> {
					public int compareTo(A o) {
						return 0;
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in Test.java (at line 4)
				Comparable<Object> c = (Comparable<Object>) a; // Fails as expected
				                       ^^^^^^^^^^^^^^^^^^^^^^
			Cannot cast from A to Comparable<Object>
			----------
			2. WARNING in Test.java (at line 5)
				Comparable<S> c2 = (Comparable<S>) a; // Should fail?
				                   ^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from A to Comparable<S>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=89940
public void test0666() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.List;
				
				public class X {
					void foo(List<Object> objects, List raw) {
				
					    List<Number> numbers;
					    List<? extends Number> ext;
					   \s
					    numbers= (List<Number>) objects; // correct - cast error
					    ext= (List<? extends Number>) objects; // wrong, should fail
				
					    ext= raw; // correct - raw conversion warning issued
					    numbers= raw; // correct - raw conversion warning issued
					}
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 4)
				void foo(List<Object> objects, List raw) {
				                               ^^^^
			List is a raw type. References to generic type List<E> should be parameterized
			----------
			2. ERROR in X.java (at line 9)
				numbers= (List<Number>) objects; // correct - cast error
				         ^^^^^^^^^^^^^^^^^^^^^^
			Cannot cast from List<Object> to List<Number>
			----------
			3. ERROR in X.java (at line 10)
				ext= (List<? extends Number>) objects; // wrong, should fail
				     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Cannot cast from List<Object> to List<? extends Number>
			----------
			4. WARNING in X.java (at line 12)
				ext= raw; // correct - raw conversion warning issued
				     ^^^
			Type safety: The expression of type List needs unchecked conversion to conform to List<? extends Number>
			----------
			5. WARNING in X.java (at line 13)
				numbers= raw; // correct - raw conversion warning issued
				         ^^^
			Type safety: The expression of type List needs unchecked conversion to conform to List<Number>
			----------
			""");
}
public void _test0667() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				
				public class X {
				    public static void foo(List<? super Object[]> l) {    }
				\s
				    public static void foo2(List<Object[]> l) {    }
				\s
				    public static void foo3(List<? extends Object[]> l) {    }
				\s
				    public static void bar(List<? super Object> l) {    }
				\s
				    public static void bar2(List<Object> l) {    }
				\s
				    public static void bar3(List<? extends Object> l) {    }
				\s
				    public static void bar4(List<?> l) {    }
				\s
				    public static void main(String[] args) {
				        {   // can be { Object, Object[] }
				            List<? super Object[]> l = new ArrayList<Object[]>();
				            l.add(l.get(0));  // illegal [01]
				            l.add((Object) null);  // illegal [02]
				            l.add((Integer) null);  // illegal [03]
				            l.add((Object []) null); // illegal [04]
				            l.add((Integer []) null); // illegal [05]
				            l.add((Integer [][]) null); // illegal [06]
				\s
				            foo(l); // List<? super Object[]> - legal [07]
				            foo2(l); // List<Object[]> - illegal [08]
				            foo3(l); // List<? extends Object[]> - illegal [09]
				            bar(l); // List<? super Object> - illegal [10]
				            bar2(l); // List<Object> - illegal [11]
				            bar3(l); // List<? extends Object> - legal [12]
				            bar4(l); // List<?> - legal [13]
				        }
				        {   // can be Object[] or (? extends Object)[]
				            List<Object[]> l = new ArrayList<Object[]>();
				            l.add(l.get(0));  // legal [14]
				            l.add((Object) null);  // illegal [15]
				            l.add((Integer) null);  // illegal [16]
				            l.add((Object []) null); // legal [17]
				            l.add((Integer []) null); // legal [18]
				            l.add((Integer [][]) null); // legal [19]
				\s
				            foo(l); // List<? super Object[]> - legal [20]
				            foo2(l); // List<Object[]> - legal [21]
				            foo3(l); // List<? extends Object[]> - legal [22]
				            bar(l); // List<? super Object> - illegal [23]
				            bar2(l); // List<Object> - illegal [24]
				            bar3(l); // List<? extends Object> - legal [25]
				            bar4(l); // List<?> - legal [26]
				        }
				        {   // Only allows wildcards, Object is illegal.
				            List<? extends Object[]> l = new ArrayList<Object[]>();
				            l.add(l.get(0));  // illegal [27]
				            l.add((Object) null);  // illegal [28]
				            l.add((Integer) null);  // illegal [29]
				            l.add((Object []) null); // illegal [30]
				            l.add((Integer []) null); // illegal [31]
				            l.add((Integer [][]) null); // illegal [32]
				\s
				            foo(l); // List<? super Object[]> - illegal [33]
				            foo2(l); // List<Object[]> - illegal [34]
				            foo3(l); // List<? extends Object[]> - legal [35]
				            bar(l); // List<? super Object> - illegal [36]
				            bar2(l); // List<Object> - illegal [37]
				            bar3(l); // List<? extends Object> - legal [38]
				            bar4(l); // List<?> - legal [39]
				        }
				        {   // can add non-arrays but can only match ? super Object, ? super Object[], or ? extends Object, but not Object \s
				            List<? super Object> l = new ArrayList<Object>();
				            l.add(l.get(0));  // legal [40]
				            l.add((Object) null);  // legal [41]
				            l.add((Integer) null);  // legal [42]
				            l.add((Object []) null); // illegal [43]
				            l.add((Integer []) null); // illegal [44]
				            l.add((Integer [][]) null); // illegal [45]
				\s
				            foo(l); // legal [46]
				            foo2(l); // illegal [47]
				            foo3(l); // illegal [48]
				            bar(l); // legal [49]
				            bar2(l); // illegal [50]
				            bar3(l); // legal [51]
				            bar4(l); // legal [52]
				        }
				        {   // can add array but cannot call a method which expects an array. 100% !
				            List<Object> l = new ArrayList<Object>();
				            l.get(0).toString();
				            l.add(l.get(0));  // legal [53]
				            l.add((Object) null);  // legal [54]
				            l.add((Integer) null);  // legal [55]
				            l.add((Object []) null); // legal [56]
				            l.add((Integer []) null); // legal [57]
				            l.add((Integer [][]) null); // legal [58]
				\s
				            foo(l); // legal [59]
				            foo2(l); // illegal [60]
				            foo3(l); // illegal [61]
				            bar(l); // legal [62]
				            bar2(l); // legal [63]
				            bar3(l); // legal [64]
				            bar4(l); // legal [65]
				        }
				        {   // cannot add any type but can match ? or ? extends Object.
				            List<? extends Object> l = new ArrayList<Object>();
				            l.add(l.get(0));  // illegal [66]
				            l.add((Object) null);  // illegal [67]
				            l.add((Integer) null);  // illegal [68]
				            l.add((Object []) null); // illegal [69]
				            l.add((Integer []) null); // illegal [70]
				            l.add((Integer [][]) null); // illegal [71]
				\s
				            foo(l); // List<? super Object[]> - illegal [72]
				            foo2(l); // List<Object[]> - illegal [73]
				            foo3(l); // List<? extends Object[]> - illegal [74]
				            bar(l); // List<? super Object> - illegal [75]
				            bar2(l); // List<Object> - illegal [76]
				            bar3(l); // List<? extends Object> - legal [77]
				            bar4(l); // List<?> - legal [78]
				        }
				        {   // same as ? extends Object.
				            List<?> l = new ArrayList<Object>();
				            l.add(l.get(0));  // illegal [79]
				            l.add((Object) null);  // illegal [80]
				            l.add((Integer) null);  // illegal [81]
				            l.add((Object []) null); // illegal [82]
				            l.add((Integer []) null); // illegal [83]
				            l.add((Integer [][]) null); // illegal [84]
				\s
				            foo(l); // List<? super Object[]> - illegal [85]
				            foo2(l); // List<Object[]> - illegal [86]
				            foo3(l); // List<? extends Object[]> - illegal [87]
				            bar(l); // List<? super Object> - illegal [88]
				            bar2(l); // List<Object> - illegal [89]
				            bar3(l); // List<? extends Object> - legal [90]
				            bar4(l); // List<?> - legal [91]
				        }
				    }
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 21)
				l.add(l.get(0));  // illegal [01]
				  ^^^
			The method add(capture-of ? super Object[]) in the type List<capture-of ? super Object[]> is not applicable for the arguments (capture-of ? super Object[])
			----------
			2. ERROR in X.java (at line 22)
				l.add((Object) null);  // illegal [02]
				  ^^^
			The method add(capture-of ? super Object[]) in the type List<capture-of ? super Object[]> is not applicable for the arguments (Object)
			----------
			3. ERROR in X.java (at line 23)
				l.add((Integer) null);  // illegal [03]
				  ^^^
			The method add(capture-of ? super Object[]) in the type List<capture-of ? super Object[]> is not applicable for the arguments (Integer)
			----------
			4. ERROR in X.java (at line 24)
				l.add((Object []) null); // illegal [04]
				  ^^^
			The method add(capture-of ? super Object[]) in the type List<capture-of ? super Object[]> is not applicable for the arguments (Object[])
			----------
			5. ERROR in X.java (at line 25)
				l.add((Integer []) null); // illegal [05]
				  ^^^
			The method add(capture-of ? super Object[]) in the type List<capture-of ? super Object[]> is not applicable for the arguments (Integer[])
			----------
			6. ERROR in X.java (at line 26)
				l.add((Integer [][]) null); // illegal [06]
				  ^^^
			The method add(capture-of ? super Object[]) in the type List<capture-of ? super Object[]> is not applicable for the arguments (Integer[][])
			----------
			7. ERROR in X.java (at line 28)
				foo(l); // List<? super Object[]> - legal [07]
				^^^
			The method foo(List<? super Object[]>) in the type X is not applicable for the arguments (List<capture-of ? super Object[]>)
			----------
			8. ERROR in X.java (at line 29)
				foo2(l); // List<Object[]> - illegal [08]
				^^^^
			The method foo2(List<Object[]>) in the type X is not applicable for the arguments (List<capture-of ? super Object[]>)
			----------
			9. ERROR in X.java (at line 30)
				foo3(l); // List<? extends Object[]> - illegal [09]
				^^^^
			The method foo3(List<? extends Object[]>) in the type X is not applicable for the arguments (List<capture-of ? super Object[]>)
			----------
			10. ERROR in X.java (at line 31)
				bar(l); // List<? super Object> - illegal [10]
				^^^
			The method bar(List<? super Object>) in the type X is not applicable for the arguments (List<capture-of ? super Object[]>)
			----------
			11. ERROR in X.java (at line 32)
				bar2(l); // List<Object> - illegal [11]
				^^^^
			The method bar2(List<Object>) in the type X is not applicable for the arguments (List<capture-of ? super Object[]>)
			----------
			12. ERROR in X.java (at line 39)
				l.add((Object) null);  // illegal [15]
				  ^^^
			The method add(Object[]) in the type List<Object[]> is not applicable for the arguments (Object)
			----------
			13. ERROR in X.java (at line 40)
				l.add((Integer) null);  // illegal [16]
				  ^^^
			The method add(Object[]) in the type List<Object[]> is not applicable for the arguments (Integer)
			----------
			14. ERROR in X.java (at line 48)
				bar(l); // List<? super Object> - illegal [23]
				^^^
			The method bar(List<? super Object>) in the type X is not applicable for the arguments (List<Object[]>)
			----------
			15. ERROR in X.java (at line 49)
				bar2(l); // List<Object> - illegal [24]
				^^^^
			The method bar2(List<Object>) in the type X is not applicable for the arguments (List<Object[]>)
			----------
			16. ERROR in X.java (at line 55)
				l.add(l.get(0));  // illegal [27]
				  ^^^
			The method add(capture-of ? extends Object[]) in the type List<capture-of ? extends Object[]> is not applicable for the arguments (capture-of ? extends Object[])
			----------
			17. ERROR in X.java (at line 56)
				l.add((Object) null);  // illegal [28]
				  ^^^
			The method add(capture-of ? extends Object[]) in the type List<capture-of ? extends Object[]> is not applicable for the arguments (Object)
			----------
			18. ERROR in X.java (at line 57)
				l.add((Integer) null);  // illegal [29]
				  ^^^
			The method add(capture-of ? extends Object[]) in the type List<capture-of ? extends Object[]> is not applicable for the arguments (Integer)
			----------
			19. ERROR in X.java (at line 58)
				l.add((Object []) null); // illegal [30]
				  ^^^
			The method add(capture-of ? extends Object[]) in the type List<capture-of ? extends Object[]> is not applicable for the arguments (Object[])
			----------
			20. ERROR in X.java (at line 59)
				l.add((Integer []) null); // illegal [31]
				  ^^^
			The method add(capture-of ? extends Object[]) in the type List<capture-of ? extends Object[]> is not applicable for the arguments (Integer[])
			----------
			21. ERROR in X.java (at line 60)
				l.add((Integer [][]) null); // illegal [32]
				  ^^^
			The method add(capture-of ? extends Object[]) in the type List<capture-of ? extends Object[]> is not applicable for the arguments (Integer[][])
			----------
			22. ERROR in X.java (at line 62)
				foo(l); // List<? super Object[]> - illegal [33]
				^^^
			The method foo(List<? super Object[]>) in the type X is not applicable for the arguments (List<capture-of ? extends Object[]>)
			----------
			23. ERROR in X.java (at line 63)
				foo2(l); // List<Object[]> - illegal [34]
				^^^^
			The method foo2(List<Object[]>) in the type X is not applicable for the arguments (List<capture-of ? extends Object[]>)
			----------
			24. ERROR in X.java (at line 65)
				bar(l); // List<? super Object> - illegal [36]
				^^^
			The method bar(List<? super Object>) in the type X is not applicable for the arguments (List<capture-of ? extends Object[]>)
			----------
			25. ERROR in X.java (at line 66)
				bar2(l); // List<Object> - illegal [37]
				^^^^
			The method bar2(List<Object>) in the type X is not applicable for the arguments (List<capture-of ? extends Object[]>)
			----------
			26. ERROR in X.java (at line 75)
				l.add((Object []) null); // illegal [43]
				  ^^^
			The method add(capture-of ? super Object) in the type List<capture-of ? super Object> is not applicable for the arguments (Object[])
			----------
			27. ERROR in X.java (at line 76)
				l.add((Integer []) null); // illegal [44]
				  ^^^
			The method add(capture-of ? super Object) in the type List<capture-of ? super Object> is not applicable for the arguments (Integer[])
			----------
			28. ERROR in X.java (at line 77)
				l.add((Integer [][]) null); // illegal [45]
				  ^^^
			The method add(capture-of ? super Object) in the type List<capture-of ? super Object> is not applicable for the arguments (Integer[][])
			----------
			29. ERROR in X.java (at line 79)
				foo(l); // legal [46]
				^^^
			The method foo(List<? super Object[]>) in the type X is not applicable for the arguments (List<capture-of ? super Object>)
			----------
			30. ERROR in X.java (at line 80)
				foo2(l); // illegal [47]
				^^^^
			The method foo2(List<Object[]>) in the type X is not applicable for the arguments (List<capture-of ? super Object>)
			----------
			31. ERROR in X.java (at line 81)
				foo3(l); // illegal [48]
				^^^^
			The method foo3(List<? extends Object[]>) in the type X is not applicable for the arguments (List<capture-of ? super Object>)
			----------
			32. ERROR in X.java (at line 83)
				bar2(l); // illegal [50]
				^^^^
			The method bar2(List<Object>) in the type X is not applicable for the arguments (List<capture-of ? super Object>)
			----------
			33. ERROR in X.java (at line 98)
				foo2(l); // illegal [60]
				^^^^
			The method foo2(List<Object[]>) in the type X is not applicable for the arguments (List<Object>)
			----------
			34. ERROR in X.java (at line 99)
				foo3(l); // illegal [61]
				^^^^
			The method foo3(List<? extends Object[]>) in the type X is not applicable for the arguments (List<Object>)
			----------
			35. ERROR in X.java (at line 107)
				l.add(l.get(0));  // illegal [66]
				  ^^^
			The method add(capture-of ? extends Object) in the type List<capture-of ? extends Object> is not applicable for the arguments (capture-of ? extends Object)
			----------
			36. ERROR in X.java (at line 108)
				l.add((Object) null);  // illegal [67]
				  ^^^
			The method add(capture-of ? extends Object) in the type List<capture-of ? extends Object> is not applicable for the arguments (Object)
			----------
			37. ERROR in X.java (at line 109)
				l.add((Integer) null);  // illegal [68]
				  ^^^
			The method add(capture-of ? extends Object) in the type List<capture-of ? extends Object> is not applicable for the arguments (Integer)
			----------
			38. ERROR in X.java (at line 110)
				l.add((Object []) null); // illegal [69]
				  ^^^
			The method add(capture-of ? extends Object) in the type List<capture-of ? extends Object> is not applicable for the arguments (Object[])
			----------
			39. ERROR in X.java (at line 111)
				l.add((Integer []) null); // illegal [70]
				  ^^^
			The method add(capture-of ? extends Object) in the type List<capture-of ? extends Object> is not applicable for the arguments (Integer[])
			----------
			40. ERROR in X.java (at line 112)
				l.add((Integer [][]) null); // illegal [71]
				  ^^^
			The method add(capture-of ? extends Object) in the type List<capture-of ? extends Object> is not applicable for the arguments (Integer[][])
			----------
			41. ERROR in X.java (at line 114)
				foo(l); // List<? super Object[]> - illegal [72]
				^^^
			The method foo(List<? super Object[]>) in the type X is not applicable for the arguments (List<capture-of ? extends Object>)
			----------
			42. ERROR in X.java (at line 115)
				foo2(l); // List<Object[]> - illegal [73]
				^^^^
			The method foo2(List<Object[]>) in the type X is not applicable for the arguments (List<capture-of ? extends Object>)
			----------
			43. ERROR in X.java (at line 116)
				foo3(l); // List<? extends Object[]> - illegal [74]
				^^^^
			The method foo3(List<? extends Object[]>) in the type X is not applicable for the arguments (List<capture-of ? extends Object>)
			----------
			44. ERROR in X.java (at line 117)
				bar(l); // List<? super Object> - illegal [75]
				^^^
			The method bar(List<? super Object>) in the type X is not applicable for the arguments (List<capture-of ? extends Object>)
			----------
			45. ERROR in X.java (at line 118)
				bar2(l); // List<Object> - illegal [76]
				^^^^
			The method bar2(List<Object>) in the type X is not applicable for the arguments (List<capture-of ? extends Object>)
			----------
			46. ERROR in X.java (at line 124)
				l.add(l.get(0));  // illegal [79]
				  ^^^
			The method add(capture-of ?) in the type List<capture-of ?> is not applicable for the arguments (capture-of ?)
			----------
			47. ERROR in X.java (at line 125)
				l.add((Object) null);  // illegal [80]
				  ^^^
			The method add(capture-of ?) in the type List<capture-of ?> is not applicable for the arguments (Object)
			----------
			48. ERROR in X.java (at line 126)
				l.add((Integer) null);  // illegal [81]
				  ^^^
			The method add(capture-of ?) in the type List<capture-of ?> is not applicable for the arguments (Integer)
			----------
			49. ERROR in X.java (at line 127)
				l.add((Object []) null); // illegal [82]
				  ^^^
			The method add(capture-of ?) in the type List<capture-of ?> is not applicable for the arguments (Object[])
			----------
			50. ERROR in X.java (at line 128)
				l.add((Integer []) null); // illegal [83]
				  ^^^
			The method add(capture-of ?) in the type List<capture-of ?> is not applicable for the arguments (Integer[])
			----------
			51. ERROR in X.java (at line 129)
				l.add((Integer [][]) null); // illegal [84]
				  ^^^
			The method add(capture-of ?) in the type List<capture-of ?> is not applicable for the arguments (Integer[][])
			----------
			52. ERROR in X.java (at line 131)
				foo(l); // List<? super Object[]> - illegal [85]
				^^^
			The method foo(List<? super Object[]>) in the type X is not applicable for the arguments (List<capture-of ?>)
			----------
			53. ERROR in X.java (at line 132)
				foo2(l); // List<Object[]> - illegal [86]
				^^^^
			The method foo2(List<Object[]>) in the type X is not applicable for the arguments (List<capture-of ?>)
			----------
			54. ERROR in X.java (at line 133)
				foo3(l); // List<? extends Object[]> - illegal [87]
				^^^^
			The method foo3(List<? extends Object[]>) in the type X is not applicable for the arguments (List<capture-of ?>)
			----------
			55. ERROR in X.java (at line 134)
				bar(l); // List<? super Object> - illegal [88]
				^^^
			The method bar(List<? super Object>) in the type X is not applicable for the arguments (List<capture-of ?>)
			----------
			56. ERROR in X.java (at line 135)
				bar2(l); // List<Object> - illegal [89]
				^^^^
			The method bar2(List<Object>) in the type X is not applicable for the arguments (List<capture-of ?>)
			----------
			""");
}
public void test0668() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				import java.util.List;
				\s
				public class X {
				    void foo(List<? super Object[]> l) {
				        l.add(new Object[0]);
				    }
				}
				""",
		},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=95289
public void test0669() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				
				public class X {
				private static<T> int indexOf(final T[] array,final T elem) {
					return 0;
				}
				public static void meth(AContainer ac, AInfo[] aiArray) {
				  for(AInfo ai: aiArray) {
					int index1 = indexOf(ac.getAs(),ai.a);
					int index2 = indexOf(ac.getAs(),ai); // ai.class!=ai.a.class!!!
				  }
				}
				}
				
				class AContainer {
				   public A[] getAs(){ return null; }
				}
				
				class AInfo {
				   public A a;
				}
				
				class A {
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=95021 (ensure not even a warning)
public void test0670() {
	runConformTest(
		true,
		new String[] {
			"X.java",
			"""
				import java.util.Map;
				
				interface MethodProperty<ActualType extends MethodProperty<ActualType>> {
					public void copyFrom(ActualType other);
				}
				
				class MethodPropertyDatabase<Property extends MethodProperty<Property>> {
					Map<String, Property> propertyMap;
				\t
					void read(String fileName) {
					}
				}
				
				class FooProperty implements MethodProperty<FooProperty> {
					String value;
				
					public void copyFrom(FooProperty other) {
						this.value = other.value;
					}
				}
				
				class FooPropertyDatabase extends MethodPropertyDatabase<FooProperty> {
				}
				
				public class X {
					FooPropertyDatabase fooDatabase;
				\t
					public void readDatabase() {
						FooPropertyDatabase database = new FooPropertyDatabase();
					\t
						fooDatabase = readDatabase(database, "foodatabase.db"); // Bug reported on this line
					}
				\t
					private<
						Property extends MethodProperty<Property>,
						DatabaseType extends MethodPropertyDatabase<Property>
						> DatabaseType readDatabase(DatabaseType database, String fileName) {
							database.read(fileName);
							return database;
						}
				\t
				}
				""",
		},
		"",
		null,
		null,
		JavacTestOptions.EclipseJustification.EclipseBug95021);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=95021 - variation: ensure not even a warning
public void test0671() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.Map;
				
				interface MethodProperty<ActualType extends MethodProperty<ActualType>> {
					public void copyFrom(ActualType other);
				}
				
				class MethodPropertyDatabase<Property extends MethodProperty<Property>> {
					Map<String, Property> propertyMap;
				\t
					void read(String fileName) {
					}
				}
				
				class FooProperty implements MethodProperty<FooProperty> {
					String value;
				
					public void copyFrom(FooProperty other) {
						this.value = other.value;
					}
				}
				
				class FooPropertyDatabase extends MethodPropertyDatabase<FooProperty> {
				}
				
				public class X {
				  Zork z;
					FooPropertyDatabase fooDatabase;
				\t
					public void readDatabase() {
						FooPropertyDatabase database = new FooPropertyDatabase();
					\t
						fooDatabase = readDatabase(database, "foodatabase.db"); // Bug reported on this line
					}
				\t
					private<
						Property extends MethodProperty<Property>,
						DatabaseType extends MethodPropertyDatabase<Property>
						> DatabaseType readDatabase(DatabaseType database, String fileName) {
							database.read(fileName);
							return database;
						}
				\t
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 26)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=95021 - variation: ensure not even a warning
// SHOULD FAIL AT 1.8 (18.2.3): The method read(D, String) in the type X is not applicable for the arguments (Bar<Foo>, String)
public void test0672() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				interface Foo<T extends Foo<T>> {
				}
				
				class Bar<Q> {
				}
				
				
				public class X {
					Zork z;
					void readDatabase() {
						Bar<Foo> bar = new Bar<Foo>();
						read(bar, "sadasd");
					}
				\t
					<P extends Foo<P>, D extends Bar<P>>\s
					D read(D d, String s) {
							return d;
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 9)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			2. WARNING in X.java (at line 11)
				Bar<Foo> bar = new Bar<Foo>();
				    ^^^
			Foo is a raw type. References to generic type Foo<T> should be parameterized
			----------
			3. WARNING in X.java (at line 11)
				Bar<Foo> bar = new Bar<Foo>();
				                       ^^^
			Foo is a raw type. References to generic type Foo<T> should be parameterized
			----------
			4. WARNING in X.java (at line 12)
				read(bar, "sadasd");
				^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked invocation read(Bar<Foo>, String) of the generic method read(D, String) of type X
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=95638
public void test0673() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.List;
				
				class Key<E, F extends Type<E, F>> {
				}
				
				class State<S extends State> {
				}
				
				class Type<T, U extends Type<T, U>> {
				}
				
				class Store<A, B extends Type<A, B>, C extends Key<A, B>, D extends State<D>> {
				}
				
				public class X<K> {
					List<Store<K, ?, ? extends Key<K, ?>, ? extends State<?>>> stores;
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=95638 - variation
public void test0674() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				class Key<E extends Key<E>> {}
				class Store<F extends Key<F>> {}
				
				public class X<T extends Key<T>> {
					Store<? extends Key<T>> store;
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=95638 - variation
public void test0675() {
	runNegativeTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				class Key<E extends Key<E>> {}
				class Store<F extends Key<F>> {}
				
				public class X<T> {
					Store<? extends Key<T>> store1;
					Store<? extends Key<? extends T>> store2;
				}
				""",
		},
		// compiler results
		"----------\n" + /* expected compiler log */
		"1. ERROR in X.java (at line 5)\n" +
		"	Store<? extends Key<T>> store1;\n" +
		"	                    ^\n" +
		"Bound mismatch: The type T is not a valid substitute for the bounded parameter <E extends Key<E>> of the type Key<E>\n" +
		"----------\n" +
		"2. ERROR in X.java (at line 6)\n" +
		"	Store<? extends Key<? extends T>> store2;\n" +
		"	                    ^^^^^^^^^^^\n" +
		"Bound mismatch: The type ? extends T is not a valid substitute for the bounded parameter <E extends Key<E>> of the type Key<E>\n" +
		"----------\n",
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}
//check fault tolerance, in spite of bound mismatch, still pass param type for further resolving message send
public void test0676() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends Throwable> {
					T get() { return null; }
				\t
					void foo(X<String> xs) {
						xs.get().printStackTrace();
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 4)
				void foo(X<String> xs) {
				           ^^^^^^
			Bound mismatch: The type String is not a valid substitute for the bounded parameter <T extends Throwable> of the type X<T>
			----------
			2. ERROR in X.java (at line 5)
				xs.get().printStackTrace();
				         ^^^^^^^^^^^^^^^
			The method printStackTrace() is undefined for the type String
			----------
			""");
}
public void test0677() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				public class X {
					public static void main(String[] args) {
						{
							ArrayList<Number> arrayList = new ArrayList<Integer>(); // compile error
							Number number = arrayList.get(0);
						}
						{
							ArrayList<? extends Number> arrayList = new ArrayList<Integer>(); //correct
							Number number = arrayList.get(0);
						}
						{
							ArrayList<? super Integer> arrayList = new ArrayList<Number>();
							Object number = arrayList.get(0); //returns java.lang.Object
						}
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 5)
				ArrayList<Number> arrayList = new ArrayList<Integer>(); // compile error
				                              ^^^^^^^^^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from ArrayList<Integer> to ArrayList<Number>
			----------
			""");
}
public void test0678() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.io.Serializable;
				
				public class X<T, T2 extends T & Serializable > {
				\t
					X<Object, Serializable> right1;
					X<String, Serializable> wrong1;
					X<Y, Y> right2;
				\t
					static class Y implements Serializable {
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 3)
				public class X<T, T2 extends T & Serializable > {
				                                 ^^^^^^^^^^^^
			Cannot specify any additional bound Serializable when first bound is a type parameter
			----------
			2. ERROR in X.java (at line 6)
				X<String, Serializable> wrong1;
				          ^^^^^^^^^^^^
			Bound mismatch: The type Serializable is not a valid substitute for the bounded parameter <T2 extends T & Serializable> of the type X<T,T2>
			----------
			3. WARNING in X.java (at line 9)
				static class Y implements Serializable {
				             ^
			The serializable class Y does not declare a static final serialVersionUID field of type long
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=95638 - variation
public void test0679() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				class Key<E, F extends Key<E, F>> {}
				class Store<A, B extends Key<A, B>> {}
				
				public class X<K extends Key<?, K>> {
					Store<K, ? extends Key<K, ?>> store;
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=95638 - variation
public void test0680() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.List;
				
				class Key<E, F extends Type<E, F, G, H>, G extends Key<E, F, G, H>, H extends State<H>> {}
				class State<S extends State> {}
				class Type<T, U extends Type<T, U, V, W>, V extends Key<T, U, V, W>, W extends State<W>> {}
				class Store<A, B extends Type<A, B, C, D>, C extends Key<A, B, C, D>, D extends State<D>> {}
				
				public class X<K extends Key<K, ?,?,?>> {
					List<Store<K, ?, ? extends Key<K, ?, ?, ?>, ? extends State<?>>> stores;
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=95638 - variation
public void test0681() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				class Key<E, K extends Key<E, K>> {
				}
				class Store<E, K extends Key<E, K>> {
				}
				class X<E> {
					Store<E, ?> store1;
					Store<E, ? extends Key<E, ?>> store2;
				
					class StoreHolder <F extends Key<E, F>> {
						Store<E, F> store;
					}
				}
				class Y<T, U extends Y<T, U>> {
					Y<?, ?> y;
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=95963
public void test0682() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"class X extends A<X.M> {}\n" +
			"class A<T> {}\n"
		},
		"""
			----------
			1. ERROR in X.java (at line 1)
				class X extends A<X.M> {}
				                  ^^^
			X.M cannot be resolved to a type
			----------
			"""
	);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=96085
public void test0683() {
	this.runConformTest(
		new String[] {
			"P.java",
			"""
				public interface P<V> {
				    interface A {}
				}
				""",
			"P2.java",
			"""
				public class P2 implements P.A {
				    P2(P.A problem) {}
				}
				""",
			"P3.java",
			"""
				public class P3 {
				    void test() {P.A o = new P2((P.A) null);}
				}
				""",
		},
		"");
	this.runConformTest(
		new String[] {
			"P3.java",
			"""
				class P3 {
				    void test() {P.A o = new P2((P.A) null);}
				}
				""",
		},
		"",
		null,
		false,
		null);
}
public void test0684() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {
					<U> U foo(U u1, U u2) {
						return u1;
					}
					void bar(X<? extends Throwable> x1, X<? extends Runnable> x2) {
						X<String> x = foo(x1, x2);
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 6)
				X<String> x = foo(x1, x2);
				              ^^^^^^^^^^^
			Type mismatch: cannot convert from X<capture#3-of ? extends Object> to X<String>
			----------
			""");
}
public void test0685() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {
					<U> U foo(U u1, U u2) {
						return u1;
					}
					void bar(X<? extends Throwable> x1, X<? extends Runnable> x2) {
						X<String> x = foo(x1, x2);
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 6)
				X<String> x = foo(x1, x2);
				              ^^^^^^^^^^^
			Type mismatch: cannot convert from X<capture#3-of ? extends Object> to X<String>
			----------
			""");
}
// check wildcard bounds wrt variable boundCheck
public void test0686() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.List;
				class Other<T extends List<? extends Runnable>> {
				}
				
				public class X {
					Other<? extends List<? extends Throwable>> other1;
					Other<? extends List<? super String>> other2;\t
					Other<? extends List<? extends String>> other3;	\t
					Other<? extends List<? extends Runnable>> other7 = other1;
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 7)
				Other<? extends List<? super String>> other2;\t
				      ^^^^^^^^^^^^^^
			Bound mismatch: The type ? extends List<? super String> is not a valid substitute for the bounded parameter <T extends List<? extends Runnable>> of the type Other<T>
			----------
			2. ERROR in X.java (at line 8)
				Other<? extends List<? extends String>> other3;	\t
				      ^^^^^^^^^^^^^^
			Bound mismatch: The type ? extends List<? extends String> is not a valid substitute for the bounded parameter <T extends List<? extends Runnable>> of the type Other<T>
			----------
			""");
}
// check wildcard bounds wrt variable boundCheck
public void test0687() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.List;
				class Other<T extends List<? extends Runnable>> {
				}
				
				public class X {
					Other<? extends List<?>> other2;
					Other<? extends List<? super Throwable>> other3;
					Other<? super List<? extends Throwable>> other4;
					Other<? super List<?>> other5;
					Other<? super List<? super Throwable>> other6;
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 7)
				Other<? extends List<? super Throwable>> other3;
				      ^^^^^^^^^^^^^^
			Bound mismatch: The type ? extends List<? super Throwable> is not a valid substitute for the bounded parameter <T extends List<? extends Runnable>> of the type Other<T>
			----------
			2. ERROR in X.java (at line 8)
				Other<? super List<? extends Throwable>> other4;
				      ^^^^^^^^^^^^
			Bound mismatch: The type ? super List<? extends Throwable> is not a valid substitute for the bounded parameter <T extends List<? extends Runnable>> of the type Other<T>
			----------
			3. ERROR in X.java (at line 9)
				Other<? super List<?>> other5;
				      ^^^^^^^^^^^^
			Bound mismatch: The type ? super List<?> is not a valid substitute for the bounded parameter <T extends List<? extends Runnable>> of the type Other<T>
			----------
			4. ERROR in X.java (at line 10)
				Other<? super List<? super Throwable>> other6;
				      ^^^^^^^^^^^^
			Bound mismatch: The type ? super List<? super Throwable> is not a valid substitute for the bounded parameter <T extends List<? extends Runnable>> of the type Other<T>
			----------
			""");
}
// check wildcard bounds wrt variable boundCheck
public void test0688() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.List;
				class Other<T extends List<? extends Runnable>> {
				}
				
				public class X {
					Other<? super List<? extends Runnable>> other5;
				}
				""",
		},
		"");
}
// check wildcard bounds wrt variable boundCheck
public void test0689() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.List;
				class Other<T extends List<? extends Runnable>> {
				}
				
				public class X {
					Other<? super List<? super Runnable>> other5;
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 6)
				Other<? super List<? super Runnable>> other5;
				      ^^^^^^^^^^^^
			Bound mismatch: The type ? super List<? super Runnable> is not a valid substitute for the bounded parameter <T extends List<? extends Runnable>> of the type Other<T>
			----------
			""");
}
// check assignment rules across param types with wildcards
public void test0690() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.List;
				public class X {
					void foo(List<? extends Runnable> lr, List<?> la) {
						lr = la;
						la = lr;
					}
				}        \s
				
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 4)
				lr = la;
				     ^^
			Type mismatch: cannot convert from List<capture#2-of ?> to List<? extends Runnable>
			----------
			""");
}
// check that final class bound is more restrictive
public void test0691() {
	this.runNegativeTest(
		new String[] {
			"XX.java",
			"""
				public class XX<T extends Runnable> {
					void foo(XX<?> lhs, XX<? extends String> rhs) {
						lhs = rhs;
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in XX.java (at line 2)
				void foo(XX<?> lhs, XX<? extends String> rhs) {
				                       ^^^^^^^^^^^^^^^^
			Bound mismatch: The type ? extends String is not a valid substitute for the bounded parameter <T extends Runnable> of the type XX<T>
			----------
			""");
}
// check wildcard bounds wrt variable boundCheck
public void test0692() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.List;
				
				public class X<T extends List<Object>> {
				\t
					void foo(X<? extends List<String>> x) {
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 5)
				void foo(X<? extends List<String>> x) {
				           ^^^^^^^^^^^^^^
			Bound mismatch: The type ? extends List<String> is not a valid substitute for the bounded parameter <T extends List<Object>> of the type X<T>
			----------
			""");
}
// bound checks
public void test0693() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends Runnable> {
					X<X<String>> x1;
					X<? extends String> x2;
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 2)
				X<X<String>> x1;
				  ^
			Bound mismatch: The type X<String> is not a valid substitute for the bounded parameter <T extends Runnable> of the type X<T>
			----------
			2. ERROR in X.java (at line 2)
				X<X<String>> x1;
				    ^^^^^^
			Bound mismatch: The type String is not a valid substitute for the bounded parameter <T extends Runnable> of the type X<T>
			----------
			3. ERROR in X.java (at line 3)
				X<? extends String> x2;
				  ^^^^^^^^^^^^^^^^
			Bound mismatch: The type ? extends String is not a valid substitute for the bounded parameter <T extends Runnable> of the type X<T>
			----------
			""");
}
// bound checks
public void test0694() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends X<T>> {
					X<X<X<String>>> x1;
					X<? extends X<? extends X<String>>> x2;
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 2)
				X<X<X<String>>> x1;
				  ^
			Bound mismatch: The type X<X<String>> is not a valid substitute for the bounded parameter <T extends X<T>> of the type X<T>
			----------
			2. ERROR in X.java (at line 2)
				X<X<X<String>>> x1;
				    ^
			Bound mismatch: The type X<String> is not a valid substitute for the bounded parameter <T extends X<T>> of the type X<T>
			----------
			3. ERROR in X.java (at line 2)
				X<X<X<String>>> x1;
				      ^^^^^^
			Bound mismatch: The type String is not a valid substitute for the bounded parameter <T extends X<T>> of the type X<T>
			----------
			4. ERROR in X.java (at line 3)
				X<? extends X<? extends X<String>>> x2;
				  ^^^^^^^^^^^
			Bound mismatch: The type ? extends X<? extends X<String>> is not a valid substitute for the bounded parameter <T extends X<T>> of the type X<T>
			----------
			5. ERROR in X.java (at line 3)
				X<? extends X<? extends X<String>>> x2;
				              ^^^^^^^^^^^
			Bound mismatch: The type ? extends X<String> is not a valid substitute for the bounded parameter <T extends X<T>> of the type X<T>
			----------
			6. ERROR in X.java (at line 3)
				X<? extends X<? extends X<String>>> x2;
				                          ^^^^^^
			Bound mismatch: The type String is not a valid substitute for the bounded parameter <T extends X<T>> of the type X<T>
			----------
			""");
}
// bound checks
public void test0695() {
	this.runConformTest(
		new String[] {
			"I.java",
			"interface I<T extends I<? extends T>> {\n" +
			"}\n",
		},
		"");
}
public void test0696() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				class Key<E extends Key<E>> {}
				class Store<F extends Key<F>> {}
				
				public class X<T> {
					Store<? extends Key<T>> store = new Store<Key<T>>();
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 5)
				Store<? extends Key<T>> store = new Store<Key<T>>();
				                    ^
			Bound mismatch: The type T is not a valid substitute for the bounded parameter <E extends Key<E>> of the type Key<E>
			----------
			2. ERROR in X.java (at line 5)
				Store<? extends Key<T>> store = new Store<Key<T>>();
				                                          ^^^
			Bound mismatch: The type Key<T> is not a valid substitute for the bounded parameter <F extends Key<F>> of the type Store<F>
			----------
			3. ERROR in X.java (at line 5)
				Store<? extends Key<T>> store = new Store<Key<T>>();
				                                              ^
			Bound mismatch: The type T is not a valid substitute for the bounded parameter <E extends Key<E>> of the type Key<E>
			----------
			""");
}
public void test0697() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.List;
				public class X<U, V extends List<U>> {
					V v;
				\t
					void foo(X<String, ?> x1, X<Object, ?> x2) {
						String s =x1.v.get(0);
						Object o = x2.v.get(0);
					\t
					}
				}
				""",
		},
		"");
}
public void test0698() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.List;
				
				public class X<U extends List<Object>, V extends List<String>> {
				\t
					X<? super Exception, ? super Exception> x;
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 5)
				X<? super Exception, ? super Exception> x;
				  ^^^^^^^^^^^^^^^^^
			Bound mismatch: The type ? super Exception is not a valid substitute for the bounded parameter <U extends List<Object>> of the type X<U,V>
			----------
			2. ERROR in X.java (at line 5)
				X<? super Exception, ? super Exception> x;
				                     ^^^^^^^^^^^^^^^^^
			Bound mismatch: The type ? super Exception is not a valid substitute for the bounded parameter <V extends List<String>> of the type X<U,V>
			----------
			""");
}
public void test0699() {
	this.runNegativeTest(
		new String[] {
			"X2.java",
			"""
				import java.util.List;
				class Other2<T extends List< Runnable>> {
				}
				
				class X2 {
					Other2<? extends List<Throwable>> other1;
					Other2<? extends List<? super String>> other2;\t
					Other2<? extends List<? extends String>> other3;	\t
					Other2<? extends List<? extends Runnable>> other7 = other1;
				}
				""",
		},
		"""
			----------
			1. ERROR in X2.java (at line 6)
				Other2<? extends List<Throwable>> other1;
				       ^^^^^^^^^^^^^^
			Bound mismatch: The type ? extends List<Throwable> is not a valid substitute for the bounded parameter <T extends List<Runnable>> of the type Other2<T>
			----------
			2. ERROR in X2.java (at line 7)
				Other2<? extends List<? super String>> other2;\t
				       ^^^^^^^^^^^^^^
			Bound mismatch: The type ? extends List<? super String> is not a valid substitute for the bounded parameter <T extends List<Runnable>> of the type Other2<T>
			----------
			3. ERROR in X2.java (at line 8)
				Other2<? extends List<? extends String>> other3;	\t
				       ^^^^^^^^^^^^^^
			Bound mismatch: The type ? extends List<? extends String> is not a valid substitute for the bounded parameter <T extends List<Runnable>> of the type Other2<T>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=96646
public void test0700() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				abstract class BaseFactory<T> {
					public T create() throws Exception {
						return getType().newInstance();
					}
					public abstract Class<T> getType();
				}
				interface StringFactory {
					public String create() throws Exception;
				}
				public class X extends BaseFactory<String> implements StringFactory {
					@Override
					public Class<String> getType() {
						return String.class;
					}
					public static void main(String[] args) throws Exception {
						String emptyString = new X().create();
						System.out.printf("SUCCESS");
					}
				}
				""",
		},
		"SUCCESS");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=97303
public void test0701() {
	Map options = getCompilerOptions();
	options.put(JavaCore.COMPILER_PB_UNCHECKED_TYPE_OPERATION, JavaCore.IGNORE);
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.Arrays;
				import java.util.List;
				
				class Deejay {
					class Counter<T> {}
				
					Counter<Song> songCounter = new Counter<Song>();
					Counter<Genre> genreCounter = new Counter<Genre>();
				
					List<Counter<?>> list1 = Arrays.asList(songCounter, genreCounter);
					List<Counter<? extends Object>> list2 = Arrays.asList(songCounter, genreCounter);
					List<Counter<?>> list3 = Arrays.<Counter<?>>asList(songCounter, genreCounter);
					List<Counter<?>> list4 = Arrays.asList(new Counter<?>[] {songCounter, genreCounter});
					List<Counter<? extends String>> list5 = Arrays.asList(songCounter, genreCounter);
				}
				class Genre {}
				class Song {}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 14)
				List<Counter<? extends String>> list5 = Arrays.asList(songCounter, genreCounter);
				                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from List<Deejay.Counter<? extends Object>> to List<Deejay.Counter<? extends String>>
			----------
			""",
		null,
		true,
		options);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=97303 - variation
public void test0702() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"public class X<T extends Runnable> implements Runnable {\n" +
			"	\n" +
			"	void foo0(X<X<?>> lhs, X<X<? extends Runnable>> rhs) {\n" +
			"		lhs = rhs; // 0\n" +
			"	}\n" +
			"	void foo1(X<X<?>> lhs, X<X<? extends Object>> rhs) {\n" +
			"		lhs = rhs; // 1\n" + // TODO (philippe) should be ok using capture rules for equivalence
			"	}\n" +
			"	void foo2(X<X<? extends Cloneable>> lhs, X<X<? extends Object>> rhs) {\n" +
			"		lhs = rhs; // 2\n" +
			"	}\n" +
			"	void foo3(X<X<? extends Runnable>> lhs, X<X<? extends Object>> rhs) {\n" +
			"		lhs = rhs; // 3\n" +
			"	}\n" +
			"	void foo4(X<X<? extends Runnable>> lhs, X<X<?>> rhs) {\n" +
			"		lhs = rhs; // 4\n" +
			"	}\n" +
			"	void foo5(X<X<?>> lhs, X<X<? extends Cloneable>> rhs) {\n" +
			"		lhs = rhs; // 5\n" +
			"	}\n" +
			"	void foo6(X<X<X<X<X<?>>>>> lhs, X<X<X<X<X<? extends Runnable>>>>> rhs) {\n" +
			"		lhs = rhs; // 6\n" +
			"	}	\n" +
			"	public void run() {\n" +
			"	}\n" +
			"}\n",
		},
		"""
			----------
			1. ERROR in X.java (at line 7)
				lhs = rhs; // 1
				      ^^^
			Type mismatch: cannot convert from X<X<? extends Object>> to X<X<?>>
			----------
			2. ERROR in X.java (at line 10)
				lhs = rhs; // 2
				      ^^^
			Type mismatch: cannot convert from X<X<? extends Object>> to X<X<? extends Cloneable>>
			----------
			3. ERROR in X.java (at line 13)
				lhs = rhs; // 3
				      ^^^
			Type mismatch: cannot convert from X<X<? extends Object>> to X<X<? extends Runnable>>
			----------
			4. ERROR in X.java (at line 19)
				lhs = rhs; // 5
				      ^^^
			Type mismatch: cannot convert from X<X<? extends Cloneable>> to X<X<?>>
			----------
			""");
}
public void test0703() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends X<T>> {}
				class Y extends X<Y> {
				    X<?> p = (Y)null;
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=97800
public void test0704() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				public class X {
						 public static void main(String[] args) {
						 		 List<String> l = (List<String>)Collections.emptyList();
						 }	\s
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 4)
				List<String> l = (List<String>)Collections.emptyList();
				                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Cannot cast from List<Object> to List<String>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=97480
public void test0705() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				
				public class X {
				  void f(Object o){
						 ((Map.Entry)o).setValue("bug");
						 		\s
						 Map.Entry me= (Map.Entry)o;\s
						 me.setValue("ok");
						 		\s
						 ((Vector)o).add("ok");
				  }
				 Zork z;
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 5)
				((Map.Entry)o).setValue("bug");
				^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: The method setValue(Object) belongs to the raw type Map.Entry. References to generic type Map.Entry<K,V> should be parameterized
			----------
			2. WARNING in X.java (at line 5)
				((Map.Entry)o).setValue("bug");
				  ^^^^^^^^^
			Map.Entry is a raw type. References to generic type Map.Entry<K,V> should be parameterized
			----------
			3. WARNING in X.java (at line 7)
				Map.Entry me= (Map.Entry)o;\s
				^^^^^^^^^
			Map.Entry is a raw type. References to generic type Map.Entry<K,V> should be parameterized
			----------
			4. WARNING in X.java (at line 7)
				Map.Entry me= (Map.Entry)o;\s
				               ^^^^^^^^^
			Map.Entry is a raw type. References to generic type Map.Entry<K,V> should be parameterized
			----------
			5. WARNING in X.java (at line 8)
				me.setValue("ok");
				^^^^^^^^^^^^^^^^^
			Type safety: The method setValue(Object) belongs to the raw type Map.Entry. References to generic type Map.Entry<K,V> should be parameterized
			----------
			6. WARNING in X.java (at line 10)
				((Vector)o).add("ok");
				^^^^^^^^^^^^^^^^^^^^^
			Type safety: The method add(Object) belongs to the raw type Vector. References to generic type Vector<E> should be parameterized
			----------
			7. WARNING in X.java (at line 10)
				((Vector)o).add("ok");
				  ^^^^^^
			Vector is a raw type. References to generic type Vector<E> should be parameterized
			----------
			8. ERROR in X.java (at line 12)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=97219
public void test0706() {
	String outputExpectedBelow17 = (this.complianceLevel == ClassFileConstants.JDK1_6)?
			"""
				----------
				1. WARNING in X.java (at line 9)
					class BB extends AA<CC> { <U> BB test() {return null;} }
					                                 ^^^^^^
				Name clash: The method test() of type BB has the same erasure as test() of type AA<T> but does not override it
				----------
				""":
				"""
					----------
					1. ERROR in X.java (at line 9)
						class BB extends AA<CC> { <U> BB test() {return null;} }
						                                 ^^^^^^
					Name clash: The method test() of type BB has the same erasure as test() of type AA<T> but does not override it
					----------
					""";
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					void foo() {
						BB bb = new BB();
						bb.<Object>test();
						((AA<CC>) bb).test();
					}
				}
				class AA<T> { AA<Object> test() {return null;} }
				class BB extends AA<CC> { <U> BB test() {return null;} }
				class CC {}
				""",
		},
		(this.complianceLevel < ClassFileConstants.JDK1_7)
		? outputExpectedBelow17
		: """
			----------
			1. ERROR in X.java (at line 4)
				bb.<Object>test();
				           ^^^^
			The method test() is ambiguous for the type BB
			----------
			2. ERROR in X.java (at line 9)
				class BB extends AA<CC> { <U> BB test() {return null;} }
				                                 ^^^^^^
			Name clash: The method test() of type BB has the same erasure as test() of type AA<T> but does not override it
			----------
			"""
	);
/*
X.java:4: reference to test is ambiguous, both method test() in AA and method <U>test() in BB match
                bb.<Object>test();
                  ^
  where U is a type-variable:
    U extends Object declared in method <U>test()
X.java:9: name clash: <U>test() in BB and test() in AA have the same erasure, yet neither overrides the other
class BB extends AA<CC> { <U> BB test() {return null;} }
                                 ^
  where U is a type-variable:
    U extends Object declared in method <U>test()
2 errors
 */
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=97219
public void test0706a() {
	// http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6182950
	String expectedCompilerLog = (this.complianceLevel == ClassFileConstants.JDK1_6)?
			"""
				----------
				1. ERROR in X.java (at line 4)
					AA<Object> res1 = bb.test();
					                     ^^^^
				The method test() is ambiguous for the type BB
				----------
				2. WARNING in X.java (at line 5)
					AA res3 = bb.test();
					^^
				AA is a raw type. References to generic type AA<T> should be parameterized
				----------
				3. ERROR in X.java (at line 5)
					AA res3 = bb.test();
					             ^^^^
				The method test() is ambiguous for the type BB
				----------
				4. WARNING in X.java (at line 9)
					class BB extends AA<CC> { <U> BB test() {return null;} }
					                                 ^^^^^^
				Name clash: The method test() of type BB has the same erasure as test() of type AA<T> but does not override it
				----------
				""":
				"""
					----------
					1. ERROR in X.java (at line 4)
						AA<Object> res1 = bb.test();
						                     ^^^^
					The method test() is ambiguous for the type BB
					----------
					2. WARNING in X.java (at line 5)
						AA res3 = bb.test();
						^^
					AA is a raw type. References to generic type AA<T> should be parameterized
					----------
					3. ERROR in X.java (at line 5)
						AA res3 = bb.test();
						             ^^^^
					The method test() is ambiguous for the type BB
					----------
					4. ERROR in X.java (at line 9)
						class BB extends AA<CC> { <U> BB test() {return null;} }
						                                 ^^^^^^
					Name clash: The method test() of type BB has the same erasure as test() of type AA<T> but does not override it
					----------
					""";
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					void foo() {
						BB bb = new BB();
						AA<Object> res1 = bb.test();
						AA res3 = bb.test();
					}
				}
				class AA<T> { AA<Object> test() {return null;} }
				class BB extends AA<CC> { <U> BB test() {return null;} }
				class CC {}
				""",
		},
		expectedCompilerLog
	);
/*
X.java:4: reference to test is ambiguous, both method test() in AA and method <U>test() in BB match
                AA<Object> res1 = bb.test();
                                    ^
  where U is a type-variable:
    U extends Object declared in method <U>test()
X.java:5: reference to test is ambiguous, both method test() in AA and method <U>test() in BB match
                AA res3 = bb.test();
                            ^
  where U is a type-variable:
    U extends Object declared in method <U>test()
X.java:9: name clash: <U>test() in BB and test() in AA have the same erasure, yet neither overrides the other
class BB extends AA<CC> { <U> BB test() {return null;} }
                                 ^
  where U is a type-variable:
    U extends Object declared in method <U>test()
3 errors
 */
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=97219
public void test0706b() {
	// http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6182950
	String expectedCompilerLog = (this.complianceLevel == ClassFileConstants.JDK1_6)?
			"""
				----------
				1. ERROR in X.java (at line 4)
					AA<CC> res = bb.test();
					                ^^^^
				The method test() is ambiguous for the type BB
				----------
				2. ERROR in X.java (at line 5)
					BB res2 = bb.test();
					             ^^^^
				The method test() is ambiguous for the type BB
				----------
				3. WARNING in X.java (at line 9)
					class BB extends AA<CC> { <U> BB test() {return null;} }
					                                 ^^^^^^
				Name clash: The method test() of type BB has the same erasure as test() of type AA<T> but does not override it
				----------
				""":
				"""
					----------
					1. ERROR in X.java (at line 4)
						AA<CC> res = bb.test();
						                ^^^^
					The method test() is ambiguous for the type BB
					----------
					2. ERROR in X.java (at line 5)
						BB res2 = bb.test();
						             ^^^^
					The method test() is ambiguous for the type BB
					----------
					3. ERROR in X.java (at line 9)
						class BB extends AA<CC> { <U> BB test() {return null;} }
						                                 ^^^^^^
					Name clash: The method test() of type BB has the same erasure as test() of type AA<T> but does not override it
					----------
					""";
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					void foo() {
						BB bb = new BB();
						AA<CC> res = bb.test();
						BB res2 = bb.test();
					}
				}
				class AA<T> { AA<Object> test() {return null;} }
				class BB extends AA<CC> { <U> BB test() {return null;} }
				class CC {}
				""",
		},
		expectedCompilerLog
	);
/*
X.java:4: reference to test is ambiguous, both method test() in AA and method <U>test() in BB match
                AA<CC> res = bb.test();
                               ^
  where U is a type-variable:
    U extends Object declared in method <U>test()
X.java:4: incompatible types
                AA<CC> res = bb.test();
                                    ^
  required: AA<CC>
  found:    AA<Object>
X.java:5: reference to test is ambiguous, both method test() in AA and method <U>test() in BB match
                BB res2 = bb.test();
                            ^
  where U is a type-variable:
    U extends Object declared in method <U>test()
X.java:5: incompatible types
                BB res2 = bb.test();
                                 ^
  required: BB
  found:    AA<Object>
X.java:9: name clash: <U>test() in BB and test() in AA have the same erasure, yet neither overrides the other
class BB extends AA<CC> { <U> BB test() {return null;} }
                                 ^
  where U is a type-variable:
    U extends Object declared in method <U>test()
5 errors
 */
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					void foo() {
						BB bb = new BB();
						AA<CC> res = bb.test();
						BB res2 = bb.test();
					}
				}
				class AA<T> { AA<Object> test() {return null;} }
				class BB extends AA<CC> { }
				class CC {}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 4)
				AA<CC> res = bb.test();
				             ^^^^^^^^^
			Type mismatch: cannot convert from AA<Object> to AA<CC>
			----------
			2. ERROR in X.java (at line 5)
				BB res2 = bb.test();
				          ^^^^^^^^^
			Type mismatch: cannot convert from AA<Object> to BB
			----------
			"""
	);
/*
X.java:4: incompatible types
                AA<CC> res = bb.test();
                                    ^
  required: AA<CC>
  found:    AA<Object>
X.java:5: incompatible types
                BB res2 = bb.test();
                                 ^
  required: BB
  found:    AA<Object>
2 errors
 */
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98079
public void test0707() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {
				
				    B<? extends T> b() {
				        return a();
				    }
				   \s
				    <U extends T> B<U> a() {
				        return null;
				    }
				   \s
				    static class B<V> { }
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=95684
public void test0708() {
	this.runConformTest(
		new String[] {
			"UserClass.java",
			"""
				public class UserClass<K> {
				    protected class DataHolder {}
				    protected void loadHook(DataHolder data) {}
				}
				""",
		},
		"");
	this.runConformTest(
		new String[] {
			"ChildClass.java",
			"""
				public class ChildClass extends UserClass<Object> {
				    @Override protected void loadHook(DataHolder data) {}
				}
				""",
		},
		"",
		null,
		false,
		null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=95684 - variation
public void test0709() {
	this.runConformTest(
		new String[] {
			"UserClass.java",
			"""
				public class UserClass<K> {
				    protected class DataHolder {}
				    protected void loadHook(DataHolder[] data) {}
				}
				""",
		},
		"");
	this.runConformTest(
		new String[] {
			"ChildClass.java",
			"""
				public class ChildClass extends UserClass<Object> {
				    @Override protected void loadHook(DataHolder[] data) {}
				}
				""",
		},
		"",
		null,
		false,
		null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=96713
public void test0710() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public static <V, P extends Persistent<V>> P createDataObject(V value) {
						return null;
					}
					public static void testCreateDataObject(Object v) {
						Persistent d = createDataObject(v);
					}
				
					private interface Persistent<V> {
						public V getValueObject();
					}
				}
				""",
		},
		"");
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=97108
public void test0711(){
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.ArrayList;
				import java.util.HashMap;
				import java.util.List;
				import java.util.Map;
				
				public class X<T> {
					static private Map<String, XX> m1 = new HashMap<String, XX>();
					private List<XX> m2 = new ArrayList<XX>();
					static protected XX foo()
					{
						return null;
					}
					static public abstract class XX<TT>
					{
					}
				}
				""",
		},
	    "");

	this.runConformTest(
		new String[] {
			"Y.java",
			"""
				public class Y extends X<Object> \s
				{       \s
				}
				"""
		},
	    "",
	    null,
	    false,
	    null);
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=97108
// The case that works
public void test0712(){
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.ArrayList;
				import java.util.HashMap;
				import java.util.List;
				import java.util.Map;
				
				public class X<T> {
					static private Map<String, XX> m1 = new HashMap<String, XX>();
					private List<XX<T>> m2 = new ArrayList<XX<T>>();
					static protected XX foo()
					{
						return null;
					}
					static public abstract class XX<TT>
					{
					}
				}
				""",
		},
        "");
	this.runConformTest(
		new String[] {
			"Y.java",
			"""
				public class Y extends X<Object> \s
				{       \s
				}
				"""
		},
        "",
        null,
        false,
        null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=96713
public void test0713() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {
					int i = 0;
					interface Y {
						java.util.List<T> lt = null;
						int j = i;
						void m1(T t);	\t
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 4)
				java.util.List<T> lt = null;
				               ^
			Cannot make a static reference to the non-static type T
			----------
			2. ERROR in X.java (at line 5)
				int j = i;
				        ^
			Cannot make a static reference to the non-static field i
			----------
			3. ERROR in X.java (at line 6)
				void m1(T t);	\t
				        ^
			Cannot make a static reference to the non-static type T
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98232
public void test0714() {
	this.runConformTest(
		new String[] {
			"B.java",
			"""
				import java.util.Map;
				import java.util.Set;
				import java.util.SortedSet;
				
				public class B  {
					static Set<Map.Entry> foo(SortedSet<Map.Entry> set) {
						return null;
					}
				}
				
				""",
		},
        "");
	this.runConformTest(
		new String[] {
			"A.java",
			"""
				public class A {
					A() {
						B.foo(null);
					}
				}
				"""
		},
        "",
        null,
        false,
        null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98393
public void test0715() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
				    void foo() {
				    	Comparable<String> c = (java.util.List)bar(5, 5.0);
				    }
				   \s
				    <T> T bar(T t1, T t2) { return t1; }
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 3)
				Comparable<String> c = (java.util.List)bar(5, 5.0);
				                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from List to Comparable<String>
			----------
			2. WARNING in X.java (at line 3)
				Comparable<String> c = (java.util.List)bar(5, 5.0);
				                        ^^^^^^^^^^^^^^
			List is a raw type. References to generic type List<E> should be parameterized
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98396
// **
public void test0716() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends Number & Comparable<String>> {
				    void foo(T t) {
				    		 Comparable<Integer> ci = (Comparable<Integer>) t; \s
				    }
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 3)
				Comparable<Integer> ci = (Comparable<Integer>) t; \s
				                         ^^^^^^^^^^^^^^^^^^^^^^^
			Cannot cast from T to Comparable<Integer>
			----------
			""");
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=98396 - variation
public void test0717() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.List;
				public class X<T extends Comparable<String> & List<Integer>> {
				    void foo(T t) {
				    		 Comparable<Integer> ci = (Comparable<Integer>) t; \s
				    }
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 4)
				Comparable<Integer> ci = (Comparable<Integer>) t; \s
				                         ^^^^^^^^^^^^^^^^^^^^^^^
			Cannot cast from T to Comparable<Integer>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98478
// SHOULD FAIL AT 1.8 (18.2.3): The method max(Collection<? extends T>) in the type Collections is not applicable for the arguments (Set<X.ActionImpl>)
public void test0718() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.Collections;
				import java.util.Set;
				import java.util.TreeSet;
				
				public class X {
				   \s
				    public interface Base {
				    }
				   \s
				    abstract class Action<T extends Base> {
				    }
				
				    public class ActionImpl<T extends Base> extends Action<T> implements Comparable<ActionImpl> {
				        public int compareTo(ActionImpl o) {
				            return 0;
				        }
				    }
				
				    public void test() {
				        Set<ActionImpl> set = new TreeSet<ActionImpl>();
				        Collections.max(set);
				    }
				   Zork z;
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 13)
				public class ActionImpl<T extends Base> extends Action<T> implements Comparable<ActionImpl> {
				                                                                                ^^^^^^^^^^
			X.ActionImpl is a raw type. References to generic type X.ActionImpl<T> should be parameterized
			----------
			2. WARNING in X.java (at line 14)
				public int compareTo(ActionImpl o) {
				                     ^^^^^^^^^^
			X.ActionImpl is a raw type. References to generic type X.ActionImpl<T> should be parameterized
			----------
			3. WARNING in X.java (at line 20)
				Set<ActionImpl> set = new TreeSet<ActionImpl>();
				    ^^^^^^^^^^
			X.ActionImpl is a raw type. References to generic type X.ActionImpl<T> should be parameterized
			----------
			4. WARNING in X.java (at line 20)
				Set<ActionImpl> set = new TreeSet<ActionImpl>();
				                                  ^^^^^^^^^^
			X.ActionImpl is a raw type. References to generic type X.ActionImpl<T> should be parameterized
			----------
			5. WARNING in X.java (at line 21)
				Collections.max(set);
				^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked invocation max(Set<X.ActionImpl>) of the generic method max(Collection<? extends T>) of type Collections
			----------
			6. ERROR in X.java (at line 23)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98364
public void test0719() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.Iterator;
				import java.util.ListIterator;
				
				interface IntegerIterator extends Iterator {}
				interface IntegerListIterator extends ListIterator<Integer>, IntegerIterator {}
				
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 4)
				interface IntegerIterator extends Iterator {}
				                                  ^^^^^^^^
			Iterator is a raw type. References to generic type Iterator<E> should be parameterized
			----------
			2. ERROR in X.java (at line 5)
				interface IntegerListIterator extends ListIterator<Integer>, IntegerIterator {}
				          ^^^^^^^^^^^^^^^^^^^
			The interface Iterator cannot be implemented more than once with different arguments: Iterator and Iterator<Integer>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98364 - variation
public void test0720() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				interface Foo<T> {}
				interface Bar extends Foo<Integer> {}
				interface Baz extends Bar, Foo {}
				
				class XSuper implements Foo {}
				class XSub extends XSuper implements Foo<Integer> {}
				
				public class X implements Bar, Foo {}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 3)
				interface Baz extends Bar, Foo {}
				          ^^^
			The interface Foo cannot be implemented more than once with different arguments: Foo and Foo<Integer>
			----------
			2. WARNING in X.java (at line 3)
				interface Baz extends Bar, Foo {}
				                           ^^^
			Foo is a raw type. References to generic type Foo<T> should be parameterized
			----------
			3. WARNING in X.java (at line 5)
				class XSuper implements Foo {}
				                        ^^^
			Foo is a raw type. References to generic type Foo<T> should be parameterized
			----------
			4. ERROR in X.java (at line 6)
				class XSub extends XSuper implements Foo<Integer> {}
				      ^^^^
			The interface Foo cannot be implemented more than once with different arguments: Foo and Foo<Integer>
			----------
			5. ERROR in X.java (at line 8)
				public class X implements Bar, Foo {}
				             ^
			The interface Foo cannot be implemented more than once with different arguments: Foo and Foo<Integer>
			----------
			6. WARNING in X.java (at line 8)
				public class X implements Bar, Foo {}
				                               ^^^
			Foo is a raw type. References to generic type Foo<T> should be parameterized
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98561
public void test0721() {
	this.runConformTest(
			new String[] {
				"Foo.java",
				"""
					public class Foo<T>
					{
						protected abstract class InnerFoo
						{
							protected abstract void doSomething();
						}
					\t
						protected void run( InnerFoo innerFoo )
						{
							innerFoo.doSomething();
						}
					}""",
			},
	        "");
		this.runConformTest(
			new String[] {
				"Bar.java",
				"""
					public class Bar extends Foo<Integer>
					{
						public void go()
						{
							InnerFoo inner = new InnerFoo()
							{
								protected void doSomething()
								{
									System.out.println( "hello" );
								}
							};
							run( inner );
						}
					}"""
			},
	        "",
	        null,
	        false,
	        null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98364 - variation
public void test0722() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				interface I1<T1> {
				}
				
				interface I2<T2> extends I1<T2> {
				}
				
				public class X<U1> implements I1<U1>, I2<U1> {
				}
				""",
		},
		"");
}
public void test0723() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				interface IA<E> {}
				interface IB<E> extends IA<E> {}
				class A<E> implements IA<E> {}
				class B<E> implements IB<E> {}
				
				public class X {
				
					public static void main(String[] args) {
						A<Integer> x = new A<Integer>();
						B<Integer> y = new B<Integer>();
						print(x);
						print(y);
					}
					public static <T extends IA<?>> void print(T a) {
						System.out.print("A");
					}
					public static <T extends IB<?>> void print(T a) {
						System.out.println("B");
					}
				}
				""",
		},
		"AB");
}
public void test0724() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.HashMap;
				
				public class X {
				
					public static void main(String[] args) {
						HashMap<Byte, Byte> subst = new HashMap<Byte, Byte>();
						subst.put((byte)1, (byte)1);
						if (1 + subst.get((byte)1) > 0.f) {
							System.out.println("SUCCESS");
						}	\t
					}
				}
				""",
		},
		"SUCCESS");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98500
public void test0725() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				class AbsC {
					public <T> T[] resize(T[] src, T[] dest) {
						return dest;
					}
				}
				
				class ConrC<T> extends AbsC {
					T[][] data;
					protected void allocateChunkSlots(int maxChunkNo) {
						data = resize(data, new Object[maxChunkNo][]);
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 10)
				data = resize(data, new Object[maxChunkNo][]);
				       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from Object[][] to T[][]
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98500
public void test0726() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X {
				\t
					void foo() {
					\t
						Controller<?> ctrl = null;
						foobar(ctrl.getView().getContent());\s
					}\s
				\t
					static void foobar(X x) {
					}
				}
				interface Controller<T extends View<?>> {
				    public T getView() ;
				}
				interface View<U extends X> {
					public U getContent();
				}
				"""
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98500 - variation
public void test0727() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<E> {
				\t
					void foo() {
					\t
						Controller<?> ctrl = null;
						foobar(ctrl.getView().getContent());\s
					}\s
				\t
					static void foobar(X<String> x) {
					}
				}
				interface Controller<T extends View<?>> {
				    public T getView() ;
				}
				interface View<U extends X<String>> {
					public U getContent();
				}
				"""
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98500 - variation
public void test0728() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<E> {
				\t
					public static void main(String[] args) {
					\t
						Controller<?> ctrl = null;
						foobar(ctrl.getView().getContent());\s
					}\s
				\t
					static void foobar(X<String> x) {
					}
				}
				interface Controller<T extends View<?>> {
				    public T getView() ;
				}
				interface View<U extends X<U>> {
					public U getContent();
				}
				"""
		},
		"""
			----------
			1. ERROR in X.java (at line 6)
				foobar(ctrl.getView().getContent());\s
				^^^^^^
			The method foobar(X<String>) in the type X<E> is not applicable for the arguments (capture#2-of ?)
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=96586
public void test0729() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X implements I<Y> {}
				interface I<T> {}
				class Y extends X implements I<Y> {}
				"""
		},
		"");
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X implements I<Y> {}
				interface I<T extends I<? super T>> {}
				class Y extends X implements I<X> {}
				"""
		},
		"""
			----------
			1. ERROR in X.java (at line 3)
				class Y extends X implements I<X> {}
				      ^
			The interface I cannot be implemented more than once with different arguments: I<Y> and I<X>
			----------
			2. ERROR in X.java (at line 3)
				class Y extends X implements I<X> {}
				                               ^
			Bound mismatch: The type X is not a valid substitute for the bounded parameter <T extends I<? super T>> of the type I<T>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=90437
public void test0730() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
				
				    Zork z;
				    public interface SuperInterface<A> {
				    }
				
				    public interface SubInterface extends SuperInterface<String> {
				        public String getString();
				    }
				
				    private SuperInterface< ? extends SuperInterface> x = null;
				
				    public void f() {
				        ((SubInterface) this.x).getString();
				    }
				}
				"""
		},
		"""
			----------
			1. ERROR in X.java (at line 3)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			2. WARNING in X.java (at line 11)
				private SuperInterface< ? extends SuperInterface> x = null;
				                                  ^^^^^^^^^^^^^^
			X.SuperInterface is a raw type. References to generic type X.SuperInterface<A> should be parameterized
			----------
			3. ERROR in X.java (at line 14)
				((SubInterface) this.x).getString();
				^^^^^^^^^^^^^^^^^^^^^^^
			Cannot cast from X.SuperInterface<capture#1-of ? extends X.SuperInterface> to X.SubInterface
			----------
			"""	);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=97440
public void test0731() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<E> {
					X<? super E> parent;
					X<? super E> current;
				
					X<? extends E> parent2;
					X<? extends E> current2;
				
					void foo() {
						current = current.parent;
					}
				
					void bar() {
						current2 = current2.parent2;
					}
				}
				"""
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98331
public void test0732() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				interface B<T> {}
				interface C extends B<String>{}
				interface D extends B<Integer>{}
				
				public class X {
				             public static void main(String[] args) {
				                         D d = null;
				                         C c = (C)d; // illegal
				             }
				}
				"""
		},
		"""
			----------
			1. ERROR in X.java (at line 8)
				C c = (C)d; // illegal
				      ^^^^
			Cannot cast from D to C
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98331 - variation
public void test0733() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				interface B<T> {}
				interface C extends B<String>{}
				interface D<E> extends B<E>{}
				
				
				public class X {
							Object foo(C c) {
									return (D<? extends String>) c;
				             }
				}
				"""
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98331 - variation
public void test0734() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				interface B<T> {}
				interface C extends B<String>{}
				interface D<E> extends B<E>{}
				
				
				public class X {
							Object foo(C c, D<? extends String> d) {
									return c != null ? c : d;\s
				             }
				}
				"""
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98331 - variation
public void test0735() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				interface B<T> {}
				interface C extends B<String>{}
				interface D<E> extends B<E>{}
				
				
				public class X {
							Object foo(C c, D<? extends Exception> d) {
									return c != null ? c : d;\s
				             }
				}
				"""
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98331 - variation
public void test0736() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				interface B<T> {}
				interface C extends B<String>{}
				interface D<E> extends B<E>{}
				
				
				public class X {
							void bar(C c) {
									D<? extends Exception> d = (D<? extends Exception>) c;
									foo(d, c);
				             }
							<U> void foo(U u1, U u2) {
							}
				}
				"""
		},
		"""
			----------
			1. ERROR in X.java (at line 8)
				D<? extends Exception> d = (D<? extends Exception>) c;
				                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
			Cannot cast from C to D<? extends Exception>
			----------
			""");
}
public void test0737() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				class Sup {
				}
				
				class Sub1 extends Sup {
				}
				
				class Sub2 extends Sup {
				
				}
				abstract class X {
					abstract <S, A extends S, B extends S> S method(A la, B lb);
				
					void m2() {
						Sup Sup = method(new Sub1(), new Sub2());// <-- compiles?? ( A=Sub1, B=Sub2, S=Sup)
						Object obj = method(1, "32");// <--doesn't compile?? ( A=Integer, B=String, S=Object)
					}
				}
				""",
		},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_7 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98331 - variation
public void test0738() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				interface B<T> {}
				class C implements B<String>{}
				interface D extends B<Integer>{}
				
				public class X {
				             public static void main(String[] args) {
				                         D d = null;
				                         C c = (C)d; // illegal
				             }
				}
				"""
		},
		"""
			----------
			1. ERROR in X.java (at line 8)
				C c = (C)d; // illegal
				      ^^^^
			Cannot cast from D to C
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98331 - variation
public void test0739() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				interface B<T> {}
				interface C extends B<String>{}
				class D implements B<Integer>{}
				
				public class X {
				             public static void main(String[] args) {
				                         D d = null;
				                         C c = (C)d; // illegal
				             }
				}
				"""
		},
		"""
			----------
			1. ERROR in X.java (at line 8)
				C c = (C)d; // illegal
				      ^^^^
			Cannot cast from D to C
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98331 - variation
public void test0740() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				interface B<T> {}
				final class C implements B<String>{}
				
				public class X {
				             public static void main(String[] args) {
				                         B<Integer> d = null;
				                         C c = (C)d; // illegal
				             }
				}
				"""
		},
		"""
			----------
			1. ERROR in X.java (at line 7)
				C c = (C)d; // illegal
				      ^^^^
			Cannot cast from B<Integer> to C
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98331 - variation
public void test0741() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				interface B<T> {}
				final class D implements B<Integer>{}
				
				public class X {
				             public static void main(String[] args) {
				                         D d = null;
				                         B<String> c = (B<String>)d; // illegal
				             }
				}
				"""
		},
		"""
			----------
			1. ERROR in X.java (at line 7)
				B<String> c = (B<String>)d; // illegal
				              ^^^^^^^^^^^^
			Cannot cast from D to B<String>
			----------
			""");
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=98538
// **
// FAIL ERRMSG
public void test0742() {
	if (this.complianceLevel >= ClassFileConstants.JDK1_8)
		return;
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				
				 public class X {
				\s
					static abstract class SelfType<T extends SelfType<T>>{
					}
				\s
					static class SuperType extends SelfType<SuperType>{
					}
				\s
					static class SubType extends SuperType{}
				\s
					static <T extends SelfType<T>> List<T> makeSingletonList(T t){
						return Collections.singletonList(t);
					}
				\s
					static <T extends SelfType<T>,S extends T> List<T> makeSingletonList2(S s){
						return Collections.singletonList((T)s); // #0
					}
				\s
					public static void main(String[] args){
						makeSingletonList(new SuperType()); // #1 - OK
						List<SuperType> lsup = makeSingletonList(new SuperType()); // #2 - OK
						List<SubType> lsub = makeSingletonList(new SubType()); // #3 - ERROR
						makeSingletonList(new SubType()); // #4 - ERROR
				 		makeSingletonList2(new SubType()); // #5 - ERROR
						lsup = makeSingletonList2(new SubType()); // #6 - OK
						lsub = makeSingletonList2(new SubType()); // #7 - ERROR
						makeSingletonList2(new SuperType()); // #8 - OK
						lsup = makeSingletonList2(new SuperType()); // #9 - OK
					}
				}
				"""
		},
		(this.complianceLevel < ClassFileConstants.JDK1_8 ?
		"""
			----------
			1. ERROR in X.java (at line 24)
				List<SubType> lsub = makeSingletonList(new SubType()); // #3 - ERROR
				                     ^^^^^^^^^^^^^^^^^
			Bound mismatch: The generic method makeSingletonList(T) of type X is not applicable for the arguments (X.SubType). The inferred type X.SubType is not a valid substitute for the bounded parameter <T extends X.SelfType<T>>
			----------
			2. ERROR in X.java (at line 25)
				makeSingletonList(new SubType()); // #4 - ERROR
				^^^^^^^^^^^^^^^^^
			Bound mismatch: The generic method makeSingletonList(T) of type X is not applicable for the arguments (X.SubType). The inferred type X.SubType is not a valid substitute for the bounded parameter <T extends X.SelfType<T>>
			----------
			3. ERROR in X.java (at line 26)
				makeSingletonList2(new SubType()); // #5 - ERROR
				^^^^^^^^^^^^^^^^^^
			Bound mismatch: The generic method makeSingletonList2(S) of type X is not applicable for the arguments (X.SubType). The inferred type X.SubType is not a valid substitute for the bounded parameter <T extends X.SelfType<T>>
			----------
			4. ERROR in X.java (at line 28)
				lsub = makeSingletonList2(new SubType()); // #7 - ERROR
				       ^^^^^^^^^^^^^^^^^^
			Bound mismatch: The generic method makeSingletonList2(S) of type X is not applicable for the arguments (X.SubType). The inferred type X.SubType is not a valid substitute for the bounded parameter <T extends X.SelfType<T>>
			----------
			"""
		: """
			----------
			1. ERROR in X.java (at line 24)
				List<SubType> lsub = makeSingletonList(new SubType()); // #3 - ERROR
				                     ^^^^^^^^^^^^^^^^^
			Bound mismatch: The generic method makeSingletonList(T) of type X is not applicable for the arguments (X.SubType). The inferred type X.SubType is not a valid substitute for the bounded parameter <T extends X.SelfType<T>>
			----------
			2. ERROR in X.java (at line 28)
				lsub = makeSingletonList2(new SubType()); // #7 - ERROR
				       ^^^^^^^^^^^^^^^^^^
			Bound mismatch: The generic method makeSingletonList2(S) of type X is not applicable for the arguments (X.SubType). The inferred type X.SubType is not a valid substitute for the bounded parameter <T extends X.SelfType<T>>
			----------
			"""));
}

//https://bugs.eclipse.org/bugs/show_bug.cgi?id=99553
public void test0743() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				interface TestGeneric2<A> {
					Nested<A> getNested2(); // super
				
					class Nested<B> implements TestGeneric2<B> {
						public Nested<B> getNested2() { // sub
							return this;//2
						}
					}
				}
				\s
				class TestGeneric3<A> {
					Nested<A> getNested3() { return null; } // super
				
					class Nested<B> extends TestGeneric3<B> {
						@Override public Nested<B> getNested3() { // sub
							return this;//3
						}
					}
				}
				"""
		},
		"""
			----------
			1. ERROR in X.java (at line 16)
				return this;//3
				       ^^^^
			Type mismatch: cannot convert from TestGeneric3<A>.Nested<B> to TestGeneric3<B>.Nested<B>
			----------
			""");
}
public void test0744() {
	this.runNegativeTest(
		new String[] {
			"java/util/X.java",
			"""
				package java.util;
				
				import java.io.*;
				
				class Super<U, V> {
					static class Entry<U,V> {
						Entry(int i, U u, V v, Entry<U,V> entry) {}
						void recordAccess(Super<U,V> s) {
						}
					}
				}
				public abstract class X<K1, V1> extends Super<K1, V1> {
				
					Entry<K1, V1> h;
				
					private static class Entry<K2, V2> extends Super.Entry<K2, V2> {
				
						Entry() {
							super(0, null, null, null);
						}
				
						void ab(Entry<K2, V2> e) {
						}
				
						@Override void recordAccess(Super<K2, V2> m) {
							X<K2, V2> x = (X<K2, V2>) m;
							ab(x.h);
						}
					}
				  Zork z;
				}
				"""
		},
		"""
			----------
			1. ERROR in java\\util\\X.java (at line 30)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=99922
public void test0745() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X {
					void test() {
						java.util.Arrays.asList(3, 3.1);
					}
				}
				"""
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=99922 - variation
public void test0746() {
	Map options = getCompilerOptions();
	options.put(JavaCore.COMPILER_PB_UNCHECKED_TYPE_OPERATION, JavaCore.IGNORE);
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					void test() {
						String s = java.util.Arrays.asList(3, 3.1);
					}
				}
				"""
		},
		"----------\n" +
		"1. ERROR in X.java (at line 3)\n" +
		"	String s = java.util.Arrays.asList(3, 3.1);\n" +
		"	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
		"Type mismatch: cannot convert from List<"+intersection("Number","Comparable<?>")+"> to String\n" +
		"----------\n",
		null,
		true,
		options);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=99983
public void test0747() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {
				  interface I {}
				  class Y<U extends T & I> {
				  }
				}""",
		},
		"""
			----------
			1. ERROR in X.java (at line 3)
				class Y<U extends T & I> {
				                      ^
			Cannot specify any additional bound X.I when first bound is a type parameter
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=100007
public void test0748() {
	// http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6182950
	String expectedCompilerLog = (this.complianceLevel == ClassFileConstants.JDK1_6)?
			"""
				----------
				1. WARNING in X.java (at line 5)
					public byte[] create(Class<byte[]> cl) { return null; }
					              ^^^^^^^^^^^^^^^^^^^^^^^^
				Name clash: The method create(Class<byte[]>) of type X has the same erasure as create(Class<U>) of type Factory<T> but does not override it
				----------
				""":
				"""
					----------
					1. ERROR in X.java (at line 5)
						public byte[] create(Class<byte[]> cl) { return null; }
						              ^^^^^^^^^^^^^^^^^^^^^^^^
					Name clash: The method create(Class<byte[]>) of type X has the same erasure as create(Class<U>) of type Factory<T> but does not override it
					----------
					""";
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				interface Factory<T> {
					<U extends T> U create(Class<U> cl);
				}
				abstract class X implements Factory<byte[]> {
					public byte[] create(Class<byte[]> cl) { return null; }
				}
				""",
		},
		expectedCompilerLog
	);
// javac 7 reports the name clash when X subclasses another class or is a concrete type
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=100149
public void test0749() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.List;
				
				public class X<T extends X<?>> {
					T get() { return null; }
					void foo(X x) {
						String s = x.get();
					}
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 5)
				void foo(X x) {
				         ^
			X is a raw type. References to generic type X<T> should be parameterized
			----------
			2. ERROR in X.java (at line 6)
				String s = x.get();
				           ^^^^^^^
			Type mismatch: cannot convert from X to String
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=100149 - variation
public void test0750() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.List;
				
				public class X<T extends List<String>> {
					T get() { return null; }
					void foo(X x) {
						List<Object> l = x.get();
					}
				  Zork z ;
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 5)
				void foo(X x) {
				         ^
			X is a raw type. References to generic type X<T> should be parameterized
			----------
			2. WARNING in X.java (at line 6)
				List<Object> l = x.get();
				                 ^^^^^^^
			Type safety: The expression of type List needs unchecked conversion to conform to List<Object>
			----------
			3. ERROR in X.java (at line 8)
				Zork z ;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=100153
public void test0751() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends X<T>> {
				\t
					void foo(X<? extends T> x) {
						X<T> x2 = x;
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 4)
				X<T> x2 = x;
				          ^
			Type mismatch: cannot convert from X<capture#1-of ? extends T> to X<T>
			----------
			""");
}
public void test0752() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.io.Serializable;
				
				public class X<E extends Serializable> {
					X<? extends I<E>> parent;
					X<? extends I<E>> current;
					void foo() {
						current = current.parent;
					}
				}
				
				interface I<T> {
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 7)
				current = current.parent;
				          ^^^^^^^^^^^^^^
			Type mismatch: cannot convert from X<capture#3-of ? extends I<capture#2-of ? extends I<E>>> to X<? extends I<E>>
			----------
			""");
}
public void test0753() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.io.Serializable;
				
				public class X<E extends Serializable> {
					X<? super I<E>> parent;
					X<? super I<E>> current;
					void foo() {
						current = current.parent;
					}
				}
				
				interface I<T> {
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 4)
				X<? super I<E>> parent;
				  ^^^^^^^^^
			Bound mismatch: The type ? super I<E> is not a valid substitute for the bounded parameter <E extends Serializable> of the type X<E>
			----------
			2. ERROR in X.java (at line 5)
				X<? super I<E>> current;
				  ^^^^^^^^^
			Bound mismatch: The type ? super I<E> is not a valid substitute for the bounded parameter <E extends Serializable> of the type X<E>
			----------
			3. ERROR in X.java (at line 7)
				current = current.parent;
				          ^^^^^^^^^^^^^^
			Type mismatch: cannot convert from X<capture#3-of ? super I<capture#2-of ? super I<E>>> to X<? super I<E>>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=99578
public void test0754() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				class bugSuper<T extends Object> {
					public T getData(){
						return null;
					}
				}
				
				class bugElement {
				}
				
				class bugClass<T extends bugElement> extends bugSuper<T>{
				}
				
				public class X{
					public void method(bugClass bc){
						bugElement be = bc.getData();   //<< here
					}
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 14)
				public void method(bugClass bc){
				                   ^^^^^^^^
			bugClass is a raw type. References to generic type bugClass<T> should be parameterized
			----------
			2. ERROR in X.java (at line 15)
				bugElement be = bc.getData();   //<< here
				                ^^^^^^^^^^^^
			Type mismatch: cannot convert from Object to bugElement
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=99999
public void test0755() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {
				  public static class B {}
				  public static void main (String... args) {
				    X<?>.B[] b = new X<?>.B[1];
				  }
				}""",
		},
		"""
			----------
			1. ERROR in X.java (at line 4)
				X<?>.B[] b = new X<?>.B[1];
				^^^^^^
			The member type X.B cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X<?>
			----------
			2. ERROR in X.java (at line 4)
				X<?>.B[] b = new X<?>.B[1];
				                 ^^^^^^
			The member type X.B cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X<?>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=99999 - variation
public void test0756() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				public class X<T> {
				  public class B {}
				  public static void main (String... args) {
				    X<?>.B[] b = new X<?>.B[1];
				  }
				}""",
		},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_7 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=100147
public void test0757() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<K, V> {
					static class EntryMap<K, V> {
						class Entry {
						}
					}
				
					EntryMap.Entry internalGet(Object key) {
						return null;
					}
				\t
					void foo(Object key) {
						EntryMap<K,V>.Entry entry = internalGet(key);
					}
				  Zork z;
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 7)
				EntryMap.Entry internalGet(Object key) {
				^^^^^^^^^^^^^^
			X.EntryMap.Entry is a raw type. References to generic type X.EntryMap<K,V>.Entry should be parameterized
			----------
			2. WARNING in X.java (at line 12)
				EntryMap<K,V>.Entry entry = internalGet(key);
				                            ^^^^^^^^^^^^^^^^
			Type safety: The expression of type X.EntryMap.Entry needs unchecked conversion to conform to X.EntryMap<K,V>.Entry
			----------
			3. ERROR in X.java (at line 14)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=100147 - variation
public void test0758() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<K, V> {
					static class EntryMap<K, V> {
						class Entry {
						}
					}
				
					EntryMap.Entry internalGet(Object key) {
						return null;
					}
				\t
					void foo(Object key) {
						EntryMap<K,V>.Entry entry = (EntryMap.Entry) internalGet(key);
					}
				  Zork z;
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 7)
				EntryMap.Entry internalGet(Object key) {
				^^^^^^^^^^^^^^
			X.EntryMap.Entry is a raw type. References to generic type X.EntryMap<K,V>.Entry should be parameterized
			----------
			2. WARNING in X.java (at line 12)
				EntryMap<K,V>.Entry entry = (EntryMap.Entry) internalGet(key);
				                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Unnecessary cast from X.EntryMap.Entry to X.EntryMap.Entry
			----------
			3. WARNING in X.java (at line 12)
				EntryMap<K,V>.Entry entry = (EntryMap.Entry) internalGet(key);
				                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: The expression of type X.EntryMap.Entry needs unchecked conversion to conform to X.EntryMap<K,V>.Entry
			----------
			4. WARNING in X.java (at line 12)
				EntryMap<K,V>.Entry entry = (EntryMap.Entry) internalGet(key);
				                             ^^^^^^^^^^^^^^
			X.EntryMap.Entry is a raw type. References to generic type X.EntryMap<K,V>.Entry should be parameterized
			----------
			5. ERROR in X.java (at line 14)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=100128
public void test0759() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<E>
				{
				  E[] m;
				  public X()
				  {
					X<? extends E> x = null;
					System.out.println(x.m.length);
				  }
				}
				""",
		},
		"");
}
public void test0760() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				
				public class X<U> {
					public static <T> X<T> make() {
						return null;
					}
					public static <T> T itself(T t) {
						return t;
					}
				
					void foo() {
						X<Integer> x1 = make();
						X<Integer> x2 = itself(x1);
					}
					void bar() {
						X<Integer> x2 = itself(make());
					}
					void baz() {
						X<Integer> x2 = itself((X<Integer>)make());
					}\t
				}\s
				""",
		},
		(this.complianceLevel < ClassFileConstants.JDK1_8 ?
		"""
			----------
			1. ERROR in X.java (at line 16)
				X<Integer> x2 = itself(make());
				                ^^^^^^^^^^^^^^
			Type mismatch: cannot convert from X<Object> to X<Integer>
			----------
			2. ERROR in X.java (at line 19)
				X<Integer> x2 = itself((X<Integer>)make());
				                       ^^^^^^^^^^^^^^^^^^
			Cannot cast from X<Object> to X<Integer>
			----------
			"""
		:
		"""
			----------
			1. ERROR in X.java (at line 19)
				X<Integer> x2 = itself((X<Integer>)make());
				                       ^^^^^^^^^^^^^^^^^^
			Cannot cast from X<Object> to X<Integer>
			----------
			"""
		));
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=100421
public void test0761() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X {
				
				  public abstract class ClassA<A, B> {
				    public abstract B method(A param);
				  }
				
				  public class ClassB<C, D extends C> {
				    // the following field declaration causes an error
				    ClassA<? super C, ? extends D> classA;
				
				    public D method(D d) {
				      return classA.method(d);
				    }
				  }
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=100421 - variation
public void test0762() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X {
				
				  public abstract class ClassA<A, B extends Number> {
				    public abstract B method(A param);
				  }
				
				  public class ClassB<C extends Number, D extends C> {
				    // the following field declaration causes an error
				    ClassA<? super C, ? extends D> classA;
				
				    public D method(D d) {
				      return classA.method(d);
				    }
				  }
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=100519
public void test0763() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<E> {
					public static class InnerClass {
						public InnerClass() {
							System.out.println("class : " + InnerClass.this);
						}
					}
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=100527
public void test0764() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				\s
				interface IIfClosure {}
				\s
				public class X {
				    public X(String label, HashMap<String,Object> bindings) {
				        this(label, bindings, (List<IIfClosure>)Collections.emptyList());
				    }
				   \s
				    public X(String label, HashMap<String,Object> bindings, Collection<IIfClosure> coll) {
				    }
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 7)
				this(label, bindings, (List<IIfClosure>)Collections.emptyList());
				                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Cannot cast from List<Object> to List<IIfClosure>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98379
public void test0765() {
	this.runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				public class X {
				    static <T extends X> T f1() throws Exception{
				    	return null;
				    }
				    static <U extends X> U f2() throws Exception {
				        return f1();
				    }
				}
				""",
		},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBug6302954 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=99453
public void test0766() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				
				interface Cloneable<T extends Cloneable<T>> {
					public T clone();
				}
				
				interface CloneableMap<K, V extends Cloneable<V>> extends Map<K, V>, Cloneable<CloneableMap<K, V>> {
				}
				
				interface C<T extends C<T>> extends Cloneable<T> {
				}
				public class X {
					void foo() {
						CloneableMap<String, C<?>> map = null;
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 14)
				CloneableMap<String, C<?>> map = null;
				                     ^
			Bound mismatch: The type C<?> is not a valid substitute for the bounded parameter <V extends Cloneable<V>> of the type CloneableMap<K,V>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=99453 - variation
public void test0767() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				
				interface Cloneable<T extends Cloneable<T>> {
					public T clone();
				}
				
				interface CloneableMap<K, V extends Cloneable<V>> extends Map<K, V>, Cloneable<CloneableMap<K, V>> {
				}
				
				interface C extends Cloneable<C> {
				}
				public class X {
					void foo() {
						CloneableMap<String, C> map = null;
					}
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=100619
public void test0768() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					<T extends Runnable, U extends Runnable & T>  T foo1() { return null; }
					<T extends Y<Object>, U extends Z & T>  T foo2() { return null; }
					<T extends Y<Object>, U extends T & Z>  T foo3() { return null; }
					<T extends Y<Object>, U extends W & Z>  T foo4() { return null; }
				}
				
				interface Y<T> {
				}
				
				interface Z extends Y<String> {}
				interface W extends Y<Object> {}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 2)
				<T extends Runnable, U extends Runnable & T>  T foo1() { return null; }
				                                          ^
			The type T is not an interface; it cannot be specified as a bounded parameter
			----------
			2. ERROR in X.java (at line 3)
				<T extends Y<Object>, U extends Z & T>  T foo2() { return null; }
				                                    ^
			The type T is not an interface; it cannot be specified as a bounded parameter
			----------
			3. ERROR in X.java (at line 4)
				<T extends Y<Object>, U extends T & Z>  T foo3() { return null; }
				                                    ^
			Cannot specify any additional bound Z when first bound is a type parameter
			----------
			4. ERROR in X.java (at line 4)
				<T extends Y<Object>, U extends T & Z>  T foo3() { return null; }
				                                    ^
			The interface Y cannot be implemented more than once with different arguments: Y<String> and Y<Object>
			----------
			5. ERROR in X.java (at line 5)
				<T extends Y<Object>, U extends W & Z>  T foo4() { return null; }
				                                    ^
			The interface Y cannot be implemented more than once with different arguments: Y<String> and Y<Object>
			----------
			""");
}
public void test0769() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				class XSuper<T> {
					T value;
				}
				public class X extends XSuper<String>{
					public void a() {
						value += 1;
						value = value + 1;
						System.out.println(value);
					}
				
					public static void main(final String[] args) {
						X x = new X();
						x.value = "[";
						x.a();
					}
				}
				""",
		},
		"[11");
}
public void test0770() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				class XSuper<T> {
					T value;
				}
				public class X extends XSuper<String>{
					public void a() {
						this.value += 1;
						this.value = this.value + 1;
						System.out.println(this.value);
					}
				
					public static void main(final String[] args) {
						X x = new X();
						x.value = "[";
						x.a();
					}
				}
				""",
		},
		"[11");
}
public void test0771() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				class XSuper<T> {
					T value;
				}
				public class X extends XSuper<String>{
					public static void a(X x) {
						x.value += 1;
						x.value = x.value + 1;
						System.out.println(x.value);
					}
				
					public static void main(final String[] args) {
						X x = new X();
						x.value = "[";
						a(x);
					}
				}
				""",
		},
		"[11");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=101794
public void test0772() throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				interface Foo<T> {
				  public T getIt();
				}
				
				class FooImpl implements Foo {
				  public String getIt() {
				    return null;
				  }
				}
				public class X {
				  public void doIt() {
				    Object s = new FooImpl().getIt();
				  }
				}
				""",
		},
		"");
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X {
				  public void doIt() {
				    Object s = new FooImpl().getIt();
				  }
				}
				""",
		},
		"",
		null,
		false,
		null);
		String expectedOutput =
			"""
			  // Method descriptor #18 ()Ljava/lang/Object;
			  // Stack: 1, Locals: 1
			  public bridge synthetic java.lang.Object getIt();
			    0  aload_0 [this]
			    1  invokevirtual FooImpl.getIt() : java.lang.String [19]
			    4  areturn
			      Line numbers:
			        [pc: 0, line: 1]
			""";

		File f = new File(OUTPUT_DIR + File.separator + "FooImpl.class");
		byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
		ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
		String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
		int index = result.indexOf(expectedOutput);
		if (index == -1 || expectedOutput.length() == 0) {
			System.out.println(Util.displayString(result, 3));
		}
		if (index == -1) {
			assertEquals("Wrong contents", expectedOutput, result);
		}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=101794 - variation
public void test0773() throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				interface Foo<T extends Exception> {
				  public T getIt() throws T;
				}
				
				class FooImpl implements Foo {
				  public NullPointerException getIt() {
				    return null;
				  }
				}
				public class X {
				  public void doIt() {
				    Object s = new FooImpl().getIt();
				  }
				}
				""",
		},
		"");
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X {
				  public void doIt() {
				    Object s = new FooImpl().getIt();
				  }
				}
				""",
		},
		"",
		null,
		false,
		null);
		String expectedOutput =
			"""
			  // Method descriptor #18 ()Ljava/lang/Exception;
			  // Stack: 1, Locals: 1
			  public bridge synthetic java.lang.Exception getIt() throws java.lang.Exception;
			    0  aload_0 [this]
			    1  invokevirtual FooImpl.getIt() : java.lang.NullPointerException [22]
			    4  areturn
			      Line numbers:
			        [pc: 0, line: 1]
			""";

		File f = new File(OUTPUT_DIR + File.separator + "FooImpl.class");
		byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
		ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
		String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
		int index = result.indexOf(expectedOutput);
		if (index == -1 || expectedOutput.length() == 0) {
			System.out.println(Util.displayString(result, 3));
		}
		if (index == -1) {
			assertEquals("Wrong contents", expectedOutput, result);
		}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=98532
public void test0774() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {
					static class StaticInnerNoParam {
						T x;
					}
					class NonStaticInnerParam<T> {}\t
					static class StaticInnerParam<T> {	}
					<T> void foo(T t) {}
					static <T> void bar(T t) {}
					<T> X(T t) {}
				\t
					class U {}
					<U> void foo2(U t) {}
					static <U> void bar2(U t) {}
					class NonStaticInnerParam2<U> {}\t
					static class StaticInnerParam2<U> {}\t
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 3)
				T x;
				^
			Cannot make a static reference to the non-static type T
			----------
			2. WARNING in X.java (at line 5)
				class NonStaticInnerParam<T> {}\t
				                          ^
			The type parameter T is hiding the type T
			----------
			3. WARNING in X.java (at line 7)
				<T> void foo(T t) {}
				 ^
			The type parameter T is hiding the type T
			----------
			4. WARNING in X.java (at line 9)
				<T> X(T t) {}
				 ^
			The type parameter T is hiding the type T
			----------
			5. WARNING in X.java (at line 12)
				<U> void foo2(U t) {}
				 ^
			The type parameter U is hiding the type X<T>.U
			----------
			6. WARNING in X.java (at line 13)
				static <U> void bar2(U t) {}
				        ^
			The type parameter U is hiding the type X<T>.U
			----------
			7. WARNING in X.java (at line 14)
				class NonStaticInnerParam2<U> {}\t
				                           ^
			The type parameter U is hiding the type X<T>.U
			----------
			8. WARNING in X.java (at line 15)
				static class StaticInnerParam2<U> {}\t
				                               ^
			The type parameter U is hiding the type X<T>.U
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=100153
public void test0775() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends X<T>> {
					void foo1(X<? extends T> x) {}
					void foo2(X<? super T> x) {}
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=103023
public void test0776() {
	runConformTest(
		// test directory preparation
		true /* flush output directory */,
		new String[] { /* test files */
			"X.java",
			"""
				import java.util.*;
				
				public class X<T extends Comparable<? super T>> {
				
				    abstract class Foo<E> implements I<Foo<? extends E>> {}
				
				    abstract class Bar<E> implements I<Bar<? extends E>> {}
				
				    public void bar(List<Foo<T>> f, List<Bar<T>> b) {
					foo(f, b);
				    }
				
				    <C> void foo(List<? extends C> f, List<? extends C> b) {
					System.out.println("SUCCESS");
				    }
				    public static void main(String... args) {
					new X().bar(null, null);
				    }
				}
				interface I<U> {}
				""",
		},
		// compiler results
		null /* do not check compiler log */,
		// runtime results
		"SUCCESS" /* expected output string */,
		null /* do not check error string */,
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=103472
public void test0777() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public interface B<T> {
						public T a();
					}
				
					public interface C extends B {
					}
				
					public class D implements B<Integer> {
						public Integer a() {
							return 0;
						}
					}
				
					// Illegal
					public class E implements B<Integer>, C {
						public Integer a() {
							return 0;
						}
					}
				
					// why is this allowed?
					public class F extends D implements C {
						public Integer a() {
							return 0;
						}
					}
				
					public interface G<T> {
						public void a(T pArg);
					}
				
					public interface H extends G {
						public Object b();
					}
				
					public class I implements G<Integer> {
						public void a(Integer pInt) {
						}
					}
				
					// Illegal. Huh?
					public class J extends I implements G {
						public Integer a() {
							return 0;
						}
					}
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 6)
				public interface C extends B {
				                           ^
			X.B is a raw type. References to generic type X.B<T> should be parameterized
			----------
			2. ERROR in X.java (at line 16)
				public class E implements B<Integer>, C {
				             ^
			The interface B cannot be implemented more than once with different arguments: X.B and X.B<Integer>
			----------
			3. ERROR in X.java (at line 23)
				public class F extends D implements C {
				             ^
			The interface B cannot be implemented more than once with different arguments: X.B<Integer> and X.B
			----------
			4. WARNING in X.java (at line 24)
				public Integer a() {
				               ^^^
			The method a() of type X.F should be tagged with @Override since it actually overrides a superclass method
			----------
			5. WARNING in X.java (at line 33)
				public interface H extends G {
				                           ^
			X.G is a raw type. References to generic type X.G<T> should be parameterized
			----------
			6. ERROR in X.java (at line 43)
				public class J extends I implements G {
				             ^
			The interface G cannot be implemented more than once with different arguments: X.G<Integer> and X.G
			----------
			7. WARNING in X.java (at line 43)
				public class J extends I implements G {
				                                    ^
			X.G is a raw type. References to generic type X.G<T> should be parameterized
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=103472 - variation
public void test0778() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					interface B<T> {}
				
					interface C extends B {}
				
					class D implements B<Integer> {}
				
					class F extends D implements C {}
				\t
					class V<U extends D & C> {}
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 4)
				interface C extends B {}
				                    ^
			X.B is a raw type. References to generic type X.B<T> should be parameterized
			----------
			2. ERROR in X.java (at line 8)
				class F extends D implements C {}
				      ^
			The interface B cannot be implemented more than once with different arguments: X.B<Integer> and X.B
			----------
			3. ERROR in X.java (at line 10)
				class V<U extends D & C> {}
				                      ^
			The interface B cannot be implemented more than once with different arguments: X.B and X.B<Integer>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=103227
public void test0779() throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.AbstractList;
				import java.util.List;
				
				public class X {
					private static class Entry {
						public void doIt(final List<? extends String> args) {
							List<String> list = new AbstractList<String>() {
								@Override public int size() { return 0; }
								@Override public String get(int i) { return args.get(i); }
							};
						}
					}
					public static void main(String[] args) {
						new Entry().doIt(null);
						System.out.println("SUCCESS");
					}
				}
				""",
		},
		"SUCCESS");

	String expectedOutput =
		"""
		  // Method descriptor #31 (I)Ljava/lang/Object;
		  // Stack: 2, Locals: 2
		  public bridge synthetic java.lang.Object get(int arg0);
		    0  aload_0 [this]
		    1  iload_1 [arg0]
		    2  invokevirtual X$Entry$1.get(int) : java.lang.String [36]
		    5  areturn
		      Line numbers:
		        [pc: 0, line: 1]
		""";

	// check no unnecessary checkcast on bridge method for X$1
	File f = new File(OUTPUT_DIR + File.separator + "X$Entry$1.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=103227 - variation
public void test0780() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				
				public class X {
					long foo(List<? extends Long> list) {
						return list.get(0);
					}
					public static void main(String[] args) {
						List<Long> list = new ArrayList<Long>();
						list.add(123L);
						System.out.println(new X().foo(list));
					}
				}
				""",
		},
		"123");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=104109
public void test0781() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
				
				    public static <E, T extends E & Comparable<? super T>> Foo<E> doIt(T t) {
				        return null;
				    }
				   \s
				    interface Foo<E> {
				        boolean ok(E e);
				    }
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 3)
				public static <E, T extends E & Comparable<? super T>> Foo<E> doIt(T t) {
				                                ^^^^^^^^^^
			Cannot specify any additional bound Comparable<? super T> when first bound is a type parameter
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=104082
public void test0782() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.lang.reflect.*;
				import java.util.*;
				
				interface StoredObject {
					String getUid();
					String getName();
					String getDescription();
				}
				
				interface GraphDiagramNode // extends Comparable
				{
				}
				
				public class X<ObjectType extends StoredObject, ParentType extends StoredObject> implements GraphDiagramNode {
					private final JccsGraphDiagramModel model;
					private final X<? extends ParentType, ?> parent;
					private final ObjectType object;
				
					public class JccsGraphDiagramModel {
					}
				
					public interface GraphDiagramModel {
					}
				
					public class Dependency {
				
					}
				
					public X(JccsGraphDiagramModel argModel, X<? extends ParentType, ?> argParent, ObjectType argObject) {
						model = argModel;
						parent = argParent;
						object = argObject;
					}
				
					protected <ChildType extends StoredObject> Collection<? extends X<ChildType, ? super ObjectType>> createChildren(
							Iterator<ChildType> argData, Class<? extends X<ChildType, ? super ObjectType>> argChildNodeClass,
							Class<? extends StoredObject> argInterface) {
						Collection<X<ChildType, ? super ObjectType>> output = new LinkedList<X<ChildType, ? super ObjectType>>();
				
						try {
							while (argData.hasNext()) {
								ChildType next = argData.next();
								Constructor<? extends X<ChildType, ? super ObjectType>> constructor = argChildNodeClass.getConstructor(
										JccsGraphDiagramModel.class, getClass(), argInterface);
				
								output.add(constructor.newInstance(model, this, next));
							}
						} catch (Exception x) {
							x.printStackTrace();
						}
				
						return output;
					}
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=104167
public void test0783() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {
				  private static class B{
				    private int foo; //incorrectly identified as unused
				  }
				  void bar(B b){
				    if (b.foo == 0)
				      return;
				  }
				  Zork z;
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 9)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=104082 - variation
public void test0784() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T, U> {
					X<? extends U, ?> parent;
				
					public X(X<? extends U, ?> parent) {
						this.parent = parent;
					}
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=103528
public void test0785() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				public class X {
				    <T extends Collection<? extends Number>> T getLonger(T t1, T t2) {
				        return t1.size() > t2.size() ? t1 : t2;
				    }
				   \s
				    void m(HashSet<?> list, ArrayList<?> set) {
				        getLonger(list, set);
				    }
				}
				""",
		},
		this.complianceLevel < ClassFileConstants.JDK1_8 ?
		"""
			----------
			1. ERROR in X.java (at line 8)
				getLonger(list, set);
				^^^^^^^^^
			Bound mismatch: The generic method getLonger(T, T) of type X is not applicable for the arguments (HashSet<capture#3-of ?>, ArrayList<capture#4-of ?>). The inferred type AbstractCollection<? extends Object>&Cloneable&Serializable is not a valid substitute for the bounded parameter <T extends Collection<? extends Number>>
			----------
			""" :
			"""
				----------
				1. ERROR in X.java (at line 8)
					getLonger(list, set);
					^^^^^^^^^
				The method getLonger(T, T) in the type X is not applicable for the arguments (HashSet<capture#3-of ?>, ArrayList<capture#4-of ?>)
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=103528 - variation
public void test0786() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				public class X {
				    <T extends Collection<? extends Object>> T getLonger(T t1, T t2) {
				        return t1.size() > t2.size() ? t1 : t2;
				    }
				   \s
				    void m(HashSet<?> list, ArrayList<?> set) {
				        getLonger(list, set);
				    }
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=103528 - variation
public void test0787() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				public class X<U> {
				    <T extends Collection<? extends U>> T getLonger(T t1, T t2) {
				        return t1.size() > t2.size() ? t1 : t2;
				    }
				   \s
				    void m(HashSet<?> list, ArrayList<?> set) {
				        getLonger(list, set);
				    }
				}
				""",
		},
		this.complianceLevel < ClassFileConstants.JDK1_8 ?
		"""
			----------
			1. ERROR in X.java (at line 8)
				getLonger(list, set);
				^^^^^^^^^
			Bound mismatch: The generic method getLonger(T, T) of type X<U> is not applicable for the arguments (HashSet<capture#3-of ?>, ArrayList<capture#4-of ?>). The inferred type AbstractCollection<? extends Object>&Cloneable&Serializable is not a valid substitute for the bounded parameter <T extends Collection<? extends U>>
			----------
			""" :
			"""
				----------
				1. ERROR in X.java (at line 8)
					getLonger(list, set);
					^^^^^^^^^
				The method getLonger(T, T) in the type X<U> is not applicable for the arguments (HashSet<capture#3-of ?>, ArrayList<capture#4-of ?>)
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=103994
public void test0788() {
	this.runConformTest(
		new String[] {
			"test/A.java",
			"""
				package test;
				
				public class A<C extends java.nio.channels.Channel>
				{
					class B
						extends A<java.nio.channels.SocketChannel>
					{
					}
				}
				""",
			"java/nio/channels/spi/AbstractSelectableChannel.java",
			"""
				package java.nio.channels.spi;
				
				public abstract class AbstractSelectableChannel
					extends java.nio.channels.SelectableChannel
				{
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=103994 - variation (change ordering of files should have no effect)
public void test0789() {
	this.runConformTest(
		new String[] {
			"java/nio/channels/spi/AbstractSelectableChannel.java",
			"""
				package java.nio.channels.spi;
				
				public abstract class AbstractSelectableChannel
					extends java.nio.channels.SelectableChannel
				{
				}
				""",
			"test/A.java",
			"""
				package test;
				
				public class A<C extends java.nio.channels.Channel>
				{
					class B
						extends A<java.nio.channels.SocketChannel>
					{
					}
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=103485
public void test0790() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					<T extends Comparable<T>> boolean isGreater(T t1, T t2) {
						return t1.compareTo(t2) > 0 ? true : false;\s
					}
				
					void method1(Integer i, Double d) {
						if (isGreater(i, d))\s
							System.out.println("GREATER");
						else
							System.out.println("LOWER");
					}
					void method2(Integer i, Double d) {
						Comparable<? extends Number> c1= i;
						Comparable<? extends Number> c2= d;
						isGreater(c1, c2);
					}\t
					void method3(Integer i, Double d) {
						Comparable c1= i;
						Comparable c2= d;
						isGreater(c1, c2);
					}\t
					public static void main(String[] args) {
						Integer i = 1;
						Double d = 2.0;
						new X().method1(i, d);
						new X().method2(i, d);
						new X().method3(i, d);
					}
				}
				""",
		},
		this.complianceLevel < ClassFileConstants.JDK1_8 ?
		"----------\n" +
		"1. ERROR in X.java (at line 7)\n" +
		"	if (isGreater(i, d)) \n" +
		"	    ^^^^^^^^^\n" +
		"Bound mismatch: The generic method isGreater(T, T) of type X is not applicable for the arguments (Integer, Double). The inferred type "+ intersection("Number", "Comparable<?>") +" is not a valid substitute for the bounded parameter <T extends Comparable<T>>\n" +
		"----------\n" +
		"2. ERROR in X.java (at line 15)\n" +
		"	isGreater(c1, c2);\n" +
		"	^^^^^^^^^\n" +
		"Bound mismatch: The generic method isGreater(T, T) of type X is not applicable for the arguments (Comparable<capture#1-of ? extends Number>, Comparable<capture#2-of ? extends Number>). The inferred type Comparable<? extends Number> is not a valid substitute for the bounded parameter <T extends Comparable<T>>\n" +
		"----------\n" +
		"3. WARNING in X.java (at line 18)\n" +
		"	Comparable c1= i;\n" +
		"	^^^^^^^^^^\n" +
		"Comparable is a raw type. References to generic type Comparable<T> should be parameterized\n" +
		"----------\n" +
		"4. WARNING in X.java (at line 19)\n" +
		"	Comparable c2= d;\n" +
		"	^^^^^^^^^^\n" +
		"Comparable is a raw type. References to generic type Comparable<T> should be parameterized\n" +
		"----------\n" +
		"5. WARNING in X.java (at line 20)\n" +
		"	isGreater(c1, c2);\n" +
		"	^^^^^^^^^^^^^^^^^\n" +
		"Type safety: Unchecked invocation isGreater(Comparable, Comparable) of the generic method isGreater(T, T) of type X\n" +
		"----------\n" :
			"""
				----------
				1. ERROR in X.java (at line 7)
					if (isGreater(i, d))\s
					    ^^^^^^^^^
				The method isGreater(T, T) in the type X is not applicable for the arguments (Integer, Double)
				----------
				2. ERROR in X.java (at line 15)
					isGreater(c1, c2);
					^^^^^^^^^
				The method isGreater(T, T) in the type X is not applicable for the arguments (Comparable<capture#1-of ? extends Number>, Comparable<capture#2-of ? extends Number>)
				----------
				3. WARNING in X.java (at line 18)
					Comparable c1= i;
					^^^^^^^^^^
				Comparable is a raw type. References to generic type Comparable<T> should be parameterized
				----------
				4. WARNING in X.java (at line 19)
					Comparable c2= d;
					^^^^^^^^^^
				Comparable is a raw type. References to generic type Comparable<T> should be parameterized
				----------
				5. WARNING in X.java (at line 20)
					isGreater(c1, c2);
					^^^^^^^^^^^^^^^^^
				Type safety: Unchecked invocation isGreater(Comparable, Comparable) of the generic method isGreater(T, T) of type X
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=104655
public void test0791() {
	runConformTest(
		// test directory preparation
		true /* flush output directory */,
		new String[] { /* test files */
			"X.java",
			"""
				public class X {
				  <Sup, E1 extends Sup, E2 extends Sup> Sup method1(boolean b, E1 e1, E2 e2) {
				    if (b)
				      return e1;
				    else
				      return e2;
				  }
				
				  <Sup, E1 extends Sup, E2 extends Sup> Sup method2(boolean b, E1 e1, E2 e2) {
				    return b ? e1 : e2;
				  }
				}
				""",
		},
		// compiler results
		null /* do not check compiler log */,
		// runtime results
		"" /* expected output string */,
		null /* do not check error string */,
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_7 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=104649
public void test0792() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				public class X<E> {
					void shouldcompile() {
						java.util.Collections.max(null);
					}
				}
				""",
		},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_7 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=105635
public void test0793() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				class X {\s
					public java.util.List<Integer> i,j[],k;
					void m() {
						  i[0] = null;
						  j[0] = null;
						  k[0] = null;
					}
				}""",
		},
		"""
			----------
			1. ERROR in X.java (at line 4)
				i[0] = null;
				^^^^
			The type of the expression must be an array type but it resolved to List<Integer>
			----------
			2. ERROR in X.java (at line 6)
				k[0] = null;
				^^^^
			The type of the expression must be an array type but it resolved to List<Integer>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=105635
public void test0794() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.List;
				class X {\s
					public List<Integer> i,j[],k;
					void m() {
						  i[0] = null;
						  j[0] = null;
						  k[0] = null;
					}
				}""",
		},
		"""
			----------
			1. ERROR in X.java (at line 5)
				i[0] = null;
				^^^^
			The type of the expression must be an array type but it resolved to List<Integer>
			----------
			2. ERROR in X.java (at line 7)
				k[0] = null;
				^^^^
			The type of the expression must be an array type but it resolved to List<Integer>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=106297
public void test0795() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {\s
						 class B {
							 B() {
								 System.out.println("SUCCESS");
							 }
						 }
						 static {\s
						 		 new X<String>().new B() {};
						 }
						 public static void main(String[] args) {
						\t
						}
				}
				""",
		},
		"SUCCESS");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=106297 - variation
public void test0796() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {\s
						 class B {
							 B(T t) {
								 System.out.println("SUCCESS");
							 }
						 }
						 static {\s
						 		 new X<String>().new B(12) {};
						 }
						 public static void main(String[] args) {
						\t
						}
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 8)
				new X<String>().new B(12) {};
				^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			The constructor X<String>.B(int) is undefined
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=106297 - variation
public void test0797() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {\s
						 class B {
							 B() {
								 System.out.println("SUCCESS");
							 }
						 }
						 static {\s
						 		 new X<String>().new B();
						 }
						 public static void main(String[] args) {
						\t
						}
				}
				""",
		},
		"SUCCESS");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=106284
public void test0798() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.math.BigDecimal;
				
				public class X
				{
				    private static <T extends Comparable<? super T>> T max(T... elems)
				    {
				        T max=null;
				        for (T elem : elems)
				            if (max == null || max.compareTo(elem) < 0)
				                max=elem;
				        return max;
				    }
				
				    public static void main(String[] args)
				    {
				        System.out.println(max(1, 2.0, new BigDecimal(Math.PI)));
				    }
				}
				""",
		},
		this.complianceLevel < ClassFileConstants.JDK1_7 ?
		"""
			----------
			1. ERROR in X.java (at line 16)
				System.out.println(max(1, 2.0, new BigDecimal(Math.PI)));
				                   ^^^
			Bound mismatch: The generic method max(T...) of type X is not applicable for the arguments (Integer, Double, BigDecimal). The inferred type Number&Comparable<?> is not a valid substitute for the bounded parameter <T extends Comparable<? super T>>
			----------
			""" :
			this.complianceLevel < ClassFileConstants.JDK1_8 ?
			"""
				----------
				1. WARNING in X.java (at line 5)
					private static <T extends Comparable<? super T>> T max(T... elems)
					                                                            ^^^^^
				Type safety: Potential heap pollution via varargs parameter elems
				----------
				2. ERROR in X.java (at line 16)
					System.out.println(max(1, 2.0, new BigDecimal(Math.PI)));
					                   ^^^
				Bound mismatch: The generic method max(T...) of type X is not applicable for the arguments (Integer, Double, BigDecimal). The inferred type Number&Comparable<?> is not a valid substitute for the bounded parameter <T extends Comparable<? super T>>
				----------
				""" :
				"""
					----------
					1. WARNING in X.java (at line 5)
						private static <T extends Comparable<? super T>> T max(T... elems)
						                                                            ^^^^^
					Type safety: Potential heap pollution via varargs parameter elems
					----------
					2. ERROR in X.java (at line 16)
						System.out.println(max(1, 2.0, new BigDecimal(Math.PI)));
						                   ^^^
					The method max(T...) in the type X is not applicable for the arguments (int, double, BigDecimal)
					----------
					""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=105531
public void test0799() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {
					Y first;
					Y first2;
				
					<U> U foo(U u1, U u2) {
						return u1;
					}
					void bar2(Y<? extends T> ref) {
						String s = foo(ref, first);
					}
				\t
					void foo(Y<? extends T> ref) {
						ref.next = first == null ? ref : first;
						String s = first == null ? ref : first;
						ref.next = first2 == null ? ref : first2;
					}
					Y<? extends T> bar(Y<? extends T> ref) {
						return first == null ? ref : first;
					}
				}
				
				class Y<E> {
					Y<E> next;
				}
				""",
		},
		this.complianceLevel < ClassFileConstants.JDK1_8 ?
			"""
				----------
				1. WARNING in X.java (at line 2)
					Y first;
					^
				Y is a raw type. References to generic type Y<E> should be parameterized
				----------
				2. WARNING in X.java (at line 3)
					Y first2;
					^
				Y is a raw type. References to generic type Y<E> should be parameterized
				----------
				3. ERROR in X.java (at line 9)
					String s = foo(ref, first);
					           ^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Y to String
				----------
				4. WARNING in X.java (at line 13)
					ref.next = first == null ? ref : first;
					           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: The expression of type Y needs unchecked conversion to conform to Y<capture#2-of ? extends T>
				----------
				5. ERROR in X.java (at line 14)
					String s = first == null ? ref : first;
					           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Y to String
				----------
				6. WARNING in X.java (at line 15)
					ref.next = first2 == null ? ref : first2;
					           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: The expression of type Y needs unchecked conversion to conform to Y<capture#5-of ? extends T>
				----------
				7. WARNING in X.java (at line 18)
					return first == null ? ref : first;
					       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: The expression of type Y needs unchecked conversion to conform to Y<? extends T>
				----------
				""" :
				"""
					----------
					1. WARNING in X.java (at line 2)
						Y first;
						^
					Y is a raw type. References to generic type Y<E> should be parameterized
					----------
					2. WARNING in X.java (at line 3)
						Y first2;
						^
					Y is a raw type. References to generic type Y<E> should be parameterized
					----------
					3. ERROR in X.java (at line 9)
						String s = foo(ref, first);
						           ^^^^^^^^^^^^^^^
					Type mismatch: cannot convert from Y to String
					----------
					4. ERROR in X.java (at line 13)
						ref.next = first == null ? ref : first;
						                           ^^^
					Type mismatch: cannot convert from Y<capture#3-of ? extends T> to Y<capture#2-of ? extends T>
					----------
					5. WARNING in X.java (at line 13)
						ref.next = first == null ? ref : first;
						                                 ^^^^^
					Type safety: The expression of type Y needs unchecked conversion to conform to Y<capture#2-of ? extends T>
					----------
					6. ERROR in X.java (at line 14)
						String s = first == null ? ref : first;
						                           ^^^
					Type mismatch: cannot convert from Y<capture#4-of ? extends T> to String
					----------
					7. ERROR in X.java (at line 14)
						String s = first == null ? ref : first;
						                                 ^^^^^
					Type mismatch: cannot convert from Y to String
					----------
					8. ERROR in X.java (at line 15)
						ref.next = first2 == null ? ref : first2;
						                            ^^^
					Type mismatch: cannot convert from Y<capture#6-of ? extends T> to Y<capture#5-of ? extends T>
					----------
					9. WARNING in X.java (at line 15)
						ref.next = first2 == null ? ref : first2;
						                                  ^^^^^^
					Type safety: The expression of type Y needs unchecked conversion to conform to Y<capture#5-of ? extends T>
					----------
					10. WARNING in X.java (at line 18)
						return first == null ? ref : first;
						                             ^^^^^
					Type safety: The expression of type Y needs unchecked conversion to conform to Y<? extends T>
					----------
					""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=106744
public void test0800() {
	runNegativeTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				import java.lang.reflect.Constructor;
				
				public class X {
					public static void main(String[] args) {
				        final Class<Ann> AnnClass = Ann.class;
					    Constructor[] constrs = X.class.getConstructors();
				        for (Constructor constructor  : constrs) {
				            final String message = constructor.getAnnotation(AnnClass).message();
				            System.out.println(message);
				        }
					}
				}
				
				@interface Ann {
					String message();
				}
				""",
		},
		// compiler results
		"----------\n" + /* expected compiler log */
		"1. WARNING in X.java (at line 6)\n" +
		"	Constructor[] constrs = X.class.getConstructors();\n" +
		"	^^^^^^^^^^^\n" +
		"Constructor is a raw type. References to generic type Constructor<T> should be parameterized\n" +
		"----------\n" +
		"2. WARNING in X.java (at line 7)\n" +
		"	for (Constructor constructor  : constrs) {\n" +
		"	     ^^^^^^^^^^^\n" +
		"Constructor is a raw type. References to generic type Constructor<T> should be parameterized\n" +
		"----------\n" +
		"3. WARNING in X.java (at line 8)\n" +
		"	final String message = constructor.getAnnotation(AnnClass).message();\n" +
		"	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
		"Type safety: The method getAnnotation(Class) belongs to the raw type Constructor. References to generic type Constructor<T> should be parameterized\n" +
		"----------\n" +
		"4. ERROR in X.java (at line 8)\n" +
		"	final String message = constructor.getAnnotation(AnnClass).message();\n" +
		"	                                                           ^^^^^^^\n" +
		"The method message() is undefined for the type Annotation\n" +
		"----------\n",
		// javac options
		JavacTestOptions.JavacHasABug.JavacBug6400189 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=106744 - variation
public void test0801() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public static void main(String[] args) {
						try {
						    X.class.getConstructor(new Class[0]).getAnnotation(Ann.class).message();
						} catch(Exception e) {
						}
					}
				}
				
				@interface Ann {
					String message();
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=106744 - variation
public void test0802() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<U> {
				    void bar(Y y, X<ZZ> x) {
				    	y.foo(x).zz();
				    }
				}
				class Y<V> {
				    <T extends Z> T foo(X<T> x) { return null; }
				}
				
				class Z {
				}
				class ZZ extends Z {
					void zz() {}
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 2)
				void bar(Y y, X<ZZ> x) {
				         ^
			Y is a raw type. References to generic type Y<V> should be parameterized
			----------
			2. WARNING in X.java (at line 3)
				y.foo(x).zz();
				^^^^^^^^
			Type safety: The method foo(X) belongs to the raw type Y. References to generic type Y<V> should be parameterized
			----------
			3. ERROR in X.java (at line 3)
				y.foo(x).zz();
				         ^^
			The method zz() is undefined for the type Z
			----------
			""");
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=101831
public void test0803() {
	this.runNegativeTest(
		false /* skipJavac */,
		this.complianceLevel < ClassFileConstants.JDK1_8 ? null : JavacTestOptions.Excuse.EclipseHasSomeMoreWarnings,
		new String[] {
			"X.java",
			"""
				import java.util.*;
				
				public class X<A> {
				  ArrayList<A> list = new ArrayList<A>();
				  ArrayList<? super A> superList = new ArrayList<A>();
				  ArrayList<? extends A> extendsList = new ArrayList<A>();
				
				  ArrayList<A> getList() {
				    return true ? list : list;
				  }
				
				  ArrayList<? super A> getSuperList() {
				    return true ? superList : superList;
				  }
				
				  ArrayList<? extends A> getExtendsList() {
				    return true ? extendsList : extendsList;
				  }
				}
				""",
		},
		this.complianceLevel < ClassFileConstants.JDK1_8 ?
			"""
				----------
				1. WARNING in X.java (at line 9)
					return true ? list : list;
					                     ^^^^
				Dead code
				----------
				2. ERROR in X.java (at line 13)
					return true ? superList : superList;
					       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from ArrayList<capture#3-of ? extends Object> to ArrayList<? super A>
				----------
				3. WARNING in X.java (at line 17)
					return true ? extendsList : extendsList;
					                            ^^^^^^^^^^^
				Dead code
				----------
				""" :
				"""
					----------
					1. WARNING in X.java (at line 9)
						return true ? list : list;
						                     ^^^^
					Dead code
					----------
					2. WARNING in X.java (at line 13)
						return true ? superList : superList;
						                          ^^^^^^^^^
					Dead code
					----------
					3. WARNING in X.java (at line 17)
						return true ? extendsList : extendsList;
						                            ^^^^^^^^^^^
					Dead code
					----------
					"""
			);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=106865
public void test0804() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				class Y<E> {
					void foo(E e) {
					}
				}
				public class X {
				    void method1(Y<? super Object[]> y, Object[] os) {
				        y.foo(os);
				    }
				    void method2(Y<? super Cloneable> y, Cloneable c) {
				        y.foo(c);
				    }   \s
				    void method3(Y<? extends Object[]> y, Object[] os) {
				        y.foo(os);
				    }
				    void method4(Y<? extends Cloneable> y, Cloneable c) {
				        y.foo(c);
				    }   \s
				   \s
				    void bar(Y<Object> y) {
				    	method2(y, null);
				    }
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 13)
				y.foo(os);
				  ^^^
			The method foo(capture#3-of ? extends Object[]) in the type Y<capture#3-of ? extends Object[]> is not applicable for the arguments (Object[])
			----------
			2. ERROR in X.java (at line 16)
				y.foo(c);
				  ^^^
			The method foo(capture#4-of ? extends Cloneable) in the type Y<capture#4-of ? extends Cloneable> is not applicable for the arguments (Cloneable)
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=106936
public void test0805() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
				 	static <T> T foo(T t1, T t2) { return t1; }
				 	public static void main(String[] args) {
						Number[] numbers = {}, numbers2, numbers3;
						Float[] floats = {};
						Integer[] integers = {};
				
						numbers2 = foo(numbers, floats);
				 		numbers3 = numbers != null ? numbers : floats;
				 		String s = foo(numbers, floats); 	\t
				
				 		numbers2 = foo(integers, floats);
				 		numbers3 = integers != null ? integers : floats;
				 		String s2 = foo(integers, floats);
				 	}
				}
				""",
		},
		"----------\n" +
		"1. ERROR in X.java (at line 10)\n" +
		"	String s = foo(numbers, floats); 		\n" +
		"	           ^^^^^^^^^^^^^^^^^^^^\n" +
		"Type mismatch: cannot convert from Number[] to String\n" +
		"----------\n" +
		"2. ERROR in X.java (at line 14)\n" +
		"	String s2 = foo(integers, floats);\n" +
		"	            ^^^^^^^^^^^^^^^^^^^^^\n" +
		"Type mismatch: cannot convert from "+intersection("Number",
				intersection("Comparable<? extends "+intersection("Number","Comparable<?>")+">")
				)+"[] to String\n" +
		"----------\n");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=107079
public void test0806() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.ArrayList;
				import java.util.List;
				
				/**
				 * This class demonstrates a generic program that Eclipse must not compile as it
				 * can lead to a ClassCastException despite having no explicit type casts.
				 */
				public class X {
					private static class ValueHolder<T> {
						public T value;
					}
				
					public static void main(final String[] args) {
						List<ValueHolder<?>> multiList = new ArrayList<ValueHolder<?>>();
				
						ValueHolder<Integer> intHolder = new ValueHolder<Integer>();
						intHolder.value = 1;
				
						ValueHolder<Double> doubleHolder = new ValueHolder<Double>();
						doubleHolder.value = 1.5;
				
						multiList.add(intHolder);
						multiList.add(doubleHolder);
				
						// I believe this line is being erroneously treated as a capture
				        // conversion under 3.1 JDT.
						// I believe the problem is that ? cannot be captured except in a first
				        // level wildcard.
						swapFirstTwoValues(multiList);
				
						// this line causes a ClassCastException when checked.
						Integer value = intHolder.value;
						System.out.println(value);
					}
				
					private static <T> void swapFirstTwoValues(List<ValueHolder<T>> multiList) {
						ValueHolder<T> intHolder = multiList.get(0);
						ValueHolder<T> doubleHolder = multiList.get(1);
				
						intHolder.value = doubleHolder.value;
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 29)
				swapFirstTwoValues(multiList);
				^^^^^^^^^^^^^^^^^^
			The method swapFirstTwoValues(List<X.ValueHolder<T>>) in the type X is not applicable for the arguments (List<X.ValueHolder<?>>)
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=107756
public void test0807() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				interface Prop<BeanT> {
					Unmarshaller.Handler createHandler();
				}
				
				abstract class Unmarshaller {
					public static abstract class Handler {}
				}
				
				public class X {
					void foo(Prop p) {
						Unmarshaller.Handler h = p.createHandler();\s
					}
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=107756 - variation
public void test0808() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {
				   \s
				    public static void main(String[] args) {
				        X x = new X();
				        x.ax = new AX<String>();
				    }
				   \s
				    AX<T> ax;
				}
				
				class AX <P> {
				    AX<P> p;
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=106946
public void test0809() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.Iterator;
				
				class Node {}
				interface Set1<N extends Node> extends Iterable<N> {}
				interface Set2 extends Iterable<Node> {}
				
				class SetIterator<N extends Node> implements Iterator<N> {
					public N next() {
						return null;
					}
					public boolean hasNext() {
						return true;
					}
					public void remove() {
					}
				}
				interface Set3<N extends Node> extends Iterable<N> {
					SetIterator<N> iterator();
				}
				public class X {
					void f1(Set1 s) {
						Node n_ = s.iterator().next();
						// ^Type mismatch: cannot convert from Object to Node
						// this was unexpected (s can only contain types derivered from Node)
						for (Node n : s) {
							// ^Type mismatch: cannot convert from Object to Node
							// this was unexpected
						}
					}
					void f2(Set2 s) {
						Node n_ = s.iterator().next();
						for (Node n : s) {
						}
					}
					void f3(Set3 s) {
						Node n_ = s.iterator().next();
						// (^ no error here)
						for (Node n : s) {
							// ^Type mismatch: cannot convert from Object to Node
							// this is even stranger as we already know that s.iterator().next()
				            // have the right type
						}
					}
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 21)
				void f1(Set1 s) {
				        ^^^^
			Set1 is a raw type. References to generic type Set1<N> should be parameterized
			----------
			2. ERROR in X.java (at line 22)
				Node n_ = s.iterator().next();
				          ^^^^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from Object to Node
			----------
			3. ERROR in X.java (at line 25)
				for (Node n : s) {
				              ^
			Type mismatch: cannot convert from element type Object to Node
			----------
			4. WARNING in X.java (at line 35)
				void f3(Set3 s) {
				        ^^^^
			Set3 is a raw type. References to generic type Set3<N> should be parameterized
			----------
			5. ERROR in X.java (at line 38)
				for (Node n : s) {
				              ^
			Type mismatch: cannot convert from element type Object to Node
			----------
			""");
}
public void test0810() {
	runConformTest(
		// test directory preparation
		true /* flush output directory */,
		new String[] { /* test files */
			"X.java",
			"""
				class A<T, U> {
					public String toString() {
						return "SUCCESS";
					}
				}
				public class X {
				
					public <K> A<K,K> foo(K type) {
						return new A<K,K>();
					}
				
					public static void main(String args[]) {
						X x = new X();
						A<?,?> a = x.foo(null);
						System.out.println(a);
					}
				}""",
		},
		// compiler results
		null /* do not check compiler log */,
		// runtime results
		"SUCCESS" /* expected output string */,
		"" /* expected error string */,
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=108372
public void test0811() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {
				    private T t;
				    private X.Inner inner;
				    private X.Inner[] inners;
				    public X(T t,  X.Inner in, X.Inner[] ins) {
				        this.t = t;
				        this.inner = in;
				        this.inner = new X(null, null, null).new Inner();
				        this.inners = ins;
				        this.inners = new X.Inner[10];
				        //Type mismatch: cannot convert from X.Inner[] to X<T>.Inner[]
				    }
				    private class Inner {
				    }
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=108372 - variation
public void test0812() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {
				    private T t;
				    private X<?>.Inner inner;
				    private X<?>.Inner[] inners;
				    public X(T t) {
				        this.t = t;
				        this.inner = new X.Inner();
				        this.inners = new X.Inner[10];
				        Zork z;
				    }
				    private class Inner {
				    }
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 7)
				this.inner = new X.Inner();
				                 ^^^^^^^
			X.Inner is a raw type. References to generic type X<T>.Inner should be parameterized
			----------
			2. ERROR in X.java (at line 9)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=108372 - variation
public void test0813() {
	runConformTest(
		// test directory preparation
		true /* flush output directory */,
		new String[] { /* test files */
			"X.java",
			"""
				public class X<T> {
				    private T t;
				    private X<?>.Inner[] inners;
				    public X(T t) {
				        this.t = t;
				        this.inners = new X<?>.Inner[10];
				    }
				    private class Inner {
				    }
				}
				""",
		},
		// compiler results
		null /* do not check compiler log */,
		// runtime results
		"" /* expected output string */,
		"" /* expected error string */,
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_7 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=104695
public void test0814() {
	if (this.complianceLevel >= ClassFileConstants.JDK16)
		return;
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				public class X<E> {
				    void method(Object o) {
				        if (o instanceof E[]) { //incorrect: cannot test non-reifiable type
				            E[] es = (E[]) o;
				        }
				        if (o instanceof List<E>[]) { //incorrect too
				            List<E>[] es = (List<E>[]) o;\s
				        }
				        if (o instanceof List<?>[]) { // unbound is ok
				            List<?>[] es = (List<?>[]) o;
				        }
				    }
				    void method(ArrayList<E>[] al) {
				        if (al instanceof List<E>[]) { //incorrect too
				            List<E>[] es = (List<E>[]) al;\s
				        }       \s
				    }
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 4)
				if (o instanceof E[]) { //incorrect: cannot test non-reifiable type
				    ^^^^^^^^^^^^^^^^
			Cannot perform instanceof check against type parameter E[]. Use its erasure Object[] instead since further generic type information will be erased at runtime
			----------
			2. WARNING in X.java (at line 5)
				E[] es = (E[]) o;
				         ^^^^^^^
			Type safety: Unchecked cast from Object to E[]
			----------
			3. ERROR in X.java (at line 7)
				if (o instanceof List<E>[]) { //incorrect too
				    ^^^^^^^^^^^^^^^^^^^^^^
			Cannot perform instanceof check against parameterized type List<E>[]. Use the form List<?>[] instead since further generic type information will be erased at runtime
			----------
			4. WARNING in X.java (at line 8)
				List<E>[] es = (List<E>[]) o;\s
				               ^^^^^^^^^^^^^
			Type safety: Unchecked cast from Object to List<E>[]
			----------
			5. ERROR in X.java (at line 15)
				if (al instanceof List<E>[]) { //incorrect too
				    ^^^^^^^^^^^^^^^^^^^^^^^
			Cannot perform instanceof check against parameterized type List<E>[]. Use the form List<?>[] instead since further generic type information will be erased at runtime
			----------
			6. WARNING in X.java (at line 16)
				List<E>[] es = (List<E>[]) al;\s
				               ^^^^^^^^^^^^^^
			Unnecessary cast from ArrayList<E>[] to List<E>[]
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=104695 - variation
public void test0815() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<E> {
					void foo(Object[][] e) {
						E[] o = (E[]) e;
						Zork z;
					}
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 3)
				E[] o = (E[]) e;
				        ^^^^^^^
			Type safety: Unchecked cast from Object[][] to E[]
			----------
			2. ERROR in X.java (at line 4)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=104695 - variation
public void test0816() {
	String expectedLog = this.complianceLevel >= ClassFileConstants.JDK16 ?
			"""
				----------
				1. ERROR in X.java (at line 4)
					if (o instanceof List<E>[][]) { //incorrect too
					    ^
				Type Object[] cannot be safely cast to List<E>[][]
				----------
				2. WARNING in X.java (at line 5)
					List<E>[][] es = (List<E>[][]) o;\s
					                 ^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Object[] to List<E>[][]
				----------
				"""
			:
				"""
					----------
					1. ERROR in X.java (at line 4)
						if (o instanceof List<E>[][]) { //incorrect too
						    ^^^^^^^^^^^^^^^^^^^^^^^^
					Cannot perform instanceof check against parameterized type List<E>[][]. Use the form List<?>[][] instead since further generic type information will be erased at runtime
					----------
					2. WARNING in X.java (at line 5)
						List<E>[][] es = (List<E>[][]) o;\s
						                 ^^^^^^^^^^^^^^^
					Type safety: Unchecked cast from Object[] to List<E>[][]
					----------
					""";
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				public class X<E> {
				    void method(Object[] o) {
				        if (o instanceof List<E>[][]) { //incorrect too
				            List<E>[][] es = (List<E>[][]) o;\s
				        }
				    }
				}
				""",
		},
		expectedLog
		);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=104695 - variation
public void test0817() {
	String log = this.complianceLevel >= ClassFileConstants.JDK16 ?
			"""
					    ^
				Type List cannot be safely cast to List<? extends String>
				----------
				6. WARNING in X.java (at line 18)
					void foo(List[] ls) {
					         ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				7. WARNING in X.java (at line 19)
					if (ls instanceof List<?>[]) {}
					    ^^^^^^^^^^^^^^^^^^^^^^^
				The expression of type List[] is already an instance of type List<?>
				----------
				8. ERROR in X.java (at line 20)
					if (ls instanceof List<? extends String>[]) {}
					    ^^
				Type List[] cannot be safely cast to List<? extends String>[]
				"""
			:
				"""
						    ^^^^^^^^^^^^^^^^^
					Cannot perform instanceof check against parameterized type List<? extends String>. Use the form List<?> instead since further generic type information will be erased at runtime
					----------
					6. WARNING in X.java (at line 18)
						void foo(List[] ls) {
						         ^^^^
					List is a raw type. References to generic type List<E> should be parameterized
					----------
					7. WARNING in X.java (at line 19)
						if (ls instanceof List<?>[]) {}
						    ^^^^^^^^^^^^^^^^^^^^^^^
					The expression of type List[] is already an instance of type List<?>
					----------
					8. ERROR in X.java (at line 20)
						if (ls instanceof List<? extends String>[]) {}
						    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
					Cannot perform instanceof check against parameterized type List<? extends String>[]. Use the form List<?>[] instead since further generic type information will be erased at runtime
					""";
	this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					import java.util.List;
					
					public class X<T> {
					    private T t;
					    private X<?>.Inner inner;
					    private X<?>.Inner[] inners;
					    public X(T t) {
					        this.t = t;
					        if (this.inner instanceof X<?>.Inner) {}
					        if (this.inners instanceof X<?>.Inner[]) {}
					    }
					    private class Inner {
					    }
					    void foo(List l) {
					    	if (l instanceof List<?>) {}
					    	if (l instanceof List<? extends String>) {}
					    }
					    void foo(List[] ls) {
					    	if (ls instanceof List<?>[]) {}
					    	if (ls instanceof List<? extends String>[]) {}
					    }
					}
					""",
			},
			"----------\n" +
			"1. WARNING in X.java (at line 9)\n" +
			"	if (this.inner instanceof X<?>.Inner) {}\n" +
			"	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"The expression of type X<?>.Inner is already an instance of type X<?>.Inner\n" +
			"----------\n" +
			"2. WARNING in X.java (at line 10)\n" +
			"	if (this.inners instanceof X<?>.Inner[]) {}\n" +
			"	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"The expression of type X<?>.Inner[] is already an instance of type X<?>.Inner[]\n" +
			"----------\n" +
			"3. WARNING in X.java (at line 14)\n" +
			"	void foo(List l) {\n" +
			"	         ^^^^\n" +
			"List is a raw type. References to generic type List<E> should be parameterized\n" +
			"----------\n" +
			"4. WARNING in X.java (at line 15)\n" +
			"	if (l instanceof List<?>) {}\n" +
			"	    ^^^^^^^^^^^^^^^^^\n" +
			"The expression of type List is already an instance of type List<?>\n" +
			"----------\n" +
			"5. ERROR in X.java (at line 16)\n" +
			"	if (l instanceof List<? extends String>) {}\n" +
			log +
			"----------\n");
}
public void test0818() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {
				    boolean b = this instanceof Y;
				    static class Y extends X<Object> {
				    }
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=101380
public void test0819() {
	this.runConformTest(
			new String[] {
				"X.java",
				"""
					public class X implements MyInterface {
						public void myMethod(myEnum value) {
							System.out.println("value is "+value);
						}
						public static void main(String[] args){
							new X().myMethod(myEnum.one);	\t
						}
					}
					
					interface MyInterface<T> {
						enum myEnum {one,two};
						public void myMethod(myEnum value);\s
					}
					""",
			},
			"value is one");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=101380 - variation
public void test0820() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X implements I {
				  public void x(M value) {}
				}
				interface I<T> {
				  class M {}
				  void x(M value);\s
				}
				""",
		},
		"");
}
public void test0821() throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.io.Serializable;
				
				public class X<T extends Serializable & Runnable> {
					T t;
					X(T t) {
						this.t = t;
					}
					void foo() {
						t.run();
					}
					public static void main(String[] args) {
						new X<A>(new A()).foo();
					}
				}
				class A implements Serializable, Runnable {
					public void run() {
						System.out.println("AA");
					}
				}
				""",
		},
		"AA");
	// 	ensure proper declaring class for #run() invocation
	String expectedOutput =
		"""
		  // Method descriptor #15 ()V
		  // Stack: 1, Locals: 1
		  void foo();
		     0  aload_0 [this]
		     1  getfield X.t : java.io.Serializable [16]
		     4  checkcast java.lang.Runnable [25]
		     7  invokeinterface java.lang.Runnable.run() : void [27] [nargs: 1]
		    12  return
		      Line numbers:
		        [pc: 0, line: 9]
		        [pc: 12, line: 10]
		      Local variable table:
		        [pc: 0, pc: 13] local: this index: 0 type: X
		      Local variable type table:
		        [pc: 0, pc: 13] local: this index: 0 type: X<T>
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
		}
}
public void test0822() throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.io.Serializable;
				
				public class X<T extends Serializable & Runnable> {
					void foo(T t) {
						t.run();
					}
					public static void main(String[] args) {
						new X<A>().foo(new A());
					}
				}
				class A implements Serializable, Runnable {
					public void run() {
						System.out.println("AA");
					}
				}
				""",
		},
		"AA");
	// 	ensure proper declaring class for #run() invocation
	String expectedOutput =
		"""
		  // Method descriptor #17 (Ljava/io/Serializable;)V
		  // Signature: (TT;)V
		  // Stack: 1, Locals: 2
		  void foo(java.io.Serializable t);
		     0  aload_1 [t]
		     1  checkcast java.lang.Runnable [20]
		     4  invokeinterface java.lang.Runnable.run() : void [22] [nargs: 1]
		     9  return
		      Line numbers:
		        [pc: 0, line: 5]
		        [pc: 9, line: 6]
		      Local variable table:
		        [pc: 0, pc: 10] local: this index: 0 type: X
		        [pc: 0, pc: 10] local: t index: 1 type: java.io.Serializable
		      Local variable type table:
		        [pc: 0, pc: 10] local: this index: 0 type: X<T>
		        [pc: 0, pc: 10] local: t index: 1 type: T
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
public void test0823() throws Exception {
	runConformTest(
		true,
		new String[] {
			"X.java",
			"""
				import java.io.Serializable;
				
				public class X<T extends Serializable & Runnable, V extends T> {
					T t;
					X(T t) {
						this.t = t;
					}
					void foo() {
						(this == null ? t : t).run();
						((V) t).run();
					}
					public static void main(String[] args) {
						new X<A, A>(new A()).foo();
					}
				}
				class A implements Serializable, Runnable {
					public void run() {
						System.out.print("AA");
					}
				}
				""",
		},
		null,
		"AAAA",
		null,
		JavacTestOptions.JavacHasABug.JavacBug6531075);
	// 	ensure proper declaring class for #run() invocation
	String expectedOutput =
		"""
		  // Method descriptor #15 ()V
		  // Stack: 1, Locals: 1
		  void foo();
		     0  aload_0 [this]
		     1  ifnonnull 11
		     4  aload_0 [this]
		     5  getfield X.t : java.io.Serializable [16]
		     8  goto 15
		    11  aload_0 [this]
		    12  getfield X.t : java.io.Serializable [16]
		    15  checkcast java.lang.Runnable [25]
		    18  invokeinterface java.lang.Runnable.run() : void [27] [nargs: 1]
		    23  aload_0 [this]
		    24  getfield X.t : java.io.Serializable [16]
		    27  checkcast java.lang.Runnable [25]
		    30  invokeinterface java.lang.Runnable.run() : void [27] [nargs: 1]
		    35  return
		      Line numbers:
		        [pc: 0, line: 9]
		        [pc: 23, line: 10]
		        [pc: 35, line: 11]
		      Local variable table:
		        [pc: 0, pc: 36] local: this index: 0 type: X
		      Local variable type table:
		        [pc: 0, pc: 36] local: this index: 0 type: X<T,V>
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
public void test0824() throws Exception {
	runConformTest(
		true,
		new String[] {
			"X.java",
			"""
				import java.io.Serializable;
				
				public class X<T extends Serializable & Runnable, V extends T> {
					void foo(T t) {
						(this == null ? t : t).run();
						((V) t).run();
					}
					public static void main(String[] args) {
						new X<A, A>().foo(new A());
					}
				}
				class A implements Serializable, Runnable {
					public void run() {
						System.out.print("AA");
					}
				}
				""",
		},
		null,
		"AAAA",
		null,
		JavacTestOptions.JavacHasABug.JavacBug6531075);
	// 	ensure proper declaring class for #run() invocation
	String expectedOutput =
		"""
		  // Method descriptor #17 (Ljava/io/Serializable;)V
		  // Signature: (TT;)V
		  // Stack: 1, Locals: 2
		  void foo(java.io.Serializable t);
		     0  aload_0 [this]
		     1  ifnonnull 8
		     4  aload_1 [t]
		     5  goto 9
		     8  aload_1 [t]
		     9  checkcast java.lang.Runnable [20]
		    12  invokeinterface java.lang.Runnable.run() : void [22] [nargs: 1]
		    17  aload_1 [t]
		    18  checkcast java.lang.Runnable [20]
		    21  invokeinterface java.lang.Runnable.run() : void [22] [nargs: 1]
		    26  return
		      Line numbers:
		        [pc: 0, line: 5]
		        [pc: 17, line: 6]
		        [pc: 26, line: 7]
		      Local variable table:
		        [pc: 0, pc: 27] local: this index: 0 type: X
		        [pc: 0, pc: 27] local: t index: 1 type: java.io.Serializable
		      Local variable type table:
		        [pc: 0, pc: 27] local: this index: 0 type: X<T,V>
		        [pc: 0, pc: 27] local: t index: 1 type: T
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
public void test0825() throws Exception {
	if (this.complianceLevel >= ClassFileConstants.JDK1_8)
		return;
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.io.Serializable;
				
				public class X<T extends Serializable & Runnable, V extends T> {
					void foo(T t) {
						Runnable r1 = t;
						Runnable r2 = (this == null ? t : t);
						Runnable r3 = ((V) t);
					\t
						bar(t);
						bar(this == null ? t : t);
						bar((V)t);
					}
					void bar(Runnable r) {}\t
					public static void main(String[] args) {
						new X<A, A>().foo(new A());
					}
				}
				class A implements Serializable, Runnable {
					public void run() {
						System.out.println("AA");
					}
				}
				""",
		},
		"");
	// 	ensure proper declaring class for #run() invocation
	String expectedOutput = this.complianceLevel < ClassFileConstants.JDK1_8 ?
		"""
			  // Method descriptor #17 (Ljava/io/Serializable;)V
			  // Signature: (TT;)V
			  // Stack: 2, Locals: 5
			  void foo(java.io.Serializable t);
			     0  aload_1 [t]
			     1  checkcast java.lang.Runnable [20]
			     4  astore_2 [r1]
			     5  aload_0 [this]
			     6  ifnonnull 13
			     9  aload_1 [t]
			    10  goto 14
			    13  aload_1 [t]
			    14  astore_3 [r2]
			    15  aload_1 [t]
			    16  astore 4 [r3]
			    18  aload_0 [this]
			    19  aload_1 [t]
			    20  checkcast java.lang.Runnable [20]
			    23  invokevirtual X.bar(java.lang.Runnable) : void [22]
			    26  aload_0 [this]
			    27  aload_0 [this]
			    28  ifnonnull 35
			    31  aload_1 [t]
			    32  goto 36
			    35  aload_1 [t]
			    36  invokevirtual X.bar(java.lang.Runnable) : void [22]
			    39  aload_0 [this]
			    40  aload_1 [t]
			    41  invokevirtual X.bar(java.lang.Runnable) : void [22]
			    44  return
			      Line numbers:
			        [pc: 0, line: 5]
			        [pc: 5, line: 6]
			        [pc: 15, line: 7]
			        [pc: 18, line: 9]
			        [pc: 26, line: 10]
			        [pc: 39, line: 11]
			        [pc: 44, line: 12]
			      Local variable table:
			        [pc: 0, pc: 45] local: this index: 0 type: X
			        [pc: 0, pc: 45] local: t index: 1 type: java.io.Serializable
			        [pc: 5, pc: 45] local: r1 index: 2 type: java.lang.Runnable
			        [pc: 15, pc: 45] local: r2 index: 3 type: java.lang.Runnable
			        [pc: 18, pc: 45] local: r3 index: 4 type: java.lang.Runnable
			      Local variable type table:
			        [pc: 0, pc: 45] local: this index: 0 type: X<T,V>
			        [pc: 0, pc: 45] local: t index: 1 type: T
			""" :

			"""
				  // Method descriptor #17 (Ljava/io/Serializable;)V
				  // Signature: (TT;)V
				  // Stack: 2, Locals: 5
				  void foo(java.io.Serializable t);
				     0  aload_1 [t]
				     1  checkcast java.lang.Runnable [20]
				     4  astore_2 [r1]
				     5  aload_0 [this]
				     6  ifnonnull 16
				     9  aload_1 [t]
				    10  checkcast java.lang.Runnable [20]
				    13  goto 20
				    16  aload_1 [t]
				    17  checkcast java.lang.Runnable [20]
				    20  astore_3 [r2]
				    21  aload_1 [t]
				    22  astore 4 [r3]
				    24  aload_0 [this]
				    25  aload_1 [t]
				    26  checkcast java.lang.Runnable [20]
				    29  invokevirtual X.bar(java.lang.Runnable) : void [22]
				    32  aload_0 [this]
				    33  aload_0 [this]
				    34  ifnonnull 44
				    37  aload_1 [t]
				    38  checkcast java.lang.Runnable [20]
				    41  goto 48
				    44  aload_1 [t]
				    45  checkcast java.lang.Runnable [20]
				    48  invokevirtual X.bar(java.lang.Runnable) : void [22]
				    51  aload_0 [this]
				    52  aload_1 [t]
				    53  invokevirtual X.bar(java.lang.Runnable) : void [22]
				    56  return
				      Line numbers:
				        [pc: 0, line: 5]
				        [pc: 5, line: 6]
				        [pc: 21, line: 7]
				        [pc: 24, line: 9]
				        [pc: 32, line: 10]
				        [pc: 51, line: 11]
				        [pc: 56, line: 12]
				      Local variable table:
				        [pc: 0, pc: 57] local: this index: 0 type: X
				        [pc: 0, pc: 57] local: t index: 1 type: java.io.Serializable
				        [pc: 5, pc: 57] local: r1 index: 2 type: java.lang.Runnable
				        [pc: 21, pc: 57] local: r2 index: 3 type: java.lang.Runnable
				        [pc: 24, pc: 57] local: r3 index: 4 type: java.lang.Runnable
				      Local variable type table:
				        [pc: 0, pc: 57] local: this index: 0 type: X<T,V>
				        [pc: 0, pc: 57] local: t index: 1 type: T
				""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=110570
public void test0826() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {
				
				  public <V1, V2 extends V1> void test(V1 p1, V2 p2) {}
				\t
				  public static void main(String[] args) {
				    XA a = new XA(){};
				    XB b = new XB(){};
				
				    X t1 = new X();
				    t1.test(a, b); //this gives an error but should be OK
				   \s
				    X<Object> t2 = new X<Object>();
				    t2.test(a, b); //this compiles OK
				    Zork z;
				  }
				}
				
				interface XA {}
				interface XB extends XA {}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 9)
				X t1 = new X();
				^
			X is a raw type. References to generic type X<T> should be parameterized
			----------
			2. WARNING in X.java (at line 9)
				X t1 = new X();
				           ^
			X is a raw type. References to generic type X<T> should be parameterized
			----------
			3. WARNING in X.java (at line 10)
				t1.test(a, b); //this gives an error but should be OK
				^^^^^^^^^^^^^
			Type safety: The method test(Object, Object) belongs to the raw type X. References to generic type X<T> should be parameterized
			----------
			4. ERROR in X.java (at line 14)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=110570 - variation
// ensure variable V2 is substituted with upper bound erasure (List) and not just upperbound List<String>
// for raw generic method invocation
public void test0827() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.List;
				public class X<T> {
				  public <V1, V2 extends List<String>> void test(V1 p1, V2 p2) {}
				  public static void main(String[] args) {
				    XA a = new XA(){};
				    List<Object> b = null;
				    X t1 = new X();
				    t1.test(a, b); //this gives an error but should be OK
				    X<Object> t2 = new X<Object>();
				    t2.test(a, b); //this compiles OK
				  }
				}
				interface XA {}
				
				""",
		},
		this.complianceLevel < ClassFileConstants.JDK1_8 ?
		"""
			----------
			1. WARNING in X.java (at line 7)
				X t1 = new X();
				^
			X is a raw type. References to generic type X<T> should be parameterized
			----------
			2. WARNING in X.java (at line 7)
				X t1 = new X();
				           ^
			X is a raw type. References to generic type X<T> should be parameterized
			----------
			3. WARNING in X.java (at line 8)
				t1.test(a, b); //this gives an error but should be OK
				^^^^^^^^^^^^^
			Type safety: The method test(Object, List) belongs to the raw type X. References to generic type X<T> should be parameterized
			----------
			4. ERROR in X.java (at line 10)
				t2.test(a, b); //this compiles OK
				   ^^^^
			Bound mismatch: The generic method test(V1, V2) of type X<T> is not applicable for the arguments (XA, List<Object>). The inferred type List<Object> is not a valid substitute for the bounded parameter <V2 extends List<String>>
			----------
			""" :
			"""
				----------
				1. WARNING in X.java (at line 7)
					X t1 = new X();
					^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				2. WARNING in X.java (at line 7)
					X t1 = new X();
					           ^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				3. WARNING in X.java (at line 8)
					t1.test(a, b); //this gives an error but should be OK
					^^^^^^^^^^^^^
				Type safety: The method test(Object, List) belongs to the raw type X. References to generic type X<T> should be parameterized
				----------
				4. ERROR in X.java (at line 10)
					t2.test(a, b); //this compiles OK
					   ^^^^
				The method test(V1, V2) in the type X<Object> is not applicable for the arguments (XA, List<Object>)
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=109249
public void test0828() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				interface Transformable<T extends Transformable>
				{
					public T transform();
				}
				interface Volume<V extends Volume> extends Transformable<V>
				{
				//	public V transform();
				}
				@SuppressWarnings("null")
				public class X {
					void foo(){
						Volume v1 = null;
						Volume v2 = v1.transform();
					}
					void bar(){
						Volume<Volume> v1 = null;
						Volume v2 = v1.transform();
					}
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 1)
				interface Transformable<T extends Transformable>
				                                  ^^^^^^^^^^^^^
			Transformable is a raw type. References to generic type Transformable<T> should be parameterized
			----------
			2. WARNING in X.java (at line 5)
				interface Volume<V extends Volume> extends Transformable<V>
				                           ^^^^^^
			Volume is a raw type. References to generic type Volume<V> should be parameterized
			----------
			3. WARNING in X.java (at line 12)
				Volume v1 = null;
				^^^^^^
			Volume is a raw type. References to generic type Volume<V> should be parameterized
			----------
			4. WARNING in X.java (at line 13)
				Volume v2 = v1.transform();
				^^^^^^
			Volume is a raw type. References to generic type Volume<V> should be parameterized
			----------
			5. ERROR in X.java (at line 13)
				Volume v2 = v1.transform();
				            ^^^^^^^^^^^^^^
			Type mismatch: cannot convert from Transformable to Volume
			----------
			6. WARNING in X.java (at line 16)
				Volume<Volume> v1 = null;
				       ^^^^^^
			Volume is a raw type. References to generic type Volume<V> should be parameterized
			----------
			7. WARNING in X.java (at line 17)
				Volume v2 = v1.transform();
				^^^^^^
			Volume is a raw type. References to generic type Volume<V> should be parameterized
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=109249 - variation
public void test0829() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				interface Transformable<T extends Transformable>
				{
					public T transform();
				}
				interface Volume<V extends Volume> extends Transformable<V>
				{
					public V transform();
				}
				public class X {
					void foo(){
						Volume v1 = null;
						Volume v2 = v1.transform();
					}
					void bar(){
						Volume<Volume> v1 = null;
						Volume v2 = v1.transform();
					}
				}
				""",
		},
		"");
}

public void test0830() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				public class X<T> {
					void foo(Object o) {
						boolean b = o instanceof X;
						X x = (X) o;
						X<String> xs = (X<String>)o;
						Zork z;
					}
					void bar(ArrayList<String> al) {
						List l = (List) al;
					}
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 5)
				X x = (X) o;
				^
			X is a raw type. References to generic type X<T> should be parameterized
			----------
			2. WARNING in X.java (at line 5)
				X x = (X) o;
				       ^
			X is a raw type. References to generic type X<T> should be parameterized
			----------
			3. WARNING in X.java (at line 6)
				X<String> xs = (X<String>)o;
				               ^^^^^^^^^^^^
			Type safety: Unchecked cast from Object to X<String>
			----------
			4. ERROR in X.java (at line 7)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			5. WARNING in X.java (at line 10)
				List l = (List) al;
				^^^^
			List is a raw type. References to generic type List<E> should be parameterized
			----------
			6. WARNING in X.java (at line 10)
				List l = (List) al;
				         ^^^^^^^^^
			Unnecessary cast from ArrayList<String> to List
			----------
			7. WARNING in X.java (at line 10)
				List l = (List) al;
				          ^^^^
			List is a raw type. References to generic type List<E> should be parameterized
			----------
			""");
}
//unnecessary cast may be combined with unchecked cast warning
public void test0831() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				public class X {
					void foo(Object o1) {
						Object o2 = (List<String>) o1;
					\t
						foo((List<String>)o2);
					}
					Zork z;
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 4)
				Object o2 = (List<String>) o1;
				            ^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from Object to List<String>
			----------
			2. WARNING in X.java (at line 4)
				Object o2 = (List<String>) o1;
				            ^^^^^^^^^^^^^^^^^
			Unnecessary cast from Object to List<String>
			----------
			3. WARNING in X.java (at line 6)
				foo((List<String>)o2);
				    ^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from Object to List<String>
			----------
			4. WARNING in X.java (at line 6)
				foo((List<String>)o2);
				    ^^^^^^^^^^^^^^^^
			Unnecessary cast from Object to List<String>
			----------
			5. ERROR in X.java (at line 8)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=106010
public void test0832() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				class C1<T> {
					class C11 {	}
					class C12 {
						T t;
						C1<T>.C11[] m() {
							C1<T>.C11[] ts = (C1<T>.C11[]) new C1<?>.C11[5];
							return ts;
						}
					}
					Zork z;
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 6)
				C1<T>.C11[] ts = (C1<T>.C11[]) new C1<?>.C11[5];
				                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from C1<?>.C11[] to C1<T>.C11[]
			----------
			2. ERROR in X.java (at line 10)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=111014
public void test0833() {
	this.runConformTest(
		new String[] {
			"A.java",
			"class A<T1> {}\n",
			"B.java",
			"class B<T2> extends A<B<T2>.Inner> { class Inner {} }\n",
			"C.java",
			"class C { B<Integer> b; }\n",
		},
		"");
	this.runConformTest(
		new String[] {
			"C.java",
			"class C { B<Integer> b; }\n",
		},
		"",
		null,
		false,
		null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=100809
public void test0834() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				public class X {
				    public static void main(String[] args) {
				        Set<Integer> set = new HashSet<Integer>();
				        set.add(42);
				        Collection<Number> collection;
				        collection = (Collection) set;
				        System.out.println(collection.iterator().next());
				        Zork z;
				    }
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 7)
				collection = (Collection) set;
				             ^^^^^^^^^^^^^^^^
			Type safety: The expression of type Collection needs unchecked conversion to conform to Collection<Number>
			----------
			2. WARNING in X.java (at line 7)
				collection = (Collection) set;
				              ^^^^^^^^^^
			Collection is a raw type. References to generic type Collection<E> should be parameterized
			----------
			3. ERROR in X.java (at line 9)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=100809 - variation
public void test0835() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				public class X {
					void foo(List<String> ls) {
						ArrayList<?> als = (ArrayList) ls;
					}
					Zork z;
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 4)
				ArrayList<?> als = (ArrayList) ls;
				                    ^^^^^^^^^
			ArrayList is a raw type. References to generic type ArrayList<E> should be parameterized
			----------
			2. ERROR in X.java (at line 6)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=111208
public void test0836() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				 import java.util.Iterator;
				 import java.util.List;
				
				 public class X<A> {
				
				 interface Factory<T> {
				 T invoke();
					}
				
					public static <E> Iterator<E> iterate(Iterable<E> iterable) {
						return iterable.iterator();
					}
				
					public Factory<Iterator<? extends A>> factory(final Factory<? extends List<? extends A>> factory) {
						return new Factory<Iterator<? extends A>>() {
							public Iterator<? extends A> invoke() {
								//String s = iterate(factory.invoke());
								return iterate(factory.invoke());
							}
						};
					}
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=111208 - variation
public void test0837() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				
				public class X {
					public void foo(List<? extends List<? extends Number>> l) {
						bar(l.get(0));
						swap(l.get(0));
					}
					void bar(String s) {}
					private static <T> void swap(List<T> l) {
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 5)
				bar(l.get(0));
				^^^
			The method bar(String) in the type X is not applicable for the arguments (capture#1-of ? extends List<? extends Number>)
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=111689
public void test0838() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public class CClass<T extends AClass.BClass<T>> {
					}
				}
				""",
			"AClass.java",
			"""
				public interface AClass<X extends AClass> {
					public interface BClass<T extends BClass> extends AClass<T> {
					}
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=109118
public void test0839() {
	this.runConformTest(
		new String[] {
			"com/test/Tester.java",
			"""
				package com.test;
				
				import com.test.TestClass.MyException;
				
				public class Tester {
				
					public static void main(String[] args) {
						try {
							TestClass<String> test = new TestClass<String>();
						} catch (MyException e) {
							System.out.println("SUCCESS");
						}
					}
				}""",
			"com/test/TestClass.java",
			"""
				package com.test;
				
				public class TestClass<T> {
				\t
					public TestClass() throws MyException {
						throw new MyException();
					}
				
					public static class MyException extends Exception {
					\t
						public MyException() {
							super();
						}
					}
				}"""
		},
		"SUCCESS");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=109118
public void test0840() {
	this.runNegativeTest(
		new String[] {
			"generics/NodeList.java",
			"""
				package generics;
				public class NodeList<E> {
				    public class Cursor { }
				}""",
			"generics/user/User.java",
			"""
				package generics.user;
				import generics.NodeList;
				import generics.NodeList.Cursor;
				public class User {
				    Cursor raw;
				    NodeList.Cursor rawQualified;
				    NodeList<String>.Cursor parameterized;
				
				    void foo() {
				        parameterized= rawQualified; //unchecked warning (OK)
				        rawQualified= parameterized;
				
				        parameterized= raw; //should just give unchecked warning, but errors
				        raw= parameterized; //should not error
				
				        raw= rawQualified; //should not error
				        rawQualified= raw;
				    }
				    Zork z;
				}""",
		},
		"""
			----------
			1. WARNING in generics\\user\\User.java (at line 5)
				Cursor raw;
				^^^^^^
			NodeList.Cursor is a raw type. References to generic type NodeList<E>.Cursor should be parameterized
			----------
			2. WARNING in generics\\user\\User.java (at line 6)
				NodeList.Cursor rawQualified;
				^^^^^^^^^^^^^^^
			NodeList.Cursor is a raw type. References to generic type NodeList<E>.Cursor should be parameterized
			----------
			3. WARNING in generics\\user\\User.java (at line 10)
				parameterized= rawQualified; //unchecked warning (OK)
				               ^^^^^^^^^^^^
			Type safety: The expression of type NodeList.Cursor needs unchecked conversion to conform to NodeList<String>.Cursor
			----------
			4. WARNING in generics\\user\\User.java (at line 13)
				parameterized= raw; //should just give unchecked warning, but errors
				               ^^^
			Type safety: The expression of type NodeList.Cursor needs unchecked conversion to conform to NodeList<String>.Cursor
			----------
			5. ERROR in generics\\user\\User.java (at line 19)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=112268
public void test0841() {
	this.runConformTest(
		new String[] {
			"X.java", // =================
			"""
				import java.util.*;
				
				public class X {
				  List<? extends Comparator> bar() {
					  List<? extends Comparator> l = foo();
					  return foo();
				  }
				  <T> List<T> foo() {
					  return null;
				  }
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=112500
public void test0842() {
	String expectedError = isJRE11Plus ? intersection("Object","Serializable","Comparable<?>", "CharSequence") :
		intersection("Object","Serializable","CharSequence");
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				import java.util.List;
				
				public class X {
					static <T> List<T> merge(List<? extends T> a, List<? extends T> b) {
						return null;
					}
				
					public static void main(String[] args) {
						List<String> list1 = null;
						List<StringBuilder> list2 = null;
						List<? extends CharSequence> result = merge(list1, list2);
						List<? extends String> result2 = merge(list1, list2);
					}
				}
				""",
		},
		"----------\n" +
		"1. ERROR in X.java (at line 12)\n" +
		"	List<? extends String> result2 = merge(list1, list2);\n" +
		"	                                 ^^^^^^^^^^^^^^^^^^^\n" +
		"Type mismatch: cannot convert from List<" + expectedError + "> to List<? extends String>\n" +
		"----------\n");
}
public void test0843() {
	String expectedError = isJRE11Plus ? intersection("Object","Serializable","Comparable<?>", "CharSequence") :
		intersection("Object","Serializable","CharSequence");
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				import java.util.List;
				
				public class X {
					static <T> List<T> merge(List<? extends T> a, List<? extends T> b) {
						return null;
					}
				
					public static void main(String[] args) {
						List<String> list1 = null;
						List<StringBuilder> list2 = null;
						Object result3 = (List<? extends CharSequence>)merge(list1, list2);
						Object result4 = (List<? extends String>)merge(list1, list2);
					}
				}
				""",
		},
		"----------\n" +
		"1. WARNING in X.java (at line 11)\n" +
		"	Object result3 = (List<? extends CharSequence>)merge(list1, list2);\n" +
		"	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
		"Unnecessary cast from List<" + expectedError + "> to List<? extends CharSequence>\n" +
		"----------\n" +
		"2. ERROR in X.java (at line 12)\n" +
		"	Object result4 = (List<? extends String>)merge(list1, list2);\n" +
		"	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
		"Cannot cast from List<" + expectedError + "> to List<? extends String>\n" +
		"----------\n" +
		"3. WARNING in X.java (at line 12)\n" +
		"	Object result4 = (List<? extends String>)merge(list1, list2);\n" +
		"	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
		"Unnecessary cast from List<" + expectedError + "> to List<? extends String>\n" +
		"----------\n");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=112595
public void test0844() {
	this.runConformTest(
		new String[] {
			"X.java", // =================
			"""
				import java.util.*;
				public class X {
				    public Set< ? extends X> getModifiers()
				    {
				        return Collections.emptySet();
				    }
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=112595
public void test0845() {
	this.runConformTest(
		new String[] {
			"Generic.java", // =================
			"""
				public class Generic<T> {
					public int size() {
						return 0;
					}
					public static void main(String[] args) {
						System.out.println("SUCCESS");
					}
				}""", // =================
		},
		"SUCCESS");
	this.runNegativeTest(
			new String[] {
				"X.java", // =================
				"""
					import java.util.ArrayList;
					
					public class X {
						public void testList(ArrayList aList) {
							aList.size();
						}
						public void testGeneric(Generic aGeneric) {
							aGeneric.size();
						}
						Zork z;
					}
					""", // =================
			},
			"""
				----------
				1. WARNING in X.java (at line 4)
					public void testList(ArrayList aList) {
					                     ^^^^^^^^^
				ArrayList is a raw type. References to generic type ArrayList<E> should be parameterized
				----------
				2. ERROR in X.java (at line 7)
					public void testGeneric(Generic aGeneric) {
					                        ^^^^^^^
				Generic cannot be resolved to a type
				----------
				3. ERROR in X.java (at line 10)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
	}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=112666
public void test0846() {
	this.runConformTest(
		new String[] {
			"X.java", // =================
			"""
				import java.util.Collection;
				public class X {
					void m() {
						Collection<? super Collection<? super Number>> col = null;
						java.util.List<java.lang.Number> n = null;
						col.add(n);
					}
				}
				""", // =================
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=112666
public void test0847() {
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				import java.util.Collection;
				
				public class X {
					void m() {
						Collection<? extends Collection<? super Number>> col = null;
						java.util.List<java.lang.Number> n = null;
						col.add(n);
					}
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 7)
				col.add(n);
				    ^^^
			The method add(capture#1-of ? extends Collection<? super Number>) in the type Collection<capture#1-of ? extends Collection<? super Number>> is not applicable for the arguments (List<Number>)
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=106451
public void test0848() throws Exception {
	this.runNegativeTest(
			new String[] {
				"X.java", // =================
				"""
					import java.util.*;
					
					public class X<E> {
						public static <T> List<T> asList(T a) { return null; }
						Collection<? extends Number> asList= asList(1);
						List<Number> nums= (List<Number>) asList; // correct warning
						List<Number> numz= (LinkedList<Number>) asList; // type safety warning missing
						Zork z;
					}
					""", // =================
			},
			"""
				----------
				1. WARNING in X.java (at line 6)
					List<Number> nums= (List<Number>) asList; // correct warning
					                   ^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Collection<capture#1-of ? extends Number> to List<Number>
				----------
				2. WARNING in X.java (at line 7)
					List<Number> numz= (LinkedList<Number>) asList; // type safety warning missing
					                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Collection<capture#2-of ? extends Number> to LinkedList<Number>
				----------
				3. ERROR in X.java (at line 8)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");

		this.runConformTest(
				new String[] {
					"X.java", // =================
					"""
						import java.util.*;
						
						public class X<E> {
							Collection<? extends Number> asList= Arrays.asList(1, 2.2);
							List<Number> nums= (List<Number>) asList; // correct warning
							List<Number> numz= (LinkedList<Number>) asList; // type safety warning missing
						}
						""", // =================
				},
				"");
		// 	ensure presence of: "checkcast java.util.LinkedList" before putfield X.numz
		String expectedOutput =
		"""
			  // Method descriptor #14 ()V
			  // Stack: 6, Locals: 1
			  public X();
			     0  aload_0 [this]
			     1  invokespecial java.lang.Object() [16]
			     4  aload_0 [this]
			     5  iconst_2
			     6  anewarray java.lang.Number [18]
			     9  dup
			    10  iconst_0
			    11  iconst_1
			    12  invokestatic java.lang.Integer.valueOf(int) : java.lang.Integer [20]
			    15  aastore
			    16  dup
			    17  iconst_1
			    18  ldc2_w <Double 2.2> [26]
			    21  invokestatic java.lang.Double.valueOf(double) : java.lang.Double [28]
			    24  aastore
			    25  invokestatic java.util.Arrays.asList(java.lang.Object[]) : java.util.List [33]
			    28  putfield X.asList : java.util.Collection [38]
			    31  aload_0 [this]
			    32  aload_0 [this]
			    33  getfield X.asList : java.util.Collection [38]
			    36  checkcast java.util.List [40]
			    39  putfield X.nums : java.util.List [42]
			    42  aload_0 [this]
			    43  aload_0 [this]
			    44  getfield X.asList : java.util.Collection [38]
			    47  checkcast java.util.LinkedList [44]
			    50  putfield X.numz : java.util.List [46]
			    53  return
			""";

		File f = new File(OUTPUT_DIR + File.separator + "X.class");
		byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
		ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
		String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
		int index = result.indexOf(expectedOutput);
		if (index == -1 || expectedOutput.length() == 0) {
			System.out.println(Util.displayString(result, 3));
		}
		if (index == -1) {
			assertEquals("Wrong contents", expectedOutput, result);
		}
}
//ensure no unsafe cast is diagnosed
public void test0849() {
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				public class X {
				    static <T, U extends T> T[] cast(U[] a) { return (T[]) a; }
				    Zork z;
				}
				""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 2)
				static <T, U extends T> T[] cast(U[] a) { return (T[]) a; }
				                                                 ^^^^^^^
			Unnecessary cast from U[] to T[]
			----------
			2. ERROR in X.java (at line 3)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
public void test0850() {
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				public class X {
				    <T> T f(Object o) {
					return (T) o; // OK
				    }
				
				    <U, T extends U> T g(Object o) {
					return (T) o; // bug???
				    }
				
				    <U, T extends U> T h(Object o) {
					return X.<T>castTo(o); // workaround
				    }
				
				    private static <T> T castTo(Object o) {
					return (T) o;
				    }
				    Zork z;
				}
				""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 3)
				return (T) o; // OK
				       ^^^^^
			Type safety: Unchecked cast from Object to T
			----------
			2. WARNING in X.java (at line 7)
				return (T) o; // bug???
				       ^^^^^
			Type safety: Unchecked cast from Object to T
			----------
			3. WARNING in X.java (at line 15)
				return (T) o;
				       ^^^^^
			Type safety: Unchecked cast from Object to T
			----------
			4. ERROR in X.java (at line 17)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
public void test0851() {
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				interface Foo {}
				interface Bar<T> {}
				public class X {
				    Object m(Foo f) {
				        return (Bar<Object>)f;
				    }
				    Zork z;
				}
				""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 5)
				return (Bar<Object>)f;
				       ^^^^^^^^^^^^^^
			Type safety: Unchecked cast from Foo to Bar<Object>
			----------
			2. WARNING in X.java (at line 5)
				return (Bar<Object>)f;
				       ^^^^^^^^^^^^^^
			Unnecessary cast from Foo to Bar<Object>
			----------
			3. ERROR in X.java (at line 7)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=106466
public void test0852() {
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				public class X {
					<T extends Runnable, U extends T & Runnable>  T foo() { return null; }
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 2)
				<T extends Runnable, U extends T & Runnable>  T foo() { return null; }
				                                   ^^^^^^^^
			Cannot specify any additional bound Runnable when first bound is a type parameter
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=112109
public void test0853() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<C extends I> {
					void test(java.util.List<C> list) { list.get(0).notify(null); }
				}
				interface I { Object notify(Object o); }""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=113236
public void test0854() {
	runConformTest(
		// test directory preparation
		true /* flush output directory */,
		new String[] { /* test files */
			"X.java",
			"""
				public class X {
					public static void main(String[] args) {
						Field field = new Field();
						Form form = new Form(field);
						String result = form.getField().toString();
						System.out.print(result);
					}
				}""",
			"Form.java",
			"""
				public class Form {
					private final Field field;
					public Form(Field field) {
						this.field = field;
					}
					public <T extends Field> T getField() {
						return (T) field;
					}
				}""",
			"Field.java",
			"""
				public class Field {
					@Override
					public String toString() {
						return "SUCCESS";
					}
				}""",
		},
		// compiler results
		null /* do not check compiler log */,
		// runtime results
		"SUCCESS" /* expected output string */,
		"" /* expected error string */,
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=113218
public void test0855() {
	runConformTest(
		// test directory preparation
		true /* flush output directory */,
		new String[] { /* test files */
			"X.java",
			"""
				public class X {
					public static void main(String[] args) {
						FieldManager manager = new FieldManagerImpl();
						FieldMeta<FieldImpl> meta = new FieldMeta<FieldImpl>(manager);
						Field<? extends Field> field = new FieldImpl(meta);
						FieldMeta<? extends Field> meta2 = field.getFieldMeta();
						System.out.print(meta2.getFieldManager() instanceof ExtFieldManager);
					}
				}""",
			"FieldMeta.java",
			"""
				public class FieldMeta<F extends Field> {
					private final FieldManager<F> fieldManager;
					public FieldMeta(FieldManager<F> fieldManager) {
						this.fieldManager = fieldManager;
					}
					public <FB extends FieldManager<F>> FB getFieldManager() {
						return (FB) fieldManager;
					}
				}""",
			"FieldManagerImpl.java",
			"""
				public class FieldManagerImpl extends FieldManager<FieldImpl> implements
					ExtFieldManager<FieldImpl> {
				}""",
			"FieldManager.java",
			"public abstract class FieldManager<F extends Field> {}",
			"FieldImpl.java",
			"""
				public class FieldImpl extends Field<FieldImpl> {
					public FieldImpl(FieldMeta<FieldImpl> fieldMeta) {
						super(fieldMeta);
					}
				}""",
			"Field.java",
			"""
				public class Field<F extends Field> {
					private final FieldManager<F> fieldManager;
					private final FieldMeta<F> fieldMeta;
					public FieldMeta<F> getFieldMeta() {
						return fieldMeta;
					}
					public Field(FieldMeta<F> fieldMeta) {
						this.fieldMeta = fieldMeta;
						this.fieldManager = fieldMeta.getFieldManager();
					}
					public FieldManager<F> getFieldManager() {
						return fieldManager;
					}
				}""",
			"ExtFieldManager.java",
			"public interface ExtFieldManager<F extends Field> {}"
		},
		// compiler results
		null /* do not check compiler log */,
		// runtime results
		"true" /* expected output string */,
		"" /* expected error string */,
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}
public void test0856() {
	runConformTest(
		// test directory preparation
		true /* flush output directory */,
		new String[] { /* test files */
			"X.java",
			"""
				public class X {
					static class MX<T> {
						T t = null;
					}
					static <T> T getT() {
						return (new MX<T>()).t;
					}
					public static void test() {
						getT().getClass(); // error: java.lang.Object cannot be dereferenced
					}
				
					public static void main(String[] args) {
						System.out.println("SUCCESS");
					}
				}
				""",
		},
		// compiler results
		"" /* expected compiler log */,
		// runtime results
		"SUCCESS" /* expected output string */,
		"" /* expected error string */,
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=113070
public void test0857() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public <U, T extends U & Cloneable & Runnable> void m(T t) {
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 2)
				public <U, T extends U & Cloneable & Runnable> void m(T t) {
				                         ^^^^^^^^^
			Cannot specify any additional bound Cloneable when first bound is a type parameter
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=113560
public void test0858() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				interface ExtCloneable extends Cloneable {
					public ExtCloneable clone( String arg) throws CloneNotSupportedException;
				}
				public class X {
					public static <V extends ExtCloneable> ExtCloneable cloneItem1( V value) throws CloneNotSupportedException {
						return value.clone( "");
					}
					public static <V extends ExtCloneable> ExtCloneable cloneItem2( ExtCloneable value) throws CloneNotSupportedException {
						return value.clone( "");
					}
					public static <V extends ExtCloneable> ExtCloneable cloneItem3( V value) throws CloneNotSupportedException {
						return ((ExtCloneable)value).clone( "");
					}
				}""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=113710
public void test0859() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.awt.Graphics2D;
				import java.awt.Shape;
				public class X<V extends DrawObject> {
				   /** Base object for wrapping */
				   protected V draw;
				   /**
				    * Draw the object with its attached text
				    *\s
				    * @param graphics the graphics object to draw into
				    */
				   public void draw( Graphics2D graphics ) {
				      draw.draw(graphics);
				   }
				}
				abstract class DrawObject implements Drawable {
				   protected void draw( Graphics2D graphics, Shape shape ) {
				   }
				}
				interface Drawable {
				   void draw( Graphics2D graphics );
				}""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=114304
public void test0860() {
	this.runConformTest(
		new String[] {
			"A.java",
			"""
				interface A {
				    A.I foo();
				    interface I { }
				}
				
				interface B<T> extends A { }
				
				interface C extends B<Object> {
				    C.J foo();
				    interface J extends B.I { }
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=114304 - variation
public void test0861() {
	this.runConformTest(
		new String[] {
			"A.java",
			"""
				interface A {
				    A.I foo();
				    interface I { }
				}
				
				interface B<T> extends A { }
				
				interface C extends B<Object> {
				    C.J foo();
				    interface J extends A.I { }
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=114304 - variation
public void test0862() {
	this.runConformTest(
		new String[] {
			"A.java",
			"""
				interface A {
				    interface I { }
				
				    A.I foo();
				}
				
				interface B<T> extends A {\s
				    interface J extends B.I { }
				}
				
				interface C extends B<Object> {
				    C.J foo();
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=114304 - variation
public void test0863() {
	this.runConformTest(
		new String[] {
			"A.java",
			"""
				interface A {
				    interface I { }
				
				    A.I foo();
				}
				
				interface B<T> extends A {\s
				    interface J extends B.I { }
				}
				
				interface C extends B<Object> {
				    B.J foo();
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=114304 - variation
public void test0864() {
	this.runNegativeTest(
		new String[] {
			"A.java",
			"""
				interface A {
				    interface I<T> { }
				
				    A.I<Object> foo();
				}
				
				interface B<T> extends A {\s
				    interface J<E> extends B.I<E> { }
				}
				
				interface C extends B<Object> {
				    C.J<Object> foo();
				    B<Object>.J<Object> bar();
				}
				""",
		},
		"""
			----------
			1. ERROR in A.java (at line 13)
				B<Object>.J<Object> bar();
				^^^^^^^^^^^
			The member type B.J<E> cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type B<Object>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=114304 - variation
public void test0865() {
	this.runConformTest(
		new String[] {
			"A.java",
			"""
				class A {
				    interface I { }
				
				    A.I foo() { return null; }
				}
				
				class B<T> extends A {\s
				    interface J extends B.I { }
				}
				
				class C extends B<Object> {
					@Override
				    C.J foo() { return (B.J)super.foo(); }
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=114997
public void test0866() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.Collections;
				import java.util.List;
				
				public class X {
				  public interface Interface {
					  // nothing
				  }
				  public List<? extends Interface> field = Collections.emptyList();
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=114087
// SHOULD FAIL AT 1.8 (RET): Type mismatch: cannot convert from List<Runnable> to List
public void test0867() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.List;
				
				class Foo {
				
					static <T extends Runnable> List<List<T>> foo1() {
						return null;
					}
					static <T extends Runnable> void bar1(List<List<T>> l) {
					}
					static <T extends Runnable> List<T> foo2() {
						return null;
					}
					static <T extends Runnable> void bar2(List<T> l) {
					}
				}
				
				public class X {
				
					{
						List<List> o = Foo.foo1();
						Foo.bar1(o);
					}
					{
						List o = Foo.foo2();
						Foo.bar2(o);
					}
				
				}
				""",
		},
		"----------\n" +
		"1. WARNING in X.java (at line 20)\n" +
		"	List<List> o = Foo.foo1();\n" +
		"	     ^^^^\n" +
		"List is a raw type. References to generic type List<E> should be parameterized\n" +
		"----------\n" +
		"2. ERROR in X.java (at line 20)\n" +
		(this.complianceLevel < ClassFileConstants.JDK1_8 ?
		"	List<List> o = Foo.foo1();\n" +
		"	                   ^^^^\n" +
		"The method foo1() in the type Foo is not applicable for the arguments ()\n"
		:
		"	List<List> o = Foo.foo1();\n" +
		"	               ^^^^^^^^^^\n" +
		"Type mismatch: cannot convert from List<List<Runnable>> to List<List>\n" // TODO(stephan) more specific error message
		)+
		"----------\n" +
		"3. ERROR in X.java (at line 21)\n" +
		"	Foo.bar1(o);\n" +
		"	    ^^^^\n" +
		"The method bar1(List<List<T>>) in the type Foo is not applicable for the arguments (List<List>)\n" +
		"----------\n" +
		"4. WARNING in X.java (at line 24)\n" +
		"	List o = Foo.foo2();\n" +
		"	^^^^\n" +
		"List is a raw type. References to generic type List<E> should be parameterized\n" +
		"----------\n" +
		"5. WARNING in X.java (at line 25)\n" +
		"	Foo.bar2(o);\n" +
		"	^^^^^^^^^^^\n" +
		"Type safety: Unchecked invocation bar2(List) of the generic method bar2(List<T>) of type Foo\n" +
		"----------\n" +
		"6. WARNING in X.java (at line 25)\n" +
		"	Foo.bar2(o);\n" +
		"	         ^\n" +
		"Type safety: The expression of type List needs unchecked conversion to conform to List<Runnable>\n" +
		"----------\n");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=114365
public void test0868() {
	Map options = getCompilerOptions();
	options.put(CompilerOptions.OPTION_ReportRawTypeReference, CompilerOptions.IGNORE);
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.Collection;
				import java.util.Iterator;
				import java.io.Serializable;
				import java.lang.Cloneable;
				public class X<A extends Collection & Serializable > implements Collection {
					public int size() {
						// TODO Auto-generated method stub
						return 0;
					}
					public boolean isEmpty() {
						// TODO Auto-generated method stub
						return false;
					}
					public boolean contains(Object arg0) {
						// TODO Auto-generated method stub
						return false;
					}
					public Iterator iterator() {
						// TODO Auto-generated method stub
						return null;
					}
					public Object[] toArray() {
						// TODO Auto-generated method stub
						return null;
					}
					public Object[] toArray(Object[] arg0) {
						// TODO Auto-generated method stub
						return null;
					}
					public boolean add(Object arg0) {
						// TODO Auto-generated method stub
						return false;
					}
					public boolean remove(Object arg0) {
						// TODO Auto-generated method stub
						return false;
					}
					public boolean containsAll(Collection arg0) {
						// TODO Auto-generated method stub
						return false;
					}
					public boolean addAll(Collection arg0) {
						// TODO Auto-generated method stub
						return false;
					}
					public boolean removeAll(Collection arg0) {
						// TODO Auto-generated method stub
						return false;
					}
					public boolean retainAll(Collection arg0) {
						// TODO Auto-generated method stub
						return false;
					}
					public void clear() {
						// TODO Auto-generated method stub
					\t
					}\
				}""",
		},
		"",
		null,
		true,
		null,
		options,
		null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=115181
public void test0869() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.Comparator;
				
				public class X {
					public static void main(String[] args) {
						Class<?> c = Comparator.class;
						Zork z;
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 6)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=113950
public void test0870() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.List;
				
				public class X {
					public interface I<T> {
					        public <S extends T> void foo(List<S> ls);
					}
				
					public abstract class A<T> implements I<T> {
					        public <S extends T> void foo(List<S> ls) { }
					}
				
					public class C<T> extends A<List<T>> { }
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=107788
public void test0871() {
	this.runConformTest(
		new String[] {
			"Lister.java",
			"""
				interface Lister<BeanT, PropT, PackT> {
					void endPacking(PackT p, BeanT b, Accessor<BeanT, PropT> acc);
				
					static class IDRefs<BeanT, PropT> implements
							Lister<BeanT, PropT, IDRefs<BeanT, PropT>.Pack> {
						public void endPacking(Pack p, BeanT b, Accessor<BeanT, PropT> acc) {
						}
				
						private class Pack {
						}
					}
				}
				
				class Accessor<BeanT, PropT> {
				}
				""",
		},
		"");
}
public void test0872() {
	String expectedError = this.complianceLevel < ClassFileConstants.JDK16 ?
			"""
				----------
				1. ERROR in X.java (at line 22)
					M3<X>.N3<X> n = m.new N3<X>();
					^^^^^^^^
				The member type X.M3.N3<U> cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X.M3<X>
				----------
				2. ERROR in X.java (at line 22)
					M3<X>.N3<X> n = m.new N3<X>();
					                ^
				Illegal enclosing instance specification for type X.M3.N3<X>
				----------
				3. ERROR in X.java (at line 25)
					static class N3<U> {
					             ^^
				The member type N3 cannot be declared static; static types can only be declared in static or top level types
				----------
				4. ERROR in X.java (at line 30)
					M4<X>.N4<X> n = m.new N4<X>();
					^^^^^^^^
				The member type X.M4.N4<U> cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X.M4<X>
				----------
				5. ERROR in X.java (at line 30)
					M4<X>.N4<X> n = m.new N4<X>();
					                ^
				Illegal enclosing instance specification for type X.M4.N4<X>
				----------
				""" :
						"""
							----------
							1. ERROR in X.java (at line 22)
								M3<X>.N3<X> n = m.new N3<X>();
								^^^^^^^^
							The member type X.M3.N3<U> cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X.M3<X>
							----------
							2. ERROR in X.java (at line 22)
								M3<X>.N3<X> n = m.new N3<X>();
								                ^
							Illegal enclosing instance specification for type X.M3.N3<X>
							----------
							3. ERROR in X.java (at line 30)
								M4<X>.N4<X> n = m.new N4<X>();
								^^^^^^^^
							The member type X.M4.N4<U> cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X.M4<X>
							----------
							4. ERROR in X.java (at line 30)
								M4<X>.N4<X> n = m.new N4<X>();
								                ^
							Illegal enclosing instance specification for type X.M4.N4<X>
							----------
							""";
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				import java.io.PrintStream;
				
				public class X {
					public void foo1(){
						M1<X> m = new M1<X>();
						M1<X>.N1<X> n = m.new N1<X>();
					}
					static class M1<T> {
						class N1<U> {
						}
					}
					public void foo2(){
						M2<X> m = new M2<X>();
						M2<X>.N2<X> n = m.new N2<X>();
					}
					class M2<T> {
						class N2<U> {
						}
					}
					public void foo3(){
						M3<X> m = new M3<X>();
						M3<X>.N3<X> n = m.new N3<X>();
					}
					class M3<T> {
						static class N3<U> {
						}
					}
					public void foo4(){
						M4<X> m = new M4<X>();
						M4<X>.N4<X> n = m.new N4<X>();
					}
					static class M4<T> {
						static class N4<U> {
						}
					}
				}
				""",
		},
		expectedError);
}
public void test0873() {
	this.runConformTest(
		new String[] {
			"X.java", // =================
			"""
				public class X<T> {
				    static class XMap {
				        XEntry[] table;
				        static class XEntry {}   \s
				        void foo() {
				            XEntry e = table[0];
				        }\t
				    }       \s
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=115693
public void test0874() throws Exception {
	this.runConformTest(
		new String[] {
			"X.java", // =================
			"""
				class A {}
				abstract class B<T> {
				    public B<T> label(String s) { return this; }
				}
				final class C extends B<A> {
				    public static C instance(String s) { return new C(); }
				    @Override public String toString() {
				    	return "SUCCESS";
				    }
				}
				public class X {
				    public static void main(String[] args) {
				        C c = (C)C.instance("X").label("Y");
				        System.out.println(c.toString());
				    }
				}
				""",
		},
		"SUCCESS");
	// 	ensure only one checkcast C
	String expectedOutput =
		"""
		  // Method descriptor #15 ([Ljava/lang/String;)V
		  // Stack: 2, Locals: 2
		  public static void main(java.lang.String[] args);
		     0  ldc <String "X"> [16]
		     2  invokestatic C.instance(java.lang.String) : C [17]
		     5  ldc <String "Y"> [23]
		     7  invokevirtual C.label(java.lang.String) : B [25]
		    10  checkcast C [18]
		    13  astore_1 [c]
		    14  getstatic java.lang.System.out : java.io.PrintStream [29]
		    17  aload_1 [c]
		    18  invokevirtual C.toString() : java.lang.String [35]
		    21  invokevirtual java.io.PrintStream.println(java.lang.String) : void [39]
		    24  return
		      Line numbers:
		        [pc: 0, line: 13]
		        [pc: 14, line: 14]
		        [pc: 24, line: 15]
		      Local variable table:
		        [pc: 0, pc: 25] local: args index: 0 type: java.lang.String[]
		        [pc: 14, pc: 25] local: c index: 1 type: C
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=119395
public void test0875() {
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				import java.util.*;
				public class X {
				
					public static class DatabaseObject {}
					public static class ObjectFormUI<T extends DatabaseObject> {}
					private static final Map<Class<? extends DatabaseObject>, Class<? extends ObjectFormUI>> uiMap = new HashMap<Class<? extends DatabaseObject>, Class<? extends ObjectFormUI>>();
				
					public static <T extends DatabaseObject> Class<? extends ObjectFormUI<T>> getUI(
							Class<T> persistentClass) {
						return null != null\s
							? uiMap.get(persistentClass)
							: (Class<? extends ObjectFormUI<T>>) uiMap.get(persistentClass);
					}
				}
				""",
		},
		this.complianceLevel < ClassFileConstants.JDK1_8 ?
			"""
				----------
				1. WARNING in X.java (at line 6)
					private static final Map<Class<? extends DatabaseObject>, Class<? extends ObjectFormUI>> uiMap = new HashMap<Class<? extends DatabaseObject>, Class<? extends ObjectFormUI>>();
					                                                                          ^^^^^^^^^^^^
				X.ObjectFormUI is a raw type. References to generic type X.ObjectFormUI<T> should be parameterized
				----------
				2. WARNING in X.java (at line 6)
					private static final Map<Class<? extends DatabaseObject>, Class<? extends ObjectFormUI>> uiMap = new HashMap<Class<? extends DatabaseObject>, Class<? extends ObjectFormUI>>();
					                                                                                                                                                              ^^^^^^^^^^^^
				X.ObjectFormUI is a raw type. References to generic type X.ObjectFormUI<T> should be parameterized
				----------
				3. ERROR in X.java (at line 10)
					return null != null\s
							? uiMap.get(persistentClass)
							: (Class<? extends ObjectFormUI<T>>) uiMap.get(persistentClass);
					       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Class<capture#4-of ? extends X.ObjectFormUI> to Class<? extends X.ObjectFormUI<T>>
				----------
				4. WARNING in X.java (at line 12)
					: (Class<? extends ObjectFormUI<T>>) uiMap.get(persistentClass);
					  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Class<capture#2-of ? extends X.ObjectFormUI> to Class<? extends X.ObjectFormUI<T>>
				----------
				""" :
				"""
					----------
					1. WARNING in X.java (at line 6)
						private static final Map<Class<? extends DatabaseObject>, Class<? extends ObjectFormUI>> uiMap = new HashMap<Class<? extends DatabaseObject>, Class<? extends ObjectFormUI>>();
						                                                                          ^^^^^^^^^^^^
					X.ObjectFormUI is a raw type. References to generic type X.ObjectFormUI<T> should be parameterized
					----------
					2. WARNING in X.java (at line 6)
						private static final Map<Class<? extends DatabaseObject>, Class<? extends ObjectFormUI>> uiMap = new HashMap<Class<? extends DatabaseObject>, Class<? extends ObjectFormUI>>();
						                                                                                                                                                              ^^^^^^^^^^^^
					X.ObjectFormUI is a raw type. References to generic type X.ObjectFormUI<T> should be parameterized
					----------
					3. ERROR in X.java (at line 11)
						? uiMap.get(persistentClass)
						  ^^^^^^^^^^^^^^^^^^^^^^^^^^
					Type mismatch: cannot convert from Class<capture#1-of ? extends X.ObjectFormUI> to Class<? extends X.ObjectFormUI<T>>
					----------
					4. WARNING in X.java (at line 12)
						: (Class<? extends ObjectFormUI<T>>) uiMap.get(persistentClass);
						  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
					Type safety: Unchecked cast from Class<capture#2-of ? extends X.ObjectFormUI> to Class<? extends X.ObjectFormUI<T>>
					----------
					""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=119395 - variation
public void test0876() {
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				import java.util.*;
				public class X {
					void foo(){
						Class<Class<Object>> cco = null;
						Class<Class> cc = cco; // ko
						Class<Class<Object>> cco2 = cc; // ko
					\t
						Class<? extends Class<Object>> ceco = null;
						Class<? extends Class> cec = ceco; // ok
						Class<? extends Class<Object>> ceco2 = cec; // ko
					}
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 5)
				Class<Class> cc = cco; // ko
				      ^^^^^
			Class is a raw type. References to generic type Class<T> should be parameterized
			----------
			2. ERROR in X.java (at line 5)
				Class<Class> cc = cco; // ko
				                  ^^^
			Type mismatch: cannot convert from Class<Class<Object>> to Class<Class>
			----------
			3. ERROR in X.java (at line 6)
				Class<Class<Object>> cco2 = cc; // ko
				                            ^^
			Type mismatch: cannot convert from Class<Class> to Class<Class<Object>>
			----------
			4. WARNING in X.java (at line 9)
				Class<? extends Class> cec = ceco; // ok
				                ^^^^^
			Class is a raw type. References to generic type Class<T> should be parameterized
			----------
			5. ERROR in X.java (at line 10)
				Class<? extends Class<Object>> ceco2 = cec; // ko
				                                       ^^^
			Type mismatch: cannot convert from Class<capture#2-of ? extends Class> to Class<? extends Class<Object>>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=119395 - variation
public void test0877() {
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				import java.util.*;
				public class X {
					<T extends Class> void bar(T t) {
						Class<Object> c = t; // ok - unchecked
					}
					<T extends Class> void bar2(List<? extends T> let) {
						Class<Object> c = let.get(0); // ok - unchecked
					}
					void bar3(List<? extends Class> lec) {
						Class<Object> c = lec.get(0); // ok - unchecked
					}
					Zork z;
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 3)
				<T extends Class> void bar(T t) {
				           ^^^^^
			Class is a raw type. References to generic type Class<T> should be parameterized
			----------
			2. WARNING in X.java (at line 3)
				<T extends Class> void bar(T t) {
				           ^^^^^
			The type parameter T should not be bounded by the final type Class. Final types cannot be further extended
			----------
			3. WARNING in X.java (at line 4)
				Class<Object> c = t; // ok - unchecked
				                  ^
			Type safety: The expression of type T needs unchecked conversion to conform to Class<Object>
			----------
			4. WARNING in X.java (at line 6)
				<T extends Class> void bar2(List<? extends T> let) {
				           ^^^^^
			Class is a raw type. References to generic type Class<T> should be parameterized
			----------
			5. WARNING in X.java (at line 6)
				<T extends Class> void bar2(List<? extends T> let) {
				           ^^^^^
			The type parameter T should not be bounded by the final type Class. Final types cannot be further extended
			----------
			6. WARNING in X.java (at line 7)
				Class<Object> c = let.get(0); // ok - unchecked
				                  ^^^^^^^^^^
			Type safety: The expression of type capture#1-of ? extends T needs unchecked conversion to conform to Class<Object>
			----------
			7. WARNING in X.java (at line 9)
				void bar3(List<? extends Class> lec) {
				                         ^^^^^
			Class is a raw type. References to generic type Class<T> should be parameterized
			----------
			8. WARNING in X.java (at line 10)
				Class<Object> c = lec.get(0); // ok - unchecked
				                  ^^^^^^^^^^
			Type safety: The expression of type capture#2-of ? extends Class needs unchecked conversion to conform to Class<Object>
			----------
			9. ERROR in X.java (at line 12)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=115693 - variation
public void test0878() throws Exception {
	this.runConformTest(
		new String[] {
			"X.java", // =================
			"""
				class A {}
				class D extends A {}
				abstract class B<T> {
				    public T label(String s) { return null; }
				}
				final class C extends B<A> {
				    public static C instance(String s) { return new C(); }
				    @Override public String toString() {
				    	return "SUCCESS";\s
				    }
				}
				public class X {
				    public static void main(String[] args) {
				        D d = (D)C.instance("X").label("Y");
				        System.out.println(d);
				    }
				}
				""",
		},
		"null");
	// 	ensure only one checkcast D
	String expectedOutput =
		"""
		  // Method descriptor #15 ([Ljava/lang/String;)V
		  // Stack: 2, Locals: 2
		  public static void main(java.lang.String[] args);
		     0  ldc <String "X"> [16]
		     2  invokestatic C.instance(java.lang.String) : C [17]
		     5  ldc <String "Y"> [23]
		     7  invokevirtual C.label(java.lang.String) : java.lang.Object [25]
		    10  checkcast D [29]
		    13  astore_1 [d]
		    14  getstatic java.lang.System.out : java.io.PrintStream [31]
		    17  aload_1 [d]
		    18  invokevirtual java.io.PrintStream.println(java.lang.Object) : void [37]
		    21  return
		      Line numbers:
		        [pc: 0, line: 14]
		        [pc: 14, line: 15]
		        [pc: 21, line: 16]
		      Local variable table:
		        [pc: 0, pc: 22] local: args index: 0 type: java.lang.String[]
		        [pc: 14, pc: 22] local: d index: 1 type: D
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=122610
public void test0879() {
	this.runConformTest(
		new String[] {
			"X.java", // =================
			"""
				public class X<V, R> {
				
				    private class InnerClass1 {
				            void foo() {
				                    X<V, R> c = X.this;
				            }
				    }
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=121369
public void test0880() {
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				class Foo {
					static <T, U extends java.util.List<T>> U foo() {
						return null;
					}
				}
				
				public class X {
					{
						String s = (String) Foo.foo();
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 9)
				String s = (String) Foo.foo();
				           ^^^^^^^^^^^^^^^^^^
			Cannot cast from List<Object> to String
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=121369 - variation
public void test0881() {
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				class Foo {
					static <T, U extends java.util.List<U>> U foo() {
						return null;
					}
				}
				
				public class X {
					{
						String s = (String) Foo.foo();
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 9)
				String s = (String) Foo.foo();
				           ^^^^^^^^^^^^^^^^^^
			Cannot cast from List<List<U>> to String
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=121369 - variation
public void test0882() {
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				import java.util.List;
				
				public class X {
					static <U extends List<U>> U foo(U u) {
						String s = (String) foo(u);
						return u;
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 5)
				String s = (String) foo(u);
				           ^^^^^^^^^^^^^^^
			Cannot cast from U to String
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=121369 - variation
public void test0883() {
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				import java.util.List;
				
				public class X {
					static <U extends List<U>> U foo(U u) {
						List<U> listu = null;
						String s = (String)foo(listu);
						return u;
					}
					static <V extends List<V>> V bar(V v) {
						List<V> listv = null;
						String s = (String)foo(listv);
						return v;
					}
				}
				""",
		},
		(this.complianceLevel < ClassFileConstants.JDK1_8 ?
		"""
			----------
			1. ERROR in X.java (at line 6)
				String s = (String)foo(listu);
				           ^^^^^^^^^^^^^^^^^^
			Cannot cast from List<U> to String
			----------
			2. ERROR in X.java (at line 6)
				String s = (String)foo(listu);
				                   ^^^
			Bound mismatch: The generic method foo(U) of type X is not applicable for the arguments (List<U>). The inferred type List<U> is not a valid substitute for the bounded parameter <U extends List<U>>
			----------
			3. ERROR in X.java (at line 11)
				String s = (String)foo(listv);
				           ^^^^^^^^^^^^^^^^^^
			Cannot cast from List<V> to String
			----------
			4. ERROR in X.java (at line 11)
				String s = (String)foo(listv);
				                   ^^^
			Bound mismatch: The generic method foo(U) of type X is not applicable for the arguments (List<V>). The inferred type List<V> is not a valid substitute for the bounded parameter <U extends List<U>>
			----------
			"""
		:
			"""
				----------
				1. ERROR in X.java (at line 6)
					String s = (String)foo(listu);
					                   ^^^
				The method foo(U) in the type X is not applicable for the arguments (List<U>)
				----------
				2. ERROR in X.java (at line 11)
					String s = (String)foo(listv);
					                   ^^^
				The method foo(U) in the type X is not applicable for the arguments (List<V>)
				----------
				""" ));
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=123078
// SHOULD FAIL AT 1.8 (18.2.3): The method getDefault(Class<T>) in the type X<C> is not applicable for the arguments (Class<capture#2-of ? extends X>)
public void test0884() {
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				public abstract class X<C extends X<C>> {
					public static <T extends X<T>> T getDefault(Class<T> clz) {
						return null;
					}
				
					public Object getDefault() {
						String s = getClass();
						return (String) getDefault(getClass());
					}
				}
				""" ,
		},
		"""
			----------
			1. ERROR in X.java (at line 7)
				String s = getClass();
				           ^^^^^^^^^^
			Type mismatch: cannot convert from Class<capture#1-of ? extends X> to String
			----------
			2. ERROR in X.java (at line 8)
				return (String) getDefault(getClass());
				       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Cannot cast from X to String
			----------
			3. WARNING in X.java (at line 8)
				return (String) getDefault(getClass());
				                ^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked invocation getDefault(Class<capture#2-of ? extends X>) of the generic method getDefault(Class<T>) of type X<C>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=125445
public void test0885() {
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				public class X {
					public static <C extends Number, A extends C & Comparable<C>> int m(
							A comparableNumberObj) {
						return comparableNumberObj.compareTo(comparableNumberObj);
					}
				}
				""" ,
		},
		"""
			----------
			1. ERROR in X.java (at line 2)
				public static <C extends Number, A extends C & Comparable<C>> int m(
				                                               ^^^^^^^^^^
			Cannot specify any additional bound Comparable<C> when first bound is a type parameter
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=124943
public void test0886() {
	Map customOptions= getCompilerOptions();
	customOptions.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_4);
	runConformTest(
		// test directory preparation
		true /* flush output directory */,
		new String[] { /* test files */
			"X.java", // =================
			"""
				public class X {
					void test() {
						"Hello".compareTo((Object) "Hello");
					}
				}
				""" ,
		},
		// compiler options
		null /* no class libraries */,
		customOptions /* custom options */,
		// compiler results
		"" /* expected compiler log */,
		// runtime results
		"" /* expected output string */,
		null /* do not check error string */,
		// javac options
		new JavacTestOptions("-source 1.4 -Xlint:-options") /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=122775
public void test0887() {
	this.runNegativeTest(
		new String[] {
			"Bar.java", // =================
			"""
				class Foo<T> {}
				public class Bar<X extends Foo<Foo<? super X>>>{
				    Bar(X x){
				        Foo<? super X> f = x;
				    }
				}
				""",
		},
		"""
			----------
			1. ERROR in Bar.java (at line 4)
				Foo<? super X> f = x;
				                   ^
			Type mismatch: cannot convert from X to Foo<? super X>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=122775 - variation
public void test0888() {
	this.runNegativeTest(
		new String[] {
			"Bar.java", // =================
			"""
				class Foo<T> {}
				public class Bar<X extends Foo<Foo<? super X>>>{
				    Bar(X x){
				        Foo<? extends X> f = x;
				    }
				}
				""",
		},
		"""
			----------
			1. ERROR in Bar.java (at line 4)
				Foo<? extends X> f = x;
				                     ^
			Type mismatch: cannot convert from X to Foo<? extends X>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=122775 - variation
public void test0889() {
	this.runConformTest(
		// test directory preparation
		true /* flush output directory */,
		new String[] { /* test files */
			"Test.java", // =================
			"""
				import java.util.*;
				
				class Group<E extends Comparable<? super E>> extends ArrayList<E> implements
						Comparable<Group<? extends E>> {
					public int compareTo(Group<? extends E> o) {
						return 0;
					}
				}
				
				class Sequence<E extends Comparable<? super E>> extends TreeSet<E> implements
						Comparable<Sequence<? extends E>> {
					public int compareTo(Sequence<? extends E> o) {
						return 0;
					}
				}
				
				class Test<T extends Comparable<? super T>> {
					<C extends Collection<T>> void foo(SortedSet<? extends C> setToCheck,
							SortedSet<? extends C> validSet) {
					}
				
					public void containsCombination(SortedSet<Group<T>> groups,
							SortedSet<Sequence<T>> sequences) {
						foo(groups, sequences);
					}
				}
				""",
		},
		// compiler results
		null /* do not check compiler log */,
		// runtime results
		"" /* expected output string */,
		"" /* expected error string */,
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=122775 - variation
public void test0890() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"Simple.java", // =================
			"""
				class A<T extends A<T>> {}
				class B extends A<B> {}
				class C extends B {}
				class D<T> {}
				
				public class Simple {
					<T extends A<T>, S extends T> D<T> m(S s) {
						C c = null;
						D<B> d = m(c);
						return null;
					}
				}
				""",
		},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_7 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=122775 - variation
public void test0891() {
	String xSource =
			"""
		interface Function<A, B> {
			B apply(A x);
		}
		class Id<A> implements Function<A, A> {
			public A apply(A x) {
				return x;
			}
		}
		class Test {
			<A> Id<A> identity() {
				return new Id<A>();
			}
		
			<B> B applyToString(Function<String, B> f) {
				return f.apply("abc");
			}
			void test() {
				String s = applyToString(identity());
			}
		}
		""";
	if (this.complianceLevel < ClassFileConstants.JDK1_8) {
		this.runNegativeTest(
			new String[] {
				"Test.java",
				xSource
			},
			"""
				----------
				1. ERROR in Test.java (at line 18)
					String s = applyToString(identity());
					           ^^^^^^^^^^^^^
				The method applyToString(Function<String,B>) in the type Test is not applicable for the arguments (Id<Object>)
				----------
				""");
	} else {
		runConformTest(
			new String[] {
				"Test.java",
				xSource
			});
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=126180
public void test0892() {
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				public class X {
					public static void main(String[] args) {
						C2 c2 = null;
						C3 c3 = null;
						Object oc1 = m1(c2, c3).new C1Member();
					}
				
					public static <T> T m1(T t1, T t2) {
						return null;
					}
				
					class C1 {}
					interface I1 {}
					class C2 extends C1 implements I1 {}
					class C3 extends C1 implements I1 {
					}
				}
				""",
		},
		"----------\n" +
		"1. ERROR in X.java (at line 5)\n" +
		"	Object oc1 = m1(c2, c3).new C1Member();\n" +
		"	                            ^^^^^^^^\n" +
		intersection("X.C1","X.I1.C1Member")+" cannot be resolved to a type\n" +
		"----------\n");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=126177
public void test0893() {
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				public class X {
					static String foo;
				
					public static void main(String[] args) {
						C2 c2 = null;
						C3 c3 = null;
						// method access
						m1(c2, c3).c1m1();
						m1(c2, c3).i1m1();
						m1(c2, c3).i2m1();
				
						// field access
						int ic1 = m1(c2, c3).c1f1;
						int ii1 = m1(c2, c3).i1f1;
						int ii2 = m1(c2, c3).i2f1;
				\t
						// member type access
						Object oc1 = m1(c2, c3).new C1Member();
						Object oi1 = m1(c2, c3).new I1Member();\s
						Object oi2 = m1(c2, c3).new I2Member();
					}
				
					public static <T> T m1(T t1, T t2) {
						return null;
					}
				
					class C1 {
						void c1m1() {}
						int c1f1 = 0;
						class C1Member {}
					}
				
					interface I1 {
						void i1m1();
						int i1f1 = 1;
						class I1Member {}
					}
				
					interface I2 {
						void i2m1();
						int i2f1 = 2;
						class I2Member {}
					}
				
					class C2 extends C1 implements I1, I2 {
						public void i1m1() {
						}
						public void i2m1() {
						}
					}
				
					class C3 extends C1 implements I1, I2 {
						public void i1m1() {
						}
						public void i2m1() {
						}
					}
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 14)
				int ii1 = m1(c2, c3).i1f1;
				                     ^^^^
			The static field X.I1.i1f1 should be accessed in a static way
			----------
			2. WARNING in X.java (at line 15)
				int ii2 = m1(c2, c3).i2f1;
				                     ^^^^
			The static field X.I2.i2f1 should be accessed in a static way
			----------
			3. ERROR in X.java (at line 19)
				Object oi1 = m1(c2, c3).new I1Member();\s
				             ^^^^^^^^^^
			Illegal enclosing instance specification for type X.I1.I1Member
			----------
			4. ERROR in X.java (at line 20)
				Object oi2 = m1(c2, c3).new I2Member();
				             ^^^^^^^^^^
			Illegal enclosing instance specification for type X.I2.I2Member
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=126177 - variation
public void test0894() {
	runConformTest(
		// test directory preparation
		true /* flush output directory */,
		new String[] { /* test files */
			"X.java", // =================
			"""
				public class X {
				        static class C1 {
				                void c1m1() {
				                        System.out.print("[c1m1]");
				                }
				        }
				        static interface I {}
				        static class C2 extends C1 implements I {}
				        static class C3 extends C1 implements I {}
				
				        public <T> T m1(T t1, T t2) {
				                return t1;
				        }
				
				        public <T extends C1 & I> void test(C2 c2, C3 c3, T t) {
				                m1(c2, c3).c1m1(); // 1
				                t.c1m1(); // 2
				                (t != null ? c2 : c3).c1m1(); // 3
				        }
				
				        public static void main(String... args) {
				                X x = new X();
				                x.test(new C2(), new C3(), new C2()); // 4
				                System.out.println();
				        }
				}
				""",
		},
		// compiler results
		"" /* expected compiler log */,
		// runtime results
		"[c1m1][c1m1][c1m1]" /* expected output string */,
		"" /* expected error string */,
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}
public void test0895() {
	if (this.complianceLevel < ClassFileConstants.JDK1_7) {
		this.runNegativeTest(
			new String[] {
				"X.java", // =================
				"""
					interface I {}
					public class X {
					    Object o = new <Object> I() {};
					}
					""" ,
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					Object o = new <Object> I() {};
					           ^^^^^^^^^^^^^^^^^^^
				The constructor Object() of type Object is not generic; it cannot be parameterized with arguments <Object>
				----------
				""");
		return;
	}
	this.runNegativeTest(
			new String[] {
				"X.java", // =================
				"""
					interface I {}
					public class X {
					    Object o = new <Object> I() {};
					}
					""" ,
				"Y.java",
				"class Y extends Zork {}\n",
			},
			"""
				----------
				1. WARNING in X.java (at line 3)
					Object o = new <Object> I() {};
					                ^^^^^^
				Unused type arguments for the non generic constructor Object() of type Object; it should not be parameterized with arguments <Object>
				----------
				----------
				1. ERROR in Y.java (at line 1)
					class Y extends Zork {}
					                ^^^^
				Zork cannot be resolved to a type
				----------
				""");
}
public void test0896() {
	runConformTest(
		// test directory preparation
		true /* flush output directory */,
		new String[] { /* test files */
			"X.java", // =================
			"""
				public class X {
					interface I {		void f(); 	}
					interface J {		void g(); }
				
					static class A implements I, J {
						public void f() {	System.out.print("[A#f()]");}
						public void g() {	System.out.print("[A#g()]");}
					}
				
					static class B implements J, I {
						public void f() {	System.out.print("[B#f()]");}
						public void g() {	System.out.print("[B#g()]");}
					}
				
					public static void main(String[] args) {
						f(true, new A(), new B());
						f(false, new A(), new B());
						System.out.println();
					}
				
					static void f(boolean cond, A a, B b) {
						(cond ? a : b).f();
						(cond ? a : b).g();
					}
				}
				""",
		},
		// compiler results
		"" /* expected compiler log */,
		// runtime results
		"[A#f()][A#g()][B#f()][B#g()]" /* expected output string */,
		"" /* expected error string */,
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}
public void test0897() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"Test.java", // =================
			"""
				interface I { }
				class X { }
				class A extends X implements I { }
				class B extends X implements I { }
				public class Test {
				    void test(A a, B b) {
					X x = (a.hashCode() == b.hashCode()) ? a : b;
				    }
				}
				
				""",
		},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}
public void test0898() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java", // =================
			"""
				interface I1 {
					void i1();
				}
				class G1<T extends I1> {
					T get() {
						return null;
					}
				}
				interface I2 {
					void i2();
				}
				public class X {
					void f1(G1<?> g1) {
						g1.get().i1();
					}
					void f2(G1<? extends I2> g1) {
						g1.get().i1();
						g1.get().i2();
					}
				}
				""",
		},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=122331
public void test0899() {
	this.runConformTest(
		new String[] {
			"A.java", // =================
			"""
				public class A<T extends A<T>> extends SomeArbitraryClass<T> {
				  public static class B {
				    private C c;
				    protected void set(C val) {
				      c = val;
				    }
				    protected class C {
				    }
				  }
				}""",
			"C.java",
			"""
				public class C {
				 \s
				  public C() {
				    //do nothing
				  }
				 \s
				}""",
			"ObjThatExtendsB.java",
			"""
				public class ObjThatExtendsB extends A.B {
				  protected void doSomeSetting() {
				    super.set(new ObjThatExtendsC());
				  }
				  protected class ObjThatExtendsC extends C {
				  }
				}""",
			"ObjThatExtendsC.java",
			"""
				public class ObjThatExtendsC extends C {
				  public ObjThatExtendsC() {
				    //do nothing
				  }
				}""",
			"SomeArbitraryClass.java",
			"""
				public class SomeArbitraryClass<T extends SomeArbitraryClass<T>> {
				  public SomeArbitraryClass() {
				    //do nothing
				  }
				}"""
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=97693
public void test0900() {
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				public class X<R> {
					static interface Interface extends Comparable<String> {}
				
					static final class Implements implements Interface {
						public int compareTo(String o) {
							return 0;
						}
					}
				
					void method() {
						((Comparable<R>) new Implements()).toString();
						((Comparable) new Implements()).toString();
						((Comparable<?>) new Implements()).toString();
						((Comparable<? extends String>) new Implements()).toString();
						((Comparable<? super String>) new Implements()).toString();
						Zork z;
					}
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 11)
				((Comparable<R>) new Implements()).toString();
				^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from X.Implements to Comparable<R>
			----------
			2. WARNING in X.java (at line 12)
				((Comparable) new Implements()).toString();
				  ^^^^^^^^^^
			Comparable is a raw type. References to generic type Comparable<T> should be parameterized
			----------
			3. ERROR in X.java (at line 16)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
// Object array vs Object into generic method
public void test0901() {
	runNegativeTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				public class X {
				    static <T> T foo(T p1, T p2) {
				        return p1;
				    }
				    static Object[] bar(int[] i, float[] f) {
				        return foo(i, f);
				    }
				}"""},
		"----------\n" +
		"1. ERROR in X.java (at line 6)\n" +
		"	return foo(i, f);\n" +
		"	       ^^^^^^^^^\n" +
		"Type mismatch: cannot convert from "+intersection("Object","Serializable","Cloneable")+" to Object[]\n" +
		"----------\n",
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}

// circular references amongst generic interfaces with co-implementing classes
public void test0902() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"I.java",
			"public interface I<U extends J<? extends I<U>>> {\n" +
			"}",
			"J.java",
			"public interface J<T extends I<? extends J<T>>> {\n" +
			"}",
			"CI.java",
			"""
				class CI<U extends CJ<T, U> & J<T>,
							T extends CI<U, T> & I<U>>
					implements I<U> {
				}""",
			"CJ.java",
			"""
				class CJ<T extends CI<U, T> & I<U>,
							U extends CJ<T, U> & J<T>>
					implements J<T> {
				}"""},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}

// https://bugs.eclipse.org/bugs/show_bug.cgi?id=126914
public void test0903() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				interface I<T extends J<T,U>, U extends I<T,U>> {
				    // empty
				}
				interface J<T extends J<T,U>, U extends I<T,U>> {
				    // empty
				}
				final class Y<T, U> extends X<T, U> implements I<X<T, U>, Y<T, U>> {
				    // empty
				}
				abstract class X<T, U> implements J<X<T, U>, Y<T, U>> {
				    // empty
				}
				"""
			},
		"");
}

// https://bugs.eclipse.org/bugs/show_bug.cgi?id=126914
public void test0904() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				interface I<T extends J<T,U>, U extends I<T,U>> {
				    // empty
				}
				interface J<T extends J<T,U>, U extends I<T,U>> {
				    // empty
				}
				abstract class X<T, U> implements J<X<T, U>, Y<T, U>> {
				    // empty
				}
				final class Y<T, U> extends X<T, U> implements I<X<T, U>, Y<T, U>> {
				    // empty
				}
				"""
			},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}

// array in super bound
public void test0905() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				import java.util.List;
				\s
				class X {
				    void foo(List<? super Object[]> p) {
				        p.add(new Object[0]);
				    }
				}"""},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}

// raw types in casts
public void test0906() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				interface I<V> {
				    // empty
				}        \s
				public class X implements I {
				    I<Integer> x1 = (I<Integer>) (X) null;
				    I<Integer> x2 = (I<Integer>) new X();
				    I<Integer> x3 = (I<Integer>) null;
				    X x4 = (X) (I<Integer>) null;
				}"""},
			"""
				----------
				1. WARNING in X.java (at line 4)
					public class X implements I {
					                          ^
				I is a raw type. References to generic type I<V> should be parameterized
				----------
				2. WARNING in X.java (at line 5)
					I<Integer> x1 = (I<Integer>) (X) null;
					                ^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from X to I<Integer>
				----------
				3. WARNING in X.java (at line 5)
					I<Integer> x1 = (I<Integer>) (X) null;
					                ^^^^^^^^^^^^^^^^^^^^^
				Unnecessary cast from X to I<Integer>
				----------
				4. WARNING in X.java (at line 5)
					I<Integer> x1 = (I<Integer>) (X) null;
					                             ^^^^^^^^
				Unnecessary cast from null to X
				----------
				5. WARNING in X.java (at line 6)
					I<Integer> x2 = (I<Integer>) new X();
					                ^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from X to I<Integer>
				----------
				6. WARNING in X.java (at line 6)
					I<Integer> x2 = (I<Integer>) new X();
					                ^^^^^^^^^^^^^^^^^^^^
				Unnecessary cast from X to I<Integer>
				----------
				7. WARNING in X.java (at line 7)
					I<Integer> x3 = (I<Integer>) null;
					                ^^^^^^^^^^^^^^^^^
				Unnecessary cast from null to I<Integer>
				----------
				8. WARNING in X.java (at line 8)
					X x4 = (X) (I<Integer>) null;
					           ^^^^^^^^^^^^^^^^^
				Unnecessary cast from null to I<Integer>
				----------
				""");
}

// parametrized method with array extends Object upper bound verification
public void test0907() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.Collection;
				import java.util.Collections;
				public class X<T extends X<T, V>, V> {
				    public void foo() {
				        Y o = (new Z<Object>()).<Y, double[]> bar(Collections
				                .singleton(new Y()));
				        o.toString();
				    }
				}
				class Y extends X<Y, double[]> {
				    // empty
				}
				class Z<V> {
				    public <U extends X<U, W>, W extends V> U bar(Collection<U> c) {
				        return null;
				    }
				}
				"""},
		"");
}

// check capture for conditional operator - variant
public void test0908() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				public abstract class X {
				    protected <T> void foo(Class<? extends T> clazz) {
				        Class<? extends T> l = clazz.isInterface() ? bar(clazz) : clazz;
				    }
				    abstract public <T> Class<? extends T> bar(Class<T> p);
				}"""},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=126105
public void test0909() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					private static class B<T> {
						private Object x;
				
						public B(T x) {
							this.x = x;
						}
					}
				
					private static class C {
						private Object x;
				
						public C(Object x) {
							this.x = x;
						}
					}
				
					public static void main(String[] args) throws Throwable {
						B<String> b = new B<String>("foo");
						System.out.println(b.x);
				
						C c = new C("foo");
						System.out.println(c.x);
						Zork z;
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 24)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}

//https://bugs.eclipse.org/bugs/show_bug.cgi?id=127583
public void test0910() {
	int[] capIds = this.complianceLevel < ClassFileConstants.JDK1_8
			? new int[]{ 1, 3, 4, 6, 13}
			: new int[]{ 1, 2, 3, 4, 8};
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.ArrayList;
				import java.util.Collection;
				import java.util.List;
				
				public class X {
				
					void bar() {
						List<Collection> lc1 = null;
						List<Collection<?>> lc2 = null;
						List<? extends Collection<?>> lc3 = null;
						List<? extends Collection> lc4 = null;
						lc1 = lc2; //1 ko
						lc1 = lc3; //2 ko
						lc1 = lc4; //3 ko
						lc2 = lc1; //4 ko
						lc2 = lc3; //5 ko
						lc2 = lc4; //6 ko
						lc3 = lc1; //7 ko
						lc3 = lc2; //8 ok
						lc3 = lc4; //9 ko
						lc4 = lc1; //10 ok
						lc4 = lc2; //11 ok
						lc4 = lc3; //12 ok
					}
					private final List<Collection> aList = new ArrayList<Collection>();
					public void foo() {
						final List<Collection<?>> listCopy = new ArrayList<Collection<?>>(this.aList); // ko
					}
				}
				""",
		},
		"----------\n" +
		"1. WARNING in X.java (at line 8)\n" +
		"	List<Collection> lc1 = null;\n" +
		"	     ^^^^^^^^^^\n" +
		"Collection is a raw type. References to generic type Collection<E> should be parameterized\n" +
		"----------\n" +
		"2. WARNING in X.java (at line 11)\n" +
		"	List<? extends Collection> lc4 = null;\n" +
		"	               ^^^^^^^^^^\n" +
		"Collection is a raw type. References to generic type Collection<E> should be parameterized\n" +
		"----------\n" +
		"3. ERROR in X.java (at line 12)\n" +
		"	lc1 = lc2; //1 ko\n" +
		"	      ^^^\n" +
		"Type mismatch: cannot convert from List<Collection<?>> to List<Collection>\n" +
		"----------\n" +
		"4. ERROR in X.java (at line 13)\n" +
		"	lc1 = lc3; //2 ko\n" +
		"	      ^^^\n" +
		"Type mismatch: cannot convert from List<capture#"+capIds[0]+"-of ? extends Collection<?>> to List<Collection>\n" +
		"----------\n" +
		"5. ERROR in X.java (at line 14)\n" +
		"	lc1 = lc4; //3 ko\n" +
		"	      ^^^\n" +
		"Type mismatch: cannot convert from List<capture#"+capIds[1]+"-of ? extends Collection> to List<Collection>\n" +
		"----------\n" +
		"6. ERROR in X.java (at line 15)\n" +
		"	lc2 = lc1; //4 ko\n" +
		"	      ^^^\n" +
		"Type mismatch: cannot convert from List<Collection> to List<Collection<?>>\n" +
		"----------\n" +
		"7. ERROR in X.java (at line 16)\n" +
		"	lc2 = lc3; //5 ko\n" +
		"	      ^^^\n" +
		"Type mismatch: cannot convert from List<capture#"+capIds[2]+"-of ? extends Collection<?>> to List<Collection<?>>\n" +
		"----------\n" +
		"8. ERROR in X.java (at line 17)\n" +
		"	lc2 = lc4; //6 ko\n" +
		"	      ^^^\n" +
		"Type mismatch: cannot convert from List<capture#"+capIds[3]+"-of ? extends Collection> to List<Collection<?>>\n" +
		"----------\n" +
		"9. ERROR in X.java (at line 18)\n" +
		"	lc3 = lc1; //7 ko\n" +
		"	      ^^^\n" +
		"Type mismatch: cannot convert from List<Collection> to List<? extends Collection<?>>\n" +
		"----------\n" +
		"10. ERROR in X.java (at line 20)\n" +
		"	lc3 = lc4; //9 ko\n" +
		"	      ^^^\n" +
		"Type mismatch: cannot convert from List<capture#"+capIds[4]+"-of ? extends Collection> to List<? extends Collection<?>>\n" +
		"----------\n" +
		"11. WARNING in X.java (at line 25)\n" +
		"	private final List<Collection> aList = new ArrayList<Collection>();\n" +
		"	                   ^^^^^^^^^^\n" +
		"Collection is a raw type. References to generic type Collection<E> should be parameterized\n" +
		"----------\n" +
		"12. WARNING in X.java (at line 25)\n" +
		"	private final List<Collection> aList = new ArrayList<Collection>();\n" +
		"	                                                     ^^^^^^^^^^\n" +
		"Collection is a raw type. References to generic type Collection<E> should be parameterized\n" +
		"----------\n" +
		"13. ERROR in X.java (at line 27)\n" +
		"	final List<Collection<?>> listCopy = new ArrayList<Collection<?>>(this.aList); // ko\n" +
		"	                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
		"The constructor ArrayList<Collection<?>>(List<Collection>) is undefined\n" +
		"----------\n");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=127583 - variation
public void test0911() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.ArrayList;
				import java.util.Collection;
				import java.util.List;
				
				public class X {
					void bar() {
						List<Collection> lc1 = null;
						List<Collection<?>> lc2 = null;
						List<? super Collection<?>> lc3 = null;
						List<? super Collection> lc4 = null;
						lc1 = lc2; //1 ko
						lc1 = lc3; //2 ko
						lc1 = lc4; //3 ko
						lc2 = lc1; //4 ko
						lc2 = lc3; //5 ko
						lc2 = lc4; //6 ko
						lc3 = lc1; //7 ok
						lc3 = lc2; //8 ok
						lc3 = lc4; //9 ok
						lc4 = lc1; //10 ok
						lc4 = lc2; //11 ko
						lc4 = lc3; //12 ko
					}
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 7)
				List<Collection> lc1 = null;
				     ^^^^^^^^^^
			Collection is a raw type. References to generic type Collection<E> should be parameterized
			----------
			2. WARNING in X.java (at line 10)
				List<? super Collection> lc4 = null;
				             ^^^^^^^^^^
			Collection is a raw type. References to generic type Collection<E> should be parameterized
			----------
			3. ERROR in X.java (at line 11)
				lc1 = lc2; //1 ko
				      ^^^
			Type mismatch: cannot convert from List<Collection<?>> to List<Collection>
			----------
			4. ERROR in X.java (at line 12)
				lc1 = lc3; //2 ko
				      ^^^
			Type mismatch: cannot convert from List<capture#1-of ? super Collection<?>> to List<Collection>
			----------
			5. ERROR in X.java (at line 13)
				lc1 = lc4; //3 ko
				      ^^^
			Type mismatch: cannot convert from List<capture#2-of ? super Collection> to List<Collection>
			----------
			6. ERROR in X.java (at line 14)
				lc2 = lc1; //4 ko
				      ^^^
			Type mismatch: cannot convert from List<Collection> to List<Collection<?>>
			----------
			7. ERROR in X.java (at line 15)
				lc2 = lc3; //5 ko
				      ^^^
			Type mismatch: cannot convert from List<capture#3-of ? super Collection<?>> to List<Collection<?>>
			----------
			8. ERROR in X.java (at line 16)
				lc2 = lc4; //6 ko
				      ^^^
			Type mismatch: cannot convert from List<capture#4-of ? super Collection> to List<Collection<?>>
			----------
			9. ERROR in X.java (at line 21)
				lc4 = lc2; //11 ko
				      ^^^
			Type mismatch: cannot convert from List<Collection<?>> to List<? super Collection>
			----------
			10. ERROR in X.java (at line 22)
				lc4 = lc3; //12 ko
				      ^^^
			Type mismatch: cannot convert from List<capture#12-of ? super Collection<?>> to List<? super Collection>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=127583 - variation
public void test0912() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				
				public class X {
					void foo(List<? extends Collection<String>[]> l1, List<Collection[]> l2) {
						l1 = l2;
						l2 = l1;
					}
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 4)
				void foo(List<? extends Collection<String>[]> l1, List<Collection[]> l2) {
				                                                       ^^^^^^^^^^
			Collection is a raw type. References to generic type Collection<E> should be parameterized
			----------
			2. ERROR in X.java (at line 5)
				l1 = l2;
				     ^^
			Type mismatch: cannot convert from List<Collection[]> to List<? extends Collection<String>[]>
			----------
			3. ERROR in X.java (at line 6)
				l2 = l1;
				     ^^
			Type mismatch: cannot convert from List<capture#2-of ? extends Collection<String>[]> to List<Collection[]>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=127583 - variation
public void test0913() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				public class X {
					void bar() {
						List<Collection[]> lc1 = null;
						List<Collection<?>[]> lc2 = null;
						List<? extends Collection<?>[]> lc3 = null;
						List<? extends Collection[]> lc4 = null;
						lc1 = lc2; //1 ko
						lc1 = lc3; //2 ko
						lc1 = lc4; //3 ko
						lc2 = lc1; //4 ko
						lc2 = lc3; //5 ko
						lc2 = lc4; //6 ko
						lc3 = lc1; //7 ko
						lc3 = lc2; //8 ok
						lc3 = lc4; //9 ko
						lc4 = lc1; //10 ok
						lc4 = lc2; //11 ok
						lc4 = lc3; //12 ok	\t
					}
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 4)
				List<Collection[]> lc1 = null;
				     ^^^^^^^^^^
			Collection is a raw type. References to generic type Collection<E> should be parameterized
			----------
			2. WARNING in X.java (at line 7)
				List<? extends Collection[]> lc4 = null;
				               ^^^^^^^^^^
			Collection is a raw type. References to generic type Collection<E> should be parameterized
			----------
			3. ERROR in X.java (at line 8)
				lc1 = lc2; //1 ko
				      ^^^
			Type mismatch: cannot convert from List<Collection<?>[]> to List<Collection[]>
			----------
			4. ERROR in X.java (at line 9)
				lc1 = lc3; //2 ko
				      ^^^
			Type mismatch: cannot convert from List<capture#1-of ? extends Collection<?>[]> to List<Collection[]>
			----------
			5. ERROR in X.java (at line 10)
				lc1 = lc4; //3 ko
				      ^^^
			Type mismatch: cannot convert from List<capture#2-of ? extends Collection[]> to List<Collection[]>
			----------
			6. ERROR in X.java (at line 11)
				lc2 = lc1; //4 ko
				      ^^^
			Type mismatch: cannot convert from List<Collection[]> to List<Collection<?>[]>
			----------
			7. ERROR in X.java (at line 12)
				lc2 = lc3; //5 ko
				      ^^^
			Type mismatch: cannot convert from List<capture#3-of ? extends Collection<?>[]> to List<Collection<?>[]>
			----------
			8. ERROR in X.java (at line 13)
				lc2 = lc4; //6 ko
				      ^^^
			Type mismatch: cannot convert from List<capture#4-of ? extends Collection[]> to List<Collection<?>[]>
			----------
			9. ERROR in X.java (at line 14)
				lc3 = lc1; //7 ko
				      ^^^
			Type mismatch: cannot convert from List<Collection[]> to List<? extends Collection<?>[]>
			----------
			10. ERROR in X.java (at line 16)
				lc3 = lc4; //9 ko
				      ^^^
			Type mismatch: cannot convert from List<capture#8-of ? extends Collection[]> to List<? extends Collection<?>[]>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=127583 - variation
public void test0914() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				public class X {
					void bar() {
						List<Collection[]> lc1 = null;
						List<Collection<?>[]> lc2 = null;
						List<? super Collection<?>[]> lc3 = null;
						List<? super Collection[]> lc4 = null;
						lc1 = lc2; //1 ko
						lc1 = lc3; //2 ko
						lc1 = lc4; //3 ko
						lc2 = lc1; //4 ko
						lc2 = lc3; //5 ko
						lc2 = lc4; //6 ko
						lc3 = lc1; //7 ok
						lc3 = lc2; //8 ok
						lc3 = lc4; //9 ok
						lc4 = lc1; //10 ok
						lc4 = lc2; //11 ko
						lc4 = lc3; //12 ko	\t
					}
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 4)
				List<Collection[]> lc1 = null;
				     ^^^^^^^^^^
			Collection is a raw type. References to generic type Collection<E> should be parameterized
			----------
			2. WARNING in X.java (at line 7)
				List<? super Collection[]> lc4 = null;
				             ^^^^^^^^^^
			Collection is a raw type. References to generic type Collection<E> should be parameterized
			----------
			3. ERROR in X.java (at line 8)
				lc1 = lc2; //1 ko
				      ^^^
			Type mismatch: cannot convert from List<Collection<?>[]> to List<Collection[]>
			----------
			4. ERROR in X.java (at line 9)
				lc1 = lc3; //2 ko
				      ^^^
			Type mismatch: cannot convert from List<capture#1-of ? super Collection<?>[]> to List<Collection[]>
			----------
			5. ERROR in X.java (at line 10)
				lc1 = lc4; //3 ko
				      ^^^
			Type mismatch: cannot convert from List<capture#2-of ? super Collection[]> to List<Collection[]>
			----------
			6. ERROR in X.java (at line 11)
				lc2 = lc1; //4 ko
				      ^^^
			Type mismatch: cannot convert from List<Collection[]> to List<Collection<?>[]>
			----------
			7. ERROR in X.java (at line 12)
				lc2 = lc3; //5 ko
				      ^^^
			Type mismatch: cannot convert from List<capture#3-of ? super Collection<?>[]> to List<Collection<?>[]>
			----------
			8. ERROR in X.java (at line 13)
				lc2 = lc4; //6 ko
				      ^^^
			Type mismatch: cannot convert from List<capture#4-of ? super Collection[]> to List<Collection<?>[]>
			----------
			9. ERROR in X.java (at line 18)
				lc4 = lc2; //11 ko
				      ^^^
			Type mismatch: cannot convert from List<Collection<?>[]> to List<? super Collection[]>
			----------
			10. ERROR in X.java (at line 19)
				lc4 = lc3; //12 ko	\t
				      ^^^
			Type mismatch: cannot convert from List<capture#12-of ? super Collection<?>[]> to List<? super Collection[]>
			----------
			""");
}

//https://bugs.eclipse.org/bugs/show_bug.cgi?id=128389
public void test0915() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {
					class Y1 extends Throwable {
						private static final long serialVersionUID = 1L;
						T t;
					}
					static class Y2 extends Throwable {
						private static final long serialVersionUID = 1L;
					}
					class Y3<U> extends Throwable {
						private static final long serialVersionUID = 1L;
				
						T t;
					}
				}
				class Y4<E> extends Throwable {}
				
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 2)
				class Y1 extends Throwable {
				                 ^^^^^^^^^
			The generic class X<T>.Y1 may not subclass java.lang.Throwable
			----------
			2. ERROR in X.java (at line 9)
				class Y3<U> extends Throwable {
				                    ^^^^^^^^^
			The generic class X<T>.Y3<U> may not subclass java.lang.Throwable
			----------
			3. WARNING in X.java (at line 15)
				class Y4<E> extends Throwable {}
				      ^^
			The serializable class Y4 does not declare a static final serialVersionUID field of type long
			----------
			4. ERROR in X.java (at line 15)
				class Y4<E> extends Throwable {}
				                    ^^^^^^^^^
			The generic class Y4<E> may not subclass java.lang.Throwable
			----------
			""");
}

// synchronized inheritance for multiple generic types
public void test0916() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				public class X<T extends X2<?>> {
				    T m2;
				    T getX2() {
				        return this.m2;
				    }
				}
				class X2<T extends X3> {
				    T m3;
				    T getX3() {
				        return this.m3;
				    }
				}
				class X3 {
				}
				class Y1<T extends Y2<?>> extends X<T> {
				    public void foo() {
				        getX2().getX3().bar(); // getX3 appropriately returns an Y3
				    }
				}
				class Y2<T extends Y3> extends X2<T> {
				}
				class Y3 extends X3 {
				    public void bar() {
				    }
				}
				"""},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}

// https://bugs.eclipse.org/bugs/show_bug.cgi?id=128423
// [1.5][compiler] ClassCastException on illegal code fragment
public void test0917() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends A> extends X2<T.M> { }
				class X2<T> { }
				class A { static class M {} }"""
		},
		"""
			----------
			1. ERROR in X.java (at line 1)
				public class X<T extends A> extends X2<T.M> { }
				                                       ^^^
			Illegal qualified access from the type parameter T
			----------
			"""
	);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=128423 - variation
public void test0917a() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"public class X<T> extends X2<T.clazz> { }\n" +
			"class X2<T> { }\n"
		},
		"""
			----------
			1. ERROR in X.java (at line 1)
				public class X<T> extends X2<T.clazz> { }
				                             ^^^^^^^
			Illegal qualified access from the type parameter T
			----------
			"""
	);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=128423 - variation
public void test0917b() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"public class X<T> { Class<T> c = T.class; }"
		},
		"""
			----------
			1. ERROR in X.java (at line 1)
				public class X<T> { Class<T> c = T.class; }
				                                 ^^^^^^^
			Illegal class literal for the type parameter T
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=128423 - variation
public void test0917c() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"public class X<T> extends X2<T.class> { }\n" +
			"class X2<T> { }\n"
		},
		"""
			----------
			1. ERROR in X.java (at line 1)
				public class X<T> extends X2<T.class> { }
				                               ^^^^^
			Syntax error on token "class", Identifier expected
			----------
			""");
}

//https://bugs.eclipse.org/bugs/show_bug.cgi?id=128560
public void test0918() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"BasicNode.java",
			"""
				class BasicEdge<N extends BasicNode<E, N> & Node<E>, E extends BasicEdge<N, E> & Edge<N>>
						implements Edge<N> {
				}
				
				public class BasicNode<E extends BasicEdge<N, E> & Edge<N>, N extends BasicNode<E, N> & Node<E>>
						implements Node<E> {
				}
				
				interface Edge<N extends Node<? extends Edge<N>>> {
				}
				
				interface Node<E extends Edge<? extends Node<E>>> {
				}
				""",
		},
	// javac options
	JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}

public void test0919() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				class Box<E> {
					private E element;
					void put(E elem) {
						this.element = elem;
					}
					E get() {
						return this.element;
					}
					Pair<E, E> asPair() {
						return new Pair<E, E>(this.element, this.element);
					}
					Box<Box<E>> nest() {
						Box<Box<E>> wrapper = new Box<Box<E>>();
						wrapper.put(this);
						return wrapper;
					}
				}
				
				class Pair<U, V> {
					Pair(U u, V v) {
					}
				}
				
				class PandoraBox<T extends Box<T>> extends Box<T> {
				}
				
				public class X {
					void test(PandoraBox<?> pbox) {
						Box<?> box = pbox.get();
						Pair<?,?> pair = pbox.asPair();
						Box<?> nbox = pbox.nest();
					}
				}
				""",
		},
		"");
}
public void test0920() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				class Stack<E> {
					private List<E> contents = new ArrayList<E>();
					void push(E e) {
						this.contents.add(e);
					}
					E pop() {
						int last = this.contents.size() - 1;
						if (last < 0) throw new EmptyStackException();
						return this.contents.remove(last);
					}
					private static <T> void doSwap(Stack<T> s) {
						T t1 = s.pop();
						T t2 = s.pop();
						s.push(t1);
						s.push(t2);
					}
					static void swap(Stack<?> s) { doSwap(s); }
				}
				public class X {
					public static void main(String[] args) {
						Stack<Integer> si = new Stack<Integer>();
						Integer[] ints = { 12, 13, 14, 15, };
						for (Integer i : ints) si.push(i);
						try {
							while(true) {
								System.out.print("["+si.pop()+"]");
							}
						} catch(EmptyStackException e) {
							System.out.println("[done]");
						}
					}
				}
				""",
		},
		"[15][14][13][12][done]");
}
// FIXME: javac8 rejects
public void test0921() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"Graph.java",
			"""
				class Node<N extends Node<N,E>, E extends Edge<N,E>> {
				}
				class Edge<N extends Node<N,E>, E extends Edge<N,E>> {
				}
				class Graph<N extends Node<N,E>, E extends Edge<N,E>>{
					N n;
					E e;
					private Graph(N n, E e) {
						this.n = n;
						this.e = e;
					}
					static <N extends Node<N,E>, E extends Edge<N,E>>
					Graph<N,E> copy(Graph<N,E> g) {
						return create(g.n,g.e);
					}
					static <N extends Node<N,E>, E extends Edge<N,E>>
					Graph<N,E> create(N n, E e) {
						return new Graph<N,E>(n,e);
					}
					Graph<?,?> builder() {
						Graph<?,?> g = null;
						return copy(g);
					}
				}
				""",
		},
	// javac options
	this.complianceLevel < ClassFileConstants.JDK1_8 ?
			(JavacTestOptions) JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 :
			JavacTestOptions.DEFAULT/* javac test options */);
}
// Test case which comes from JDT/UI tests TypeEnvironmentTest.testWildcardAssignements
public void test0922() {
	this.runNegativeTest(
		new String[] {
		"Test.java",
		"""
			import java.util.*;
			public class Test {
				List<List> list_raw_list;
				{
					Collection<? extends Collection<? extends Number>> col = list_raw_list;
				}
			}
			"""
		},
		"""
			----------
			1. WARNING in Test.java (at line 3)
				List<List> list_raw_list;
				     ^^^^
			List is a raw type. References to generic type List<E> should be parameterized
			----------
			2. ERROR in Test.java (at line 5)
				Collection<? extends Collection<? extends Number>> col = list_raw_list;
				                                                         ^^^^^^^^^^^^^
			Type mismatch: cannot convert from List<List> to Collection<? extends Collection<? extends Number>>
			----------
			"""
	);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=129129
public void test0923() {
	this.runNegativeTest(
		new String[] {
		"X.java",
		"""
			public class X<T> {
			
			  static void a(Class<? extends X<?>> c) {}
			
			  static void b(X<?> t) {
			    X.a(t.getClass());
			  }
			}
			"""
		},
		"""
			----------
			1. ERROR in X.java (at line 6)
				X.a(t.getClass());
				  ^
			The method a(Class<? extends X<?>>) in the type X is not applicable for the arguments (Class<capture#2-of ? extends X>)
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=129190
public void test0924() {
	runConformTest(
		// test directory preparation
		true /* flush output directory */,
		new String[] { /* test files */
			"ExtendedOuter.java",
			"""
				class Outer<O> {
					class Inner {
					}
				
					static void method(Outer<?>.Inner x) {
						System.out.println("SUCCESS");
					}
				}
				
				public class ExtendedOuter<E> extends Outer<E> {
					class ExtendedInner extends Inner {
						{
							Outer.method(this);
						}
					}
					public static void main(String[] args) {
						new ExtendedOuter<String>().new ExtendedInner();
					}
				}
				"""
		},
		// compiler results
		"" /* expected compiler log */,
		// runtime results
		"SUCCESS" /* expected output string */,
		"" /* expected error string */,
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}
public void test0925() {
	runConformTest(
		// test directory preparation
		true /* flush output directory */,
		new String[] { /* test files */
			"X.java",
			"""
				import java.util.*;
				
				public class X<A, B> {
					private List<A> toAdd;
				
					public X(List<A> toAdd) {
						this.toAdd = toAdd;
					}
				
					private List<A> getRelated(B b) {
						// some application logic
						// for demo
						return toAdd;
					}
				
					@SuppressWarnings("unchecked")
					public <L extends List<? super A>, LF extends Factory<L>> L addOrCreate4(
							B b, L l, LF lf) {
						if (l == null) {
							l = lf.create();
						}
						((List<? super A>) l).addAll(getRelated(b));\s
						l.addAll(getRelated(b));
						return l;
					}
				
					public static class ListFactory<T> implements Factory<List<T>> {
						public List<T> create() {
							return new ArrayList<T>();
						}
					}
				
					public static interface Factory<T> {
						public T create();
					}
				
					public static void main(String... args) {
						ListFactory<Number> lf = new ListFactory<Number>();
						List<Long> longs = new ArrayList<Long>();
						longs.add(new Long(1));
						X<Long, Number> test = new X<Long, Number>(longs);
						List<Number> ret4 = null;
						ret4 = test.addOrCreate4(1, ret4, lf);
						System.out.println("SUCCESS");
					}
				}
				"""
		},
		// compiler results
		null /* do not check compiler log */,
		// runtime results
		"SUCCESS" /* expected output string */,
		"" /* expected error string */,
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10_b24 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=129261
public void test0926() {
	String xSource =
			"""
		public class X {
			@SuppressWarnings("null")
			public void foo() {
				NonTerminalSourcePart<? extends Tuple<Boolean, Term>> RESULT = null;
				NonTerminalSourcePart<? extends Tuple<? extends Term, ? extends Formula>> t = null;
				RESULT = NonTerminalSourcePart.create(Tuple.create(true, t.value().fst()));
			}
		}
		
		class Term {
		}
		
		class Formula {
		}
		
		final class NonTerminalSourcePart<V> {
			static <V> NonTerminalSourcePart<V> create(final V _value) {
				return null;
			}
			final V value() {
				return null;
			}
		}
		
		class Tuple<A, B> {
			public static <A, B> Tuple<A, B> create(final A a, final B b) {
				return null;
			}
			public A fst() {
				return null;
			}
		}
		""";
	if (this.complianceLevel < ClassFileConstants.JDK1_8) {
		runNegativeTest(
			new String[] {
				"X.java",
				xSource
			},
			// compiler results
			"----------\n" + /* expected compiler log */
			"1. ERROR in X.java (at line 6)\n" +
			"	RESULT = NonTerminalSourcePart.create(Tuple.create(true, t.value().fst()));\n" +
			"	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Type mismatch: cannot convert from NonTerminalSourcePart<Tuple<Boolean,capture#3-of ? extends Term>> to NonTerminalSourcePart<? extends Tuple<Boolean,Term>>\n" +
			"----------\n",
			// javac options
			JavacTestOptions.JavacHasABug.JavacBug6557661 /* javac test options */);
	} else {
		runConformTest(
			new String[] {
				"X.java",
				xSource
			});
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=129261 - variation
public void test0927() {
	this.runNegativeTest(
		new String[] {
		"X.java",
		"""
			import java.util.*;
			@SuppressWarnings("null") public class X {
				public void foo() {
					List<? extends List<Object>> RESULT = null;
					List<? extends Object> lst = null;
					RESULT = Collections.singletonList(Collections.singletonList(lst.get(0)));
				}
				public void bar() {
					List<List<Object>> RESULT = null;
					List<? extends Object> lst = null;
					RESULT = Collections.singletonList(Collections.singletonList(lst.get(0)));
				}
				public void baz() {
					List<List<Object>> RESULT = null;
					List<?> lst = null;
					RESULT = Collections.singletonList(Collections.singletonList(lst.get(0)));
				}
				public void bar2(List<? extends Object> lst) {
					List<Object> RESULT = null;
					RESULT = lst;
					RESULT = Collections.singletonList(lst.get(0));
				}\t
				public static void main(String[] args) {
					List<String> ls = new ArrayList<String>();
					ls.add("str");
					new X().bar2(ls);
				}
			}
			""",
		},
		(this.complianceLevel < ClassFileConstants.JDK1_8 ?
		"""
			----------
			1. ERROR in X.java (at line 6)
				RESULT = Collections.singletonList(Collections.singletonList(lst.get(0)));
				         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from List<List<capture#2-of ? extends Object>> to List<? extends List<Object>>
			----------
			2. ERROR in X.java (at line 11)
				RESULT = Collections.singletonList(Collections.singletonList(lst.get(0)));
				         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from List<List<capture#3-of ? extends Object>> to List<List<Object>>
			----------
			3. ERROR in X.java (at line 16)
				RESULT = Collections.singletonList(Collections.singletonList(lst.get(0)));
				         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from List<List<capture#4-of ?>> to List<List<Object>>
			----------
			4. ERROR in X.java (at line 20)
				RESULT = lst;
				         ^^^
			Type mismatch: cannot convert from List<capture#5-of ? extends Object> to List<Object>
			----------
			5. ERROR in X.java (at line 21)
				RESULT = Collections.singletonList(lst.get(0));
				         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from List<capture#6-of ? extends Object> to List<Object>
			----------
			"""
		:
		"""
			----------
			1. ERROR in X.java (at line 20)
				RESULT = lst;
				         ^^^
			Type mismatch: cannot convert from List<capture#5-of ? extends Object> to List<Object>
			----------
			"""));
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=129261 - variation
public void test0928() {
	this.runNegativeTest(
		new String[] {
		"X.java",
		"""
			import java.util.*;
			public class X {
			    public static void main(String[] args) throws Throwable {
				List<?> x1 = new ArrayList<Integer>();
				List<?> x2 = new ArrayList<Integer>();
				x1.addAll(x2);
			    }
			}
			""",
		},
		"""
			----------
			1. ERROR in X.java (at line 6)
				x1.addAll(x2);
				   ^^^^^^
			The method addAll(Collection<? extends capture#1-of ?>) in the type List<capture#1-of ?> is not applicable for the arguments (List<capture#2-of ?>)
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=117119
// SHOULD FAIL AT 1.8 (18.2.3): The method allOf(Class<E>) in the type X is not applicable for the arguments (Class<capture#1-of ? extends Enum>)
public void test0929() {
	this.runNegativeTest(
		new String[] {
		"X.java",
		"""
			import java.util.Collection;
			
			public class X {
			 \s
			  public static <E extends Enum<E>> void fails () {
			    Class<? extends Enum> enumType = null;
			    final Collection<E> test = allOf(enumType);
			
			    Collection<? extends Enum> colType = null;
			    final Collection<E> test2 = colType;
			  }
			 \s
			  public static <E extends Enum<E>> Collection<E> allOf(final Class<E> enumType) {
			    return null;
			  }
			}
			""",
		},
		"""
			----------
			1. WARNING in X.java (at line 6)
				Class<? extends Enum> enumType = null;
				                ^^^^
			Enum is a raw type. References to generic type Enum<E> should be parameterized
			----------
			2. WARNING in X.java (at line 7)
				final Collection<E> test = allOf(enumType);
				                           ^^^^^^^^^^^^^^^
			Type safety: Unchecked invocation allOf(Class<capture#1-of ? extends Enum>) of the generic method allOf(Class<E>) of type X
			----------
			3. WARNING in X.java (at line 7)
				final Collection<E> test = allOf(enumType);
				                           ^^^^^^^^^^^^^^^
			Type safety: The expression of type Collection needs unchecked conversion to conform to Collection<E>
			----------
			4. WARNING in X.java (at line 9)
				Collection<? extends Enum> colType = null;
				                     ^^^^
			Enum is a raw type. References to generic type Enum<E> should be parameterized
			----------
			5. ERROR in X.java (at line 10)
				final Collection<E> test2 = colType;
				                            ^^^^^^^
			Type mismatch: cannot convert from Collection<capture#2-of ? extends Enum> to Collection<E>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=119238
public void test0930() {
	this.runNegativeTest(
		new String[] {
		"X.java",
		"""
			public class X<T> {
			        public static int I;
			        public void foo() {
			                X.I= 10;
			        }
					 {  Zork z; }
			}
			""",
		},
		"""
			----------
			1. ERROR in X.java (at line 6)
				{  Zork z; }
				   ^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=119238 - variation
public void test0931() {
	this.runNegativeTest(
		new String[] {
		"X.java",
		"""
			public class X<T> {
			        public static int I;
			        public void foo() {
			                X<T>.I= 10;
			        }
			}
			""",
		},
		"""
			----------
			1. ERROR in X.java (at line 4)
				X<T>.I= 10;
				     ^
			Syntax error on token "I", VariableDeclaratorId expected after this token
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=119238 - variation
public void _test0932() {
	this.runNegativeTest(
		new String[] {
		"X.java",
		"""
			public class X<T> {
			        public static int Method() { return 0; }
			        public void foo() {
			                X.Method();
			        }
			        public void bar() {
			                X<String>.Method();
			        }
			}
			""",
		},
		"""
			----------
			1. ERROR in X.java (at line 7)
				X<String>.Method();
				^^^^^^^^^^
			Syntax error on token(s), misplaced construct(s)
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=128063
public void test0933() {
	this.runNegativeTest(
		new String[] {
		"a/AbstractFoo.java", //================================
		"""
			package a;
			public abstract class AbstractFoo<T extends AbstractFoo<T>> {
				protected static class Inner<T extends AbstractFoo<T>> {
					public Inner() {
					}
			
					public final void doSmth() {
					}
				}
			}
			""",
		"b/CustomFoo.java", //================================
		"""
			package b;
			import a.AbstractFoo;
			public final class CustomFoo extends AbstractFoo<CustomFoo> {
				private Inner<DefaultFoo> defaultInner;
			
				Inner<DefaultFoo> getDefaultInner() {
					return (this.defaultInner == null)
							? this.defaultInner = new Inner<DefaultFoo>()
							: this.defaultInner;
				}\t
			
				private Inner<CustomFoo> customInner;
			
				Inner<CustomFoo> getCustomInner() {
					return (this.customInner == null)
							? this.customInner = new Inner<CustomFoo>()
							: this.customInner;
				}\t
			}
			""",
		"b/DefaultFoo.java", //================================
		"""
			package b;
			import a.AbstractFoo;
			public final class DefaultFoo extends AbstractFoo<DefaultFoo> {
				private Inner<DefaultFoo> defaultInner;
			
				Inner<DefaultFoo> getDefaultInner() {
					return (this.defaultInner == null)
							? this.defaultInner = new Inner<DefaultFoo>()
							: this.defaultInner;
				}\t
			
				private Inner<CustomFoo> customInner;
			
				Inner<CustomFoo> getCustomInner() {
					return (this.customInner == null)
							? this.customInner = new Inner<CustomFoo>()
							: this.customInner;
				}
			
				///////////////////////////////////////////////////////////////////////
				public void testCompilationFailure(final CustomFoo foo) {
					final DefaultFoo foo1 = this;
					final CustomFoo foo2 = foo;
			
					// These get compiled w/o error:
					foo1.getCustomInner().doSmth();
					foo1.getDefaultInner().doSmth();
			
					// These do not (Eclipse 3.2.0 M4):
					foo2.getCustomInner().doSmth();
					foo2.getDefaultInner().doSmth();
			
					// Expect error
					String s11 = foo1.getCustomInner();
					String s12 = foo2.getDefaultInner();
					String s21 = foo2.getCustomInner();
					String s22 = foo2.getDefaultInner();
			
					// However, if we split statements, everything's ok:\s
					final Inner<CustomFoo> customInner2 = foo2.getCustomInner();
					customInner2.doSmth();
			
					final Inner<DefaultFoo> defaultInner2 = foo2.getDefaultInner();
					defaultInner2.doSmth();
				}
			}
			""",
		},
		"""
			----------
			1. ERROR in b\\DefaultFoo.java (at line 34)
				String s11 = foo1.getCustomInner();
				             ^^^^^^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from AbstractFoo.Inner<CustomFoo> to String
			----------
			2. ERROR in b\\DefaultFoo.java (at line 35)
				String s12 = foo2.getDefaultInner();
				             ^^^^^^^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from AbstractFoo.Inner<DefaultFoo> to String
			----------
			3. ERROR in b\\DefaultFoo.java (at line 36)
				String s21 = foo2.getCustomInner();
				             ^^^^^^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from AbstractFoo.Inner<CustomFoo> to String
			----------
			4. ERROR in b\\DefaultFoo.java (at line 37)
				String s22 = foo2.getDefaultInner();
				             ^^^^^^^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from AbstractFoo.Inner<DefaultFoo> to String
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=128063 - variation
public void test0934() {
	this.runNegativeTest(
		new String[] {
		"X.java", //================================
		"""
			public class X<T> {
				static class Inner<U> {
					static class InInner <V> {
					}
				}
			}
			class Y<W> extends X<W> {
				void foo() {
					Inner<W> inner = null;
					String s = inner;
				}
			}
			""",
		},
		"""
			----------
			1. ERROR in X.java (at line 10)
				String s = inner;
				           ^^^^^
			Type mismatch: cannot convert from X.Inner<W> to String
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=128063 - variation
public void test0935() {
	this.runNegativeTest(
		new String[] {
		"X.java", //================================
		"""
			public class X<T> {
				static class Inner<U> {
					class InInner <V> {
					}
				}
			}
			class Y<W> extends X<W> {
				void foo() {
					Inner<W>.InInner<W> inner = null;
					String s = inner;
				}
			}
			""",
		},
		"""
			----------
			1. ERROR in X.java (at line 10)
				String s = inner;
				           ^^^^^
			Type mismatch: cannot convert from X.Inner<W>.InInner<W> to String
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=128063 - variation
public void test0936() {
	this.runNegativeTest(
		new String[] {
		"X.java", //================================
		"""
			public class X<T> {
				class Inner<U> {
					class InInner <V> {
					}
				}
			}
			class Y<W> extends X<W> {
				void foo() {
					Inner<W> inner = null;
					String s = inner;
				\t
					Inner<W>.InInner<W> inner2 = null;
					s = inner2;
			
				}
			}
			""",
		},
		"""
			----------
			1. ERROR in X.java (at line 10)
				String s = inner;
				           ^^^^^
			Type mismatch: cannot convert from X<W>.Inner<W> to String
			----------
			2. ERROR in X.java (at line 13)
				s = inner2;
				    ^^^^^^
			Type mismatch: cannot convert from X<W>.Inner<W>.InInner<W> to String
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=129190 - variation
public void test0937() {
	this.runNegativeTest(
		new String[] {
		"ExtendedOuter.java", //================================
		"""
			class Outer<O> {
			  class Inner {}
			
			  static void method(Outer.Inner x) {}
			}
			
			public class ExtendedOuter<E> extends Outer<E> {
			  class ExtendedInner extends Inner {
			    {
			      Outer.method(this);
			    }
			  }
			  void foo() {
			    Zork zk;
			  }
			}
			""",
		},
		"""
			----------
			1. WARNING in ExtendedOuter.java (at line 4)
				static void method(Outer.Inner x) {}
				                   ^^^^^^^^^^^
			Outer.Inner is a raw type. References to generic type Outer<O>.Inner should be parameterized
			----------
			2. ERROR in ExtendedOuter.java (at line 14)
				Zork zk;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=129190 - variation
public void test0938() {
	this.runNegativeTest(
		new String[] {
		"ExtendedOuter.java", //================================
		"""
			class Outer<O> {
			  class Inner {}
			
			  static void method(Outer<?>.Inner x) {}
			}
			
			public class ExtendedOuter<E> extends Outer<E> {
			  class ExtendedInner extends Inner {
			    {
			      Outer.method(this);
			    }
			  }
			  void foo() {
			    Zork zk;
			  }
			}
			""",
		},
		"""
			----------
			1. ERROR in ExtendedOuter.java (at line 14)
				Zork zk;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=129190 - variation
public void test0939() {
	this.runNegativeTest(
		new String[] {
		"ExtendedOuter.java", //================================
		"""
			class Outer<O> {
			  class Inner {}
			
			  static <I> void method(Outer<I>.Inner x) {}
			}
			
			public class ExtendedOuter<E> extends Outer<E> {
			  class ExtendedInner extends Inner {
			    {
			      Outer.method(this);
			    }
			  }
			  void foo() {
			    Zork zk;
			  }
			}
			""",
		},
		"""
			----------
			1. ERROR in ExtendedOuter.java (at line 14)
				Zork zk;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=129190 - variation
// force check that I is inferred to E, not Object
public void test0939b() {
	this.runNegativeTest(
		new String[] {
		"ExtendedOuter.java", //================================
		"""
			class Outer<O> {
			  class Inner {}
			
			  static <I> I method(Outer<I>.Inner x) { return null; }
			}
			
			public class ExtendedOuter<E extends A> extends Outer<E> {
			  class ExtendedInner extends Inner {
			    {
			      Outer.method(this).bar();
			    }
			  }
			  void foo() {
			    Zork zk;
			  }
			}
			class A { void bar() {} }
			""",
		},
		"""
			----------
			1. ERROR in ExtendedOuter.java (at line 14)
				Zork zk;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=129261 - variation
public void test0940() {
	this.runNegativeTest(
		new String[] {
		"X.java", //================================
		"""
			import java.util.*;
			public class X {
			        <U extends Object> void bar3(List<U> lst) {
			            List<Object> RESULT = null;
			            RESULT = lst; // 1
			            RESULT = Collections.singletonList(lst.get(0)); // 2
			    }             \s
			}
			""",
		},
		"----------\n" +
		"1. ERROR in X.java (at line 5)\n" +
		"	RESULT = lst; // 1\n" +
		"	         ^^^\n" +
		"Type mismatch: cannot convert from List<U> to List<Object>\n" +
		"----------\n" +
		(this.complianceLevel < ClassFileConstants.JDK1_8 ?
		"2. ERROR in X.java (at line 6)\n" +
		"	RESULT = Collections.singletonList(lst.get(0)); // 2\n" +
		"	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
		"Type mismatch: cannot convert from List<U> to List<Object>\n" +
		"----------\n"
		:
		""));
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=129261 - variation
public void test0941() {
	String xSource =
		"""
		import java.util.*;
		
		public class X {
			<T> Map<T,T> foo(T t1, T t2) {
				return null;
			}
			<U extends Object, V extends U> void bar(U u, V v) {
				Map<Object,Object> map1 = foo(u, v);
				Map<U,U> map2 = foo(u, v);
			}\t
		}
		""";
	if (this.complianceLevel < ClassFileConstants.JDK1_8) {
		this.runNegativeTest(
			new String[] {
			"X.java",
			xSource,
			},
			"""
				----------
				1. ERROR in X.java (at line 8)
					Map<Object,Object> map1 = foo(u, v);
					                          ^^^^^^^^^
				Type mismatch: cannot convert from Map<U,U> to Map<Object,Object>
				----------
				""");
	} else {
		runConformTest(new String[] { "X.java", xSource });
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=129261 - variation
public void test0942() {
	String xSource =
		"""
		import java.util.*;
		
		public class X {
			<T> Map<T,T> foo(T t1, T t2, T t3) {
				return null;
			}
			<U extends Object, V extends U> void bar(U u, V v) {
				Map<Object,Object> map1 = foo(u, v, null);
				Map<U,U> map2 = foo(u, v, null);
			}\t
		}
		""";
	if (this.complianceLevel < ClassFileConstants.JDK1_8) {
		this.runNegativeTest(
			new String[] {
				"X.java",
				xSource,
			},
			"""
				----------
				1. ERROR in X.java (at line 8)
					Map<Object,Object> map1 = foo(u, v, null);
					                          ^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Map<U,U> to Map<Object,Object>
				----------
				""");
	} else {
		runConformTest(new String[] { "X.java", xSource });
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=129261 - variation
public void test0943() {
	String xSource =
		"""
		import java.util.*;
		
		public class X {
			<T> Map<T,T> foo(T t1, T t2, T t3) {
				return null;
			}
			<U extends Object, V extends U> void bar(U u, V v, List<? extends V> lv) {
				Map<Object,Object> map1 = foo(u, v, lv.get(0));
				Map<U,U> map2 = foo(u, v, lv.get(0));
			}
		}
		""";
	if (this.complianceLevel < ClassFileConstants.JDK1_8) {
		this.runNegativeTest(
			new String[] {
			"X.java",
			xSource,
			},
			"""
				----------
				1. ERROR in X.java (at line 8)
					Map<Object,Object> map1 = foo(u, v, lv.get(0));
					                          ^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Map<U,U> to Map<Object,Object>
				----------
				""");
	} else {
		runConformTest(new String[] { "X.java", xSource });
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=129996
public void test0944() {
	this.runNegativeTest(
		new String[] {
		"X.java", //================================
		"""
			import java.util.*;
			public class X {
				public static <A> Set<A> method(List<? super A> list) {
					return new HashSet<A>();
				}
				public static void main(String[] args) {
					ArrayList<Number> l = new ArrayList<Number>();
					Set<Integer> s1 = method(l);
					Set<Integer> s2 = (Set<Integer>) method(l);
				}
			}
			""",
		},
		"""
			----------
			1. ERROR in X.java (at line 9)
				Set<Integer> s2 = (Set<Integer>) method(l);
				                  ^^^^^^^^^^^^^^^^^^^^^^^^
			Cannot cast from Set<Number> to Set<Integer>
			----------
			""");
}
public void test0945() {
	this.runNegativeTest(
		new String[] {
		"X.java", //================================
		"""
			import java.util.*;
			
			public class X {
			    public static void main(String[] args){
			        Object[] objArray = {new Object()};
			        ArrayList<String> strList = new ArrayList<String>();
			        transferBug(objArray, strList);
			        String str = strList.get(0);
			}
			public static <Var> void  transferBug(Var[] src, Collection<Var> dest){
			    dest.add(src[0]);
			}
			}
			""",
		},
		"""
			----------
			1. ERROR in X.java (at line 7)
				transferBug(objArray, strList);
				^^^^^^^^^^^
			The method transferBug(Var[], Collection<Var>) in the type X is not applicable for the arguments (Object[], ArrayList<String>)
			----------
			""");
}
public void test0946() {
	runConformTest(
		// test directory preparation
		true /* flush output directory */,
		new String[] { /* test files */
			"X.java", //================================
			"""
				public class X {
					public static void main(String[] args) {
						operate(Operations.create());
					}
					static <O extends Num<O>> void operate(Operators<O> operators) {
						System.out.println(operators.spawn());
					}
				}
				class Operations {
					static Operators<?> create() {
						return new IntOperators();
					}
				}
				interface Num<O> {
					public O spawn();
				}
				class Int implements Num<Int> {
					public Int spawn() {
						return new Int();
					}
				  public String toString() {
				    return "Int";
				  }
				}
				interface Operators<O extends Num<O>> {
					O spawn();
				}
				class IntOperators implements Operators<Int> {
					public Int spawn() {
						return new Int();
					}
				}
				""",
		},
		// compiler results
		null /* do not check compiler log */,
		// runtime results
		"Int" /* expected output string */,
		"" /* expected error string */,
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=129261 - variation
public void test0947() {
	String xSource =
		"""
		public class X {
		        public void bar2(Box<?> b) {
		        	Box<Runnable> bx = box(b.element);
		        	box(b.element).element.run();
		        }
		        static <U extends Runnable> Box<U> box(U u) {
		        	return new Box<U>(u);
		        }
		}
		class Box<E extends Runnable> {
			E element;
			Box(E element) {
				this.element = element;
			}
		}
		""";
	if (this.complianceLevel < ClassFileConstants.JDK1_8) {
		this.runNegativeTest(
			new String[] {
			"X.java",
			xSource,
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					Box<Runnable> bx = box(b.element);
					                   ^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Box<capture#1-of ?> to Box<Runnable>
				----------
				""",
			JavacTestOptions.EclipseHasABug.EclipseBug236236);
	} else {
		runConformTest(new String[]{ "X.java", xSource });
	}

}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=129261 - variation
public void test0948() {
	this.runConformTest(
		new String[] {
		"X.java", //================================
		"""
			import java.util.*;
			public class X {
			        public void bar2(Box<?> b1, Box<Runnable> b2) {
			        	Pair<Runnable,Runnable> blist = pair(b1.element, b2.element);
			        }
			        static <U> Pair<U,U> pair(U u1, U u2) {
			        	return new Pair<U,U>(u1,u2);
			        }
			}
			class Pair<E,F> {
				Pair(E e, F f){}
			}
			class Box<E extends Runnable> {
				E element;
				Box(E element) {
					this.element = element;
				}
			}
			""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=128418
public void test0949() {
	this.runNegativeTest(
		new String[] {
		"X.java", //================================
		"""
			import java.util.Arrays;
			
			public class X {
				public <T> Iterable<T> m(T... ts) {
					return Arrays.asList(ts);
				}
				public <T> void m3(Iterable<T>... ts) {
				}
				public void m2() {
					m3(m(3, 3, 3));
					m3(m());
					m3(m(new Object[]{}));
					Zork z;
				}
			}
			""",
		},
		this.complianceLevel < ClassFileConstants.JDK1_7 ?
		"""
			----------
			1. WARNING in X.java (at line 10)
				m3(m(3, 3, 3));
				^^^^^^^^^^^^^^
			Type safety: A generic array of Iterable<Integer> is created for a varargs parameter
			----------
			2. WARNING in X.java (at line 11)
				m3(m());
				^^^^^^^
			Type safety: A generic array of Iterable<Object> is created for a varargs parameter
			----------
			3. WARNING in X.java (at line 12)
				m3(m(new Object[]{}));
				^^^^^^^^^^^^^^^^^^^^^
			Type safety: A generic array of Iterable<Object> is created for a varargs parameter
			----------
			4. ERROR in X.java (at line 13)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""" :
			"""
				----------
				1. WARNING in X.java (at line 4)
					public <T> Iterable<T> m(T... ts) {
					                              ^^
				Type safety: Potential heap pollution via varargs parameter ts
				----------
				2. WARNING in X.java (at line 7)
					public <T> void m3(Iterable<T>... ts) {
					                                  ^^
				Type safety: Potential heap pollution via varargs parameter ts
				----------
				3. WARNING in X.java (at line 10)
					m3(m(3, 3, 3));
					^^^^^^^^^^^^^^
				Type safety: A generic array of Iterable<Integer> is created for a varargs parameter
				----------
				4. WARNING in X.java (at line 11)
					m3(m());
					^^^^^^^
				Type safety: A generic array of Iterable<Object> is created for a varargs parameter
				----------
				5. WARNING in X.java (at line 12)
					m3(m(new Object[]{}));
					^^^^^^^^^^^^^^^^^^^^^
				Type safety: A generic array of Iterable<Object> is created for a varargs parameter
				----------
				6. ERROR in X.java (at line 13)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=128418 - variation
public void test0950() {
	this.runNegativeTest(
		new String[] {
		"X.java", //================================
		"""
			import java.util.Arrays;
			
			public class X {
				public <T> Iterable<T> m(T[]... ts) {
					return Arrays.asList(ts[0]);
				}
				public <T> void m3(Iterable<T>... ts) {
				}
				public void m2() {
					m3(m(new Integer[]{3, 3, 3}));
					m3(m());
					m3(m(new Object[][]{}));
					Zork z;
				}
			}
			""",
		},
		this.complianceLevel < ClassFileConstants.JDK1_7 ?
		"""
			----------
			1. WARNING in X.java (at line 10)
				m3(m(new Integer[]{3, 3, 3}));
				^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: A generic array of Iterable<Object> is created for a varargs parameter
			----------
			2. WARNING in X.java (at line 11)
				m3(m());
				^^^^^^^
			Type safety: A generic array of Iterable<Object> is created for a varargs parameter
			----------
			3. WARNING in X.java (at line 12)
				m3(m(new Object[][]{}));
				^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: A generic array of Iterable<Object> is created for a varargs parameter
			----------
			4. ERROR in X.java (at line 13)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""" :
			"----------\n" +
			"1. WARNING in X.java (at line 4)\n" +
			"	public <T> Iterable<T> m(T[]... ts) {\n" +
			"	                                ^^\n" +
			"Type safety: Potential heap pollution via varargs parameter ts\n" +
			"----------\n" +
			"2. WARNING in X.java (at line 7)\n" +
			"	public <T> void m3(Iterable<T>... ts) {\n" +
			"	                                  ^^\n" +
			"Type safety: Potential heap pollution via varargs parameter ts\n" +
			"----------\n" +
			"3. WARNING in X.java (at line 10)\n" +
			"	m3(m(new Integer[]{3, 3, 3}));\n" +
			"	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			(this.complianceLevel == ClassFileConstants.JDK1_7?
			"Type safety: A generic array of Iterable<Object> is created for a varargs parameter\n"
			:
			"Type safety: A generic array of Iterable<Integer> is created for a varargs parameter\n"
			) +
			"----------\n" +
			"4. WARNING in X.java (at line 11)\n" +
			"	m3(m());\n" +
			"	^^^^^^^\n" +
			"Type safety: A generic array of Iterable<Object> is created for a varargs parameter\n" +
			"----------\n" +
			"5. WARNING in X.java (at line 12)\n" +
			"	m3(m(new Object[][]{}));\n" +
			"	^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Type safety: A generic array of Iterable<Object> is created for a varargs parameter\n" +
			"----------\n" +
			"6. ERROR in X.java (at line 13)\n" +
			"	Zork z;\n" +
			"	^^^^\n" +
			"Zork cannot be resolved to a type\n" +
			"----------\n");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=128418 - variation
public void test0951() {
	this.runNegativeTest(
		new String[] {
		"X.java", //================================
		"""
			import java.util.Arrays;
			
			public class X {
				public <T> Iterable<T> m(T[]... ts) {
					return Arrays.asList(ts[0]);
				}
				public <T> void m3(Iterable<T>... ts) {
				}
				@SuppressWarnings("unchecked")
				public void m2() {
					m3(m(new Integer[]{3, 3, 3}));
					m3(m());
					m3(m(new Object[][]{}));
					Zork z;
				}
			}
			""",
		},
		this.complianceLevel < ClassFileConstants.JDK1_7 ?
		"""
			----------
			1. ERROR in X.java (at line 14)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""" :
			"""
				----------
				1. WARNING in X.java (at line 4)
					public <T> Iterable<T> m(T[]... ts) {
					                                ^^
				Type safety: Potential heap pollution via varargs parameter ts
				----------
				2. WARNING in X.java (at line 7)
					public <T> void m3(Iterable<T>... ts) {
					                                  ^^
				Type safety: Potential heap pollution via varargs parameter ts
				----------
				3. ERROR in X.java (at line 14)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=128418 - variation
public void test0952() {
	this.runNegativeTest(
		new String[] {
		"X.java", //================================
		"""
			public class X {
				public <T> Iterable<T> m(T... ts) {
					return null;
				}
				public <T> void m3(Iterable<T>... ts) {
				}
				public void m2() {
					m3(m(null));
					Zork z;
				}
			}
			""",
		},
		this.complianceLevel < ClassFileConstants.JDK1_7 ?
		"""
			----------
			1. WARNING in X.java (at line 8)
				m3(m(null));
				^^^^^^^^^^^
			Type safety: A generic array of Iterable<Object> is created for a varargs parameter
			----------
			2. WARNING in X.java (at line 8)
				m3(m(null));
				   ^^^^^^^
			Type null of the last argument to method m(Object...) doesn't exactly match the vararg parameter type. Cast to Object[] to confirm the non-varargs invocation, or pass individual arguments of type Object for a varargs invocation.
			----------
			3. ERROR in X.java (at line 9)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""" :
			"""
				----------
				1. WARNING in X.java (at line 2)
					public <T> Iterable<T> m(T... ts) {
					                              ^^
				Type safety: Potential heap pollution via varargs parameter ts
				----------
				2. WARNING in X.java (at line 5)
					public <T> void m3(Iterable<T>... ts) {
					                                  ^^
				Type safety: Potential heap pollution via varargs parameter ts
				----------
				3. WARNING in X.java (at line 8)
					m3(m(null));
					^^^^^^^^^^^
				Type safety: A generic array of Iterable<Object> is created for a varargs parameter
				----------
				4. WARNING in X.java (at line 8)
					m3(m(null));
					   ^^^^^^^
				Type null of the last argument to method m(Object...) doesn't exactly match the vararg parameter type. Cast to Object[] to confirm the non-varargs invocation, or pass individual arguments of type Object for a varargs invocation.
				----------
				5. ERROR in X.java (at line 9)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=106325
public void test0953() {
	if (this.complianceLevel >= ClassFileConstants.JDK1_7) return;
	this.runNegativeTest(
		new String[] {
		"X.java", //================================
		"""
			import java.lang.ref.WeakReference;
			import java.util.Arrays;
			import java.util.List;
			
			public class X {
			  void m(WeakReference<Integer> ref) {
			    List<WeakReference<Integer>> list= Arrays.asList(ref);
			    Zork z;
			  }
			}
			""",
		},
		"""
			----------
			1. WARNING in X.java (at line 7)
				List<WeakReference<Integer>> list= Arrays.asList(ref);
				                                   ^^^^^^^^^^^^^^^^^^
			Type safety: A generic array of WeakReference<Integer> is created for a varargs parameter
			----------
			2. ERROR in X.java (at line 8)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130543
public void test0954() {
	this.runNegativeTest(
		new String[] {
		"X.java", //================================
		"""
			import java.util.*;
			
			public class X<A,B> {
				class Member<C,D> {}
				static class SMember<U,V> {}
				void foo1() {
					X<?,?>[] xs = new X<?,?>[]{};//1
					for(X<?,?> x : xs) {
						System.out.println(x);
					}
				}
				void bar1() {
					Member<?,?>[] members = new Member<?,?>[]{};//2
					for(Member<?,?> m : members) {
						System.out.println(m);
					}
				}
				void bas1() {
					SMember<?,?>[] members = new SMember<?,?>[]{};//3
					for(SMember<?,?> m : members) {
						System.out.println(m);
					}
				}
				void baz1() {
					class Local<E,F>{}
					Local<?,?>[] locals = new Local<?,?>[]{};//4
					for(Local<?,?> l : locals) {
						System.out.println(l);
					}
				}
				void foo2() {
					X<?,?>[] xs = new X<?,?>[5];//5
					for(X<?,?> x : xs) {
						System.out.println(x);
					}
				}
				void bar2() {
					Member<?,?>[] members = new Member<?,?>[5];//6
					for(Member<?,?> m : members) {
						System.out.println(m);
					}
				}
				void bas2() {
					SMember<?,?>[] members = new SMember<?,?>[5];//7
					for(SMember<?,?> m : members) {
						System.out.println(m);
					}
				}
				void baz2() {
					class Local<E,F>{}
					Local<?,?>[] locals = new Local<?,?>[5];//8
					for(Local<?,?> l : locals) {
						System.out.println(l);
					}
				}
				void foo3() {
					X<?,?>[] xs = new X<?,?>[5];//9
					for(X<?,?> x : xs) {
						System.out.println(x);
					}
				}
				void bar3() {
					X<?,?>.Member<?,?>[] members = new X<?,?>.Member<?,?>[5];//10
					for(X<?,?>.Member<?,?> m : members) {
						System.out.println(m);
					}
				}
				static void baz3() {
					class Local<E,F>{}
					Local<?,?>[] locals = new Local<?,?>[5];//11
					for(Local<?,?> l : locals) {
						System.out.println(l);
					}
				}
			}
			""",
		},
		"""
			----------
			1. ERROR in X.java (at line 13)
				Member<?,?>[] members = new Member<?,?>[]{};//2
				                                         ^^
			Cannot create a generic array of X<A,B>.Member<?,?>
			----------
			2. ERROR in X.java (at line 26)
				Local<?,?>[] locals = new Local<?,?>[]{};//4
				                                      ^^
			Cannot create a generic array of Local<?,?>
			----------
			3. ERROR in X.java (at line 38)
				Member<?,?>[] members = new Member<?,?>[5];//6
				                        ^^^^^^^^^^^^^^^^^^
			Cannot create a generic array of X<A,B>.Member<?,?>
			----------
			4. ERROR in X.java (at line 51)
				Local<?,?>[] locals = new Local<?,?>[5];//8
				                      ^^^^^^^^^^^^^^^^^
			Cannot create a generic array of Local<?,?>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=105049
public void test0955() {
	String errorlog = this.complianceLevel >= ClassFileConstants.JDK16 ?
			"	    ^\n" +
			"Type Object cannot be safely cast to List<E>[]\n"
				:
				"	    ^^^^^^^^^^^^^^^^^^^^^^\n" +
				"Cannot perform instanceof check against parameterized type List<E>[]. Use the form List<?>[] instead since further generic type information will be erased at runtime\n";
	this.runNegativeTest(
		new String[] {
		"X.java", //================================
		"""
			import java.util.List;
			public class X<E> {
			    void method(Object o) {
			        if (o instanceof List<E>[]) { //incorrect: bug 104695
			            List<E>[] es= (List<E>[]) o; //unchecked
			        }
			    }
			}
			""",
		},
		"----------\n" +
		"1. ERROR in X.java (at line 4)\n" +
		"	if (o instanceof List<E>[]) { //incorrect: bug 104695\n" +
		errorlog +
		"----------\n" +
		"2. WARNING in X.java (at line 5)\n" +
		"	List<E>[] es= (List<E>[]) o; //unchecked\n" +
		"	              ^^^^^^^^^^^^^\n" +
		"Type safety: Unchecked cast from Object to List<E>[]\n" +
		"----------\n");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=130128
public void test0956() {
	this.runConformTest(
		new String[] {
		"X.java", //================================
		"""
			public class X<F> {
			
			    public void printNickname(Person<F> person) {
			        Person<F>.Nickname nickname = person.getNickname();
			        System.out.println(nickname);
			    }
			
			    static class Person<E> {
			        private Nickname nickname;
			
			        public Nickname getNickname() {
			            return nickname;
			        }
			
			        public void setNickname(Nickname nickname) {
			            this.nickname = nickname;
			        }
			
			        class Nickname {
			            private String name;
			            private boolean insulting;
			        }
			    }
			}
			""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=132348
public void test0957() {
	this.runNegativeTest(
		new String[] {
		"AnyInterface.java", //================================
		"""
			public interface AnyInterface {
			        public void doSomething();
			}""",
		"UsingGenericsClass",
		"""
			public class UsingGenericsClass<A,B extends A & AnyInterface> {
			        public UsingGenericsClass(){
			        }
			}"""
		},
		"""
			----------
			1. ERROR in UsingGenericsClass (at line 1)
				public class UsingGenericsClass<A,B extends A & AnyInterface> {
				                                                ^^^^^^^^^^^^
			Cannot specify any additional bound AnyInterface when first bound is a type parameter
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=131935
public void test0958() {
	this.runNegativeTest(
		new String[] {
		"X.java", //================================
		"""
			import java.lang.ref.ReferenceQueue;
			import java.lang.ref.SoftReference;
			import java.util.Hashtable;
			
			public class X {
				private static final Hashtable<Integer, Soft> cache = new Hashtable<Integer, Soft>();
			
				private static final ReferenceQueue<String> trash = new ReferenceQueue<String>();
			
				private static final class Soft extends SoftReference<String> {
					int key;
			
					Soft() {
						super(null);
					}
				}
			
				final Thread clean = new Thread("BigTableModel cleaner") {
					@Override
					public void run() {
						for (;;)
							try {
								cache.remove(((Soft) trash.remove()).key);
							} catch (final InterruptedException e) {
								return;
							}
							Zork z;
					}
				};
			}
			"""
		},
		"""
			----------
			1. ERROR in X.java (at line 27)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=133803
public void test0959() {
	this.runNegativeTest(
		new String[] {
			"X.java", //================================
			"""
				import java.lang.ref.*;
				
				class Soft extends SoftReference<String> {
				    Soft() { super(null); }
				}
				
				class Bug {
				    void m(Reference<? extends Number> remove) {
				        Soft soft= (Soft) remove;
				    }
				}
				"""
		},
		"""
			----------
			1. ERROR in X.java (at line 9)
				Soft soft= (Soft) remove;
				           ^^^^^^^^^^^^^
			Cannot cast from Reference<capture#1-of ? extends Number> to Soft
			----------
			""");
}

//https://bugs.eclipse.org/bugs/show_bug.cgi?id=118273
// SHOULD FAIL AT 1.8 (RET): Type mismatch: cannot convert from X<Comparable<Comparable<T>>> to X
public void test0960() {
	this.runNegativeTest(
		new String[] {
			"X.java", //================================
			"""
				public class X<A> {
				        <B extends Comparable<B>> X<B> newInstance() {
				                return new X<B>();
				        }
				
				        X<String>[] bugDemo() {
				                X x = newInstance();
				                return new X[] { x };
				        }
				    Zork z;
				}
				"""
		},
		"""
			----------
			1. WARNING in X.java (at line 7)
				X x = newInstance();
				^
			X is a raw type. References to generic type X<A> should be parameterized
			----------
			2. WARNING in X.java (at line 8)
				return new X[] { x };
				       ^^^^^^^^^^^^^
			Type safety: The expression of type X[] needs unchecked conversion to conform to X<String>[]
			----------
			3. ERROR in X.java (at line 10)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=118273 - variation
public void test0961() {
	this.runNegativeTest(
		new String[] {
			"X.java", //================================
			"""
				public class X<A> {
				    <B extends Comparable<B>> B newInstance2(X<B> xb) {
				            return null;
				    }
				    void foo() {
				        X x = new X();
				        Comparable c = newInstance2(x);
				    }
				    Zork z;
				}
				"""
		},
		"----------\n" +
		"1. WARNING in X.java (at line 6)\n" +
		"	X x = new X();\n" +
		"	^\n" +
		"X is a raw type. References to generic type X<A> should be parameterized\n" +
		"----------\n" +
		"2. WARNING in X.java (at line 6)\n" +
		"	X x = new X();\n" +
		"	          ^\n" +
		"X is a raw type. References to generic type X<A> should be parameterized\n" +
		"----------\n" +
		"3. WARNING in X.java (at line 7)\n" +
		"	Comparable c = newInstance2(x);\n" +
		"	^^^^^^^^^^\n" +
		"Comparable is a raw type. References to generic type Comparable<T> should be parameterized\n" +
		"----------\n" +
		"4. WARNING in X.java (at line 7)\n" +
		"	Comparable c = newInstance2(x);\n" +
		"	               ^^^^^^^^^^^^^^^\n" +
		"Type safety: Unchecked invocation newInstance2(X) of the generic method newInstance2(X<B>) of type X<A>\n" +
		"----------\n" +
		"5. WARNING in X.java (at line 7)\n" +
		"	Comparable c = newInstance2(x);\n" +
		"	                            ^\n" +
		(this.complianceLevel < ClassFileConstants.JDK1_8
		? "Type safety: The expression of type X needs unchecked conversion to conform to X<Comparable>\n"
		: "Type safety: The expression of type X needs unchecked conversion to conform to X<Comparable<Comparable<B>>>\n") +
		"----------\n" +
		"6. ERROR in X.java (at line 9)\n" +
		"	Zork z;\n" +
		"	^^^^\n" +
		"Zork cannot be resolved to a type\n" +
		"----------\n");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=134645
public void test0962() {
	runNegativeTest(
		new String[] {
			"X.java", //================================
			"""
				public class X<T> {
				    public void bug() throws Exception {
				        throw new Exception("Bug134645") {
				            @Override
				            public String toString() {
				                return "Bug134645";
				            }
				        };
				    }
				}
				"""
		},
		// compiler results
		"----------\n" + /* expected compiler log */
		"1. ERROR in X.java (at line 3)\n" +
		"	throw new Exception(\"Bug134645\") {\n" +
		"	          ^^^^^^^^^\n" +
		"The generic class new Exception(){} may not subclass java.lang.Throwable\n" +
		"----------\n" +
		"2. WARNING in X.java (at line 3)\n" +
		"	throw new Exception(\"Bug134645\") {\n" +
		"	          ^^^^^^^^^^^^^^^^^^^^^^\n" +
		"The serializable class  does not declare a static final serialVersionUID field of type long\n" +
		"----------\n",
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=134645 - variation
public void test0963() {
	this.runConformTest(
		new String[] {
			"X.java", //================================
			"""
				public class X {
				    public void bug() throws Exception {
				        throw new Exception("Bug134645") {
				            @Override
				            public String toString() {
				                return "Bug134645";
				            }
				        };
				    }
				}
				"""
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=134645 - variation
public void test0964() {
	this.runConformTest(
		new String[] {
			"X.java", //================================
			"""
				public class X<T> {
				    public static void bug() throws Exception {
				        throw new Exception("Bug134645") {
				            @Override
				            public String toString() {
				                return "Bug134645";
				            }
				        };
				    }
				}
				"""
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=97494
public void test0965() {
	this.runNegativeTest(
		new String[] {
			"X.java", //================================
			"""
				public class X<T> {
				  protected static final Class<X<?>> theClass = (Class<X<?>>) X.class;
				  void foo(Class<X> cx) {
					  Class<X<?>> cx1 = cx;
					  Class<X<?>> cx2 = (Class<X<?>>) cx;
				  }
				}
				"""
		},
		"""
			----------
			1. ERROR in X.java (at line 2)
				protected static final Class<X<?>> theClass = (Class<X<?>>) X.class;
				                                              ^^^^^^^^^^^^^^^^^^^^^
			Cannot cast from Class<X> to Class<X<?>>
			----------
			2. WARNING in X.java (at line 3)
				void foo(Class<X> cx) {
				               ^
			X is a raw type. References to generic type X<T> should be parameterized
			----------
			3. ERROR in X.java (at line 4)
				Class<X<?>> cx1 = cx;
				                  ^^
			Type mismatch: cannot convert from Class<X> to Class<X<?>>
			----------
			4. ERROR in X.java (at line 5)
				Class<X<?>> cx2 = (Class<X<?>>) cx;
				                  ^^^^^^^^^^^^^^^^
			Cannot cast from Class<X> to Class<X<?>>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=115918
public void test0966() {
	this.runConformTest(
		new String[] {
			"Child.java", //================================
			"""
				public class Child extends Parent implements Comparable<Child> {
				  public int compareTo(Child o) { return 0; }
				}
				class Parent extends Base<Child> {}
				class Base<T extends Base> {}
				"""
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=81949
public void test0967() {
	this.runConformTest(
		new String[] {
			"CSS.java", //================================
			"""
				interface Ac<S extends St<S,A>,A extends Ac<S,A>> {}
				interface St<S extends St<S,A>,A extends Ac<S,A>> {}
				class CSN<X, Y> extends CSS<X, Y> implements Ac<CSS<X, Y>, CSN<X, Y>> {}
				public class CSS<X, Y> implements St<CSS<X, Y>, CSN<X, Y>> {}
				"""
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=108045
public void test0968() {
	this.runNegativeTest(
		new String[] {
			"X.java", //================================
			"""
				import java.util.*;
				public class X<T0> extends ArrayList<T0> implements I<T0> {
				}
				interface I<T1> extends Collection {
				}
				"""
		},
		"""
			----------
			1. ERROR in X.java (at line 2)
				public class X<T0> extends ArrayList<T0> implements I<T0> {
				             ^
			The interface Collection cannot be implemented more than once with different arguments: Collection<T0> and Collection
			----------
			2. WARNING in X.java (at line 2)
				public class X<T0> extends ArrayList<T0> implements I<T0> {
				             ^
			The serializable class X does not declare a static final serialVersionUID field of type long
			----------
			3. WARNING in X.java (at line 4)
				interface I<T1> extends Collection {
				                        ^^^^^^^^^^
			Collection is a raw type. References to generic type Collection<E> should be parameterized
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=133071
public void test0969() {
	this.runConformTest(
			new String[] {
				"B.java", //================================
				"""
					class B<T extends C> extends A<T> {}
					class C extends B<C> {}
					class A<T extends C> {}"""
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=136946
public void test0970() {
	this.runNegativeTest(
			new String[] {
				"X.java", //================================
				"""
					public interface X<T> {\s
					        interface I1<T> extends X<T> {
					                interface I2<T> extends I1<T> {
					                }
					
					                interface I3<T> extends I1<T> {
					                }
					
					                interface I4<T> extends I1.I2<T>, I1.I3<T> {   \s
					                }
					        }
					}
					class XSub<E> implements X<E> {
					    I1<E> i1 = null;
					    I1.I2<E> i2 = null;
					    I1<E>.I2<E> i1i2 = null;
					}
					"""
			},
			"""
				----------
				1. ERROR in X.java (at line 16)
					I1<E>.I2<E> i1i2 = null;
					^^^^^^^^
				The member type X.I1.I2<T> cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X.I1<E>
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=136946 - variation
public void test0971() {
	this.runNegativeTest(
			new String[] {
				"X.java", //================================
				"""
					public interface X<T> {\s
					        interface I1<T> extends X {
					                interface I2<T> extends I1 {
					                }
					
					                interface I3<T> extends I1 {
					                }
					
					                interface I4<T> extends I1.I2, I1.I3 {   \s
					                }
					        }
					}
					class XSub<E> implements X<E> {
					    I1 i1 = null;
					    I1.I2 i2 = null;
					    I1<E>.I2 i1i2 = null;
					}
					"""
			},
			"""
				----------
				1. WARNING in X.java (at line 2)
					interface I1<T> extends X {
					                        ^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				2. WARNING in X.java (at line 3)
					interface I2<T> extends I1 {
					                        ^^
				X.I1 is a raw type. References to generic type X.I1<T> should be parameterized
				----------
				3. WARNING in X.java (at line 6)
					interface I3<T> extends I1 {
					                        ^^
				X.I1 is a raw type. References to generic type X.I1<T> should be parameterized
				----------
				4. WARNING in X.java (at line 9)
					interface I4<T> extends I1.I2, I1.I3 {   \s
					                        ^^^^^
				X.I1.I2 is a raw type. References to generic type X.I1.I2<T> should be parameterized
				----------
				5. WARNING in X.java (at line 9)
					interface I4<T> extends I1.I2, I1.I3 {   \s
					                               ^^^^^
				X.I1.I3 is a raw type. References to generic type X.I1.I3<T> should be parameterized
				----------
				6. WARNING in X.java (at line 14)
					I1 i1 = null;
					^^
				X.I1 is a raw type. References to generic type X.I1<T> should be parameterized
				----------
				7. WARNING in X.java (at line 15)
					I1.I2 i2 = null;
					^^^^^
				X.I1.I2 is a raw type. References to generic type X.I1.I2<T> should be parameterized
				----------
				8. ERROR in X.java (at line 16)
					I1<E>.I2 i1i2 = null;
					^^^^^^^^
				The member type X.I1.I2<T> cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type X.I1<E>
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=137203
// simulate incremental compile
public void test0972() {
	runConformTest(
		// test directory preparation
		true /* flush output directory */,
		new String[] { /* test files */
			"Outer.java", //================================
			"""
				//Outer.java
				public class Outer<O> {
				  public class Inner {}
				
				  public static void method(Outer<?>.Inner x) {
				    System.out.println("SUCCESS");
				  }
				  public static void main(String[] args) {
				    Outer<?>.Inner x = null;
				    method(x);
				  }
				}
				
				""",
			"ExtendedOuter.java", //================================
			"""
				public class ExtendedOuter<E> extends Outer<E> {
				  class ExtendedInner extends Inner {
				    {
				      Outer.method(this);
				    }
				  }
				}
				"""
		},
		// compiler results
		"" /* expected compiler log */,
		// runtime results
		"SUCCESS" /* expected output string */,
		"" /* expected error string */,
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);

	this.runConformTest(
			new String[] {
				"Outer.java", //================================
				"""
					//Outer.java
					public class Outer<O> {
					  public class Inner {}
					
					  public static void method(Outer.Inner x) {
					    System.out.println("SUCCESS");
					  }
					  public static void main(String[] args) {
					    Outer.Inner x = null;
					    method(x);
					  }
					}
					
					""",
			},
			"SUCCESS",
			null,
			false,
			null);
	this.runConformTest(
			new String[] {
					"ExtendedOuter.java", //================================
					"""
						public class ExtendedOuter<E> extends Outer<E> {
						  class ExtendedInner extends Inner {
						    {
						      Outer.method(this);
						    }
						  }
						  public static void main(String[] args) {
						    System.out.println("SUCCESS");
						  }
						}
						"""

			},
			"SUCCESS",
			null,
			false,
			null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=137203 - variation
//pure source scenario
public void test0973() {
	this.runConformTest(
			new String[] {
				"Outer.java", //================================
				"""
					//Outer.java
					public class Outer<O> {
					  public class Inner {}
					
					  public static void method(Outer.Inner x) {
					    System.out.println("SUCCESS");
					  }
					  public static void main(String[] args) {
					    Outer.Inner x = null;
					    method(x);
					  }
					}
					
					""",
				"ExtendedOuter.java", //================================
				"""
					public class ExtendedOuter<E> extends Outer<E> {
					  class ExtendedInner extends Inner {
					    {
					      Outer.method(this);
					    }
					  }
					}
					"""
			},
			"SUCCESS");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=137203 - variation
//simulate incremental compile
public void test0974() {
	this.runConformTest(
			new String[] {
				"Outer.java", //================================
				"""
					//Outer.java
					public class Outer<O> {
					  public class Inner {}
					
					  public static void method(Outer.Inner x) {
					    System.out.println("SUCCESS");
					  }
					  public static void main(String[] args) {
					    Outer.Inner x = null;
					    method(x);
					  }
					}
					
					""",
				"ExtendedOuter.java", //================================
				"""
					public class ExtendedOuter<E> extends Outer<E> {
					  class ExtendedInner extends Inner {
					    {
					      Outer.method(this);
					    }
					  }
					}
					"""
			},
			"SUCCESS");
	this.runConformTest(
			new String[] {
					"ExtendedOuter.java", //================================
					"""
						public class ExtendedOuter<E> extends Outer<E> {
						  class ExtendedInner extends Inner {
						    {
								Outer.Inner in;
						      Outer.method(this);
						    }
						  }
						  public static void main(String[] args) {
						    System.out.println("SUCCESS");
						  }
						}
						"""

			},
			"SUCCESS",
			null,
			false,
			null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=122999
public void test0975() {
	this.runNegativeTest(
			new String[] {
				"X.java", //================================
				"""
					import java.util.ArrayList;
					
					public class X extends ArrayList<Bean> {
					   public static class Bean {}
					}""", // =================
			},
			"""
				----------
				1. WARNING in X.java (at line 3)
					public class X extends ArrayList<Bean> {
					             ^
				The serializable class X does not declare a static final serialVersionUID field of type long
				----------
				2. ERROR in X.java (at line 3)
					public class X extends ArrayList<Bean> {
					                                 ^^^^
				Bean cannot be resolved to a type
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=139525
public void test0976() {
	this.runConformTest(
			new String[] {
					"S.java", // =================
					"""
						import java.util.Collection;
						public class S {
						        public static void cow(IDA<?, ?, ?, ?, ?, ?> s) {
						                Collection<IDA.Enum1> ids = s.getIds();  // Error here
						        }
								public static void main(String[] args) {
									System.out.println("SUCCESS");
						        }
						}
						""", // =================
					"ID.java", // =================
					"""
						import java.util.Collection;
						public interface ID {
						        Collection<? extends Comparable<?>> getIds();
						}
						""", // =================
					"IDA.java", // =================
					"""
						import java.util.Collection;
						public interface IDA<T1, C1, E1, E2, C2, T2> extends ID {
						        enum Enum1 {
						                ONE, TWO
						        }
						        Collection<IDA.Enum1> getIds();
						}
						""", // =================
			},
			"SUCCESS");
	this.runConformTest(
			new String[] {
					"S.java", // =================
					"""
						import java.util.Collection;
						public class S {
						        public static void cow(IDA<?, ?, ?, ?, ?, ?> s) {
						                Collection<IDA.Enum1> ids = s.getIds();  // Error here
						        }
								public static void main(String[] args) {
									System.out.println("SUCCESS2");
						        }
						}
						""", // =================
			},
			"SUCCESS2",
			null,
			false,
			null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=139619
public void test0977() {
	this.runConformTest(
			new String[] {
					"MMTPProtocol.java", // =================
					"""
						import java.io.InputStream;
						import java.util.HashSet;
						import bug.ProtocolManager;
						abstract class AbstractProtocol<R, O> implements ProtocolManager<R, O> {
						    public AbstractProtocol(HashSet<O> manager, String grp) {}
						    AbstractProtocol(){}\s
						     public void connect(ConnectType type) { }
						}
						public abstract class MMTPProtocol extends AbstractProtocol<InputStream, String> {
						    public void connect(ConnectType type) {}
						}
						""", // =================
					"bug/ProtocolManager.java", // =================
					"""
						package bug;
						public interface ProtocolManager<R, O>{
						    public enum ConnectType {Client,Server}
						    public void connect(ConnectType type) ;
						    public boolean receive(R input) throws Exception;
						}""", // =================
			},
			"");
	this.runConformTest(
			new String[] {
					"MMTPProtocol.java", // =================
					"""
						import java.io.InputStream;
						import java.util.HashSet;
						import bug.ProtocolManager;
						abstract class AbstractProtocol<R, O> implements ProtocolManager<R, O> {
						    public AbstractProtocol(HashSet<O> manager, String grp) {}
						    AbstractProtocol(){}\s
						     public void connect(ConnectType type) { }
						}
						public abstract class MMTPProtocol extends AbstractProtocol<InputStream, String> {
						    public void connect(ConnectType type) {}
						}
						""", // =================
			},
			"",
			null,
			false,
			null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=139669
public void test0978() {
	this.runConformTest(
			new String[] {
					"B.java", // =================
					"""
						public class B<T> implements A<T> {
						  public void foo(A.C c) {}
						}""", // =================
					"A.java", // =================
					"""
						public interface A<T> {
						  void foo(A.C c);
						  class C {}
						}""", // =================
			},
			"");
	this.runConformTest(
			new String[] {
					"A.java", // =================
					"""
						public interface A<T> {
						  void foo(A.C c);
						  class C {}
						}""", // =================
			},
			"",
			null,
			false,
			null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=139669
public void test0979() {
	this.runConformTest(
			new String[] {
					"B.java", // =================
					"""
						public class B<T> extends A<T> {
						  @Override
						  public void foo(A.C c) {}
						}""", // =================
					"A.java", // =================
					"""
						public class A<T> {
						  public void foo(A.C c) {}
						  public static class C {}
						}""", // =================
			},
			"");
	this.runConformTest(
			new String[] {
					"A.java", // =================
					"""
						public class A<T> {
						  public void foo(A.C c) {}
						  public static class C {}
						}""", // =================
			},
			"",
			null,
			false,
			null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=140772
public void test0980() {
	this.runConformTest(
			new String[] {
					"X.java", // =================
					"""
						import java.util.Collections;
						import java.util.Set;
						
						public class X {
						        public Set<Object> keySet() {
						                return Collections.<Object> emptySet();
						        }
						}""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=140569
//simulate incremental compile
public void test0981() {
	this.runConformTest(
			new String[] {
				"Outer.java", //================================
				"""
					//Outer.java
					public class Outer<O> {
					  public class Inner {}
					
					  public static void main(String[] args) {
					    System.out.println("SUCCESS");
					  }
					}
					
					""",
				"ExtendedOuter.java", //================================
				"""
					public class ExtendedOuter<E> extends Outer<E> {
					  class ExtendedInner extends Inner {
					    public void method(){
					      Worker.method(this);
					    }
					  }
					}
					""",
				"Worker.java", //================================
				"""
					public class Worker {
					  public static void method(Outer.Inner i) {}
					}
					""", //================================
			},
			"SUCCESS");
	this.runConformTest(
			new String[] {
					"ExtendedOuter.java", //================================
					"""
						public class ExtendedOuter<E> extends Outer<E> {
						  class ExtendedInner extends Inner {
						    public void method(){
						      Worker.method(this);
						    }
						  }
						  public static void main(String[] args) {
						    System.out.println("SUCCESS");
						  }
						}
						""", //================================
			},
			"SUCCESS",
			null,
			false,
			null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=140569
//simulate incremental compile
public void test0982() {
	this.runConformTest(
			new String[] {
				"Outer.java", //================================
				"""
					//Outer.java
					public class Outer<O> {
					  public class Inner {
					  		public class Inner2 {}
						}
					
					  public static void main(String[] args) {
					    System.out.println("SUCCESS");
					  }
					}
					
					""",
				"ExtendedOuter.java", //================================
				"""
					public class ExtendedOuter<E> extends Outer<E> {
					  class ExtendedInner extends Inner {
					    class ExtendedInner2 extends Inner2 {
					      public void method(){
					        Worker.method(this);
					      }
					    }
					  }
					}
					""",
				"Worker.java", //================================
				"""
					public class Worker {
					  public static void method(Outer.Inner.Inner2 i) {}
					}
					""", //================================
			},
			"SUCCESS");
	this.runConformTest(
			new String[] {
					"ExtendedOuter.java", //================================
					"""
						public class ExtendedOuter<E> extends Outer<E> {
						  class ExtendedInner extends Inner {
						    class ExtendedInner2 extends Inner2 {
						      public void method(){
						        Worker.method(this);
						      }
						    }
						  }
						  public static void main(String[] args) {
						    System.out.println("SUCCESS");
						  }
						}
						""", //================================
			},
			"SUCCESS",
			null,
			false,
			null);
}
public void test0983() {
	this.runNegativeTest(
			new String[] {
					"X.java", // =================
					"""
						import java.util.*;
						
						public class X {
						    public static void main(String[] args) throws Throwable {
							List<?> l1 = new ArrayList<Integer>();
							List<?> l2 = new ArrayList<Integer>();
							l1.addAll(l2);
						    }
						}
						""", // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 7)
					l1.addAll(l2);
					   ^^^^^^
				The method addAll(Collection<? extends capture#1-of ?>) in the type List<capture#1-of ?> is not applicable for the arguments (List<capture#2-of ?>)
				----------
				""");
}
// generic inner class within a non generic one
public void test0984() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				public class X {
				  public class XX<T> {}
				}""",
			"I.java",
			"""
				public interface I {
				    X.XX<String> foo();
				}""",
			"Y.java",
			"""
				public class Y extends X implements I {
				  public XX<String> foo() {
				    return null;
				  }
				}""",
		},
		// runtime results
		"" /* expected output string */);
	runConformTest(
		// test directory preparation
		false /* do not flush output directory */,
		new String[] { /* test files */
			"Y.java",
			"""
				public class Y extends X implements I {
				  public XX<String> foo() {
				    return null;
				  }
				}""",
			},
		// compiler results
		"" /* expected compiler log */,
		// runtime results
		"" /* expected output string */,
		"" /* expected error string */,
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=141330
public void test0985() {
	Map options = getCompilerOptions();
	options.put(JavaCore.COMPILER_PB_UNCHECKED_TYPE_OPERATION, JavaCore.IGNORE);
	this.runNegativeTest(
			new String[] {
					"X.java", // =================
					"""
						import java.util.*;
						public class X {
						    public void testBreak() {
						        List<Class<Object>>  lco = Arrays.asList(String.class, Integer.class, Long.class);
						    }
						}
						""", // =================
			},
			"----------\n" +
			"1. ERROR in X.java (at line 4)\n" +
			"	List<Class<Object>>  lco = Arrays.asList(String.class, Integer.class, Long.class);\n" +
			"	                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Type mismatch: cannot convert from List<Class<? extends "+intersection("Object","Serializable","Comparable<?>")+">> to List<Class<Object>>\n" +
			"----------\n",
			null,
			true,
			options);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=91709
public void test0986() {
	this.runConformTest(
			new String[] {
					"T.java", // =================
					"""
						public class T {
							public T() {
								S<String> s = new S<String>();
								s.setObj("S");
								System.out.print(s.getObj());
								S<Integer> i = new S<Integer>();
								i.setObj(new Integer(100));
								System.out.print(i.getObj());
								S<MyClass> m = new S<MyClass>();
								m.setObj(new MyClass("[Terry]"));
								System.out.print(m.getObj());
								S<MyClass> x = new S<MyClass>(new MyClass("[Corbet]"));
								System.out.print(x.getObj());
							} // End of Constructor for T.
							public static void main(String[] args) {
								try {
									new T();
									System.out.println("SUCCESS");
								} catch (Exception ex) {
									ex.printStackTrace();
								}
							} // End of main().
						
							class MyClass {
								private String str;
								public MyClass(String str) {
									this.str = str;
								} // End of Constructor for MyClass.
								@Override
								public String toString() {
									return ("MyClass = " + str);
								} // End of toString().
							} // End of Embedded MyClass Class.
						} // End of T Class.
						""",  // =================
					"S.java", // =================
					"""
						public class S<$T> extends B<$T> {
							public S() {
								super();
							} // End of Constructor for S.
							public S($T obj) {
								super(obj);
							} // End of Constructor for S.
						} // End of S Class.
						""",  // =================
					"B.java", // =================
					"""
						public abstract class B<$T> {
							$T obj;
							public B() {
								;
							} // End of Constructor for B.
							public B($T obj) {
								this.obj = obj;
							} // End ofg Constructor of B.
							public $T getObj() {
								return (obj);
							} // End of getObj().
							public void setObj($T obj) {
								this.obj = obj;
							} // End of setObj().
						} // End of B Class.""", // =================

			},
			"S100MyClass = [Terry]MyClass = [Corbet]SUCCESS");
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=140643
public void test0987() {
	String expectedOutput = new CompilerOptions(getCompilerOptions()).sourceLevel < ClassFileConstants.JDK1_6
    ?	"""
		----------
		1. ERROR in X.java (at line 7)
			abstract class GLinkElementView<M,CM> extends AbstractLinkView<M> {}
			               ^^^^^^^^^^^^^^^^
		The return types are incompatible for the inherited methods EditPart.getViewer(), AbstractLinkView<M>.getViewer()
		----------
		2. ERROR in X.java (at line 11)
			public ISheetViewer getViewer() { return null; }\t
			       ^^^^^^^^^^^^
		The return type is incompatible with EditPart.getViewer()
		----------
		3. ERROR in X.java (at line 11)
			public ISheetViewer getViewer() { return null; }\t
			                    ^^^^^^^^^^^
		The method getViewer() of type AbstractLinkView<M> must override a superclass method
		----------
		"""
    :	"""
		----------
		1. ERROR in X.java (at line 7)
			abstract class GLinkElementView<M,CM> extends AbstractLinkView<M> {}
			               ^^^^^^^^^^^^^^^^
		The return types are incompatible for the inherited methods EditPart.getViewer(), AbstractLinkView<M>.getViewer()
		----------
		2. ERROR in X.java (at line 11)
			public ISheetViewer getViewer() { return null; }\t
			       ^^^^^^^^^^^^
		The return type is incompatible with EditPart.getViewer()
		----------
		""";
	this.runNegativeTest(
			new String[] {
				"X.java",//===================
				"""
					public class X {
						void bar(GLinkElementView<?,?> g) {
							g.getViewer();
						}
					}
					
					abstract class GLinkElementView<M,CM> extends AbstractLinkView<M> {}
					
					abstract class AbstractLinkView<M> extends AbstractConnectionEditPart implements ILinkViewElement {
						@Override
						public ISheetViewer getViewer() { return null; }\t
					}
					
					abstract class AbstractConnectionEditPart implements EditPart {}
					
					abstract class AbstractEditPart implements EditPart {
						public EditPartViewer getViewer() { return null; }
					}
					
					interface ILinkViewElement {
						public ISheetViewer getViewer();
					}
					
					interface ISheetViewer {}
					
					interface EditPart {
						EditPartViewer getViewer();
					}
					
					interface EditPartViewer {}
					""", // =================
			},
			expectedOutput);
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=140643 - variation
public void test0988() {
	this.runNegativeTest(
			new String[] {
				"X.java",//===================
				"""
					public class X {
						void bar(GLinkElementView<?,?> g) {
							g.getViewer();
						}
					}
					
					abstract class GLinkElementView<M,CM> extends AbstractLinkView<M> {}
					
					abstract class AbstractLinkView<M> extends AbstractConnectionEditPart implements ILinkViewElement, IModelChangeListener {
						@Override
						public SheetViewer getViewer() { return null; }\t
					}
					
					abstract class AbstractConnectionEditPart extends AbstractGraphicalEditPart implements ConnectionEditPart {}
					
					abstract class AbstractGraphicalEditPart extends AbstractEditPart implements GraphicalEditPart {}
					
					abstract class AbstractEditPart implements EditPart {
						public EditPartViewer getViewer() { return null; }
					}
					
					interface ILinkViewElement extends INodeViewElement {
						public ISheetViewer getViewer();
					}
					
					class SheetViewer implements ISheetViewer {}
					
					interface ISheetViewer {}
					
					interface EditPart {
						EditPartViewer getViewer();
					}
					
					interface ConnectionEditPart extends GraphicalEditPart {}
					interface GraphicalEditPart extends EditPart {}
					interface EditPartViewer {}
					interface IModelChangeListener {}
					
					interface INodeViewElement {
						public ISheetViewer getViewer();
					}""", // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 7)
					abstract class GLinkElementView<M,CM> extends AbstractLinkView<M> {}
					               ^^^^^^^^^^^^^^^^
				The return types are incompatible for the inherited methods EditPart.getViewer(), AbstractLinkView<M>.getViewer()
				----------
				2. ERROR in X.java (at line 11)
					public SheetViewer getViewer() { return null; }\t
					       ^^^^^^^^^^^
				The return type is incompatible with AbstractEditPart.getViewer()
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=142653
public void test0989() {
	this.runNegativeTest(
			new String[] {
				"Child.java",//===================
				"""
					public class Child extends Parent<Object> {}
					abstract class Parent<T> extends Grandparent<T> implements IParent {}
					interface IParent<T> extends IGrandparent<T> {}
					abstract class Grandparent<T> implements IGrandparent<T> {}
					interface IGrandparent<T> {}""", // =================, // =================
			},
			"""
				----------
				1. ERROR in Child.java (at line 2)
					abstract class Parent<T> extends Grandparent<T> implements IParent {}
					               ^^^^^^
				The interface IGrandparent cannot be implemented more than once with different arguments: IGrandparent<T> and IGrandparent
				----------
				2. WARNING in Child.java (at line 2)
					abstract class Parent<T> extends Grandparent<T> implements IParent {}
					                                                           ^^^^^^^
				IParent is a raw type. References to generic type IParent<T> should be parameterized
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=142653 - variation
public void test0990() {
	this.runNegativeTest(
			new String[] {
				"Child.java",//===================
				"""
					public class Child extends Parent<Object> {}
					abstract class Parent<T> extends Grandparent<T> implements IParent<?> {}
					interface IParent<T> extends IGrandparent<T> {}
					abstract class Grandparent<T> implements IGrandparent<T> {}
					interface IGrandparent<T> {}""", // =================, // =================
			},
			"""
				----------
				1. ERROR in Child.java (at line 1)
					public class Child extends Parent<Object> {}
					             ^^^^^
				The hierarchy of the type Child is inconsistent
				----------
				2. ERROR in Child.java (at line 2)
					abstract class Parent<T> extends Grandparent<T> implements IParent<?> {}
					                                                           ^^^^^^^
				The type Parent cannot extend or implement IParent<?>. A supertype may not specify any wildcard
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=142653 - variation
public void test0991() {
	this.runNegativeTest(
			new String[] {
				"X.java",//===================
				"""
					public class X extends SX<String> implements IX<Object> {}
					class SX<T> extends TX<Thread> implements IX<T> {}
					class TX<U> implements IX<U> {}
					interface IX<V> {}
					""", // =================, // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 1)
					public class X extends SX<String> implements IX<Object> {}
					             ^
				The interface IX cannot be implemented more than once with different arguments: IX<Thread> and IX<Object>
				----------
				2. ERROR in X.java (at line 2)
					class SX<T> extends TX<Thread> implements IX<T> {}
					      ^^
				The interface IX cannot be implemented more than once with different arguments: IX<Thread> and IX<T>
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=142653 - variation
public void test0992() {
	this.runNegativeTest(
			new String[] {
				"X.java",//===================
				"""
					import java.util.*;
					public abstract class X<T0> implements Collection, I<T0> {
					\t
						void foo() {
							this.add(new Object());
							this.add(null);
						}
					}
					interface I<T1> extends Collection<String> {
					}
					""", // =================, // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					public abstract class X<T0> implements Collection, I<T0> {
					                      ^
				The interface Collection cannot be implemented more than once with different arguments: Collection<String> and Collection
				----------
				2. WARNING in X.java (at line 2)
					public abstract class X<T0> implements Collection, I<T0> {
					                                       ^^^^^^^^^^
				Collection is a raw type. References to generic type Collection<E> should be parameterized
				----------
				3. WARNING in X.java (at line 5)
					this.add(new Object());
					^^^^^^^^^^^^^^^^^^^^^^
				Type safety: The method add(Object) belongs to the raw type Collection. References to generic type Collection<E> should be parameterized
				----------
				4. WARNING in X.java (at line 6)
					this.add(null);
					^^^^^^^^^^^^^^
				Type safety: The method add(Object) belongs to the raw type Collection. References to generic type Collection<E> should be parameterized
				----------
				""");
}

//https://bugs.eclipse.org/bugs/show_bug.cgi?id=142897
public void test0993() {
	runConformTest(
		true,
		new String[] {
			"X.java",//===================
			"""
				public class X {
				  public class Inner {
				    Inner() {
				      System.out.println("SUCCESS");
				    }
				  }
				  public static void main(String[] args) {
				    new ATest<X>();
				  }
				}
				
				class ATest<T extends X> {
				   public ATest() {
				      T instance = makeInstance();
				      X.Inner peq = instance.new Inner(); //**
				   }
				
				   private T makeInstance() {
				      return (T) new X();
				   }
				}""", // =================
		},
		null,
		"SUCCESS",
		null,
		JavacTestOptions.JavacHasABug.JavacBug6569404);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=142897 - variation
public void test0994() {
	this.runConformTest(
			new String[] {
				"X.java",//===================
				"""
					public class X {
					  public class Inner {
					    Inner() {
					      System.out.println("SUCCESS");
					    }
					  }
					  void foo(boolean b, X1 x1, X2 x2) {
						  (b ? x1 : x2).new Inner();
					  }
					  public static void main(String[] args) {
					    new X().foo(true, new X1(), new X2());
					  }
					}
					
					class X1 extends X implements Comparable<X1> {
					  public int compareTo(X1 other) {
					    return 0;
					  }
					}
					class X2 extends X implements Comparable<X2> {
					  public int compareTo(X2 other) {
					    return 0;
					  }
					}
					""", // =================
			},
			"SUCCESS");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=142964
public void _test0995() {
	this.runNegativeTest(
			new String[] {
				"X.java",//===================
				"""
					public class X {
					  public class Inner {
					  }
					  void foo(boolean b, X1 x1, X2 x2) {
						  Comparable<? extends X> cx1 = b ? x1 : x2;
						  Comparable<X> cx2 = b ? x1 : x2;
						  String s = b ? x1 : x2;
					  }
					}
					
					abstract class X1 extends X implements Comparable<X1> {}
					abstract class X2 extends X implements Comparable<X2> {}""", // =================
			},
			"SUCCESS");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=143793
public void test0996() {
	this.runNegativeTest(
			new String[] {
				"X.java",//===================
				"""
					import java.util.ArrayList;
					import java.util.List;
					
					public class X<T> {
					  private T aObject = null;
					  public static <U> List<U> castList(final List<? extends Object> pList, final Class<U> pClass) {
					    final List<U> result = new ArrayList<U>();
					    for (Object o:pList) {
					      if (pClass.isInstance(o)) {
					        result.add(pClass.cast(o));
					      }
					    }
					    return result;
					  }
					
					  public static void main(final String[] pArgs) {
					    final List<Object> l1 = new ArrayList<Object>();
					    l1.add(new X<String>());
					    l1.add(new X<String>());
					    final List<X<?>> l2 = castList(l1, List.class);
					   \s
					    List<X> l3 = l2;
					    List<X<String>> l4 = null;
					    l3 = l4;
					  }
					
					}
					""", // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 20)
					final List<X<?>> l2 = castList(l1, List.class);
					                      ^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from List<List> to List<X<?>>
				----------
				2. WARNING in X.java (at line 22)
					List<X> l3 = l2;
					     ^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				3. ERROR in X.java (at line 22)
					List<X> l3 = l2;
					             ^^
				Type mismatch: cannot convert from List<X<?>> to List<X>
				----------
				4. ERROR in X.java (at line 24)
					l3 = l4;
					     ^^
				Type mismatch: cannot convert from List<X<String>> to List<X>
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=142897 - variation
public void test0997() {
	runConformTest(
		true,
		new String[] {
			"X.java",//===================
			"""
				public class X implements Outer {
				  public static void main(String[] args) {
				    new ATest<X>();
				  }
				}
				interface Outer {
				  public class Inner {
				    Inner() {
				      System.out.println("SUCCESS");
				    }
				  }
				}
				
				class ATest<T extends Outer> {
				   public ATest() {
				      Outer.Inner peq = new T.Inner(); //**
				   }
				
				   private T makeInstance() {
				      return (T) new X();
				   }
				}""", // =================
		},
		null,
		"SUCCESS",
		null,
		JavacTestOptions.JavacHasABug.JavacBug6569404);
}
//regression test for https://bugs.eclipse.org/bugs/show_bug.cgi?id=144261
public void test0998() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				class X {
				    static abstract class Generic<F> {
				        static class Inner {
				            static class InnerInner { }
				            InnerInner createTableModel() {
				                return new InnerInner();
				            }
				        }
				    }
				    static class SubGeneric<S> extends Generic<S> {
				        static class SubInner extends Inner {
				            InnerInner createTableModel() {
				                return super.createTableModel();\s
				            }
				        }
				    }
				}""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=144879
// SHOULD FAIL AT 1.8 (18.2.3): The method chain(Iterator<E>...) in the type X is not applicable for the arguments (Iterator[])
public void test0999() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				public class X {
					public static final <T,E extends T> Iterator<T> chain(Iterator<E>... it) {
						return null;
					}
					void foo1() {
						List<Integer> l1 = Arrays.asList(1, 2, 3);
						List<Float> l2 = Arrays.asList(4f, 5f, 6f);
						Iterator<Number> it1 = X.chain(new Iterator[] { l1.iterator(), l2.iterator() });
					}
					void foo2() {
						List<Integer> l1 = Arrays.asList(1, 2, 3);
						List<Float> l2 = Arrays.asList(4f, 5f, 6f);
						Iterator<Number> it2 = X.chain(l1.iterator(), l2.iterator());
					}
					void foo3() {
						List<Integer> l1 = Arrays.asList(1, 2, 3);
						Iterator<Number> it2 = X.chain(l1.iterator(), l1.iterator());
					}
				}""", // =================
		},
		this.complianceLevel < ClassFileConstants.JDK1_7 ?
		"""
			----------
			1. WARNING in X.java (at line 9)
				Iterator<Number> it1 = X.chain(new Iterator[] { l1.iterator(), l2.iterator() });
				                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked invocation chain(Iterator[]) of the generic method chain(Iterator<E>...) of type X
			----------
			2. WARNING in X.java (at line 9)
				Iterator<Number> it1 = X.chain(new Iterator[] { l1.iterator(), l2.iterator() });
				                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: The expression of type Iterator needs unchecked conversion to conform to Iterator<Number>
			----------
			3. WARNING in X.java (at line 9)
				Iterator<Number> it1 = X.chain(new Iterator[] { l1.iterator(), l2.iterator() });
				                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: The expression of type Iterator[] needs unchecked conversion to conform to Iterator<Number>[]
			----------
			4. ERROR in X.java (at line 14)
				Iterator<Number> it2 = X.chain(l1.iterator(), l2.iterator());
				                         ^^^^^
			The method chain(Iterator<E>...) in the type X is not applicable for the arguments (Iterator<Integer>, Iterator<Float>)
			----------
			5. WARNING in X.java (at line 18)
				Iterator<Number> it2 = X.chain(l1.iterator(), l1.iterator());
				                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: A generic array of Iterator<Integer> is created for a varargs parameter
			----------
			""" :
			"----------\n" +
			"1. WARNING in X.java (at line 3)\n" +
			"	public static final <T,E extends T> Iterator<T> chain(Iterator<E>... it) {\n" +
			"	                                                                     ^^\n" +
			"Type safety: Potential heap pollution via varargs parameter it\n" +
			"----------\n" +
			"2. WARNING in X.java (at line 9)\n" +
			"	Iterator<Number> it1 = X.chain(new Iterator[] { l1.iterator(), l2.iterator() });\n" +
			"	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Type safety: Unchecked invocation chain(Iterator[]) of the generic method chain(Iterator<E>...) of type X\n" +
			"----------\n" +
			"3. WARNING in X.java (at line 9)\n" +
			"	Iterator<Number> it1 = X.chain(new Iterator[] { l1.iterator(), l2.iterator() });\n" +
			"	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Type safety: The expression of type Iterator needs unchecked conversion to conform to Iterator<Number>\n" +
			"----------\n" +
			"4. WARNING in X.java (at line 9)\n" +
			"	Iterator<Number> it1 = X.chain(new Iterator[] { l1.iterator(), l2.iterator() });\n" +
			"	                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			(this.complianceLevel < ClassFileConstants.JDK1_8
			? "Type safety: The expression of type Iterator[] needs unchecked conversion to conform to Iterator<Number>[]\n"
			: "Type safety: The expression of type Iterator[] needs unchecked conversion to conform to Iterator<Object>[]\n") +
			"----------\n" +
			"5. ERROR in X.java (at line 14)\n" +
			"	Iterator<Number> it2 = X.chain(l1.iterator(), l2.iterator());\n" +
			"	                         ^^^^^\n" +
			"The method chain(Iterator<E>...) in the type X is not applicable for the arguments (Iterator<Integer>, Iterator<Float>)\n" +
			"----------\n" +
			"6. WARNING in X.java (at line 18)\n" +
			"	Iterator<Number> it2 = X.chain(l1.iterator(), l1.iterator());\n" +
			"	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Type safety: A generic array of Iterator<Integer> is created for a varargs parameter\n" +
			"----------\n");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=144879
public void test1000() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				public class X {
					public static final <T> Iterator<T> chain(Iterator<? extends T>... it) {
						return null;
					}
					void foo1() {
						List<Integer> l1 = Arrays.asList(1, 2, 3);
						List<Float> l2 = Arrays.asList(4f, 5f, 6f);
						Iterator<Number> it1 = X.chain(new Iterator[] { l1.iterator(), l2.iterator() });
					}
					void foo2() {
						List<Integer> l1 = Arrays.asList(1, 2, 3);
						List<Float> l2 = Arrays.asList(4f, 5f, 6f);
						Iterator<Number> it2 = X.chain(l1.iterator(), l2.iterator());
					}
					void foo3() {
						List<Integer> l1 = Arrays.asList(1, 2, 3);
						Iterator<Number> it2 = X.chain(l1.iterator(), l1.iterator());
					}
				}""", // =================
		},
		this.complianceLevel < ClassFileConstants.JDK1_7 ?
		"----------\n" +
		"1. WARNING in X.java (at line 9)\n" +
		"	Iterator<Number> it1 = X.chain(new Iterator[] { l1.iterator(), l2.iterator() });\n" +
		"	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
		"Type safety: Unchecked invocation chain(Iterator[]) of the generic method chain(Iterator<? extends T>...) of type X\n" +
		"----------\n" +
		"2. WARNING in X.java (at line 9)\n" +
		"	Iterator<Number> it1 = X.chain(new Iterator[] { l1.iterator(), l2.iterator() });\n" +
		"	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
		"Type safety: The expression of type Iterator needs unchecked conversion to conform to Iterator<Number>\n" +
		"----------\n" +
		"3. WARNING in X.java (at line 9)\n" +
		"	Iterator<Number> it1 = X.chain(new Iterator[] { l1.iterator(), l2.iterator() });\n" +
		"	                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
		"Type safety: The expression of type Iterator[] needs unchecked conversion to conform to Iterator<? extends Number>[]\n" +
		"----------\n" +
		"4. WARNING in X.java (at line 14)\n" +
		"	Iterator<Number> it2 = X.chain(l1.iterator(), l2.iterator());\n" +
		"	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
		"Type safety: A generic array of Iterator<? extends "+ intersection("Number", "Comparable<?>") +"> is created for a varargs parameter\n" +
		"----------\n" +
		"5. ERROR in X.java (at line 14)\n" +
		"	Iterator<Number> it2 = X.chain(l1.iterator(), l2.iterator());\n" +
		"	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
		"Type mismatch: cannot convert from Iterator<"+ intersection("Number", "Comparable<?>") +"> to Iterator<Number>\n" +
		"----------\n" +
		"6. WARNING in X.java (at line 18)\n" +
		"	Iterator<Number> it2 = X.chain(l1.iterator(), l1.iterator());\n" +
		"	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
		"Type safety: A generic array of Iterator<? extends Integer> is created for a varargs parameter\n" +
		"----------\n" +
		"7. ERROR in X.java (at line 18)\n" +
		"	Iterator<Number> it2 = X.chain(l1.iterator(), l1.iterator());\n" +
		"	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
		"Type mismatch: cannot convert from Iterator<Integer> to Iterator<Number>\n" +
		"----------\n" :
		(this.complianceLevel == ClassFileConstants.JDK1_7 ?
			"----------\n" +
			"1. WARNING in X.java (at line 3)\n" +
			"	public static final <T> Iterator<T> chain(Iterator<? extends T>... it) {\n" +
			"	                                                                   ^^\n" +
			"Type safety: Potential heap pollution via varargs parameter it\n" +
			"----------\n" +
			"2. WARNING in X.java (at line 9)\n" +
			"	Iterator<Number> it1 = X.chain(new Iterator[] { l1.iterator(), l2.iterator() });\n" +
			"	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Type safety: Unchecked invocation chain(Iterator[]) of the generic method chain(Iterator<? extends T>...) of type X\n" +
			"----------\n" +
			"3. WARNING in X.java (at line 9)\n" +
			"	Iterator<Number> it1 = X.chain(new Iterator[] { l1.iterator(), l2.iterator() });\n" +
			"	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Type safety: The expression of type Iterator needs unchecked conversion to conform to Iterator<Number>\n" +
			"----------\n" +
			"4. WARNING in X.java (at line 9)\n" +
			"	Iterator<Number> it1 = X.chain(new Iterator[] { l1.iterator(), l2.iterator() });\n" +
			"	                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Type safety: The expression of type Iterator[] needs unchecked conversion to conform to Iterator<? extends Number>[]\n" +
			"----------\n" +
			"5. WARNING in X.java (at line 14)\n" +
			"	Iterator<Number> it2 = X.chain(l1.iterator(), l2.iterator());\n" +
			"	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Type safety: A generic array of Iterator<? extends Number&"+ intersection("Comparable<?>") +"> is created for a varargs parameter\n" +
			"----------\n" +
			"6. ERROR in X.java (at line 14)\n" +
			"	Iterator<Number> it2 = X.chain(l1.iterator(), l2.iterator());\n" +
			"	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Type mismatch: cannot convert from Iterator<Number&"+ intersection("Comparable<?>") +"> to Iterator<Number>\n" +
			"----------\n" +
			"7. WARNING in X.java (at line 18)\n" +
			"	Iterator<Number> it2 = X.chain(l1.iterator(), l1.iterator());\n" +
			"	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Type safety: A generic array of Iterator<? extends Integer> is created for a varargs parameter\n" +
			"----------\n" +
			"8. ERROR in X.java (at line 18)\n" +
			"	Iterator<Number> it2 = X.chain(l1.iterator(), l1.iterator());\n" +
			"	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Type mismatch: cannot convert from Iterator<Integer> to Iterator<Number>\n" +
			"----------\n"
		:	"""
			----------
			1. WARNING in X.java (at line 3)
				public static final <T> Iterator<T> chain(Iterator<? extends T>... it) {
				                                                                   ^^
			Type safety: Potential heap pollution via varargs parameter it
			----------
			2. WARNING in X.java (at line 9)
				Iterator<Number> it1 = X.chain(new Iterator[] { l1.iterator(), l2.iterator() });
				                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked invocation chain(Iterator[]) of the generic method chain(Iterator<? extends T>...) of type X
			----------
			3. WARNING in X.java (at line 9)
				Iterator<Number> it1 = X.chain(new Iterator[] { l1.iterator(), l2.iterator() });
				                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: The expression of type Iterator needs unchecked conversion to conform to Iterator<Number>
			----------
			4. WARNING in X.java (at line 9)
				Iterator<Number> it1 = X.chain(new Iterator[] { l1.iterator(), l2.iterator() });
				                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: The expression of type Iterator[] needs unchecked conversion to conform to Iterator<? extends Object>[]
			----------
			5. WARNING in X.java (at line 14)
				Iterator<Number> it2 = X.chain(l1.iterator(), l2.iterator());
				                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: A generic array of Iterator<? extends Number> is created for a varargs parameter
			----------
			6. WARNING in X.java (at line 18)
				Iterator<Number> it2 = X.chain(l1.iterator(), l1.iterator());
				                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: A generic array of Iterator<? extends Number> is created for a varargs parameter
			----------
			"""
		)
	);
}
public void test1001() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X {
					static class Box<T> {}
					static class ABox<T extends A> {}
					static class A {}
				\t
					void foo(ABox<? extends A> a1, ABox<?> a2) {
						a1 = a2;\t
					}
				}""", // =================
		},
		"");
}
public void test1002() {
	this.runNegativeTest(
		new String[] {
			"Base.java",
			"""
				class Base {
				}
				class Foo<U extends Base, V extends Bar<U, Foo<U, V>>> {
					U u;
					V v;
				}
				class Bar<E extends Base, F extends Foo<E, Bar<E, F>>> {
					E e;
					F f;
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in Base.java (at line 3)
				class Foo<U extends Base, V extends Bar<U, Foo<U, V>>> {
				                                           ^^^
			Bound mismatch: The type Foo<U,V> is not a valid substitute for the bounded parameter <F extends Foo<E,Bar<E,F>>> of the type Bar<E,F>
			----------
			2. ERROR in Base.java (at line 7)
				class Bar<E extends Base, F extends Foo<E, Bar<E, F>>> {
				                                           ^^^
			Bound mismatch: The type Bar<E,F> is not a valid substitute for the bounded parameter <V extends Bar<U,Foo<U,V>>> of the type Foo<U,V>
			----------
			""");
}
public void test1003() {
	this.runConformTest(
		new String[] {
			"B.java",
			"""
				class B {
				}
				class S<BB extends B, SS extends S<BB, SS, TT>, TT extends T<BB, SS, TT>> {
					BB b;
					TT t;
				}
				class T<BB extends B, SS extends S<BB, SS, TT>, TT extends T<BB, SS, TT>> {
					BB b;
					SS t;
				}
				""", // =================
		},
		"");
}
public void test1004() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				public class X {
					<B> B getOtherValue() {
						return null;
					}
					<A> A getValue() {
						return getOtherValue();
					}
				}""", // =================
		},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_7 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=145420
public void test1005() {
	runConformTest(
		// test directory preparation
		true /* flush output directory */,
		new String[] { /* test files */
			"X.java",
			"""
				public class X<T1,T2> {
				
				    private static final Object NULL_REF = new Object();
				    private Object data;
				
				    private static <RT> RT unwrap(Object obj) {
				        return (RT)(obj == NULL_REF ? null : obj);
				    }
				
				    public T1 getAsT1() {
				        return unwrap(data);
				    }
				
				    public T2 getAsT2() {
				        return unwrap(data);
				    }
				}""", // =================
		},
	// compiler results
	null /* do not check compiler log */,
	// runtime results
	"" /* expected output string */,
	"" /* expected error string */,
	// javac options
	JavacTestOptions.JavacHasABug.JavacBugFixed_7 /* javac test options */);
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=145420 - variant
public void test1005b() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T1,T2> {
				
				    private static final Object NULL_REF = new Object();
				    private Object data;
				
				    private static <RT> RT unwrap(Object obj) {
				        return (RT)(obj == NULL_REF ? null : obj);
				    }
				
				    public T1 getAsT1() {
				        return unwrap(data);
				    }
				
				    public T2 getAsT2() {
				        return unwrap(data);
				    }
				    Zork z;
				}""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 7)
				return (RT)(obj == NULL_REF ? null : obj);
				       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from Object to RT
			----------
			2. ERROR in X.java (at line 17)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
public void test1006() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				class Reference<T> {
					T target;
					Reference(T target) {
						this.target = target;
					}
					T deref() {
						return this.target;
					}
					static <U> Reference<U> create(U u) {
						return new Reference<U>(u);
					}
				}
				class BaseObject {}
				class Person extends BaseObject {}
				class Building extends BaseObject {}
				
				public class X {
					void foo(Building b, Person p) {
						Reference<Building> bRef = Reference.create(b);
						Reference<Person> pRef = Reference.create(p);
				
						final Building building = bRef.deref();
						final Person person = pRef.deref();
					}
				}""", // =================
		},
		"");
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=147381
public void test1007() {
	this.runNegativeTest(
		new String[] {
			"GenericsProblem.java",
			"""
				public class GenericsProblem {
					public <T> void test(T val) {
						GenericsProblem gp = new GenericsProblem();
						Class<? extends GenericsProblem> cl2 = gp.getClass();
						Class<? extends T> cl = val.getClass();
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in GenericsProblem.java (at line 5)
				Class<? extends T> cl = val.getClass();
				                        ^^^^^^^^^^^^^^
			Type mismatch: cannot convert from Class<capture#2-of ? extends Object> to Class<? extends T>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=148061
// FAIL ERRMSG (type display)
public void test1008() {
	if (this.complianceLevel >= ClassFileConstants.JDK1_8)
		return;
	runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					void foo(L l, C<? extends X> c) {
						X x = bar(l, c);
					}
					<T> T bar(L<T> l, C<? extends T> c) {\s
						return zork;
					}\t
				}
				class C<E> {}
				class L<E> {}
				
				
				""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 2)
				void foo(L l, C<? extends X> c) {
				         ^
			L is a raw type. References to generic type L<E> should be parameterized
			----------
			2. WARNING in X.java (at line 3)
				X x = bar(l, c);
				      ^^^^^^^^^
			Type safety: Unchecked invocation bar(L, C<capture#1-of ? extends X>) of the generic method bar(L<T>, C<? extends T>) of type X
			----------
			3. WARNING in X.java (at line 3)
				X x = bar(l, c);
				          ^
			Type safety: The expression of type L needs unchecked conversion to conform to L<X>
			----------
			4. ERROR in X.java (at line 6)
				return zork;
				       ^^^^
			zork cannot be resolved to a variable
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=148061 - variation
public void test1009() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.Map;
				public class X {
				
					void foo(Map<String,Map> map) {
						bar(map);
					}
					<U,V> void bar(Map<U,Map<U,V>> map) {
					}
				}
				""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 4)
				void foo(Map<String,Map> map) {
				                    ^^^
			Map is a raw type. References to generic type Map<K,V> should be parameterized
			----------
			2. ERROR in X.java (at line 5)
				bar(map);
				^^^
			The method bar(Map<U,Map<U,V>>) in the type X is not applicable for the arguments (Map<String,Map>)
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=148061 - variation
public void test1010() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.Map;
				public class X {
				
					void foo(Map<String,Map> map) {
						bar(map);
					}
					<U,V> void bar(Map<U,? extends Map<U,V>> map) {
					}
				}
				""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 4)
				void foo(Map<String,Map> map) {
				                    ^^^
			Map is a raw type. References to generic type Map<K,V> should be parameterized
			----------
			2. ERROR in X.java (at line 5)
				bar(map);
				^^^
			The method bar(Map<U,? extends Map<U,V>>) in the type X is not applicable for the arguments (Map<String,Map>)
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=148061 - variation
public void test1011() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				public class X {
					void foo(HashMap map, String s, Map<String,String> map2) {
						bar(map, s, map2); //1
						bar(map2, s, map2); //2
						bar2(map, s, map2); //3
						bar3(map, s, map2); //4
					}
					<U> void bar(Map<U,U> map, U u, Map<U,U> map2) {}
					void bar2(Map<String,String> map, String s, Map<String,String> map2) {}
					<U> void bar3(Map<String,String> map, U s, Map<U,U> map2) {}
				}
				""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 3)
				void foo(HashMap map, String s, Map<String,String> map2) {
				         ^^^^^^^
			HashMap is a raw type. References to generic type HashMap<K,V> should be parameterized
			----------
			2. WARNING in X.java (at line 4)
				bar(map, s, map2); //1
				^^^^^^^^^^^^^^^^^
			Type safety: Unchecked invocation bar(HashMap, String, Map<String,String>) of the generic method bar(Map<U,U>, U, Map<U,U>) of type X
			----------
			3. WARNING in X.java (at line 4)
				bar(map, s, map2); //1
				    ^^^
			Type safety: The expression of type HashMap needs unchecked conversion to conform to Map<String,String>
			----------
			4. WARNING in X.java (at line 6)
				bar2(map, s, map2); //3
				     ^^^
			Type safety: The expression of type HashMap needs unchecked conversion to conform to Map<String,String>
			----------
			5. WARNING in X.java (at line 7)
				bar3(map, s, map2); //4
				^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked invocation bar3(HashMap, String, Map<String,String>) of the generic method bar3(Map<String,String>, U, Map<U,U>) of type X
			----------
			6. WARNING in X.java (at line 7)
				bar3(map, s, map2); //4
				     ^^^
			Type safety: The expression of type HashMap needs unchecked conversion to conform to Map<String,String>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=148061 - variation
public void test1012() {
	runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					void foo(L l, C<X> c) {
						X x = bar1(l, c);
						L<X> lx = bar2(l, c);
						C<X> cx = bar3(l, c);
					}
					<T> T bar1(L<T> l, C<T> c) {
						return null;
					}
					<T> L<T> bar2(L<T> l, C<T> c) {
						return null;
					}
					<T> C<T> bar3(L<T> l, C<T> c) {
						return zork;
					}
				}
				
				class C<E> {}
				class L<E> {}
				""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 2)
				void foo(L l, C<X> c) {
				         ^
			L is a raw type. References to generic type L<E> should be parameterized
			----------
			2. WARNING in X.java (at line 3)
				X x = bar1(l, c);
				      ^^^^^^^^^^
			Type safety: Unchecked invocation bar1(L, C<X>) of the generic method bar1(L<T>, C<T>) of type X
			----------
			3. WARNING in X.java (at line 3)
				X x = bar1(l, c);
				           ^
			Type safety: The expression of type L needs unchecked conversion to conform to L<X>
			----------
			4. WARNING in X.java (at line 4)
				L<X> lx = bar2(l, c);
				          ^^^^^^^^^^
			Type safety: Unchecked invocation bar2(L, C<X>) of the generic method bar2(L<T>, C<T>) of type X
			----------
			5. WARNING in X.java (at line 4)
				L<X> lx = bar2(l, c);
				          ^^^^^^^^^^
			Type safety: The expression of type L needs unchecked conversion to conform to L<X>
			----------
			6. WARNING in X.java (at line 4)
				L<X> lx = bar2(l, c);
				               ^
			Type safety: The expression of type L needs unchecked conversion to conform to L<X>
			----------
			7. WARNING in X.java (at line 5)
				C<X> cx = bar3(l, c);
				          ^^^^^^^^^^
			Type safety: Unchecked invocation bar3(L, C<X>) of the generic method bar3(L<T>, C<T>) of type X
			----------
			8. WARNING in X.java (at line 5)
				C<X> cx = bar3(l, c);
				          ^^^^^^^^^^
			Type safety: The expression of type C needs unchecked conversion to conform to C<X>
			----------
			9. WARNING in X.java (at line 5)
				C<X> cx = bar3(l, c);
				               ^
			Type safety: The expression of type L needs unchecked conversion to conform to L<X>
			----------
			10. ERROR in X.java (at line 14)
				return zork;
				       ^^^^
			zork cannot be resolved to a variable
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=148061 - variation
public void test1013() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				
				public class X {
					public static void main(String[] args) {
						List<String> ls = new ArrayList<String>();
						ls.add("foo");
						List<X> lx = new ArrayList<X>();
						lx.add(new X());
						new X().foo(ls, lx);
					}
					void done() {
						System.out.println(zork);
					}
					void foo(List l1, List<X> l2) {
						X x = bar1(l1, l2);
						x.done();
						List<X> lx = bar2(l1, l2);
						lx.get(0).done();
					}
					<T> T bar1(List<T> l1, List<T> l2) {
						return l1.get(0);
					}
					<T> List<T> bar2(List<T> l1, List<T> l2) {
						return l1;
					}
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 12)
				System.out.println(zork);
				                   ^^^^
			zork cannot be resolved to a variable
			----------
			2. WARNING in X.java (at line 14)
				void foo(List l1, List<X> l2) {
				         ^^^^
			List is a raw type. References to generic type List<E> should be parameterized
			----------
			3. WARNING in X.java (at line 15)
				X x = bar1(l1, l2);
				      ^^^^^^^^^^^^
			Type safety: Unchecked invocation bar1(List, List<X>) of the generic method bar1(List<T>, List<T>) of type X
			----------
			4. WARNING in X.java (at line 15)
				X x = bar1(l1, l2);
				           ^^
			Type safety: The expression of type List needs unchecked conversion to conform to List<X>
			----------
			5. WARNING in X.java (at line 17)
				List<X> lx = bar2(l1, l2);
				             ^^^^^^^^^^^^
			Type safety: Unchecked invocation bar2(List, List<X>) of the generic method bar2(List<T>, List<T>) of type X
			----------
			6. WARNING in X.java (at line 17)
				List<X> lx = bar2(l1, l2);
				             ^^^^^^^^^^^^
			Type safety: The expression of type List needs unchecked conversion to conform to List<X>
			----------
			7. WARNING in X.java (at line 17)
				List<X> lx = bar2(l1, l2);
				                  ^^
			Type safety: The expression of type List needs unchecked conversion to conform to List<X>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=148061 - variation
public void test1014() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				
				public class X {
					void foo1(List l, List<String> ls) {
						Set<Map.Entry<String,String>> mss1 = bar(l, ls).entrySet();
						String s = bar(l, ls).entrySet();
					}
					<U,V> Map<U,V> bar(List<U> lu, List<V> lv) { return null; }
				}
				""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 4)
				void foo1(List l, List<String> ls) {
				          ^^^^
			List is a raw type. References to generic type List<E> should be parameterized
			----------
			2. WARNING in X.java (at line 5)
				Set<Map.Entry<String,String>> mss1 = bar(l, ls).entrySet();
				                                     ^^^^^^^^^^
			Type safety: Unchecked invocation bar(List, List<String>) of the generic method bar(List<U>, List<V>) of type X
			----------
			3. WARNING in X.java (at line 5)
				Set<Map.Entry<String,String>> mss1 = bar(l, ls).entrySet();
				                                     ^^^^^^^^^^^^^^^^^^^^^
			Type safety: The expression of type Set needs unchecked conversion to conform to Set<Map.Entry<String,String>>
			----------
			4. WARNING in X.java (at line 5)
				Set<Map.Entry<String,String>> mss1 = bar(l, ls).entrySet();
				                                         ^
			Type safety: The expression of type List needs unchecked conversion to conform to List<Object>
			----------
			5. WARNING in X.java (at line 6)
				String s = bar(l, ls).entrySet();
				           ^^^^^^^^^^
			Type safety: Unchecked invocation bar(List, List<String>) of the generic method bar(List<U>, List<V>) of type X
			----------
			6. ERROR in X.java (at line 6)
				String s = bar(l, ls).entrySet();
				           ^^^^^^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from Set to String
			----------
			7. WARNING in X.java (at line 6)
				String s = bar(l, ls).entrySet();
				               ^
			Type safety: The expression of type List needs unchecked conversion to conform to List<Object>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=148061 - variation
// FAIL SHOULD RAISE MORE WARNINGS?
public void test1015() {
	if (this.complianceLevel >= ClassFileConstants.JDK1_8)
		return;
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				public class X {
					void foo1(List l, List<String> ls) {
						List<String> ls1 = bar(l, ls);
						String s = bar(l, ls);
					}
					<U,V> List<V> bar(List<U> lu, List<V> lv) { return null; }
				}
				""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 3)
				void foo1(List l, List<String> ls) {
				          ^^^^
			List is a raw type. References to generic type List<E> should be parameterized
			----------
			2. WARNING in X.java (at line 4)
				List<String> ls1 = bar(l, ls);
				                   ^^^^^^^^^^
			Type safety: Unchecked invocation bar(List, List<String>) of the generic method bar(List<U>, List<V>) of type X
			----------
			3. WARNING in X.java (at line 4)
				List<String> ls1 = bar(l, ls);
				                   ^^^^^^^^^^
			Type safety: The expression of type List needs unchecked conversion to conform to List<String>
			----------
			4. WARNING in X.java (at line 4)
				List<String> ls1 = bar(l, ls);
				                       ^
			Type safety: The expression of type List needs unchecked conversion to conform to List<Object>
			----------
			5. WARNING in X.java (at line 5)
				String s = bar(l, ls);
				           ^^^^^^^^^^
			Type safety: Unchecked invocation bar(List, List<String>) of the generic method bar(List<U>, List<V>) of type X
			----------
			6. ERROR in X.java (at line 5)
				String s = bar(l, ls);
				           ^^^^^^^^^^
			Type mismatch: cannot convert from List to String
			----------
			7. WARNING in X.java (at line 5)
				String s = bar(l, ls);
				               ^
			Type safety: The expression of type List needs unchecked conversion to conform to List<Object>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=148061 - variation
// SHOULD FAIL AT 1.8 (RET): Type mismatch: cannot convert from List<Object> to List
public void test1016() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				public class X {
					void foo1() {
						List ls1 = bar(null);
						List<String> ls2 = bar(null);
						String s = bar(null);
					}
					<U> List<U> bar(List<U> lu) { return null; }
				}
				""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 4)
				List ls1 = bar(null);
				^^^^
			List is a raw type. References to generic type List<E> should be parameterized
			----------
			2. ERROR in X.java (at line 6)
				String s = bar(null);
				           ^^^^^^^^^
			Type mismatch: cannot convert from List<Object> to String
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=148061 - variation
public void test1017() {
	this.runNegativeTest(
		new String[] {
			"SortedList.java",
			"""
				import java.util.*;
				
				public class SortedList<E extends Comparable> extends LinkedList<E>
				{
				    public boolean add(E e){
				      int index = Collections.binarySearch(this,e);
				      if (index<0)
				      super.add(-index-1,e);
				      return true;
				  }
				}""", // =================
		},
		"""
			----------
			1. WARNING in SortedList.java (at line 3)
				public class SortedList<E extends Comparable> extends LinkedList<E>
				             ^^^^^^^^^^
			The serializable class SortedList does not declare a static final serialVersionUID field of type long
			----------
			2. WARNING in SortedList.java (at line 3)
				public class SortedList<E extends Comparable> extends LinkedList<E>
				                                  ^^^^^^^^^^
			Comparable is a raw type. References to generic type Comparable<T> should be parameterized
			----------
			3. WARNING in SortedList.java (at line 5)
				public boolean add(E e){
				               ^^^^^^^^
			The method add(E) of type SortedList<E> should be tagged with @Override since it actually overrides a superclass method
			----------
			4. ERROR in SortedList.java (at line 6)
				int index = Collections.binarySearch(this,e);
				                        ^^^^^^^^^^^^
			The method binarySearch(List<? extends Comparable<? super T>>, T) in the type Collections is not applicable for the arguments (SortedList<E>, E)
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=148061 - variation
public void test1018() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<U,V> {
				
					void foo(U u) {
						bar(u, new Exception());
					}
					<T extends Exception> T bar(U u, T t) { return null; }
				}""", // =================
		},
		"");
}
public void test1018a() {
	runConformTest(
		// test directory preparation
		true /* flush output directory */,
		new String[] { /* test files */
			"X.java",
			"""
				class A<T> {}
				
				class B<E> extends A<X<String>> {}
				
				public class X<E extends String> extends B<E> {
				    public static void main(String[] args) {
				        System.out.println("SUCCESS");
				    }
				}"""
		},
		// compiler results
		null /* do not check compiler log */,
		// runtime results
		"SUCCESS" /* expected output string */,
		"" /* expected error string */,
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_7 /* javac test options */);
}
public void test1019() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public static void main(String[] args) {
						double[] d1 = new double[] { 1.0, 2.0, 3.0, 4.0 };
						System.out.println(deepToString(d1));
				
						Double[] d2 = new Double[] { 1.0, 2.0, 3.0, 4.0 };
						System.out.println(deepToString(d2));
				\t
					}
				
					public static <T> String deepToString(T[] array) {
						StringBuffer s = new StringBuffer();
						for (T t : array) {
							s.append(t.toString());
							s.append(",");
						}
						if (s.length() > 0) {
							s.setLength(s.length() - 1); // removes last ","
						}
						return s.toString();
					}
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 4)
				System.out.println(deepToString(d1));
				                   ^^^^^^^^^^^^
			The method deepToString(T[]) in the type X is not applicable for the arguments (double[])
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=149573
public void test1020() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.List;
				
				public class X {
					void foo(List<? extends Exception> l1, List<? extends Exception> l2) {
						l1.add(l2.get(0));
					}
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 5)
				l1.add(l2.get(0));
				   ^^^
			The method add(capture#1-of ? extends Exception) in the type List<capture#1-of ? extends Exception> is not applicable for the arguments (capture#2-of ? extends Exception)
			----------
			""");
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=149376
public void test1021() {
	this.runConformTest(
		new String[] {
			"p/SomeClass.java",
			"""
				package p;
				import static p.SomeClass.SomeEnum.*;
				public abstract class SomeClass<T> extends Object {
					public enum SomeEnum {
						A;
					};
				}
				""",
		},
		""
	);
}
public void test1021b() { // should this case be allowed?
	this.runNegativeTest(
		new String[] {
			"p/SomeClass2.java",
			"""
				package p;
				import static p.SomeClass2.M1.*;
				public abstract class SomeClass2<T> extends M {
					public static class M1 extends M2 {}
					public static class M2 extends M3 {}
					public static class M3 {
						public static class M {}
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in p\\SomeClass2.java (at line 3)
				public abstract class SomeClass2<T> extends M {
				                                            ^
			M cannot be resolved to a type
			----------
			2. ERROR in p\\SomeClass2.java (at line 4)
				public static class M1 extends M2 {}
				                               ^^
			Cycle detected: a cycle exists in the type hierarchy between SomeClass2.M1 and SomeClass2<T>
			----------
			"""
	);
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=151410 (duplicate of 149376)
public void test1021c() {
	runConformTest(
		new String[] {
			"ccs/jdtbug/filters/NameRF.java",
			"""
				package ccs.jdtbug.filters;
				import static ccs.jdtbug.ResultFilter.Action.*;
				import ccs.jdtbug.*;
				public class NameRF implements ResultFilter<String> {
					public NameRF() {}
					public Action getAction(String in, int ntotal, int naccept) {
						return YES;
					}
				} // end class
				""",
			"ccs/jdtbug/ResultFilter.java",
			"""
				package ccs.jdtbug;
				import java.io.*;
				public interface ResultFilter<T> {
					public enum Action {
						YES, NO, CANCEL
					}
					public Action getAction(T in, int ntotal, int naccept) throws IOException;
				} // end interface
				"""
		}
	);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=150294
public void test1022() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public static void main(String[] args) {
						String testString = "test string";
				
						testWithNonGeneric(testString);
						testWithGeneric(testString);
					}
				
					private static void testWithNonGeneric(String input) {
						Class<? extends String> clazz = input.getClass();
				
						System.out.println(clazz.getName());
					}
				
					private static <T> void testWithGeneric(T input) {
						Class<? extends T> clazz = input.getClass();
				
						System.out.println(clazz.getName());
					}
				}""", // =================,
		},
		"""
			----------
			1. ERROR in X.java (at line 16)
				Class<? extends T> clazz = input.getClass();
				                           ^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from Class<capture#3-of ? extends Object> to Class<? extends T>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=150362
public void test1023() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.Map;
				import java.util.Properties;
				
				public class X {
				
					public static void main(String[] args) {
						Properties props = new Properties();
						for (Map.Entry<String, ?> entry : props.entrySet()) {
							System.out.println(entry);
						}
						for (Map.Entry<String, ?> entry : ((Map<String, ?>) props).entrySet()) {
							System.out.println(entry);
						}
						for (Map.Entry<Object, ?> entry : ((Map<Object, ?>) props).entrySet()) {
							System.out.println(entry);
						}
						for (Map.Entry<Object, ?> entry : props.entrySet()) {
							System.out.println(entry);
						}
						for (Map.Entry<?, ?> entry : ((Map<?, ?>) props).entrySet()) {
							System.out.println(entry);
						}
						for (Map.Entry<?, ?> entry : props.entrySet()) {
							System.out.println(entry);
						}
					}
				}""", // =================,
		},
		"""
			----------
			1. ERROR in X.java (at line 8)
				for (Map.Entry<String, ?> entry : props.entrySet()) {
				                                  ^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from element type Map.Entry<Object,Object> to Map.Entry<String,?>
			----------
			2. ERROR in X.java (at line 11)
				for (Map.Entry<String, ?> entry : ((Map<String, ?>) props).entrySet()) {
				                                  ^^^^^^^^^^^^^^^^^^^^^^^^
			Cannot cast from Properties to Map<String,?>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=151275
public void test1024() {
	runConformTest(
		true,
		new String[] {
			"X.java",
			"""
				public class X {
					public static void main(String[] args) {
						Integer castInteger = genericCast(1); // works
						int castInt1 = genericCast(1); // fails in javac but works in Eclipse
						int castInt2 = X.<Integer> genericCast(1); // workaround for javac
						int castInt3 = (Integer) genericCast(1); // workaround for javac
					}
					private static <T> T genericCast(Object input) {
						@SuppressWarnings("unchecked")
						T castValue = (T) input;
						return castValue;
					}
				}""", // =================,
		},
		null,
		"",
		null,
		JavacTestOptions.EclipseJustification.EclipseBug151275);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=155753
public void test1025() {
	this.runConformTest(
		new String[] {
			"GenericBaseClass.java",
			"""
				public class GenericBaseClass<P, C> {
				  public GenericBaseClass() {
				    if (!(this instanceof ASubGenericClass)) {
				      System.out.println("I'm not ASubClass");
				    }
				  }
				}
				
				class ASubGenericClass extends GenericBaseClass<GenericBaseClass, GenericBaseClass> {
				  public ASubGenericClass() {
				    // This compiles with both
				    GenericBaseClass<GenericBaseClass, GenericBaseClass> hey = this;
				  }
				}""", // =================
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=155753
public void test1026() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				import java.util.LinkedHashSet;
				import java.util.Set;
				
				public class X {
				
				    public class A {};
				    public class B extends A {};
				
					public static void main(String[] args) {
				        X g = new X();
				        Set<A> set = g.newSet(g.new B());
				    }
				    public <T, V extends T> Set<T> newSet(V v) {
				        Set<T> set = new LinkedHashSet<T>();
				        set.add(v);
				        return set;
				    }
				}
				"""
		},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_7 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=155753 - variation
public void test1027() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			this.complianceLevel < ClassFileConstants.JDK1_7 ?
			"""
				import java.util.LinkedHashSet;
				import java.util.Set;
				
				public class X {
				
				    public class A {};
				    public class B extends A {};
				
				    public static void main(String[] args) {
				        X g = new X();
				        Set<A> set = g.newSet(g.new B());
				    }
				    public <T, V extends T> Set<T> newSet(V... objects) {
				        Set<T> set = new LinkedHashSet<T>();
				        for (T t : objects) {
				            set.add(t);
				        }
				        return set;
				    }
				}
				
				""" :
				"""
					import java.util.LinkedHashSet;
					import java.util.Set;
					
					public class X {
					
					    public class A {};
					    public class B extends A {};
					
					    public static void main(String[] args) {
					        X g = new X();
					        Set<A> set = g.newSet(g.new B());
					    }
					    @SuppressWarnings("unchecked")
					    public <T, V extends T> Set<T> newSet(V... objects) {
					        Set<T> set = new LinkedHashSet<T>();
					        for (T t : objects) {
					            set.add(t);
					        }
					        return set;
					    }
					}
					
					""", // =================, // =================
		},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_7 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=155753 - variation
public void test1028() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				import java.util.LinkedHashSet;
				import java.util.Set;
				
				public class X {
				
					public static void main(String[] args) {
				        X g = new X();
				        Set<A> set = g.newSet(new B());
				    }
				    public <T, V extends T> Set<T> newSet(V v) {
				        Set<T> set = new LinkedHashSet<T>();
				        set.add(v);
				        return set;
				    }
				}
				
				class A {};
				class B extends A {};
				""", // =================
		},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_7 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=156016
public void test1029() {
	Map options = getCompilerOptions();
	options.put(JavaCore.COMPILER_PB_UNCHECKED_TYPE_OPERATION, JavaCore.IGNORE);
	String xSource =
			"""
		import java.util.Arrays;
		import java.util.List;
		
		public class X {
		        public static <T extends Number> List<T> makeNumberList(T a, T b) {
		                return Arrays.asList(a, b);
		        }
		
		        public static void main(String... args) {
		                List<Number> name = makeNumberList(5, 5D);
		        }
		}""";
	if (this.complianceLevel < ClassFileConstants.JDK1_8) {
		this.runNegativeTest(
			new String[] {
				"X.java",
				xSource,
			},
			"----------\n" +
			"1. ERROR in X.java (at line 10)\n" +
			"	List<Number> name = makeNumberList(5, 5D);\n" +
			"	                    ^^^^^^^^^^^^^^^^^^^^^\n" +
			"Type mismatch: cannot convert from List<"+ intersection("Number", "Comparable<?>") +"> to List<Number>\n" +
			"----------\n",
			null,
			true,
			options);
	} else {
		runConformTest(new String[] { "X.java", xSource });
	}
}
public void test1030() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				
				public class X {
					public class PointList<W> extends Object implements Iterable<W> {
						private List<W> theList = new ArrayList<W>();
				
						public Iterator<W> iterator() {
							return theList.iterator();
						}
					}
				
					private PointList<Waypoint> waypoints = new PointList<Waypoint>();
				
					public void printWaypoints() {
						for (Waypoint waypoint : waypoints) { // ***** This line does not compile *****
							System.out.println(waypoint.toString());
						}
						for (Iterator<Waypoint> it = waypoints.iterator(); it.hasNext();) {
							Waypoint waypoint = it.next();
							System.out.println(waypoint.toString());
						}
					}
				}
				
				class Waypoint {}""", // =================
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=156765
// FAIL EXTRA ERR: outer non-generic invocation cannot yet feed expected type into inner inference
public void test1031() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.io.Serializable;
				
				interface IValue extends Serializable {
					public <T extends Comparable<? super T>> T getComparableValue();
				}
				
				@SuppressWarnings("null")
				public class X {
					public static void foo0() {
						IValue val1 = null;
						Object o = val1.getComparableValue(); // 0
					}
					public static void foo1() {
						IValue val1 = null;
						String s = val1.getComparableValue(); // 1
					}
					public static int foo2() {
						IValue val1 = null;
						IValue val2 = null;
						return val1.getComparableValue().compareTo(val2.getComparableValue()); // 2
					}\t
					public static int foo3() {
						Comparable<? super String> c = "aaa"; // 3
						Comparable<? super Object> o = new Object(); // 4
						return 0;
					}
				}""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 24)
				Comparable<? super Object> o = new Object(); // 4
				                               ^^^^^^^^^^^^
			Type mismatch: cannot convert from Object to Comparable<? super Object>
			----------
			""");
}
public void test1032() {
	runConformTest(
		// test directory preparation
		true /* flush output directory */,
		new String[] { /* test files */
			"X.java",
			"""
				import java.io.*;
				
				public class X {
					<T> T test(String name) {
				
						try {
							InputStream in = new FileInputStream(name);
							return (T) new ObjectInputStream(in).readObject();
						} catch (Exception e) {
						}
						return null;
					}
				
					<U> U text() {
						return test("data");
					}
				}""", // =================
		},
		// compiler results
		null /* do not check compiler log */,
		// runtime results
		"" /* expected output string */,
		"" /* expected error string */,
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_7 /* javac test options */);
}
public void test1032a() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.io.*;
				
				public class X {
					<T> T test(String name) {
				
						try {
							InputStream in = new FileInputStream(name);
							return (T) new ObjectInputStream(in).readObject();
						} catch (Exception e) {
						}
						return null;
					}
				
					<U> U text() {
						return test("data");
					}
					Zork z;
				}""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 8)
				return (T) new ObjectInputStream(in).readObject();
				       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from Object to T
			----------
			2. ERROR in X.java (at line 17)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
public void test1033() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {
					public static void main(String[] args) {
						X x = new X();
						x.bar1(Integer.TYPE);
						x.bar2(Integer.TYPE);
						x.bar2("");
					}\s
					 void bar1(Class<?>... classes) {}
					 void bar2(Class... classes) {}
					\s
				}""", // =================

		},
		"""
			----------
			1. WARNING in X.java (at line 3)
				X x = new X();
				^
			X is a raw type. References to generic type X<T> should be parameterized
			----------
			2. WARNING in X.java (at line 3)
				X x = new X();
				          ^
			X is a raw type. References to generic type X<T> should be parameterized
			----------
			3. WARNING in X.java (at line 4)
				x.bar1(Integer.TYPE);
				^^^^^^^^^^^^^^^^^^^^
			Type safety: The method bar1(Class...) belongs to the raw type X. References to generic type X<T> should be parameterized
			----------
			4. ERROR in X.java (at line 6)
				x.bar2("");
				  ^^^^
			The method bar2(Class...) in the type X is not applicable for the arguments (String)
			----------
			5. WARNING in X.java (at line 9)
				void bar2(Class... classes) {}
				          ^^^^^
			Class is a raw type. References to generic type Class<T> should be parameterized
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=158519
// FAIL ERRMSG
public void test1034() {
	this.runNegativeTest(
		new String[] {
			"ChainedClosure.java",
			"""
				interface Closure<I> {
				    public void execute(I input);
				}
				
				class ChainedClosure<I> implements Closure<I> {
				    private final Closure<? super I>[] iClosures;
				    @SuppressWarnings("unchecked")
				    public static <I> Closure<I> getInstance(Closure<? super I> closure1, Closure<? super I> closure2) {
				        if (closure1 == null || closure2 == null) {
				            throw new IllegalArgumentException("Closures must not be null");
				        }
				        Closure<I>[] closures = new Closure[] { closure1, closure2 };
				        return new ChainedClosure<I>(closures);
				    }
				    public ChainedClosure(Closure<? super I>[] closures) {
				        super();
				        iClosures = closures;
				    }
				    public void execute(I input) {
				        for (int i = 0; i < iClosures.length; i++) {
				            iClosures[i].execute(input);
				        }
				    }
				}
				class ClosureUtils {
				    public static <J> Closure<J> chainedClosure(Closure<? super J> closure1, Closure<? super J> closure2) {
				        return ChainedClosure.getInstance(closure1, closure2);
				    }
				    public static Closure<String> chainedClosure2(Closure<? super String> closure1, Closure<? super String> closure2) {
				        return ChainedClosure.getInstance(closure1, closure2);
				    }
				    public static <J> Closure<String> chainedClosure3(Closure<? super J> closure1, Closure<? super J> closure2) {
				        return ChainedClosure.getInstance(closure1, closure2);
				    }
				}""", // =================

		},
		this.complianceLevel < ClassFileConstants.JDK1_8 ?
		"""
			----------
			1. ERROR in ChainedClosure.java (at line 33)
				return ChainedClosure.getInstance(closure1, closure2);
				                      ^^^^^^^^^^^
			The method getInstance(Closure<? super I>, Closure<? super I>) in the type ChainedClosure is not applicable for the arguments (Closure<capture#10-of ? super J>, Closure<capture#11-of ? super J>)
			----------
			""" :
			"""
				----------
				1. ERROR in ChainedClosure.java (at line 33)
					return ChainedClosure.getInstance(closure1, closure2);
					       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Closure<capture#10-of ? super J & capture#11-of ? super J> to Closure<String>
				----------
				""",
		JavacTestOptions.DEFAULT);
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=158531
public void test1035() {
	this.runConformTest(
		new String[] {
			"ComparableComparator.java",
			"""
				import java.util.Comparator;
				
				@SuppressWarnings({"unchecked", "rawtypes"})
				class ComparableComparator<T extends Comparable<? super T>> implements Comparator<T> {
				
					static ComparableComparator instance = new ComparableComparator();
				
				public static <W extends Comparable<? super W>> ComparableComparator<W> getInstance() {
					return instance;
				}
				static <M extends Comparable<M>> Comparator<M> bar() {
					return null;
				}
				static <M extends String> Comparator<M> baz() {
					return null;
				}
				public int compare(T obj1, T obj2) {
					return obj1.compareTo(obj2);
				}
				}
				
				@SuppressWarnings({"unchecked", "rawtypes"})
				class ComparatorUtils {
				
					static Comparator BAR = ComparableComparator.bar();//0
					static Comparator NATURAL_COMPARATOR = ComparableComparator.getInstance();//1
					static Object BAR2 = ComparableComparator.bar();//1a
					static Comparator BAR3 = ComparableComparator.baz();//1b
				
				public static <T extends Comparable<? super T>> Comparator<T> naturalComparator() {
					return NATURAL_COMPARATOR;
				}
				
				public static <U> Comparator<U> nullLowComparator(Comparator<U> comparator) {
					if (comparator == null)
						comparator = (Comparator<U>) naturalComparator();//2
					return new NullComparator<U>(comparator, false);
				}
				}
				
				@SuppressWarnings("unchecked")
				class NullComparator<V> implements Comparator<V> {
				
					Comparator<V> nonNullComparator;
					boolean nullsAreHigh;
				
				public NullComparator() {
					this((Comparator<V>) ComparableComparator.getInstance(), true);//3
				}
				
				public NullComparator(Comparator<V> nonNullComparator) {
					this(nonNullComparator, true);
				}
				
				public NullComparator(boolean nullsAreHigh) {
					this((Comparator<V>) ComparableComparator.getInstance(), nullsAreHigh);//4
				}
				
				public NullComparator(Comparator<V> nonNullComparator, boolean nullsAreHigh) {
					this.nonNullComparator = nonNullComparator;
					this.nullsAreHigh = nullsAreHigh;
					if (nonNullComparator == null) {
						throw new NullPointerException("null nonNullComparator");
					}
				}
				
				public int compare(V obj1, V obj2) {
					return 0;
				}
				}""", // =================

		});
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=158548
public void test1036() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends String> {
				\t
					List<Zork> list;
					Map<Zork,Zork>.Entry<List<Zork>,List<Zork>>	entry;
					jaavaa.util.Map<Zork,Zork>.Entry<List<Zork>,List<Zork>>	entry2;
				\t
					p.q.Map.Entry entry3;
				\t
					String<Object>.Y<List> y; // wrong
					X<Object>.Y<List> y1; // wrong
					X<String>.Y<List> y2;
				}""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 1)
				public class X<T extends String> {
				                         ^^^^^^
			The type parameter T should not be bounded by the final type String. Final types cannot be further extended
			----------
			2. ERROR in X.java (at line 3)
				List<Zork> list;
				^^^^
			List cannot be resolved to a type
			----------
			3. ERROR in X.java (at line 3)
				List<Zork> list;
				     ^^^^
			Zork cannot be resolved to a type
			----------
			4. ERROR in X.java (at line 4)
				Map<Zork,Zork>.Entry<List<Zork>,List<Zork>>	entry;
				^^^
			Map cannot be resolved to a type
			----------
			5. ERROR in X.java (at line 4)
				Map<Zork,Zork>.Entry<List<Zork>,List<Zork>>	entry;
				    ^^^^
			Zork cannot be resolved to a type
			----------
			6. ERROR in X.java (at line 4)
				Map<Zork,Zork>.Entry<List<Zork>,List<Zork>>	entry;
				         ^^^^
			Zork cannot be resolved to a type
			----------
			7. ERROR in X.java (at line 4)
				Map<Zork,Zork>.Entry<List<Zork>,List<Zork>>	entry;
				                     ^^^^
			List cannot be resolved to a type
			----------
			8. ERROR in X.java (at line 4)
				Map<Zork,Zork>.Entry<List<Zork>,List<Zork>>	entry;
				                          ^^^^
			Zork cannot be resolved to a type
			----------
			9. ERROR in X.java (at line 4)
				Map<Zork,Zork>.Entry<List<Zork>,List<Zork>>	entry;
				                                ^^^^
			List cannot be resolved to a type
			----------
			10. ERROR in X.java (at line 4)
				Map<Zork,Zork>.Entry<List<Zork>,List<Zork>>	entry;
				                                     ^^^^
			Zork cannot be resolved to a type
			----------
			11. ERROR in X.java (at line 5)
				jaavaa.util.Map<Zork,Zork>.Entry<List<Zork>,List<Zork>>	entry2;
				^^^^^^
			jaavaa cannot be resolved to a type
			----------
			12. ERROR in X.java (at line 5)
				jaavaa.util.Map<Zork,Zork>.Entry<List<Zork>,List<Zork>>	entry2;
				                ^^^^
			Zork cannot be resolved to a type
			----------
			13. ERROR in X.java (at line 5)
				jaavaa.util.Map<Zork,Zork>.Entry<List<Zork>,List<Zork>>	entry2;
				                     ^^^^
			Zork cannot be resolved to a type
			----------
			14. ERROR in X.java (at line 5)
				jaavaa.util.Map<Zork,Zork>.Entry<List<Zork>,List<Zork>>	entry2;
				                                 ^^^^
			List cannot be resolved to a type
			----------
			15. ERROR in X.java (at line 5)
				jaavaa.util.Map<Zork,Zork>.Entry<List<Zork>,List<Zork>>	entry2;
				                                      ^^^^
			Zork cannot be resolved to a type
			----------
			16. ERROR in X.java (at line 5)
				jaavaa.util.Map<Zork,Zork>.Entry<List<Zork>,List<Zork>>	entry2;
				                                            ^^^^
			List cannot be resolved to a type
			----------
			17. ERROR in X.java (at line 5)
				jaavaa.util.Map<Zork,Zork>.Entry<List<Zork>,List<Zork>>	entry2;
				                                                 ^^^^
			Zork cannot be resolved to a type
			----------
			18. ERROR in X.java (at line 7)
				p.q.Map.Entry entry3;
				^
			p cannot be resolved to a type
			----------
			19. ERROR in X.java (at line 9)
				String<Object>.Y<List> y; // wrong
				^^^^^^
			The type String is not generic; it cannot be parameterized with arguments <Object>
			----------
			20. ERROR in X.java (at line 10)
				X<Object>.Y<List> y1; // wrong
				^^^^^^^^^^^
			X.Y cannot be resolved to a type
			----------
			21. ERROR in X.java (at line 10)
				X<Object>.Y<List> y1; // wrong
				  ^^^^^^
			Bound mismatch: The type Object is not a valid substitute for the bounded parameter <T extends String> of the type X<T>
			----------
			22. ERROR in X.java (at line 10)
				X<Object>.Y<List> y1; // wrong
				            ^^^^
			List cannot be resolved to a type
			----------
			23. ERROR in X.java (at line 11)
				X<String>.Y<List> y2;
				^^^^^^^^^^^
			X.Y cannot be resolved to a type
			----------
			24. ERROR in X.java (at line 11)
				X<String>.Y<List> y2;
				            ^^^^
			List cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=158548 - variation
public void test1037() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends String> {
				\t
					List<? extends Zork> list;
					Map.Entry<?,? super Zork>	entry;
				}""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 1)
				public class X<T extends String> {
				                         ^^^^^^
			The type parameter T should not be bounded by the final type String. Final types cannot be further extended
			----------
			2. ERROR in X.java (at line 3)
				List<? extends Zork> list;
				^^^^
			List cannot be resolved to a type
			----------
			3. ERROR in X.java (at line 3)
				List<? extends Zork> list;
				               ^^^^
			Zork cannot be resolved to a type
			----------
			4. ERROR in X.java (at line 4)
				Map.Entry<?,? super Zork>	entry;
				^^^
			Map cannot be resolved to a type
			----------
			5. ERROR in X.java (at line 4)
				Map.Entry<?,? super Zork>	entry;
				                    ^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=159021 - variation
public void test1038() throws Exception {
	Map options = getCompilerOptions();
	options.put(CompilerOptions.OPTION_PreserveUnusedLocal, CompilerOptions.OPTIMIZE_OUT);
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				interface I<T> {
				    int CONST = A.foo();
				}
				
				class A<U> {
				        static int foo() {
				        System.out.println("SUCCESS");
				        return 0;
				    }
				}
				class B<V> implements I<V> {
					static int LOCAL_STATIC;
					int local_field;
				    B(int param) {
				        int i = CONST; // keep for possible <clinit>
				        int j = param; // may optimize out
				        int k = LOCAL_STATIC; // may optimize out
				        int l = local_field; // may optimize out
				    }
				}
				public class X {
				    public static void main(String[] args) {
				        new B<String>(12);
				    }
				}""", // =================
		},
		"SUCCESS",
		null,
		false,
		null,
		options,
		null);
	// check the reference to I.CONST still got generated (for <clinit> invocation side-effect)
	String expectedOutput =
		"""
		  // Method descriptor #10 (I)V
		  // Stack: 1, Locals: 2
		  B(int param);
		    0  aload_0 [this]
		    1  invokespecial java.lang.Object() [12]
		    4  getstatic B.CONST : int [15]
		    7  pop
		    8  return
		      Line numbers:
		        [pc: 0, line: 14]
		        [pc: 4, line: 15]
		        [pc: 8, line: 19]
		      Local variable table:
		        [pc: 0, pc: 9] local: this index: 0 type: B
		        [pc: 0, pc: 9] local: param index: 1 type: int
		""";

	File f = new File(OUTPUT_DIR + File.separator + "B.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=159021 - variation
public void test1039() throws Exception {
	Map options = getCompilerOptions();
	options.put(CompilerOptions.OPTION_PreserveUnusedLocal, CompilerOptions.OPTIMIZE_OUT);
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				interface I<T> {
					Value<String> CONST = A.foo("[I.CONST]");
				}
				class Value<V> {
					static String NAME = "";
					V v;
					Value(V v) {
						this.v = v;
					}
				}
				class A {
					static Value<String> foo(String str) {
						System.out.print(str);
						return new Value<String>("str");
					}
				}
				class B<V> implements I<V> {
					static Value<String> LOCAL_STATIC = A.foo("[B.LOCAL_STATIC]");
					Value<String> local_field = A.foo("[B.local_field]");
					B(Value<String> param) {
						String i = CONST.NAME; // keep for possible <clinit>
						String j = param.NAME; // may optimize out
						String k = LOCAL_STATIC.NAME; // may optimize out
						String l = local_field.NAME; // may optimize out
					}
				}
				public class X {
					public static void main(String[] args) {
						new B<String>(new Value<String>("[PARAM]"));
					}
				}""", // =================
		},
		"[B.LOCAL_STATIC][B.local_field][I.CONST]",
		null,
		false,
		null,
		options,
		null);
	// check the reference to I.CONST still got generated (for <clinit> invocation side-effect)
	String expectedOutput =
		"""
		  // Method descriptor #28 (LValue;)V
		  // Signature: (LValue<Ljava/lang/String;>;)V
		  // Stack: 2, Locals: 2
		  B(Value param);
		     0  aload_0 [this]
		     1  invokespecial java.lang.Object() [30]
		     4  aload_0 [this]
		     5  ldc <String "[B.local_field]"> [32]
		     7  invokestatic A.foo(java.lang.String) : Value [17]
		    10  putfield B.local_field : Value [34]
		    13  getstatic B.CONST : Value [36]
		    16  pop
		    17  getstatic Value.NAME : java.lang.String [39]
		    20  pop
		    21  getstatic Value.NAME : java.lang.String [39]
		    24  pop
		    25  getstatic Value.NAME : java.lang.String [39]
		    28  pop
		    29  getstatic Value.NAME : java.lang.String [39]
		    32  pop
		    33  return
		      Line numbers:
		        [pc: 0, line: 20]
		        [pc: 4, line: 19]
		        [pc: 13, line: 21]
		        [pc: 21, line: 22]
		        [pc: 25, line: 23]
		        [pc: 29, line: 24]
		        [pc: 33, line: 25]
		      Local variable table:
		        [pc: 0, pc: 34] local: this index: 0 type: B
		        [pc: 0, pc: 34] local: param index: 1 type: Value
		""";

	File f = new File(OUTPUT_DIR + File.separator + "B.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=159021 - variation
public void test1040() throws Exception {
	Map options = getCompilerOptions();
	options.put(CompilerOptions.OPTION_PreserveUnusedLocal, CompilerOptions.OPTIMIZE_OUT);
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				interface I<T> {
					Value<String> CONST = A.foo("[I.CONST]");
				}
				class Value<V> {
					static String NAME = "";
					V v;
					Value(V v) {
						this.v = v;
					}
				}
				class A {
					static Value<String> foo(String str) {
						System.out.print(str);
						return new Value<String>("str");
					}
				}
				class B<V> implements I<V> {
					static Value<String> LOCAL_STATIC = A.foo("[B.LOCAL_STATIC]");
					Value<String> local_field = A.foo("[B.local_field]");
					B(Value<String> param) {
						String i = this.CONST.NAME; // keep for possible <clinit>
						String k = this.LOCAL_STATIC.NAME; // may optimize out
						String l = this.local_field.NAME; // may optimize out
					}
				}
				public class X {
					public static void main(String[] args) {
						new B<String>(new Value<String>("[PARAM]"));
					}
				}""", // =================
		},
		"[B.LOCAL_STATIC][B.local_field][I.CONST]",
		null,
		false,
		null,
		options,
		null);
	// check the reference to I.CONST still got generated (for <clinit> invocation side-effect)
	String expectedOutput =
		"""
		  // Method descriptor #28 (LValue;)V
		  // Signature: (LValue<Ljava/lang/String;>;)V
		  // Stack: 2, Locals: 2
		  B(Value param);
		     0  aload_0 [this]
		     1  invokespecial java.lang.Object() [30]
		     4  aload_0 [this]
		     5  ldc <String "[B.local_field]"> [32]
		     7  invokestatic A.foo(java.lang.String) : Value [17]
		    10  putfield B.local_field : Value [34]
		    13  getstatic B.CONST : Value [36]
		    16  pop
		    17  getstatic Value.NAME : java.lang.String [39]
		    20  pop
		    21  getstatic Value.NAME : java.lang.String [39]
		    24  pop
		    25  getstatic Value.NAME : java.lang.String [39]
		    28  pop
		    29  return
		      Line numbers:
		        [pc: 0, line: 20]
		        [pc: 4, line: 19]
		        [pc: 13, line: 21]
		        [pc: 21, line: 22]
		        [pc: 25, line: 23]
		        [pc: 29, line: 24]
		      Local variable table:
		        [pc: 0, pc: 30] local: this index: 0 type: B
		        [pc: 0, pc: 30] local: param index: 1 type: Value
		""";

	File f = new File(OUTPUT_DIR + File.separator + "B.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=159245
public void test1041() {
	this.runNegativeTest(
		new String[] {
			"p/X.java",
			"""
				package p;
				
				public class X<T> {
					{
						X rawx = null;
						X[] rawxs = { rawx };
						System.out.println(rawxs.length);
					}
					{
						p.X rawx = null;
						p.X[] rawxs = { rawx };
						System.out.println(rawxs.length);
					}
					Zork z;
				}""", // =================
		},
		"""
			----------
			1. WARNING in p\\X.java (at line 5)
				X rawx = null;
				^
			X is a raw type. References to generic type X<T> should be parameterized
			----------
			2. WARNING in p\\X.java (at line 6)
				X[] rawxs = { rawx };
				^
			X is a raw type. References to generic type X<T> should be parameterized
			----------
			3. WARNING in p\\X.java (at line 10)
				p.X rawx = null;
				^^^
			X is a raw type. References to generic type X<T> should be parameterized
			----------
			4. WARNING in p\\X.java (at line 11)
				p.X[] rawxs = { rawx };
				^^^
			X is a raw type. References to generic type X<T> should be parameterized
			----------
			5. ERROR in p\\X.java (at line 14)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=159818
public void test1042() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public <T extends Object> void foo(T x) {
					    Class<? extends T> c = x.getClass();
					}
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 3)
				Class<? extends T> c = x.getClass();
				                       ^^^^^^^^^^^^
			Type mismatch: cannot convert from Class<capture#1-of ? extends Object> to Class<? extends T>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=159214
public void test1043() {
	this.runNegativeTest(
		new String[] {
			"A.java",
			"""
				class A<T extends Number, S extends T> {
				  T t;
				  S s;
				  void test(A<? extends Long, ? extends S> a) {
				    this.t = this.s; //fine
				    a.t = a.s;
				  }
				}""", // =================
		},
		"""
			----------
			1. ERROR in A.java (at line 6)
				a.t = a.s;
				      ^^^
			Type mismatch: cannot convert from capture#4-of ? extends S to capture#1-of ? extends Long
			----------
			""",
		JavacTestOptions.EclipseJustification.EclipseBug159214);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=159214 - variation
public void test1044() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				class X<T extends Number> {
				    X<? extends Object> x;
				}""", // =================
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=159214 - variation
public void test1045() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				class X<T extends Number, S extends T> {
				        X<? extends Long,? extends S> x;
				}""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=160132
public void test1046() {
	this.runConformTest(
		new String[] {
			"X.java", //========================
			"""
				public interface X<E extends Object & X.Entry> {
				  interface Entry {
				    interface Internal extends Entry {
				      Internal createEntry();
				    }
				  }
				}
				""", //========================
			"Y.java",
			"""
				public class Y implements X.Entry.Internal {
				  public Internal createEntry() {
				    return null;
				  }
				}
				""" , //========================
		},
		"");
	// compile Y against X binary
	this.runConformTest(
			new String[] {
				"Y.java", //========================
				"""
					public class Y implements X.Entry.Internal {
					  public Internal createEntry() {
					    return null;
					  }
					}
					""" , //========================
			},
			"",
			null,
			false,
			null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=160132 - variation
public void test1047() {
	this.runConformTest(
		new String[] {
			"p/X.java", //========================
			"""
				package p;
				public interface X<E extends Object & X.Entry> {
				  interface Entry {
				    interface Internal extends Entry {
				      Internal createEntry();
				    }
				  }
				}
				""", //========================
			"Y.java",
			"""
				import p.X.Entry.Internal;
				public class Y implements Internal {
				  public Internal createEntry() {
				    return null;
				  }
				}
				""" , //========================
		},
		"");
	// compile Y against X binary
	this.runConformTest(
			new String[] {
				"Y.java", //========================
				"""
					import p.X.Entry.Internal;
					public class Y implements Internal {
					  public Internal createEntry() {
					    return null;
					  }
					}
					""" , //========================
			},
			"",
			null,
			false,
			null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=160132 - variation
public void test1048() {
	this.runConformTest(
		new String[] {
			"X.java", //========================
			"""
				public interface X {
				  static class Entry {
				    static abstract class Internal extends Entry {
				      abstract Internal createEntry();
				    }
				  }
				}
				""", //========================
			"Y.java",
			"""
				public class Y extends  X.Entry.Internal {
				  @Override public Internal createEntry() {
				    return null;
				  }
				}
				""" , //========================
		},
		"");
	// compile Y against X binary
	this.runConformTest(
			new String[] {
				"Y.java", //========================
				"""
					public class Y extends X.Entry.Internal {
					  @Override public Internal createEntry() {
					    return null;
					  }
					}
					""" , //========================
			},
			"",
			null,
			false,
			null);
}
public void test1049() {
	this.runConformTest(
		new String[] {
			"X.java", //========================
			"""
				import java.util.*;
				public class X {
				}
				
				//===================
				interface FooHandle<T extends Foo<T>> extends BarHandle<T> {}
				interface Foo<T extends Foo<T>> extends FooHandle<T>, Bar<T> {
					FooHandle<T> foo();
				}
				//===================
				interface EveHandle<T extends Baz<T>> extends SimpleHandle {}
				interface Eve<T extends Baz<T>> extends Simple, EveHandle<T> {
					List<BobHandle> foo();
					BazHandle<T> handles();
				}
				
				//===================
				interface BobHandle extends BillHandle {}
				interface Bob extends BobHandle, Bill {}
				
				//===================
				interface BarHandle<T extends Bar<T>> extends BazHandle<T> {
					boolean same(BarHandle<?> o);
				}
				interface Bar<T extends Bar<T>> extends Baz<T>, BarHandle<T> {
					BarHandle<T> handle();
				}
				
				//===================
				interface BazHandle<T extends Baz<T>> {
					T baz();
					boolean same(BazHandle<?> o);
				}
				interface Baz<T extends Baz<T>> extends BazHandle<T> {
					BazHandle<T> handle();
					T baz();
				}
				
				//===================
				interface BillHandle extends FooHandle<Bill> {}
				interface Bill extends BillHandle, Foo<Bill> {}
				
				//===================
				interface SimpleHandle extends BazHandle<Simple> {}
				interface Simple extends Baz<Simple>, SimpleHandle {}
				
				//===================
				interface KeyHandle extends FooHandle<Key> {}
				interface Key extends Foo<Key>, KeyHandle {}
				
				//===================
				interface ClydeHandle extends BillHandle {}
				interface Clyde extends ClydeHandle, Bill {
					void add(BobHandle h);
					public List<BobHandle> handles();
				}
				
				//===================
				interface FredHandle<T extends Fred<T>> extends BarHandle<T> {}
				interface Fred<T extends Fred<T>> extends FredHandle<T>, Bar<T> {}
				
				""", // =================
		},
		"");
}
public void test1050() {
	String expectedOutput =
		"""
		xxx
		true
		ClassCastException: Object[] cannot be cast to String[]
		ClassCastException: Object[] cannot be cast to String[]""";

	this.runConformTest(
		new String[] {
			"X.java", //========================
			"""
				class Container<E> {
				  public Container() {
				    data = (E[]) new Object[100];
				  }
				  protected E[] data;
				  protected int size;
				  E get(int index) {
				    return data[index];
				  }
				  void add(E object) {
				    data[size++] = object;
				  }
				  E[] data() {
				    return data;
				  }
				}
				class StringContainer extends Container<String> {
				  public StringContainer() {
				  }
				  public void doSomething() {
				    add("xxx");
				    System.out.println(get(0));
				    System.out.println(("" + data()).
				      startsWith("[Ljava.lang.Object;@"));
				    try {
				      System.out.println(data[0]);
				    } catch (ClassCastException e) {
				      System.out.println("ClassCastException: Object[] cannot be cast to String[]");
				    }
				    try {
				      System.out.println(data()[0]);
				    } catch (ClassCastException e) {
				      System.out.println("ClassCastException: Object[] cannot be cast to String[]");
				    }
				  }
				}
				public class X {
				  public static void main(String[] args) {
				    StringContainer x = new StringContainer();
				    x.doSomething();
				  }
				}""", // =================
		},
		expectedOutput);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=114088
public void test1051() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.List;
				
				public class X {
					public interface Intf<N> {
						void foo(List<Conc<N>.Inner> ls);
					}
				
					public class Conc<N> {
						Intf<N> impl;
						public Conc(Intf<N> impl) {
							this.impl = impl;
						}
						public class Inner { }
				
						public void bar(List<Conc<N>.Inner> ls) {
							impl.foo(ls);
						}
					}
				}""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=115691
public void test1052() {
	Map options = getCompilerOptions();
	options.put(CompilerOptions.OPTION_ReportUncheckedTypeOperation, CompilerOptions.ERROR);
	options.put(CompilerOptions.OPTION_ReportRawTypeReference, CompilerOptions.ERROR);
	options.put(CompilerOptions.OPTION_ReportUnnecessaryTypeCheck, CompilerOptions.ERROR);
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X extends java.util.ArrayList<Integer> {
					private static final long serialVersionUID = 713223190582506215L;
					static void test() {
						java.util.ArrayList<?> a1 = new X();
						X b1 = (X) a1;
						X c1 = X.class.cast(a1);
						java.util.ArrayList<Integer> a2 = new X();
						X b2 = (X) a2;
					}
				}""",
		},
		"",
		null,
		true,
		null,
		options,
		null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=122163
public void test1053() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				class X<V,R> {
				    class innerclass {
				        void foo() {
				            X<V,R> c = X.this;
				        }
				    }
				}""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=142935
public void test1054() {
	Map customOptions = getCompilerOptions();
	// check no unsafe type operation problem is issued
	customOptions.put(CompilerOptions.OPTION_ReportUncheckedTypeOperation, CompilerOptions.IGNORE);
	customOptions.put(CompilerOptions.OPTION_ReportRawTypeReference, CompilerOptions.IGNORE);
	String expectedOutput =
		"""
		----------
		1. ERROR in X.java (at line 11)
			Bar bar= clazz.getAnnotation(Bar.class);
			         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
		Type mismatch: cannot convert from Annotation to Bar
		----------
		""";
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.lang.annotation.Retention;
				import java.lang.annotation.RetentionPolicy;
				import java.lang.reflect.Method;
				
				@Bar
				public class X {
				
				        @Bar
				        public void bar() throws Exception {
				                Class clazz= X.class;
				                Bar bar= clazz.getAnnotation(Bar.class);
				                Method method= clazz.getMethod("bar");
				                Bar bar2= method.getAnnotation(Bar.class);
				        }
				}
				
				@Retention(RetentionPolicy.RUNTIME)
				@interface Bar {
				}""",
		},
		expectedOutput,
		null,
		true,
		customOptions);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=142935
public void test1055() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.lang.annotation.Retention;
				import java.lang.annotation.RetentionPolicy;
				import java.lang.reflect.Method;
				
				@Bar
				public class X {
				
				        @Bar
				        public void bar() throws Exception {
				                Class<X> clazz= X.class;
				                Bar bar= clazz.getAnnotation(Bar.class);
				                Method method= clazz.getMethod("bar");
				                Bar bar2= method.getAnnotation(Bar.class);
				        }
				}
				
				@Retention(RetentionPolicy.RUNTIME)
				@interface Bar {
				}""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=162400
public void test1056() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X {
					static <T> T foo() {
						return null;
					}
					public static void main(String[] args) {
						String[] s = { foo() };
					}\t
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=159738
public void test1057() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.Map;
				
				class GenericType<E extends Object & Comparable<E> & Map.Entry<String, E>> {
					public void doSomething(E e) {
						System.out.println(e.compareTo(e.getValue()));
					}
				}
				class ConcreteType {
					public void doSomething(Object obj) {
						System.out.println(((Comparable) obj).compareTo(((Map.Entry) obj).getValue()));
					}
				}
				public class X {
					public static void main(String[] args) {
						try {
							new GenericType().doSomething("a1");
						} catch (Throwable e) {
							System.out.print("[" + e.getClass().getSimpleName() + ":1]");
						}
						try {
							new ConcreteType().doSomething("a2");
						} catch (Throwable e) {
							System.out.print("[" + e.getClass().getSimpleName() + ":2]");
						}
					}
				}
				""", // =================,
		},
		"[ClassCastException:1][ClassCastException:2]");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=141289
public void test1058() throws Exception {
	runConformTest(
		// test directory preparation
		true /* flush output directory */,
		new String[] { /* test files */
			"X.java", // =================
			"""
				public class X {
				        public static void main(String[] args) {
				        	try {
				                int foo = 0;
				                String bar = "zero";
				                System.out.println((foo != 0 ? foo : bar).compareTo(null));
				        	} catch(NullPointerException e) {
				        		System.out.println("SUCCESS");
				        	}
				        }
				}""", // =================
		},
		// compiler results
		"" /* expected compiler log */,
		// runtime results
		"SUCCESS" /* expected output string */,
		"" /* expected error string */,
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
	String expectedOutput =
		"""
		  // Method descriptor #15 ([Ljava/lang/String;)V
		  // Stack: 3, Locals: 3
		  public static void main(java.lang.String[] args);
		     0  iconst_0
		     1  istore_1 [foo]
		     2  ldc <String "zero"> [16]
		     4  astore_2 [bar]
		     5  getstatic java.lang.System.out : java.io.PrintStream [18]
		     8  iload_1 [foo]
		     9  ifeq 19
		    12  iload_1 [foo]
		    13  invokestatic java.lang.Integer.valueOf(int) : java.lang.Integer [24]
		    16  goto 20
		    19  aload_2 [bar]
		    20  aconst_null
		    21  invokeinterface java.lang.Comparable.compareTo(java.lang.Object) : int [30] [nargs: 2]
		    26  invokevirtual java.io.PrintStream.println(int) : void [36]
		    29  goto 41
		    32  astore_1 [e]
		    33  getstatic java.lang.System.out : java.io.PrintStream [18]
		    36  ldc <String "SUCCESS"> [42]
		    38  invokevirtual java.io.PrintStream.println(java.lang.String) : void [44]
		    41  return
		      Exception Table:
		        [pc: 0, pc: 29] -> 32 when : java.lang.NullPointerException
		      Line numbers:
		        [pc: 0, line: 4]
		        [pc: 2, line: 5]
		        [pc: 5, line: 6]
		        [pc: 29, line: 7]
		        [pc: 33, line: 8]
		        [pc: 41, line: 10]
		      Local variable table:
		        [pc: 0, pc: 42] local: args index: 0 type: java.lang.String[]
		        [pc: 2, pc: 29] local: foo index: 1 type: int
		        [pc: 5, pc: 29] local: bar index: 2 type: java.lang.String
		        [pc: 33, pc: 41] local: e index: 1 type: java.lang.NullPointerException
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=160795
public void test1059() {
	this.runNegativeTest(
		new String[] {
			"A.java", // =================
			"""
				class A<T> {
				    <S> S test(A<S> a) {
				        return null;
				    }
				
				    void m() {
				        A<?> a = null;
				        Number b = test(a);
				    }
				}""", // =================
		},
		"""
			----------
			1. ERROR in A.java (at line 8)
				Number b = test(a);
				           ^^^^^^^
			Type mismatch: cannot convert from capture#1-of ? to Number
			----------
			""");
}
// See corresponding FIXME in TypeBinding.isTypeArgumentContainedBy(..)
public void test1060() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java", // =================
			"""
				import java.util.Collection;
				import java.util.List;
				
				public class X {
				    public static <B> void m(List<? super B> list,Collection<? super B> coll) {
				        m(list,coll);
				    }
				}""", // =================
		},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_7 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=159752
public void test1061() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"predicate/Predicate.java", // =================
			"""
				package predicate;
				public interface Predicate<T> {
					public boolean evaluate(T object);
				}
				final class AndPredicate<T> implements Predicate<T> {
					private final Predicate<? super T> iPredicate1;
					private final Predicate<? super T> iPredicate2;
					public static <T> Predicate<T> getInstance(Predicate<? super T> predicate1,
							Predicate<? super T> predicate2) {
						if (predicate1 == null || predicate2 == null) {
							throw new IllegalArgumentException("Predicate must not be null");
						}
						return new AndPredicate<T>(predicate1, predicate2);
					}
					public AndPredicate(Predicate<? super T> predicate1,
							Predicate<? super T> predicate2) {
						super();
						iPredicate1 = predicate1;
						iPredicate2 = predicate2;
					}
					public boolean evaluate(T object) {
						return iPredicate1.evaluate(object) && iPredicate2.evaluate(object);
					}
				}
				class PredicateUtils {
				
					public static <T> Predicate<T> andPredicate(
							Predicate<? super T> predicate1, Predicate<? super T> predicate2) {
						return AndPredicate.getInstance(predicate1, predicate2);
					}
				}""", // =================
		},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_7 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=148041
public void test1062() {
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				import java.util.HashSet;
				import java.util.Iterator;
				import java.util.Set;
				
				public class X {
					public static void main(String[] args) {
						Set<X> set = new HashSet<X>();
						for (Iterator<X> iterator = set.iterator(); iterator.hasNext();) {
							Set<X> element1 = iterator.next();
							Set<X> element2 = (Set<X>) iterator.next(); // warning
						}
					}
				}""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 9)
				Set<X> element1 = iterator.next();
				                  ^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from X to Set<X>
			----------
			2. WARNING in X.java (at line 10)
				Set<X> element2 = (Set<X>) iterator.next(); // warning
				                  ^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from X to Set<X>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=148041 - variation
public void test1063() {
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				import java.util.HashSet;
				import java.util.Iterator;
				import java.util.Set;
				
				public class X {
					public static void main(String[] args) {
						Set<Cloneable> set = new HashSet<Cloneable>();
						for (Iterator<Cloneable> iterator = set.iterator(); iterator.hasNext();) {
							Set<Cloneable> element1 = iterator.next();
							Set<Cloneable> element2 = (Set<Cloneable>) iterator.next(); // warning
						}
					}
				}""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 9)
				Set<Cloneable> element1 = iterator.next();
				                          ^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from Cloneable to Set<Cloneable>
			----------
			2. WARNING in X.java (at line 10)
				Set<Cloneable> element2 = (Set<Cloneable>) iterator.next(); // warning
				                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from Cloneable to Set<Cloneable>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=148041 - variation
public void test1064() {
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				import java.util.HashSet;
				import java.util.Iterator;
				
				public class X {
					public static void main(String[] args) {
						HashSet<X> set = new HashSet<X>();
						for (Iterator<X> iterator = set.iterator(); iterator.hasNext();) {
							HashSet<X> element1 = iterator.next();
							HashSet<X> element2 = (HashSet<X>) iterator.next();
						}
					}
				}""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 8)
				HashSet<X> element1 = iterator.next();
				                      ^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from X to HashSet<X>
			----------
			2. ERROR in X.java (at line 9)
				HashSet<X> element2 = (HashSet<X>) iterator.next();
				                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Cannot cast from X to HashSet<X>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=141289 - variation
public void test1065() throws Exception {
	runConformTest(
		// test directory preparation
		true /* flush output directory */,
		new String[] { /* test files */
			"X.java", // =================
			"""
				public class X {
					void testFoo(boolean t, A a, B b) {
						System.out.print((t ? a : b).foo());
					}
					void testBar(boolean t, A a, B b) {
						System.out.print((t ? a : b).bar());
					}
					public static void main(String[] args) {
						X x = new X();
						A a = new A();
						B b = new B();
						x.testFoo(true, a, b);
						x.testFoo(false, a, b);
						x.testBar(true, a, b);
						x.testBar(false, a, b);
					}
				}
				interface Foo { 	String foo(); }
				interface Bar { String bar(); }
				class A implements Foo, Bar {
					public String foo() { return "[A#foo()]"; }
					public String bar() { return "[A#bar()]"; }
				}
				class B implements Foo, Bar {
					public String foo() { return "[B#foo()]"; }
					public String bar() { return "[B#bar()]"; }
				}
				""", // =================
		},
		// compiler results
		"" /* expected compiler log */,
		// runtime results
		"[A#foo()][B#foo()][A#bar()][B#bar()]" /* expected output string */,
		"" /* expected error string */,
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
	// 	check presence of checkcast in #testFoo() and #testBar()
	String expectedOutput = this.complianceLevel == ClassFileConstants.JDK1_5
			?	"""
				  // Method descriptor #15 (ZLA;LB;)V
				  // Stack: 2, Locals: 4
				  void testFoo(boolean t, A a, B b);
				     0  getstatic java.lang.System.out : java.io.PrintStream [16]
				     3  iload_1 [t]
				     4  ifeq 11
				     7  aload_2 [a]
				     8  goto 12
				    11  aload_3 [b]
				    12  invokeinterface Foo.foo() : java.lang.String [22] [nargs: 1]
				    17  invokevirtual java.io.PrintStream.print(java.lang.String) : void [28]
				    20  return
				      Line numbers:
				        [pc: 0, line: 3]
				        [pc: 20, line: 4]
				      Local variable table:
				        [pc: 0, pc: 21] local: this index: 0 type: X
				        [pc: 0, pc: 21] local: t index: 1 type: boolean
				        [pc: 0, pc: 21] local: a index: 2 type: A
				        [pc: 0, pc: 21] local: b index: 3 type: B
				 \s
				  // Method descriptor #15 (ZLA;LB;)V
				  // Stack: 2, Locals: 4
				  void testBar(boolean t, A a, B b);
				     0  getstatic java.lang.System.out : java.io.PrintStream [16]
				     3  iload_1 [t]
				     4  ifeq 11
				     7  aload_2 [a]
				     8  goto 12
				    11  aload_3 [b]
				    12  checkcast Bar [41]
				    15  invokeinterface Bar.bar() : java.lang.String [43] [nargs: 1]
				    20  invokevirtual java.io.PrintStream.print(java.lang.String) : void [28]
				    23  return
				      Line numbers:
				        [pc: 0, line: 6]
				        [pc: 23, line: 7]
				      Local variable table:
				        [pc: 0, pc: 24] local: this index: 0 type: X
				        [pc: 0, pc: 24] local: t index: 1 type: boolean
				        [pc: 0, pc: 24] local: a index: 2 type: A
				        [pc: 0, pc: 24] local: b index: 3 type: B
				"""
			:	"""
				  // Method descriptor #15 (ZLA;LB;)V
				  // Stack: 2, Locals: 4
				  void testFoo(boolean t, A a, B b);
				     0  getstatic java.lang.System.out : java.io.PrintStream [16]
				     3  iload_1 [t]
				     4  ifeq 11
				     7  aload_2 [a]
				     8  goto 12
				    11  aload_3 [b]
				    12  invokeinterface Foo.foo() : java.lang.String [22] [nargs: 1]
				    17  invokevirtual java.io.PrintStream.print(java.lang.String) : void [28]
				    20  return
				      Line numbers:
				        [pc: 0, line: 3]
				        [pc: 20, line: 4]
				      Local variable table:
				        [pc: 0, pc: 21] local: this index: 0 type: X
				        [pc: 0, pc: 21] local: t index: 1 type: boolean
				        [pc: 0, pc: 21] local: a index: 2 type: A
				        [pc: 0, pc: 21] local: b index: 3 type: B
				      Stack map table: number of frames 2
				        [pc: 11, same_locals_1_stack_item, stack: {java.io.PrintStream}]
				        [pc: 12, full, stack: {java.io.PrintStream, Foo}, locals: {X, int, A, B}]
				 \s
				  // Method descriptor #15 (ZLA;LB;)V
				  // Stack: 2, Locals: 4
				  void testBar(boolean t, A a, B b);
				     0  getstatic java.lang.System.out : java.io.PrintStream [16]
				     3  iload_1 [t]
				     4  ifeq 11
				     7  aload_2 [a]
				     8  goto 12
				    11  aload_3 [b]
				    12  checkcast Bar [46]
				    15  invokeinterface Bar.bar() : java.lang.String [48] [nargs: 1]
				    20  invokevirtual java.io.PrintStream.print(java.lang.String) : void [28]
				    23  return
				      Line numbers:
				        [pc: 0, line: 6]
				        [pc: 23, line: 7]
				      Local variable table:
				        [pc: 0, pc: 24] local: this index: 0 type: X
				        [pc: 0, pc: 24] local: t index: 1 type: boolean
				        [pc: 0, pc: 24] local: a index: 2 type: A
				        [pc: 0, pc: 24] local: b index: 3 type: B
				      Stack map table: number of frames 2
				        [pc: 11, same_locals_1_stack_item, stack: {java.io.PrintStream}]
				        [pc: 12, full, stack: {java.io.PrintStream, Foo}, locals: {X, int, A, B}]
				""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=141289 - variation
public void test1066() throws Exception {
	this.runConformTest(
		new String[] {
			"X.java", // =================
			"""
				import java.util.*;
				public class X {
					public static void main(String[] args) {
						X x = new X();
						List l = new ArrayList();
						l.add("zork");
						List<A> la = l;
						List<B> lb = l;
						boolean t = true, f = false;
						try {
							System.out.print((t ? la.get(0) : lb.get(0)).foo());
						} catch (Throwable e) {
							System.out.print("[" + e.getClass().getSimpleName() + ":foo(1)]");
						}	\t
						try {
							System.out.print((f ? la.get(0) : lb.get(0)).foo());
						} catch (Throwable e) {
							System.out.print("[" + e.getClass().getSimpleName() + ":foo(2)]");
						}	\t
						try {
							System.out.print((t ? la.get(0) : lb.get(0)).bar());
						} catch (Throwable e) {
							System.out.print("[" + e.getClass().getSimpleName() + ":bar(1)]");
						}	\t
						try {
							System.out.print((f ? la.get(0) : lb.get(0)).bar());
						} catch (Throwable e) {
							System.out.print("[" + e.getClass().getSimpleName() + ":bar(2)]");
						}	\t
					}
				}
				interface Foo { 	String foo(); }
				interface Bar { String bar(); }
				abstract class A implements Foo, Bar { }
				abstract class B implements Foo, Bar { }
				""", // =================
		},
		"[ClassCastException:foo(1)][ClassCastException:foo(2)][ClassCastException:bar(1)][ClassCastException:bar(2)]");
	// 	check presence of checkcast
	String expectedOutput;
	if (this.complianceLevel >= ClassFileConstants.JDK9) {
		expectedOutput = """
			  // Stack: 3, Locals: 8
			  public static void main(java.lang.String[] args);
			      0  new X [1]
			      3  dup
			      4  invokespecial X() [16]
			      7  astore_1 [x]
			      8  new java.util.ArrayList [17]
			     11  dup
			     12  invokespecial java.util.ArrayList() [19]
			     15  astore_2 [l]
			     16  aload_2 [l]
			     17  ldc <String "zork"> [20]
			     19  invokeinterface java.util.List.add(java.lang.Object) : boolean [22] [nargs: 2]
			     24  pop
			     25  aload_2 [l]
			     26  astore_3 [la]
			     27  aload_2 [l]
			     28  astore 4 [lb]
			     30  iconst_1
			     31  istore 5 [t]
			     33  iconst_0
			     34  istore 6 [f]
			     36  getstatic java.lang.System.out : java.io.PrintStream [28]
			     39  iload 5 [t]
			     41  ifeq 57
			     44  aload_3 [la]
			     45  iconst_0
			     46  invokeinterface java.util.List.get(int) : java.lang.Object [34] [nargs: 2]
			     51  checkcast Foo [38]
			     54  goto 68
			     57  aload 4 [lb]
			     59  iconst_0
			     60  invokeinterface java.util.List.get(int) : java.lang.Object [34] [nargs: 2]
			     65  checkcast Foo [38]
			     68  invokeinterface Foo.foo() : java.lang.String [40] [nargs: 1]
			     73  invokevirtual java.io.PrintStream.print(java.lang.String) : void [44]
			     76  goto 100
			     79  astore 7 [e]
			     81  getstatic java.lang.System.out : java.io.PrintStream [28]
			     84  aload 7 [e]
			     86  invokevirtual java.lang.Object.getClass() : java.lang.Class [50]
			     89  invokevirtual java.lang.Class.getSimpleName() : java.lang.String [54]
			     92  invokedynamic 0 makeConcatWithConstants(java.lang.String) : java.lang.String [59]
			     97  invokevirtual java.io.PrintStream.print(java.lang.String) : void [44]
			    100  getstatic java.lang.System.out : java.io.PrintStream [28]
			    103  iload 6 [f]
			    105  ifeq 121
			    108  aload_3 [la]
			    109  iconst_0
			    110  invokeinterface java.util.List.get(int) : java.lang.Object [34] [nargs: 2]
			    115  checkcast Foo [38]
			    118  goto 132
			    121  aload 4 [lb]
			    123  iconst_0
			    124  invokeinterface java.util.List.get(int) : java.lang.Object [34] [nargs: 2]
			    129  checkcast Foo [38]
			    132  invokeinterface Foo.foo() : java.lang.String [40] [nargs: 1]
			    137  invokevirtual java.io.PrintStream.print(java.lang.String) : void [44]
			    140  goto 164
			    143  astore 7 [e]
			    145  getstatic java.lang.System.out : java.io.PrintStream [28]
			    148  aload 7 [e]
			    150  invokevirtual java.lang.Object.getClass() : java.lang.Class [50]
			    153  invokevirtual java.lang.Class.getSimpleName() : java.lang.String [54]
			    156  invokedynamic 1 makeConcatWithConstants(java.lang.String) : java.lang.String [63]
			    161  invokevirtual java.io.PrintStream.print(java.lang.String) : void [44]
			    164  getstatic java.lang.System.out : java.io.PrintStream [28]
			    167  iload 5 [t]
			    169  ifeq 185
			    172  aload_3 [la]
			    173  iconst_0
			    174  invokeinterface java.util.List.get(int) : java.lang.Object [34] [nargs: 2]
			    179  checkcast Foo [38]
			    182  goto 196
			    185  aload 4 [lb]
			    187  iconst_0
			    188  invokeinterface java.util.List.get(int) : java.lang.Object [34] [nargs: 2]
			    193  checkcast Foo [38]
			    196  checkcast Bar [64]
			    199  invokeinterface Bar.bar() : java.lang.String [66] [nargs: 1]
			    204  invokevirtual java.io.PrintStream.print(java.lang.String) : void [44]
			    207  goto 231
			    210  astore 7 [e]
			    212  getstatic java.lang.System.out : java.io.PrintStream [28]
			    215  aload 7 [e]
			    217  invokevirtual java.lang.Object.getClass() : java.lang.Class [50]
			    220  invokevirtual java.lang.Class.getSimpleName() : java.lang.String [54]
			    223  invokedynamic 2 makeConcatWithConstants(java.lang.String) : java.lang.String [69]
			    228  invokevirtual java.io.PrintStream.print(java.lang.String) : void [44]
			    231  getstatic java.lang.System.out : java.io.PrintStream [28]
			    234  iload 6 [f]
			    236  ifeq 252
			    239  aload_3 [la]
			    240  iconst_0
			    241  invokeinterface java.util.List.get(int) : java.lang.Object [34] [nargs: 2]
			    246  checkcast Foo [38]
			    249  goto 263
			    252  aload 4 [lb]
			    254  iconst_0
			    255  invokeinterface java.util.List.get(int) : java.lang.Object [34] [nargs: 2]
			    260  checkcast Foo [38]
			    263  checkcast Bar [64]
			    266  invokeinterface Bar.bar() : java.lang.String [66] [nargs: 1]
			    271  invokevirtual java.io.PrintStream.print(java.lang.String) : void [44]
			    274  goto 298
			    277  astore 7 [e]
			    279  getstatic java.lang.System.out : java.io.PrintStream [28]
			    282  aload 7 [e]
			    284  invokevirtual java.lang.Object.getClass() : java.lang.Class [50]
			    287  invokevirtual java.lang.Class.getSimpleName() : java.lang.String [54]
			    290  invokedynamic 3 makeConcatWithConstants(java.lang.String) : java.lang.String [70]
			    295  invokevirtual java.io.PrintStream.print(java.lang.String) : void [44]
			    298  return
			      Exception Table:
			        [pc: 36, pc: 76] -> 79 when : java.lang.Throwable
			        [pc: 100, pc: 140] -> 143 when : java.lang.Throwable
			        [pc: 164, pc: 207] -> 210 when : java.lang.Throwable
			        [pc: 231, pc: 274] -> 277 when : java.lang.Throwable
			      Line numbers:
			        [pc: 0, line: 4]
			        [pc: 8, line: 5]
			        [pc: 16, line: 6]
			        [pc: 25, line: 7]
			        [pc: 27, line: 8]
			        [pc: 30, line: 9]
			        [pc: 36, line: 11]
			        [pc: 76, line: 12]
			        [pc: 81, line: 13]
			        [pc: 100, line: 16]
			        [pc: 140, line: 17]
			        [pc: 145, line: 18]
			        [pc: 164, line: 21]
			        [pc: 207, line: 22]
			        [pc: 212, line: 23]
			        [pc: 231, line: 26]
			        [pc: 274, line: 27]
			        [pc: 279, line: 28]
			        [pc: 298, line: 30]
			      Local variable table:
			        [pc: 0, pc: 299] local: args index: 0 type: java.lang.String[]
			        [pc: 8, pc: 299] local: x index: 1 type: X
			        [pc: 16, pc: 299] local: l index: 2 type: java.util.List
			        [pc: 27, pc: 299] local: la index: 3 type: java.util.List
			        [pc: 30, pc: 299] local: lb index: 4 type: java.util.List
			        [pc: 33, pc: 299] local: t index: 5 type: boolean
			        [pc: 36, pc: 299] local: f index: 6 type: boolean
			        [pc: 81, pc: 100] local: e index: 7 type: java.lang.Throwable
			        [pc: 145, pc: 164] local: e index: 7 type: java.lang.Throwable
			        [pc: 212, pc: 231] local: e index: 7 type: java.lang.Throwable
			        [pc: 279, pc: 298] local: e index: 7 type: java.lang.Throwable
			      Local variable type table:
			        [pc: 27, pc: 299] local: la index: 3 type: java.util.List<A>
			        [pc: 30, pc: 299] local: lb index: 4 type: java.util.List<B>
			      Stack map table: number of frames 16
			        [pc: 57, full, stack: {java.io.PrintStream}, locals: {java.lang.String[], X, java.util.List, java.util.List, java.util.List, int, int}]
			        [pc: 68, full, stack: {java.io.PrintStream, Foo}, locals: {java.lang.String[], X, java.util.List, java.util.List, java.util.List, int, int}]
			        [pc: 79, same_locals_1_stack_item, stack: {java.lang.Throwable}]
			        [pc: 100, same]
			        [pc: 121, same_locals_1_stack_item, stack: {java.io.PrintStream}]
			        [pc: 132, full, stack: {java.io.PrintStream, Foo}, locals: {java.lang.String[], X, java.util.List, java.util.List, java.util.List, int, int}]
			        [pc: 143, same_locals_1_stack_item, stack: {java.lang.Throwable}]
			        [pc: 164, same]
			        [pc: 185, same_locals_1_stack_item, stack: {java.io.PrintStream}]
			        [pc: 196, full, stack: {java.io.PrintStream, Foo}, locals: {java.lang.String[], X, java.util.List, java.util.List, java.util.List, int, int}]
			        [pc: 210, same_locals_1_stack_item, stack: {java.lang.Throwable}]
			        [pc: 231, same]
			        [pc: 252, same_locals_1_stack_item, stack: {java.io.PrintStream}]
			        [pc: 263, full, stack: {java.io.PrintStream, Foo}, locals: {java.lang.String[], X, java.util.List, java.util.List, java.util.List, int, int}]
			        [pc: 277, same_locals_1_stack_item, stack: {java.lang.Throwable}]
			        [pc: 298, same]
			""";
	} else {
		expectedOutput = """
			  // Stack: 4, Locals: 8
			  public static void main(java.lang.String[] args);
			      0  new X [1]
			      3  dup
			      4  invokespecial X() [16]
			      7  astore_1 [x]
			      8  new java.util.ArrayList [17]
			     11  dup
			     12  invokespecial java.util.ArrayList() [19]
			     15  astore_2 [l]
			     16  aload_2 [l]
			     17  ldc <String "zork"> [20]
			     19  invokeinterface java.util.List.add(java.lang.Object) : boolean [22] [nargs: 2]
			     24  pop
			     25  aload_2 [l]
			     26  astore_3 [la]
			     27  aload_2 [l]
			     28  astore 4 [lb]
			     30  iconst_1
			     31  istore 5 [t]
			     33  iconst_0
			     34  istore 6 [f]
			     36  getstatic java.lang.System.out : java.io.PrintStream [28]
			     39  iload 5 [t]
			     41  ifeq 57
			     44  aload_3 [la]
			     45  iconst_0
			     46  invokeinterface java.util.List.get(int) : java.lang.Object [34] [nargs: 2]
			     51  checkcast Foo [38]
			     54  goto 68
			     57  aload 4 [lb]
			     59  iconst_0
			     60  invokeinterface java.util.List.get(int) : java.lang.Object [34] [nargs: 2]
			     65  checkcast Foo [38]
			     68  invokeinterface Foo.foo() : java.lang.String [40] [nargs: 1]
			     73  invokevirtual java.io.PrintStream.print(java.lang.String) : void [44]
			     76  goto 115
			     79  astore 7 [e]
			     81  getstatic java.lang.System.out : java.io.PrintStream [28]
			     84  new java.lang.StringBuilder [50]
			     87  dup
			     88  ldc <String "["> [52]
			     90  invokespecial java.lang.StringBuilder(java.lang.String) [54]
			     93  aload 7 [e]
			     95  invokevirtual java.lang.Object.getClass() : java.lang.Class [56]
			     98  invokevirtual java.lang.Class.getSimpleName() : java.lang.String [60]
			    101  invokevirtual java.lang.StringBuilder.append(java.lang.String) : java.lang.StringBuilder [65]
			    104  ldc <String ":foo(1)]"> [69]
			    106  invokevirtual java.lang.StringBuilder.append(java.lang.String) : java.lang.StringBuilder [65]
			    109  invokevirtual java.lang.StringBuilder.toString() : java.lang.String [71]
			    112  invokevirtual java.io.PrintStream.print(java.lang.String) : void [44]
			    115  getstatic java.lang.System.out : java.io.PrintStream [28]
			    118  iload 6 [f]
			    120  ifeq 136
			    123  aload_3 [la]
			    124  iconst_0
			    125  invokeinterface java.util.List.get(int) : java.lang.Object [34] [nargs: 2]
			    130  checkcast Foo [38]
			    133  goto 147
			    136  aload 4 [lb]
			    138  iconst_0
			    139  invokeinterface java.util.List.get(int) : java.lang.Object [34] [nargs: 2]
			    144  checkcast Foo [38]
			    147  invokeinterface Foo.foo() : java.lang.String [40] [nargs: 1]
			    152  invokevirtual java.io.PrintStream.print(java.lang.String) : void [44]
			    155  goto 194
			    158  astore 7 [e]
			    160  getstatic java.lang.System.out : java.io.PrintStream [28]
			    163  new java.lang.StringBuilder [50]
			    166  dup
			    167  ldc <String "["> [52]
			    169  invokespecial java.lang.StringBuilder(java.lang.String) [54]
			    172  aload 7 [e]
			    174  invokevirtual java.lang.Object.getClass() : java.lang.Class [56]
			    177  invokevirtual java.lang.Class.getSimpleName() : java.lang.String [60]
			    180  invokevirtual java.lang.StringBuilder.append(java.lang.String) : java.lang.StringBuilder [65]
			    183  ldc <String ":foo(2)]"> [74]
			    185  invokevirtual java.lang.StringBuilder.append(java.lang.String) : java.lang.StringBuilder [65]
			    188  invokevirtual java.lang.StringBuilder.toString() : java.lang.String [71]
			    191  invokevirtual java.io.PrintStream.print(java.lang.String) : void [44]
			    194  getstatic java.lang.System.out : java.io.PrintStream [28]
			    197  iload 5 [t]
			    199  ifeq 215
			    202  aload_3 [la]
			    203  iconst_0
			    204  invokeinterface java.util.List.get(int) : java.lang.Object [34] [nargs: 2]
			    209  checkcast Foo [38]
			    212  goto 226
			    215  aload 4 [lb]
			    217  iconst_0
			    218  invokeinterface java.util.List.get(int) : java.lang.Object [34] [nargs: 2]
			    223  checkcast Foo [38]
			    226  checkcast Bar [76]
			    229  invokeinterface Bar.bar() : java.lang.String [78] [nargs: 1]
			    234  invokevirtual java.io.PrintStream.print(java.lang.String) : void [44]
			    237  goto 276
			    240  astore 7 [e]
			    242  getstatic java.lang.System.out : java.io.PrintStream [28]
			    245  new java.lang.StringBuilder [50]
			    248  dup
			    249  ldc <String "["> [52]
			    251  invokespecial java.lang.StringBuilder(java.lang.String) [54]
			    254  aload 7 [e]
			    256  invokevirtual java.lang.Object.getClass() : java.lang.Class [56]
			    259  invokevirtual java.lang.Class.getSimpleName() : java.lang.String [60]
			    262  invokevirtual java.lang.StringBuilder.append(java.lang.String) : java.lang.StringBuilder [65]
			    265  ldc <String ":bar(1)]"> [81]
			    267  invokevirtual java.lang.StringBuilder.append(java.lang.String) : java.lang.StringBuilder [65]
			    270  invokevirtual java.lang.StringBuilder.toString() : java.lang.String [71]
			    273  invokevirtual java.io.PrintStream.print(java.lang.String) : void [44]
			    276  getstatic java.lang.System.out : java.io.PrintStream [28]
			    279  iload 6 [f]
			    281  ifeq 297
			    284  aload_3 [la]
			    285  iconst_0
			    286  invokeinterface java.util.List.get(int) : java.lang.Object [34] [nargs: 2]
			    291  checkcast Foo [38]
			    294  goto 308
			    297  aload 4 [lb]
			    299  iconst_0
			    300  invokeinterface java.util.List.get(int) : java.lang.Object [34] [nargs: 2]
			    305  checkcast Foo [38]
			    308  checkcast Bar [76]
			    311  invokeinterface Bar.bar() : java.lang.String [78] [nargs: 1]
			    316  invokevirtual java.io.PrintStream.print(java.lang.String) : void [44]
			    319  goto 358
			    322  astore 7 [e]
			    324  getstatic java.lang.System.out : java.io.PrintStream [28]
			    327  new java.lang.StringBuilder [50]
			    330  dup
			    331  ldc <String "["> [52]
			    333  invokespecial java.lang.StringBuilder(java.lang.String) [54]
			    336  aload 7 [e]
			    338  invokevirtual java.lang.Object.getClass() : java.lang.Class [56]
			    341  invokevirtual java.lang.Class.getSimpleName() : java.lang.String [60]
			    344  invokevirtual java.lang.StringBuilder.append(java.lang.String) : java.lang.StringBuilder [65]
			    347  ldc <String ":bar(2)]"> [83]
			    349  invokevirtual java.lang.StringBuilder.append(java.lang.String) : java.lang.StringBuilder [65]
			    352  invokevirtual java.lang.StringBuilder.toString() : java.lang.String [71]
			    355  invokevirtual java.io.PrintStream.print(java.lang.String) : void [44]
			    358  return
			      Exception Table:
			        [pc: 36, pc: 76] -> 79 when : java.lang.Throwable
			        [pc: 115, pc: 155] -> 158 when : java.lang.Throwable
			        [pc: 194, pc: 237] -> 240 when : java.lang.Throwable
			        [pc: 276, pc: 319] -> 322 when : java.lang.Throwable
			      Line numbers:
			        [pc: 0, line: 4]
			        [pc: 8, line: 5]
			        [pc: 16, line: 6]
			        [pc: 25, line: 7]
			        [pc: 27, line: 8]
			        [pc: 30, line: 9]
			        [pc: 36, line: 11]
			        [pc: 76, line: 12]
			        [pc: 81, line: 13]
			        [pc: 115, line: 16]
			        [pc: 155, line: 17]
			        [pc: 160, line: 18]
			        [pc: 194, line: 21]
			        [pc: 237, line: 22]
			        [pc: 242, line: 23]
			        [pc: 276, line: 26]
			        [pc: 319, line: 27]
			        [pc: 324, line: 28]
			        [pc: 358, line: 30]
			      Local variable table:
			        [pc: 0, pc: 359] local: args index: 0 type: java.lang.String[]
			        [pc: 8, pc: 359] local: x index: 1 type: X
			        [pc: 16, pc: 359] local: l index: 2 type: java.util.List
			        [pc: 27, pc: 359] local: la index: 3 type: java.util.List
			        [pc: 30, pc: 359] local: lb index: 4 type: java.util.List
			        [pc: 33, pc: 359] local: t index: 5 type: boolean
			        [pc: 36, pc: 359] local: f index: 6 type: boolean
			        [pc: 81, pc: 115] local: e index: 7 type: java.lang.Throwable
			        [pc: 160, pc: 194] local: e index: 7 type: java.lang.Throwable
			        [pc: 242, pc: 276] local: e index: 7 type: java.lang.Throwable
			        [pc: 324, pc: 358] local: e index: 7 type: java.lang.Throwable
			      Local variable type table:
			        [pc: 27, pc: 359] local: la index: 3 type: java.util.List<A>
			        [pc: 30, pc: 359] local: lb index: 4 type: java.util.List<B>
			""";
			if (this.complianceLevel != ClassFileConstants.JDK1_5) {
				expectedOutput += """
					      Stack map table: number of frames 16
					        [pc: 57, full, stack: {java.io.PrintStream}, locals: {java.lang.String[], X, java.util.List, java.util.List, java.util.List, int, int}]
					        [pc: 68, full, stack: {java.io.PrintStream, Foo}, locals: {java.lang.String[], X, java.util.List, java.util.List, java.util.List, int, int}]
					        [pc: 79, same_locals_1_stack_item, stack: {java.lang.Throwable}]
					        [pc: 115, same]
					        [pc: 136, same_locals_1_stack_item, stack: {java.io.PrintStream}]
					        [pc: 147, full, stack: {java.io.PrintStream, Foo}, locals: {java.lang.String[], X, java.util.List, java.util.List, java.util.List, int, int}]
					        [pc: 158, same_locals_1_stack_item, stack: {java.lang.Throwable}]
					        [pc: 194, same]
					        [pc: 215, same_locals_1_stack_item, stack: {java.io.PrintStream}]
					        [pc: 226, full, stack: {java.io.PrintStream, Foo}, locals: {java.lang.String[], X, java.util.List, java.util.List, java.util.List, int, int}]
					        [pc: 240, same_locals_1_stack_item, stack: {java.lang.Throwable}]
					        [pc: 276, same]
					        [pc: 297, same_locals_1_stack_item, stack: {java.io.PrintStream}]
					        [pc: 308, full, stack: {java.io.PrintStream, Foo}, locals: {java.lang.String[], X, java.util.List, java.util.List, java.util.List, int, int}]
					        [pc: 322, same_locals_1_stack_item, stack: {java.lang.Throwable}]
					        [pc: 358, same]
					""";
			}
	}

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=162991
// using only source types
public void test1067() {
	this.runConformTest(
		new String[] {
			"Something.java",
			"""
				public interface Something {
				
				}""", // =================
			"Doing.java", // =================
			"""
				public interface Doing {
				        public <S extends Something, T extends S> T get(Class<S> clazz);
				}""", // =================
			"DoingImpl.java", // =================
			"""
				public class DoingImpl implements Doing {
				        public <S extends Something, T extends S> T get(Class<S> clazz) {
				                return null;
				        }
				}"""
		},
		"");
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=162991
// using source and binary types
public void test1068() {
	this.runConformTest(
		new String[] {
			"Something.java",
			"""
				public interface Something {
				
				}""", // =================
			"Doing.java", // =================
			"""
				public interface Doing {
				        public <S extends Something, T extends S> T get(Class<S> clazz);
				}""", // =================
		},
		"");
	this.runConformTest(
		new String[] {
			"DoingImpl.java", // =================
			"""
				public class DoingImpl implements Doing {
				        public <S extends Something, T extends S> T get(Class<S> clazz) {
				                return null;
				        }
				}"""
		},
		"",
		null,
		false,
		null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=163262
public void test1069() {
	this.runConformTest(
		new String[] {
			"Bug.java", // =================
			"""
				public class Bug<A> {
				   void bug() {
				      new Runnable() {
				         public void run() {
				            Bug<A> bug = Bug.this;
				         }
				      };
				   }
				}""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=163262
public void test1070() {
	this.runConformTest(
		new String[] {
			"Bug.java", // =================
			"""
				public class Bug<A> {
				   Bug<A> reproduce() {
				      return Bug.this;
				   }
				}""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=159939
public void test1071() {
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				import java.util.*;
				public class X {
				        List<void[]> x = null;
				        void[] y;
				        void[] foo(void[] arg) {
				                void[] local;
				        }
				}""",
		},
		"""
			----------
			1. ERROR in X.java (at line 3)
				List<void[]> x = null;
				     ^^^^^^
			void[] is an invalid type
			----------
			2. ERROR in X.java (at line 4)
				void[] y;
				^^^^^^
			void[] is an invalid type
			----------
			3. ERROR in X.java (at line 5)
				void[] foo(void[] arg) {
				^^^^^^
			void[] is an invalid type
			----------
			4. ERROR in X.java (at line 5)
				void[] foo(void[] arg) {
				           ^^^^^^
			void[] is an invalid type
			----------
			5. ERROR in X.java (at line 6)
				void[] local;
				^^^^^^
			void[] is an invalid type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=159939
public void test1072() {
	Map options = getCompilerOptions();
	options.put(CompilerOptions.OPTION_ReportRawTypeReference, CompilerOptions.IGNORE);
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				import java.util.*;
				public class X {
				        List<void[]> x = null;
				        void[] y;
				        void[] foo(void[] arg) {
				                void[] local;
				                Class c = void[].class;
				        }
				}""",
		},
		"""
			----------
			1. ERROR in X.java (at line 3)
				List<void[]> x = null;
				     ^^^^^^
			void[] is an invalid type
			----------
			2. ERROR in X.java (at line 4)
				void[] y;
				^^^^^^
			void[] is an invalid type
			----------
			3. ERROR in X.java (at line 5)
				void[] foo(void[] arg) {
				^^^^^^
			void[] is an invalid type
			----------
			4. ERROR in X.java (at line 5)
				void[] foo(void[] arg) {
				           ^^^^^^
			void[] is an invalid type
			----------
			5. ERROR in X.java (at line 6)
				void[] local;
				^^^^^^
			void[] is an invalid type
			----------
			6. ERROR in X.java (at line 7)
				Class c = void[].class;
				          ^^^^^^
			void[] is an invalid type
			----------
			""",
		null,
		true,
		options);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=159939
public void test1073() {
	Map options = getCompilerOptions();
	options.put(CompilerOptions.OPTION_ReportRawTypeReference, CompilerOptions.IGNORE);
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				import java.util.*;
				public class X {
				        List<void[]> x = null;
				        void[] y;
				        void[] foo(void[] arg) {
				                try {
				                        void[] local;
				                        Class c = void[].class;
				                } catch(void[] e) {
				                }
				        }
				}""",
		},
		"""
			----------
			1. ERROR in X.java (at line 3)
				List<void[]> x = null;
				     ^^^^^^
			void[] is an invalid type
			----------
			2. ERROR in X.java (at line 4)
				void[] y;
				^^^^^^
			void[] is an invalid type
			----------
			3. ERROR in X.java (at line 5)
				void[] foo(void[] arg) {
				^^^^^^
			void[] is an invalid type
			----------
			4. ERROR in X.java (at line 5)
				void[] foo(void[] arg) {
				           ^^^^^^
			void[] is an invalid type
			----------
			5. ERROR in X.java (at line 7)
				void[] local;
				^^^^^^
			void[] is an invalid type
			----------
			6. ERROR in X.java (at line 8)
				Class c = void[].class;
				          ^^^^^^
			void[] is an invalid type
			----------
			7. ERROR in X.java (at line 9)
				} catch(void[] e) {
				        ^^^^^^
			void[] is an invalid type
			----------
			""",
		null,
		true,
		options);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=159939
public void test1074() {
	Map options = getCompilerOptions();
	options.put(CompilerOptions.OPTION_ReportRawTypeReference, CompilerOptions.IGNORE);
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				import java.util.*;
				public class X {
				        List<void[]> x = null;
				        void[] y;
				        void[] foo(void[] arg) {
				                try {
				                        void[] local = new void[0];
				                        void[] local1 = new void[]{ null, null };
				                        void[] local2 = { null, null };
				                        System.out.println((void[]) null);
				                        Class c = void[].class;
				                } catch(void[] e) {
				                }
				        }
				}""",
		},
		"""
			----------
			1. ERROR in X.java (at line 3)
				List<void[]> x = null;
				     ^^^^^^
			void[] is an invalid type
			----------
			2. ERROR in X.java (at line 4)
				void[] y;
				^^^^^^
			void[] is an invalid type
			----------
			3. ERROR in X.java (at line 5)
				void[] foo(void[] arg) {
				^^^^^^
			void[] is an invalid type
			----------
			4. ERROR in X.java (at line 5)
				void[] foo(void[] arg) {
				           ^^^^^^
			void[] is an invalid type
			----------
			5. ERROR in X.java (at line 7)
				void[] local = new void[0];
				^^^^^^
			void[] is an invalid type
			----------
			6. ERROR in X.java (at line 7)
				void[] local = new void[0];
				               ^^^^^^^^^^^
			void[] is an invalid type
			----------
			7. ERROR in X.java (at line 8)
				void[] local1 = new void[]{ null, null };
				^^^^^^
			void[] is an invalid type
			----------
			8. ERROR in X.java (at line 8)
				void[] local1 = new void[]{ null, null };
				                ^^^^^^^^^^^^^^^^^^^^^^^^
			void[] is an invalid type
			----------
			9. ERROR in X.java (at line 9)
				void[] local2 = { null, null };
				^^^^^^
			void[] is an invalid type
			----------
			10. ERROR in X.java (at line 10)
				System.out.println((void[]) null);
				                    ^^^^^^
			void[] is an invalid type
			----------
			11. ERROR in X.java (at line 11)
				Class c = void[].class;
				          ^^^^^^
			void[] is an invalid type
			----------
			12. ERROR in X.java (at line 12)
				} catch(void[] e) {
				        ^^^^^^
			void[] is an invalid type
			----------
			""",
		null,
		true,
		options);
}

//https://bugs.eclipse.org/bugs/show_bug.cgi?id=163680
public void test1075() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				public class X <T extends X<?>.J>{
					public class J implements I<T>{}
				}
				""",
			"I.java",
			"public interface I <T> {}\n",
			"Y.java",
			"public class Y extends X {}\n",
		},
		// runtime results
		"" /* expected output string */);
	runConformTest(
		// test directory preparation
		false /* do not flush output directory */,
		new String[] {
			"Y.java",
			"public class Y extends X {}",
		},
		// compiler results
		null /* do not check compiler log */,
		// runtime results
		"" /* expected output string */,
		"" /* expected error string */,
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}

// FAIL ERRMSG
public void test1076() {
	if (this.complianceLevel >= ClassFileConstants.JDK1_8)
		return;
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.List;
				public class X {
					List<Thread> threads;
					void foo(String[] strings) {}
					void bar() {
						foo(this.threads.toArray(new String[this.threads.size()]));
						foo(myToArray(this.threads, new String[this.threads.size()]));
						foo(myToArray2(this.threads, new String[this.threads.size()]));
					}
				\t
					static <T, E> T[] myToArray(List<E> list, T[] a) {
						return list.toArray(a);
					}
					static <T, E extends T> T[] myToArray2(List<E> list, T[] a) {
						return list.toArray(a);
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 8)
				foo(myToArray2(this.threads, new String[this.threads.size()]));
				    ^^^^^^^^^^
			Bound mismatch: The generic method myToArray2(List<E>, T[]) of type X is not applicable for the arguments (List<Thread>, String[]). The inferred type Thread is not a valid substitute for the bounded parameter <E extends T>
			----------
			""");
}
// check presence of field hiding warning
public void test1077() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					static class Y<T> {
						static int foo;
					}
					static class Z<U> extends Y<U> {
						int foo;
						{
							foo = 1;
						}
					}
					Zork z;
				}
				
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 6)
				int foo;
				    ^^^
			The field X.Z<U>.foo is hiding a field from type X.Y<U>
			----------
			2. ERROR in X.java (at line 11)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=165143
public void test1078() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.List;
				import java.util.Map;
				
				public class X\s
				{
				  public static void main(String[] args)
				  {
				    Object object = null;
				
				    List list = (List)object;//[1]
				
				    foo((List)object);//[2]
				    foo((List<?>)object);//[3]
				    foo((List<Object>)object);//[4]unchecked cast
				    foo((List<? extends Object>)object);//[5]
				
				    foo((Map)object);//[6]
				    foo((Map<?, ?>)object);//[7]
				    foo((Map<Object, ?>)object);//[8]unchecked cast
				    foo((Map<?, Object>)object);//[9]unchecked cast
				    foo((Map<Object, Object>)object);//[10]unchecked cast
				    foo((Map<? extends Object, Object>)object);//[11]unchecked cast
				    foo((Map<? extends Object, ? extends Object>)object);//[12]
				    Zork z;
				  }
				
				  public static void foo(List<?> list) {
				  }
				
				  public static void foo(Map<?, ?> map) {
				  }
				}""", // =================,
		},
		"""
			----------
			1. WARNING in X.java (at line 10)
				List list = (List)object;//[1]
				^^^^
			List is a raw type. References to generic type List<E> should be parameterized
			----------
			2. WARNING in X.java (at line 10)
				List list = (List)object;//[1]
				             ^^^^
			List is a raw type. References to generic type List<E> should be parameterized
			----------
			3. WARNING in X.java (at line 12)
				foo((List)object);//[2]
				     ^^^^
			List is a raw type. References to generic type List<E> should be parameterized
			----------
			4. WARNING in X.java (at line 14)
				foo((List<Object>)object);//[4]unchecked cast
				    ^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from Object to List<Object>
			----------
			5. WARNING in X.java (at line 15)
				foo((List<? extends Object>)object);//[5]
				    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from Object to List<? extends Object>
			----------
			6. WARNING in X.java (at line 17)
				foo((Map)object);//[6]
				     ^^^
			Map is a raw type. References to generic type Map<K,V> should be parameterized
			----------
			7. WARNING in X.java (at line 19)
				foo((Map<Object, ?>)object);//[8]unchecked cast
				    ^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from Object to Map<Object,?>
			----------
			8. WARNING in X.java (at line 20)
				foo((Map<?, Object>)object);//[9]unchecked cast
				    ^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from Object to Map<?,Object>
			----------
			9. WARNING in X.java (at line 21)
				foo((Map<Object, Object>)object);//[10]unchecked cast
				    ^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from Object to Map<Object,Object>
			----------
			10. WARNING in X.java (at line 22)
				foo((Map<? extends Object, Object>)object);//[11]unchecked cast
				    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from Object to Map<? extends Object,Object>
			----------
			11. WARNING in X.java (at line 23)
				foo((Map<? extends Object, ? extends Object>)object);//[12]
				    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from Object to Map<? extends Object,? extends Object>
			----------
			12. ERROR in X.java (at line 24)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=165143 - variation
public void test1079() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<E> {
				    X<? extends String> bar(Object o) {
				    	return (AX<? extends String>) o;
				   	 Zork z;
				    }
				}
				class AX<F> extends X<F> {}
				""", // =================,
		},
		"""
			----------
			1. WARNING in X.java (at line 3)
				return (AX<? extends String>) o;
				       ^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from Object to AX<? extends String>
			----------
			2. ERROR in X.java (at line 4)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=165143 - variation
public void test1080() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<E> {
					CX<E> foo(X<String> x) {
						return (CX<E>) x; // unchecked
					}
					BX bar(X<String> x) {
						return (BX) x;
					}
				   Zork z;
				}
				class AX<F> extends X<F> {}
				class BX extends AX<String> {}
				class CX<G> extends AX<String> {}
				""", // =================,
		},
		"""
			----------
			1. WARNING in X.java (at line 3)
				return (CX<E>) x; // unchecked
				       ^^^^^^^^^
			Type safety: Unchecked cast from X<String> to CX<E>
			----------
			2. ERROR in X.java (at line 8)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=165143 - variation
public void test1081() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<E> {
					AX<Object> foo(X<String> x) {
						return (BX) x;
					}
				}
				class AX<F> extends X<F> {}
				class BX extends AX<Object> {}
				""", // =================,
		},
		"""
			----------
			1. ERROR in X.java (at line 3)
				return (BX) x;
				       ^^^^^^
			Cannot cast from X<String> to BX
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=165143 - variation
public void test1082() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<E> {
					CX<E> foo(X<String> x) {
						return (CX<E>) x; // unchecked
					}
				   Zork z;
				}
				class AX<F> extends X<F> {}
				class CX<G> extends AX {}
				""", // =================,
		},
		"""
			----------
			1. WARNING in X.java (at line 3)
				return (CX<E>) x; // unchecked
				       ^^^^^^^^^
			Type safety: Unchecked cast from X<String> to CX<E>
			----------
			2. ERROR in X.java (at line 5)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			3. WARNING in X.java (at line 8)
				class CX<G> extends AX {}
				                    ^^
			AX is a raw type. References to generic type AX<F> should be parameterized
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=106451 - variation
public void test1083() {
	this.runNegativeTest(
		new String[] {
			"X.java", // =================
			"""
				import java.io.Serializable;
				import java.util.LinkedList;
				
				class SerializableList extends LinkedList<Serializable> {
					private static final long serialVersionUID = 1L;\s
				}
				public class X {
				    @SuppressWarnings({"nls", "unused"})
				    public static void main(String[] args) {
				        LinkedList<String> linkedList= new LinkedList<String>();
				        linkedList.add("Hello");
				        java.util.List<? extends Serializable> a = linkedList;
				        java.util.List<String> b = (LinkedList<String>) a; // unchecked
				        java.util.List<Integer> c = (LinkedList<Integer>) a; // unchecked
				        java.util.List<Runtime> d = (LinkedList<Runtime>) a; // inconvertible / unchecked ?
				        c.get(0).intValue(); // fails at run time
				        d.get(0).gc(); // fails at run time
				        Zork z;
				    }
				}
				""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 13)
				java.util.List<String> b = (LinkedList<String>) a; // unchecked
				                           ^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from List<capture#1-of ? extends Serializable> to LinkedList<String>
			----------
			2. WARNING in X.java (at line 14)
				java.util.List<Integer> c = (LinkedList<Integer>) a; // unchecked
				                            ^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from List<capture#2-of ? extends Serializable> to LinkedList<Integer>
			----------
			3. WARNING in X.java (at line 15)
				java.util.List<Runtime> d = (LinkedList<Runtime>) a; // inconvertible / unchecked ?
				                            ^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from List<capture#3-of ? extends Serializable> to LinkedList<Runtime>
			----------
			4. ERROR in X.java (at line 18)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}

// https://bugs.eclipse.org/bugs/show_bug.cgi?id=158870
public void test1084() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				class Y<T> {
				}
				class Z<T> {
				}
				class X {
				  void foo() {
				    Z<Y<?>> l1 = null;
				    Z<Y> l2 = (Z<Y>) l1;
				  }
				}""",
		},
		"""
			----------
			1. WARNING in X.java (at line 8)
				Z<Y> l2 = (Z<Y>) l1;
				  ^
			Y is a raw type. References to generic type Y<T> should be parameterized
			----------
			2. ERROR in X.java (at line 8)
				Z<Y> l2 = (Z<Y>) l1;
				          ^^^^^^^^^
			Cannot cast from Z<Y<?>> to Z<Y>
			----------
			3. WARNING in X.java (at line 8)
				Z<Y> l2 = (Z<Y>) l1;
				             ^
			Y is a raw type. References to generic type Y<T> should be parameterized
			----------
			""");
}

//https://bugs.eclipse.org/bugs/show_bug.cgi?id=165291
public void test1085() {
	this.runNegativeTest(
		new String[] {
			"Y.java",
			"""
				class Z {
				        Z z1 = z1;
				        Z[] z2 = z2;
				}
				public class Y<E> {
						E e0 = es[0];
						E e = e;
				        E[] es = es;
						E e2 = e2.e;
				}""", // =================
		},
		"""
			----------
			1. ERROR in Y.java (at line 2)
				Z z1 = z1;
				       ^^
			Cannot reference a field before it is defined
			----------
			2. ERROR in Y.java (at line 3)
				Z[] z2 = z2;
				         ^^
			Cannot reference a field before it is defined
			----------
			3. ERROR in Y.java (at line 6)
				E e0 = es[0];
				       ^^
			Cannot reference a field before it is defined
			----------
			4. ERROR in Y.java (at line 7)
				E e = e;
				      ^
			Cannot reference a field before it is defined
			----------
			5. ERROR in Y.java (at line 8)
				E[] es = es;
				         ^^
			Cannot reference a field before it is defined
			----------
			6. ERROR in Y.java (at line 9)
				E e2 = e2.e;
				       ^^
			Cannot reference a field before it is defined
			----------
			7. ERROR in Y.java (at line 9)
				E e2 = e2.e;
				          ^
			e cannot be resolved or is not a field
			----------
			""");
}

//https://bugs.eclipse.org/bugs/show_bug.cgi?id=165645
public void test1086() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				interface IFoo { void foo(); }
				interface IBar { void bar(); }
				public class X<Bar extends IFoo> {
					class Bar implements IBar { public void bar(){} }
					void foo(Bar b) {
						b.foo(); // unbound (Bar is member type)
						b.bar(); // ok
					}
				}
				""", // =================,
		},
		"""
			----------
			1. ERROR in X.java (at line 6)
				b.foo(); // unbound (Bar is member type)
				  ^^^
			The method foo() is undefined for the type X<Bar>.Bar
			----------
			""");
}

//https://bugs.eclipse.org/bugs/show_bug.cgi?id=165645 - variation
public void test1087() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				public class X<M> {
					static public class M {
					}
					static public class M2 extends M {
					}
				}
				
				""", // =================
		},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_7 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=165679
public void test1088() {
	this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X<M> {
						static public class M {}
						Zork z;
						void foo() {
							class M {} // hides member
						}
					}
					class Y <T> {
						class Local {}
						void foo() {
							class T {}; // hiding warning
							class Local {};
						}
						static void bar() {
							class T {}; // no hiding warning
							class Local {}; // no hiding warning
						}\t
					}
					""", // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				2. WARNING in X.java (at line 5)
					class M {} // hides member
					      ^
				The type M is hiding the type X.M
				----------
				3. WARNING in X.java (at line 11)
					class T {}; // hiding warning
					      ^
				The nested type T is hiding the type parameter T of type Y<T>
				----------
				4. WARNING in X.java (at line 12)
					class Local {};
					      ^^^^^
				The type Local is hiding the type Y<T>.Local
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=165679 - variation
public void test1089() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					class U {}
					<T> void foo(T t) {
						class T {
							T t = t;
						}
						class U {
						}
					}
				}
				
				""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 4)
				class T {
				      ^
			The nested type T is hiding the type parameter T of the generic method foo(T) of type X
			----------
			2. WARNING in X.java (at line 5)
				T t = t;
				  ^
			The field T.t is hiding another local variable defined in an enclosing scope
			----------
			3. ERROR in X.java (at line 5)
				T t = t;
				      ^
			Cannot reference a field before it is defined
			----------
			4. WARNING in X.java (at line 7)
				class U {
				      ^
			The type U is hiding the type X.U
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=165679 - variation
public void _test1090() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X <T,U> {
					class T {} // warn hiding type parameter
					class U<U> {}// warn hiding type parameter+warn param hiding member type
				\t
					void foo() {
						class Local {
							class T {} // warn hiding type parameter
							class U<U> {}// warn hiding type parameter+warn param hiding member type
						}
					}
					static void bar() {
						class Local {
							class T {} // no warn
							class U<U> {} // no warn
						}
					}
				}""", // =================
		},
		"???");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=165909
public void test1091() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.Map;
				
				public class X {
					void foo() {
						  Object a = null;
						  Map.Entry<String, String> aa = (Map.Entry<String, String>)a;	\t
					}
					void bar() {
						  Number a = null;
						  Map.Entry<String, String> aa = (Map.Entry<String, String>)a;	\t
						  Zork z;
					}
				}
				""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 6)
				Map.Entry<String, String> aa = (Map.Entry<String, String>)a;	\t
				                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from Object to Map.Entry<String,String>
			----------
			2. WARNING in X.java (at line 10)
				Map.Entry<String, String> aa = (Map.Entry<String, String>)a;	\t
				                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from Number to Map.Entry<String,String>
			----------
			3. ERROR in X.java (at line 11)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=166490
public void test1092() {
	Map customOptions = getCompilerOptions();
	customOptions.put(CompilerOptions.OPTION_ReportRawTypeReference, CompilerOptions.IGNORE);
	this.runConformTest(
		new String[] {
			"Class_01.java",
			"""
				public interface Class_01<H extends Class_02<? extends Class_01>> extends
						Class_09<H> {
				}""",
			"Class_02.java",
			"""
				public interface Class_02<E extends Class_01<? extends Class_02>> extends
						Class_10<E> {
				}""",
			"Class_03.java",
			"""
				public abstract class Class_03<E extends Class_01<? super H>, H extends Class_02<? super E>, P extends Class_06<? extends Class_07>>
						extends Class_08<E, H, P> implements Class_05 {
				}""",
			"Class_04.java",
			"public interface Class_04 extends Class_06<Class_18>, Class_19{\n" +
			"}",
			"Class_05.java",
			"public interface Class_05{\n" +
			"}",
			"Class_06.java",
			"""
				public interface Class_06<H extends Class_07<? extends Class_06>> extends
						Class_13<H, Class_12>, Class_17 {
				}""",
			"Class_07.java",
			"""
				public interface Class_07<P extends Class_06<? extends Class_07>> extends
						Class_14<P, Class_12> {
				}""",
			"Class_08.java",
			"""
				public abstract class Class_08<E extends Class_09<? super H>, H extends Class_10<? super E>, P extends Class_06<? extends Class_07>>
						extends Class_11<E, H, Class_12> implements Class_05 {
				}""",
			"Class_09.java",
			"""
				public interface Class_09<H extends Class_10<? extends Class_09>> extends
						Class_13<H, Class_12>, Class_17 {
				}""",
			"Class_10.java",
			"""
				public interface Class_10<E extends Class_09<? extends Class_10>> extends
						Class_14<E, Class_12> {
				}""",
			"Class_11.java",
			"""
				public abstract class Class_11<E extends Class_13<? super H, O>, H extends Class_14<? super E, O>, O>
						extends Class_15<E, H, O> implements Class_05 {
				}""",
			"Class_12.java",
			"public final class Class_12 {\n" +
			"}",
			"Class_13.java",
			"public interface Class_13<H extends Class_14<?, O>, O>{\n" +
			"}",
			"Class_14.java",
			"public interface Class_14<E extends Class_13<?, O>, O>{\n" +
			"}",
			"Class_15.java",
			"""
				public abstract class Class_15<E extends Class_13<? super H, O>, H extends Class_14<? super E, O>, O>
						extends Class_16 {
				}""",
			"Class_16.java",
			"public abstract class Class_16{\n" +
			"}",
			"Class_17.java",
			"public interface Class_17{\n" +
			"}",
			"Class_18.java",
			"public interface Class_18 extends Class_07<Class_04>{\n" +
			"}",
			"Class_19.java",
			"public interface Class_19{\n" +
			"}",
			"MyClass.java",
			"""
				abstract class MyClass<E extends Class_01<? super H>, H extends Class_02<? super E>>
						extends Class_03<E, H, Class_04> implements Class_05 {
				}"""
		},
		"",
		null,
		true,
		null,
		customOptions,
		null);

	// incremental build
	this.runConformTest(
			new String[] {
					"Class_01.java",
					"""
						public interface Class_01<H extends Class_02<? extends Class_01>> extends
								Class_09<H> {
						}""",
			},
			"",
			null,
			false,
			null,
			customOptions,
			null);
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=156952
// invalid bug - regression test only
public void test1093() {
	Map customOptions = getCompilerOptions();
	customOptions.put(CompilerOptions.OPTION_ReportRawTypeReference, CompilerOptions.IGNORE);
	this.runNegativeTest(new String[] {
			"X.java",
			"public class X<T> {\n" +
			"  X<T> foo() {\n" +
			"    return this;\n" +
			"  }\n" +
			"  T bar(T p) {\n" +
			"    return p;\n" + "  }\n"	+
			"  public static void main (String args) {\n" +
			"    X<String> x1 = new X<String>();\n"	+
			"    System.out.println(x1.foo().bar(\"OK\"));\n" + // OK
			"    X x2 = new X<String>();\n"	+
			"    System.out.println(x2.foo().bar(\"OK\"));\n" + // KO: type safety issue
			"  }\n" +
			"}\n"
		},
		"""
			----------
			1. WARNING in X.java (at line 12)
				System.out.println(x2.foo().bar("OK"));
				                   ^^^^^^^^^^^^^^^^^^
			Type safety: The method bar(Object) belongs to the raw type X. References to generic type X<T> should be parameterized
			----------
			""",
		null /* no extra class libraries */,
		true /* flush output directory */,
		customOptions,
		false /* do not generate output */,
		false /* do not show category */,
		false /* do not show warning token */,
		false  /* do not skip javac for this peculiar test */,
		false  /* do not perform statements recovery */);
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=167268
public void test1094() {
	Map customOptions = getCompilerOptions();
	customOptions.put(CompilerOptions.OPTION_ReportRawTypeReference, CompilerOptions.IGNORE);
	this.runConformTest(
		new String[] {
			"Crazy.java",
			"public interface Crazy<O extends Other, T extends O> {}",
			"ExampleFactory.java",
			"""
				public interface ExampleFactory {
					<O extends Other, T extends O> Crazy<O, T> createCrazy();
				}""",
			"Other.java",
			"public interface Other {}",
			"ExampleFactoryImpl.java",
			"""
				public class ExampleFactoryImpl implements ExampleFactory {
					public <O extends Other, T extends O> Crazy<O, T> createCrazy() {
						return null;
					}
				}"""
		},
		"",
		null /* no extra class libraries */,
		true /* flush output directory */,
		null /* vm arguments*/,
		customOptions,
		null /* compiler requestor*/);
	this.runConformTest(
		new String[] {
			"ExampleFactoryImpl.java",
			"""
				public class ExampleFactoryImpl implements ExampleFactory {
					public <O extends Other, T extends O> Crazy<O, T> createCrazy() {
						return null;
					}
				}"""
		},
		"",
		null /* no extra class libraries */,
		false /* flush output directory */,
		null /* vm arguments*/,
		customOptions,
		null /* compiler requestor*/);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=167952
//invalid bug - regression test only
public void test1095() {
	Map customOptions = getCompilerOptions();
	customOptions.put(CompilerOptions.OPTION_ReportRawTypeReference, CompilerOptions.IGNORE);
	customOptions.put(CompilerOptions.OPTION_ReportUncheckedTypeOperation, CompilerOptions.IGNORE);
	runNegativeTest(
	// test directory preparation
	true /* flush output directory */,
	new String[] { /* test files */
		"X.java",
		"""
			import java.lang.reflect.Constructor;
			
			@interface Annot {
				String message() default ""; //$NON-NLS-1$
			}
			
			public class X {
				X() {
				}
				public String getAnnotationValue(Constructor constructor){
					Annot annotation = constructor.getAnnotation(Annot.class);
					return (annotation != null) ? annotation.message() : null;
				}
			}"""
	},
	// compiler options
	null /* no class libraries */,
	customOptions /* custom options */,
	// compiler results
	"----------\n" + /* expected compiler log */
	"1. ERROR in X.java (at line 11)\n" +
	"	Annot annotation = constructor.getAnnotation(Annot.class);\n" +
	"	                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
	"Type mismatch: cannot convert from Annotation to Annot\n" +
	"----------\n",
	// javac options
	JavacTestOptions.JavacHasABug.JavacBug6400189 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=167952
//invalid bug - regression test only
public void test1096() {
	Map customOptions = getCompilerOptions();
	customOptions.put(CompilerOptions.OPTION_ReportRawTypeReference, CompilerOptions.IGNORE);
	customOptions.put(CompilerOptions.OPTION_ReportUncheckedTypeOperation, CompilerOptions.IGNORE);
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.lang.reflect.Constructor;
				
				@interface Annot {
					String message() default ""; //$NON-NLS-1$
				}
				
				public class X {
					X() {
					}
					public String getAnnotationValue(Constructor<X> constructor){
						Annot annotation = constructor.getAnnotation(Annot.class);
						return (annotation != null) ? annotation.message() : null;
					}
				}"""
		},
		"",
		null /* no extra class libraries */,
		true /* flush output directory */,
		null,
		customOptions,
		null/* do not perform statements recovery */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=168232
public void _test1097() {
	runNegativeTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				public class X {
					String[] foo = new <Zork>String[] {};
				}"""
		},
		// compiler results
		"----------\n" + /* expected compiler log */
		"1. ERROR in X.java (at line 2)\n" +
		"	String[] foo = new <Zork>String[] {};\n" +
		"	               ^^^^^^^^^^^^^^^^^^\n" +
		"Syntax error on token(s), misplaced construct(s)\n" +
		"----------\n" +
		"2. ERROR in X.java (at line 2)\n" +
		"	String[] foo = new <Zork>String[] {};\n" +
		"	                        ^\n" +
		"Syntax error on token \">\", , expected\n" +
		"----------\n",
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_7 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=152961
public void test1098() {
	String errMessage = isMinimumCompliant(ClassFileConstants.JDK11) ?
			"""
				----------
				1. ERROR in X.java (at line 9)
					class Y extends Zork {}
					                ^^^^
				Zork cannot be resolved to a type
				----------
				"""
			:
			"""
				----------
				1. WARNING in X.java (at line 5)
					private class Y<T> extends A {
					              ^
				Access to enclosing constructor X.A() is emulated by a synthetic accessor method
				----------
				2. ERROR in X.java (at line 9)
					class Y extends Zork {}
					                ^^^^
				Zork cannot be resolved to a type
				----------
				""";
	this.runNegativeTest(new String[] {
			"X.java",
			"""
				public class X {\s
				   private class A {
				    class B {}
				  }
				  private class Y<T> extends A {
				  }
				  Y<String>.B d = null;
				}
				class Y extends Zork {}
				"""
		},
		errMessage);
}
public void test1099() {
	runConformTest(
		// test directory preparation
		true /* flush output directory */,
		new String[] { /* test files */
			"X.java",
			"""
				import java.util.*;
				
				public class X {
				
				    public class A {};
				    public class B extends A {
				    	@Override
				    	public String toString() {
				    		return "SUCCESS";
				    	}
				    }
				
				    public static void main(String[] args) {
				        X x = new X();
				        List<A> l = x.newList(x.new B());
						for (A a: l) {
							System.out.println(a);
						}
				    }
				
				    public <U, V extends U> List<U> newList(V... values) {
				        List<U> l = new ArrayList<U>();
				        for (V v : values) {
				            l.add(v);
				        }
				        return l;
				    }
				
				}
				"""
		},
		// compiler results
		this.complianceLevel < ClassFileConstants.JDK1_7 ? "" :
				"""
					----------
					1. WARNING in X.java (at line 21)
						public <U, V extends U> List<U> newList(V... values) {
						                                             ^^^^^^
					Type safety: Potential heap pollution via varargs parameter values
					----------
					""",
		// runtime results
		"SUCCESS" /* expected output string */,
		"" /* expected error string */,
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_7 /* javac test options */);
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=170318
public void test1100() {
	this.runNegativeTest(new String[] {
			"X.java",
			"""
				class X<T> {
				}
				class Y<T> {
				  public void foo(final X<?> x) {
				  }
				}
				class Z extends Y {
				  public void foo(final X<?> x) {
				    super.foo(x);
				  }
				}"""
		},
		"""
			----------
			1. WARNING in X.java (at line 7)
				class Z extends Y {
				                ^
			Y is a raw type. References to generic type Y<T> should be parameterized
			----------
			2. ERROR in X.java (at line 8)
				public void foo(final X<?> x) {
				            ^^^^^^^^^^^^^^^^^
			Name clash: The method foo(X<?>) of type Z has the same erasure as foo(X) of type Y but does not override it
			----------
			3. WARNING in X.java (at line 9)
				super.foo(x);
				^^^^^^^^^^^^
			Type safety: The method foo(X) belongs to the raw type Y. References to generic type Y<T> should be parameterized
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=172189
public void test1101() {
	this.runNegativeTest(new String[] {
			"X.java",
			"""
				import java.util.*;
				
				public final class X<A, B> {
				    public A a;
				    public B b;
				    public X(A pa, B pb) {
				        a = pa;
				        b = pb;
				    }
				    public static <A, B> X<A, B> create(A pa, B pb) {
				        return new X<A, B>(pa, pb);
				    }
				    public static void main(String[] args) {
				        List<X<String, Object>> list = new ArrayList<X<String,Object>>();
				        list.add(X.<?, Object>create("", ""));
				    }
				}"""
		},
		"""
			----------
			1. ERROR in X.java (at line 15)
				list.add(X.<?, Object>create("", ""));
				            ^
			Wildcard is not allowed at this location
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=174434
public void test1102() {
	this.runNegativeTest(new String[] {
			"X.java",
			"""
				public class X {
					<T> X(T t) {
					}
				
					class A {
						<T> A(T t) {
						}
					}
				
					public static void main(String[] args) {
						new<?> X(null);
					}
				}"""
		},
		"""
			----------
			1. ERROR in X.java (at line 11)
				new<?> X(null);
				    ^
			Wildcard is not allowed at this location
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=174434
public void test1103() {
	this.runNegativeTest(new String[] {
			"X.java",
			"""
				public class X {
					<T> X(T t) {
					}
					X(int i) {
						<?>this(null);
					}
				}"""
		},
		"""
			----------
			1. ERROR in X.java (at line 5)
				<?>this(null);
				 ^
			Wildcard is not allowed at this location
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=174434
public void test1104() {
	this.runNegativeTest(new String[] {
			"X.java",
			"""
				public class X {
					<T> X(T t) { }
				\t
					class A {
						<T> A(T t) { }
					}
				
					public static void main(String[] args) {
						new X(null).new <?> A(null);
					}
				}"""
		},
		"""
			----------
			1. ERROR in X.java (at line 9)
				new X(null).new <?> A(null);
				                 ^
			Wildcard is not allowed at this location
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=174724
public void test1105() {
	Map customOptions = getCompilerOptions();
	customOptions.put(CompilerOptions.OPTION_ReportRawTypeReference, CompilerOptions.IGNORE);
	this.runNegativeTest(new String[] {
			"X.java",
			"""
				public class X {
					public static void main(String[] args) {
						Class foo = Class.<? extends Object>forName(Integer.class.getName());
					}
				}"""
		},
		"""
			----------
			1. ERROR in X.java (at line 3)
				Class foo = Class.<? extends Object>forName(Integer.class.getName());
				                   ^^^^^^^^^^^^^^^^
			Wildcard is not allowed at this location
			----------
			""",
		null,
		true,
		customOptions);
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=174766
public void test1106() {
	runNegativeTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				public class X<T> {
					public class Y extends Exception {
				     private static final long serialVersionUID = 1L;
					}
				}"""
		},
		// compiler results
		"----------\n" +  /* expected compiler log */
		"1. ERROR in X.java (at line 2)\n" +
		"	public class Y extends Exception {\n" +
		"	                       ^^^^^^^^^\n" +
		"The generic class X<T>.Y may not subclass java.lang.Throwable\n" +
		"----------\n",
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=172913
public void test1107() throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.ArrayList;
				import java.util.Collection;
				import java.util.HashMap;
				import java.util.Iterator;
				import java.util.List;
				
				public class X {
				  private void processLocks(HashMap locksMap, Object key) {
				    for (Iterator iter = locksMap.keySet().iterator(); iter.hasNext();) {
				      Object call = iter.next();
				      List locks = externLocks((Collection) locksMap.get(call), call);
				      // ...
				    }
				  }
				  private List externLocks(Collection locks, Object call) {
				    List result = new ArrayList();
				    // ..
				    return result;
				  }
				}
				""",
		},
		"");
	// ensure only one instance of: checkcast java.util.Collection
	String expectedOutput =
		"  // Method descriptor #15 (Ljava/util/HashMap;Ljava/lang/Object;)V\n" +
		"  // Stack: 3, Locals: 6\n" +
		"  private void processLocks(java.util.HashMap locksMap, java.lang.Object key);\n" +
		"     0  aload_1 [locksMap]\n" +
		"     1  invokevirtual java.util.HashMap.keySet() : java.util.Set [16]\n" +
		"     4  invokeinterface java.util.Set.iterator() : java.util.Iterator [22] [nargs: 1]\n" +
		"     9  astore_3 [iter]\n" +
		"    10  goto 38\n" +
		"    13  aload_3 [iter]\n" +
		"    14  invokeinterface java.util.Iterator.next() : java.lang.Object [28] [nargs: 1]\n" +
		"    19  astore 4 [call]\n" +
		"    21  aload_0 [this]\n" +
		"    22  aload_1 [locksMap]\n" +
		"    23  aload 4 [call]\n" +
		"    25  invokevirtual java.util.HashMap.get(java.lang.Object) : java.lang.Object [34]\n" +
		"    28  checkcast java.util.Collection [38]\n" +
		"    31  aload 4 [call]\n" +
		"    33  " +
		(isMinimumCompliant(ClassFileConstants.JDK11) ? "invokevirtual" : "invokespecial") +
		" X.externLocks(java.util.Collection, java.lang.Object) : java.util.List [40]\n" +
		"    36  astore 5\n" +
		"    38  aload_3 [iter]\n" +
		"    39  invokeinterface java.util.Iterator.hasNext() : boolean [44] [nargs: 1]\n" +
		"    44  ifne 13\n" +
		"    47  return\n" +
		"      Line numbers:\n" +
		"        [pc: 0, line: 9]\n" +
		"        [pc: 13, line: 10]\n" +
		"        [pc: 21, line: 11]\n" +
		"        [pc: 38, line: 9]\n" +
		"        [pc: 47, line: 14]\n" +
		"      Local variable table:\n" +
		"        [pc: 0, pc: 48] local: this index: 0 type: X\n" +
		"        [pc: 0, pc: 48] local: locksMap index: 1 type: java.util.HashMap\n" +
		"        [pc: 0, pc: 48] local: key index: 2 type: java.lang.Object\n" +
		"        [pc: 10, pc: 47] local: iter index: 3 type: java.util.Iterator\n" +
		"        [pc: 21, pc: 38] local: call index: 4 type: java.lang.Object\n";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
public void test1108() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				interface UnaryFunction <A, R, X extends Throwable> {
				    public R invoke(A o) throws X;
				}
				\s
				public class X implements UnaryFunction<String,Void,RuntimeException> {
				    public Void invoke(String o) throws RuntimeException {
				        return null;
				    }
				}
				""", // =================
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=176591
//?: cuts assignment context
public void test1109() {
	String xSource =
			"""
		class X {
		  public Y<String> foo()
		  {
		    return true ? Z.bar() : null;
		  }
		}
		class Y<T> {
		}
		class Z {
		  static <U> Y<U> bar() {
		    return null;
		  }
		}
		""";
	if (this.complianceLevel < ClassFileConstants.JDK1_8) {
		this.runNegativeTest(
			new String[] {
				"X.java",
				xSource,
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					return true ? Z.bar() : null;
					       ^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Y<Object> to Y<String>
				----------
				""");
	} else {
		runConformTest(
			new String[] {
				"X.java",
				xSource
			});
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=176591
//variant
public void test1110() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				class X {
				  public Y<String> foo()
				  {
				    return true ? Z.<String>bar() : null;
				  }
				}
				class Y<T> {
				}
				class Z {
				  static <U> Y<U> bar() {
				    return null;
				  }
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=177194
public void test1111() {
	Map settings = getCompilerOptions();
	settings.put(CompilerOptions.OPTION_PreserveUnusedLocal, CompilerOptions.OPTIMIZE_OUT);
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				class A<T> {
				        public T foo(Object o) {
				                return (T) o; // should get unchecked warning
				        }
				}
				
				public class X {
				        public static void main(String[] args) {
				                A<X> a = new A<X>();
				                try {
					                X s = a.foo(new Object());
				                } catch(ClassCastException e) {
				                	System.out.println("SUCCESS");
				                	return;
				                }
				            	System.out.println("FAILED");
				        }
				}
				""", // =================
		},
		"SUCCESS",
		null,
		true,
		null,
		settings,
		null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=177194 - variation
public void test1112() {
	Map settings = getCompilerOptions();
	settings.put(CompilerOptions.OPTION_PreserveUnusedLocal, CompilerOptions.OPTIMIZE_OUT);
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				class A<T> {
				        public T foo;
				}
				
				public class X {
				        public static void main(String[] args) {
				                A<X> a = new A<X>();
								 A ua = a;
								 ua.foo = new Object();
				                try {
					                X s = a.foo;
				                } catch(ClassCastException e) {
				                	System.out.println("SUCCESS");
				                	return;
				                }
				            	System.out.println("FAILED");
				        }
				}
				""", // =================
		},
		"SUCCESS",
		null,
		true,
		null,
		settings,
		null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=177194 - variation
public void test1113() {
	Map settings = getCompilerOptions();
	settings.put(CompilerOptions.OPTION_PreserveUnusedLocal, CompilerOptions.OPTIMIZE_OUT);
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				class A<T> {
				        public T foo;
				}
				
				public class X extends A<X>{
				        public static void main(String[] args) {
							new X().foo();
						 }
				 		 public void foo() {
								 A ua = this;
								 ua.foo = new Object();
				                try {
					                X s = foo;
				                } catch(ClassCastException e) {
				                	System.out.println("SUCCESS");
				                	return;
				                }
				            	System.out.println("FAILED");
				        }
				}
				""", // =================
		},
		"SUCCESS",
		null,
		true,
		null,
		settings,
		null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=177194 - variation
public void test1114() {
	Map settings = getCompilerOptions();
	settings.put(CompilerOptions.OPTION_PreserveUnusedLocal, CompilerOptions.OPTIMIZE_OUT);
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				class A<T> {
				        public T foo;
				}
				
				public class X extends A<X>{
				        public static void main(String[] args) {
							new X().foo();
						 }
				 		 public void foo() {
								 A ua = this;
								 ua.foo = new Object();
				                try {
					                X s = this.foo;
				                } catch(ClassCastException e) {
				                	System.out.println("SUCCESS");
				                	return;
				                }
				            	System.out.println("FAILED");
				        }
				}
				""", // =================
		},
		"SUCCESS",
		null,
		true,
		null,
		settings,
		null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=177194 - variation
public void test1115() {
	Map settings = getCompilerOptions();
	settings.put(CompilerOptions.OPTION_PreserveUnusedLocal, CompilerOptions.OPTIMIZE_OUT);
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				class A<T> {
				        public T foo;
				}
				
				public class X {
						 static X ROOT;
				        public static void main(String[] args) {
				                A<X> a = new A<X>();
								 A ua = a;
								 ua.foo = new Object();
				                try {
					                X s = a.foo.ROOT;
				                } catch(ClassCastException e) {
				                	System.out.println("SUCCESS");
				                	return;
				                }
				            	System.out.println("FAILED");
				        }
				}
				""", // =================
		},
		"SUCCESS",
		null,
		true,
		null,
		settings,
		null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=177194 - variation
public void test1116() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.io.Serializable;
				
				interface I {
				    int CONST = 1;
				}
				
				class Z<T extends Serializable&I> {
				    T c;
				    Z(T c) {
				        this.c = c;
				    }
				    int foo() {
				        return c.CONST;
				    }
				}
				
				public class X implements Serializable, I {
				    public static void main(String argv[]) {
				        Z<X> z = new Z<X>(new X());
				        Z rawz = z;
				        rawz.c = new Serializable(){};
				        try {
					        z.foo();
				        } catch(ClassCastException e) {
				        	System.out.println("SUCCESS");
				        }
				    }
				}
				""", // =================
		},
		"SUCCESS");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=177194 - variation
public void test1117() throws Exception {
	Map options = getCompilerOptions();
	options.put(CompilerOptions.OPTION_PreserveUnusedLocal, CompilerOptions.OPTIMIZE_OUT);
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				interface I<T> {
					Value<String> CONST = null;
				}
				class Value<V> {
					String NAME = "VALUE";
				}
				class B<V> implements I<V> {
					B(Value<String> param) {
						Value<String> v0 = CONST;
						Value<String> v1 = this.CONST;
						String s2 = CONST.NAME;
						Value<String> v3 = I.CONST;
						Value<String> v4 = B.CONST;
					}
				}
				public class X {
					public static void main(String[] args) {
						try {
							new B<String>(new Value<String>());
						} catch(NullPointerException e) {
							System.out.println("SUCCESS");
						}
					}
				}
				""", // =================
		},
		"SUCCESS",
		null,
		false,
		null,
		options,
		null);
	// check the reference to I.CONST is generated as B.CONST, except for v3 still issuing I.CONST
	String expectedOutput =
		"""
		  // Method descriptor #8 (LValue;)V
		  // Signature: (LValue<Ljava/lang/String;>;)V
		  // Stack: 1, Locals: 2
		  B(Value param);
		     0  aload_0 [this]
		     1  invokespecial java.lang.Object() [12]
		     4  getstatic B.CONST : Value [15]
		     7  pop
		     8  getstatic B.CONST : Value [15]
		    11  pop
		    12  getstatic B.CONST : Value [15]
		    15  getfield Value.NAME : java.lang.String [19]
		    18  pop
		    19  getstatic I.CONST : Value [25]
		    22  pop
		    23  getstatic B.CONST : Value [15]
		    26  pop
		    27  return
		      Line numbers:
		        [pc: 0, line: 8]
		        [pc: 4, line: 9]
		        [pc: 8, line: 10]
		        [pc: 12, line: 11]
		        [pc: 19, line: 12]
		        [pc: 23, line: 13]
		        [pc: 27, line: 14]
		      Local variable table:
		        [pc: 0, pc: 28] local: this index: 0 type: B
		        [pc: 0, pc: 28] local: param index: 1 type: Value
		      Local variable type table:
		        [pc: 0, pc: 28] local: this index: 0 type: B<V>
		        [pc: 0, pc: 28] local: param index: 1 type: Value<java.lang.String>
		""";

	File f = new File(OUTPUT_DIR + File.separator + "B.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=177715
public void test1118() {
	String source = """
		import java.util.List;
		
		public class X {
			X() {
				Class<? extends List<?>> cls = null;
				foo(cls);
			}
		
			<I, T extends List<I>> T foo(Class<T> pClass) {
				return null;
			}
		}
		""";
	if (this.complianceLevel < ClassFileConstants.JDK1_8) {
		runConformTest(
				new String[] { "X.java", source },
				JavacTestOptions.EclipseHasABug.EclipseBug177715 /* javac test options */);
	} else {
		runNegativeTest(
			new String[] { "X.java", source },
			"""
				----------
				1. ERROR in X.java (at line 6)
					foo(cls);
					^^^
				The method foo(Class<T>) in the type X is not applicable for the arguments (Class<capture#1-of ? extends List<?>>)
				----------
				""");
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=169728
public void test1119() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends Comparable<T> & Runnable> {
					T get() {
						return null;
					}
					public static void main(String[] args) {
					\t
						X<OnlyRunnable> x1 = null; // error
						X<OnlyComparable> x2 = null; // error
						X<ComparableRunnable> x3 = null; // ok
						X<ComparableRunnableThrowable> x4 = null; // ok
					\t
						foo1(x1); // ok
						foo1(x2); // ok
						foo1(x3); // ok
						foo1(x4); // ok
				
						foo2(x1); // error
						foo2(x2); // error
						foo2(x3); // error
						foo2(x4); // ok
					}
				\t
					static void foo1(X<?> x) {
						x.get().run(); // ok
						x.get().compareTo(null); // ok
						x.get().compareTo(x.get()); // error
					}
					static void foo2(X<? extends Throwable> x) {
						x.get().run(); // ok
						x.get().compareTo(null); // ok
						x.get().compareTo(x.get()); // error
					}\t
				}
				
				abstract class OnlyRunnable implements Runnable {}
				abstract class OnlyComparable implements Comparable<OnlyComparable> {}
				abstract class ComparableRunnable implements Comparable<ComparableRunnable>, Runnable {}
				abstract class ComparableRunnableThrowable extends Throwable implements Comparable<ComparableRunnable>, Runnable {
					private static final long serialVersionUID = 1L;
				}""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 7)
				X<OnlyRunnable> x1 = null; // error
				  ^^^^^^^^^^^^
			Bound mismatch: The type OnlyRunnable is not a valid substitute for the bounded parameter <T extends Comparable<T> & Runnable> of the type X<T>
			----------
			2. ERROR in X.java (at line 8)
				X<OnlyComparable> x2 = null; // error
				  ^^^^^^^^^^^^^^
			Bound mismatch: The type OnlyComparable is not a valid substitute for the bounded parameter <T extends Comparable<T> & Runnable> of the type X<T>
			----------
			3. ERROR in X.java (at line 10)
				X<ComparableRunnableThrowable> x4 = null; // ok
				  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Bound mismatch: The type ComparableRunnableThrowable is not a valid substitute for the bounded parameter <T extends Comparable<T> & Runnable> of the type X<T>
			----------
			4. ERROR in X.java (at line 17)
				foo2(x1); // error
				^^^^
			The method foo2(X<? extends Throwable>) in the type X<T> is not applicable for the arguments (X<OnlyRunnable>)
			----------
			5. ERROR in X.java (at line 18)
				foo2(x2); // error
				^^^^
			The method foo2(X<? extends Throwable>) in the type X<T> is not applicable for the arguments (X<OnlyComparable>)
			----------
			6. ERROR in X.java (at line 19)
				foo2(x3); // error
				^^^^
			The method foo2(X<? extends Throwable>) in the type X<T> is not applicable for the arguments (X<ComparableRunnable>)
			----------
			7. ERROR in X.java (at line 26)
				x.get().compareTo(x.get()); // error
				        ^^^^^^^^^
			The method compareTo(capture#3-of ?) in the type Comparable<capture#3-of ?> is not applicable for the arguments (capture#4-of ?)
			----------
			8. ERROR in X.java (at line 31)
				x.get().compareTo(x.get()); // error
				        ^^^^^^^^^
			The method compareTo(capture#7-of ? extends Throwable) in the type Comparable<capture#7-of ? extends Throwable> is not applicable for the arguments (capture#8-of ? extends Throwable)
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=166963
public void test1120() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public X() {
						System.out.println();
						this(zork);
						Zork.this.this();
						<Zork>this();
					}
				}""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 4)
				this(zork);
				^^^^^^^^^^^
			Constructor call must be the first statement in a constructor
			----------
			2. ERROR in X.java (at line 4)
				this(zork);
				     ^^^^
			zork cannot be resolved to a variable
			----------
			3. ERROR in X.java (at line 5)
				Zork.this.this();
				^^^^^^^^^^^^^^^^^
			Constructor call must be the first statement in a constructor
			----------
			4. ERROR in X.java (at line 5)
				Zork.this.this();
				^^^^
			Zork cannot be resolved to a type
			----------
			5. ERROR in X.java (at line 6)
				<Zork>this();
				 ^^^^
			Zork cannot be resolved to a type
			----------
			6. ERROR in X.java (at line 6)
				<Zork>this();
				      ^^^^^^^
			Constructor call must be the first statement in a constructor
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=181270
public void test1121() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {
					void foo() {
						System.out.println(T[].class);
					}
				}""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 3)
				System.out.println(T[].class);
				                   ^^^^^^^^^
			Illegal class literal for the type parameter T
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=181270
public void test1122() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					<T> void foo() {
						System.out.println(T[].class);
					}
				}""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 3)
				System.out.println(T[].class);
				                   ^^^^^^^^^
			Illegal class literal for the type parameter T
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=181270 - variation
public void test1123() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					void foo() {
						Class<Integer> c1 = int.class;
						Class<Integer> c2 = Integer.class;
						Class<Integer[]> c3 = int[].class;
						Class<int[]> c4 = int[].class;
						Class<Void> c5 = void.class;
						Class<void[]> c6 = void[].class;
					}
				}""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 5)
				Class<Integer[]> c3 = int[].class;
				                      ^^^^^^^^^^^
			Type mismatch: cannot convert from Class<int[]> to Class<Integer[]>
			----------
			2. ERROR in X.java (at line 8)
				Class<void[]> c6 = void[].class;
				      ^^^^^^
			void[] is an invalid type
			----------
			3. ERROR in X.java (at line 8)
				Class<void[]> c6 = void[].class;
				                   ^^^^^^
			void[] is an invalid type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=182192
public void test1124() {
	String errMessage = isMinimumCompliant(ClassFileConstants.JDK11) ?
			"""
				----------
				1. WARNING in X.java (at line 13)
					public static class InnerClassThatShowsBug extends X {
					                                                   ^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				2. WARNING in X.java (at line 15)
					super(null);
					^^^^^^^^^^^^
				Type safety: The constructor X(Object) belongs to the raw type X. References to generic type X<T> should be parameterized
				----------
				3. ERROR in X.java (at line 19)
					for (Map.Entry<String, String> entry : myMap().entrySet()) {
					                                       ^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from element type Object to Map.Entry<String,String>
				----------
				"""
			:
			"""
				----------
				1. WARNING in X.java (at line 13)
					public static class InnerClassThatShowsBug extends X {
					                                                   ^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				2. WARNING in X.java (at line 15)
					super(null);
					^^^^^^^^^^^^
				Type safety: The constructor X(Object) belongs to the raw type X. References to generic type X<T> should be parameterized
				----------
				3. WARNING in X.java (at line 15)
					super(null);
					^^^^^^^^^^^^
				Access to enclosing constructor X<T>(T) is emulated by a synthetic accessor method
				----------
				4. ERROR in X.java (at line 19)
					for (Map.Entry<String, String> entry : myMap().entrySet()) {
					                                       ^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from element type Object to Map.Entry<String,String>
				----------
				""";
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.HashMap;
				import java.util.Map;
				
				public class X<T> {
				
					static protected final Map<String, String> myMap = new HashMap<String, String>();
					private final T theGenericThing;
				
					private X(T something) {
						this.theGenericThing = something;
					}
				
					public static class InnerClassThatShowsBug extends X {
						public InnerClassThatShowsBug() {
							super(null);
						}
				
						public void printMap() {
							for (Map.Entry<String, String> entry : myMap().entrySet()) {
								System.out.println(entry.getKey() + " => " + entry.getValue());
							}
						}
						protected Map<String, String> myMap2() {
							return myMap;
						}
						public void printMap2() {
							for (Map.Entry<String, String> entry : myMap2().entrySet()) {
								System.out.println(entry.getKey() + " => " + entry.getValue());
							}
						}
					}
				
					protected Map<String, String> myMap() {
						return myMap;
					}
				}""", // =================
		}, errMessage);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=183216
public void test1125() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				class A {
				    class B<T> {
				        T t;
				        T getValue() {
				            return t;
				        }
				    }
				}
				
				class C<T> extends A {
					Zork z;
				}
				
				public class X {
				    static C.B<Double> c = new C().new B<Double>();
				
				    public static void main(String[] args) {
				        C.B<String> temp = new C().new B<String>();
				        String s = temp.getValue();
				        System.out.println(s);
				        foo(bar());
				    }
				
				    static C.B<? extends Number> bar() {
				        return new C().new B<Integer>();
				    }
				
				    static void foo(C.B<?> arg) {
				        Object o = arg.getValue();
				        Double d = c.getValue();
				        System.out.println(o);
				        System.out.println(d);
				    }
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 11)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			2. WARNING in X.java (at line 15)
				static C.B<Double> c = new C().new B<Double>();
				                           ^
			C is a raw type. References to generic type C<T> should be parameterized
			----------
			3. WARNING in X.java (at line 18)
				C.B<String> temp = new C().new B<String>();
				                       ^
			C is a raw type. References to generic type C<T> should be parameterized
			----------
			4. WARNING in X.java (at line 25)
				return new C().new B<Integer>();
				           ^
			C is a raw type. References to generic type C<T> should be parameterized
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=183216 - variation
public void test1126() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				class A {
				    class B<T> {
				        T t;
				        T getValue() {
				            return t;
				        }
				    }
				}
				
				public class X {
				    static A.B<Double> c = new A().new B<Double>();
				
				    public static void main(String[] args) {
				        A.B<String> temp = new A().new B<String>();
				        String s = temp.getValue();
				        System.out.print(s);
				        foo(bar());
				    }
				
				    static A.B<? extends Number> bar() {
				        return new A().new B<Integer>();
				    }
				
				    static void foo(A.B<?> arg) {
				        Object o = arg.getValue();
				        Double d = c.getValue();
				        System.out.print(o);
				        System.out.print(d);
				    }
				}
				""", // =================
		},
		"nullnullnull");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=183216 - variation
public void test1127() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				class A<E> {
				    class B<T> {
				        T t;
				        T getValue() {
				            return t;
				        }
				    }
				}
				
				class C<T> extends A<T> {
				}
				
				public class X {
				    static C.B<Double> c = new C().new B<Double>();
				
				    public static void main(String[] args) {
				        C.B<String> temp = new C().new B<String>();
				        String s = temp.getValue();
				        System.out.println(s);
				        foo(bar());
				    }
				
				    static C.B<? extends Number> bar() {
				        return new C().new B<Integer>();
				    }
				
				    static void foo(C.B<?> arg) {
				        Object o = arg.getValue();
				        Double d = c.getValue();
				        System.out.println(o);
				        System.out.println(d);
				    }
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 14)
				static C.B<Double> c = new C().new B<Double>();
				       ^^^
			The member type A.B<Double> must be qualified with a parameterized type, since it is not static
			----------
			2. WARNING in X.java (at line 14)
				static C.B<Double> c = new C().new B<Double>();
				                           ^
			C is a raw type. References to generic type C<T> should be parameterized
			----------
			3. ERROR in X.java (at line 14)
				static C.B<Double> c = new C().new B<Double>();
				                                   ^
			The member type A.B<Double> must be qualified with a parameterized type, since it is not static
			----------
			4. ERROR in X.java (at line 17)
				C.B<String> temp = new C().new B<String>();
				^^^
			The member type A.B<String> must be qualified with a parameterized type, since it is not static
			----------
			5. WARNING in X.java (at line 17)
				C.B<String> temp = new C().new B<String>();
				                       ^
			C is a raw type. References to generic type C<T> should be parameterized
			----------
			6. ERROR in X.java (at line 17)
				C.B<String> temp = new C().new B<String>();
				                               ^
			The member type A.B<String> must be qualified with a parameterized type, since it is not static
			----------
			7. ERROR in X.java (at line 23)
				static C.B<? extends Number> bar() {
				       ^^^
			The member type A.B<? extends Number> must be qualified with a parameterized type, since it is not static
			----------
			8. WARNING in X.java (at line 24)
				return new C().new B<Integer>();
				           ^
			C is a raw type. References to generic type C<T> should be parameterized
			----------
			9. ERROR in X.java (at line 24)
				return new C().new B<Integer>();
				                   ^
			The member type A.B<Integer> must be qualified with a parameterized type, since it is not static
			----------
			10. ERROR in X.java (at line 27)
				static void foo(C.B<?> arg) {
				                ^^^
			The member type A.B<?> must be qualified with a parameterized type, since it is not static
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=183216 - variation
public void test1128() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				class A<T> {
					class Member<U> {}
				}
				
				public class X extends A {
					void foo() {
						new Member<String>();
						new X().new Member<String>();
					}
				}
				""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 5)
				public class X extends A {
				                       ^
			A is a raw type. References to generic type A<T> should be parameterized
			----------
			2. ERROR in X.java (at line 7)
				new Member<String>();
				    ^^^^^^
			The member type A.Member<String> must be qualified with a parameterized type, since it is not static
			----------
			3. ERROR in X.java (at line 8)
				new X().new Member<String>();
				            ^^^^^^
			The member type A.Member<String> must be qualified with a parameterized type, since it is not static
			----------
			""");
}
public void test1129() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.io.Serializable;
				
				abstract class Arg1 implements Comparable<Arg1>, Serializable {
					private static final long serialVersionUID = 1L;
				}
				abstract class Arg2 implements Serializable, Comparable<Arg2> {
					private static final long serialVersionUID = 1L;
				}
				
				interface IX<T> {}
				
				public class X {
					void foo1(boolean b, IX<String> arg2) {
						IX<String> o = b ? null : arg2;
						IX<String> o2 = b ? arg2 : null;
					}
					void foo2(boolean b, IX<String> arg1, IX<? extends Object> arg2) {
						String s = b ? arg1 : arg2;
					}
					void foo3(boolean b, Arg1 arg1, Arg2 arg2) {
						String s = b ? arg1 : arg2;
					}
				} \s""", // =================
		},
		this.complianceLevel < ClassFileConstants.JDK1_8 ?
		"""
			----------
			1. ERROR in X.java (at line 18)
				String s = b ? arg1 : arg2;
				           ^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from IX<capture#2-of ? extends Object> to String
			----------
			2. ERROR in X.java (at line 21)
				String s = b ? arg1 : arg2;
				           ^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from Object&Comparable<?>&Serializable to String
			----------
			""" :
			"""
				----------
				1. ERROR in X.java (at line 18)
					String s = b ? arg1 : arg2;
					               ^^^^
				Type mismatch: cannot convert from IX<String> to String
				----------
				2. ERROR in X.java (at line 18)
					String s = b ? arg1 : arg2;
					                      ^^^^
				Type mismatch: cannot convert from IX<capture#1-of ? extends Object> to String
				----------
				3. ERROR in X.java (at line 21)
					String s = b ? arg1 : arg2;
					               ^^^^
				Type mismatch: cannot convert from Arg1 to String
				----------
				4. ERROR in X.java (at line 21)
					String s = b ? arg1 : arg2;
					                      ^^^^
				Type mismatch: cannot convert from Arg2 to String
				----------
				""");
}
public void test1130() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.io.Serializable;
				import java.util.List;
				
				interface IX<T extends Comparable<T>&Serializable> {}
				
				public class X<T extends Comparable<T>&Serializable> {
					void foo4(boolean b, List<? extends T> l1, List<? extends Comparable<T>> l2) {
						String s = b ? l1.get(0) : l2.get(0);
					}
				}
				""", // =================
		},
		this.complianceLevel < ClassFileConstants.JDK1_8 ?
			"""
				----------
				1. ERROR in X.java (at line 8)
					String s = b ? l1.get(0) : l2.get(0);
					           ^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Comparable<T> to String
				----------
				""" :
				"""
					----------
					1. ERROR in X.java (at line 8)
						String s = b ? l1.get(0) : l2.get(0);
						               ^^^^^^^^^
					Type mismatch: cannot convert from capture#1-of ? extends T to String
					----------
					2. ERROR in X.java (at line 8)
						String s = b ? l1.get(0) : l2.get(0);
						                           ^^^^^^^^^
					Type mismatch: cannot convert from capture#2-of ? extends Comparable<T> to String
					----------
					""");
}
public void test1131() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.io.Serializable;
				import java.util.List;
				
				public class X<T extends Comparable<T>&Serializable> {
					<V extends T> void foo4(boolean b, List<? extends V> l1, List<? extends Comparable<V>> l2) {
						String s = b ? l1.get(0) : l2.get(0);
					}
				}\s
				""", // =================
		},
		this.complianceLevel < ClassFileConstants.JDK1_8 ?
			"""
				----------
				1. ERROR in X.java (at line 6)
					String s = b ? l1.get(0) : l2.get(0);
					           ^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Comparable<capture#3-of ? extends T> to String
				----------
				""" :
				"""
					----------
					1. ERROR in X.java (at line 6)
						String s = b ? l1.get(0) : l2.get(0);
						               ^^^^^^^^^
					Type mismatch: cannot convert from capture#1-of ? extends V to String
					----------
					2. ERROR in X.java (at line 6)
						String s = b ? l1.get(0) : l2.get(0);
						                           ^^^^^^^^^
					Type mismatch: cannot convert from capture#2-of ? extends Comparable<V> to String
					----------
					""");
}
public void test1132() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				
				public class X<T> {
				
					public void thisDoesntCompile() {
						X myThing = new X<Object>();
						Integer i = myThing.getList().get(0); // Type Mismatch error - Since
																// myThing is unbounded, return
																// type List<Integer> becomes unbounded
					}
				
					public List<Integer> getList() {
						ArrayList<Integer> l = new ArrayList<Integer>();
						l.add(Integer.valueOf(0));
						return l;
					}
				
					public void thisMethodCompilesOk() {
						X<Object> myThing = new X<Object>();
						Integer i = myThing.getList().get(0);
					}
				
					public void thisMethodAlsoCompilesOk() {
						X myThing = new X<Object>();
						List<Integer> l = myThing.getList();
						Integer i = l.get(0);
					}
				}
				""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 6)
				X myThing = new X<Object>();
				^
			X is a raw type. References to generic type X<T> should be parameterized
			----------
			2. ERROR in X.java (at line 7)
				Integer i = myThing.getList().get(0); // Type Mismatch error - Since
				            ^^^^^^^^^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from Object to Integer
			----------
			3. WARNING in X.java (at line 24)
				X myThing = new X<Object>();
				^
			X is a raw type. References to generic type X<T> should be parameterized
			----------
			4. WARNING in X.java (at line 25)
				List<Integer> l = myThing.getList();
				                  ^^^^^^^^^^^^^^^^^
			Type safety: The expression of type List needs unchecked conversion to conform to List<Integer>
			----------
			""");
}
public void test1133() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				
				class Y {
					List<String> foo() { return null; }
				}
				
				public class X<T> extends Y {
					List<String> bar() { return null; }
				\t
					void m(X x) {
						List<Object> l1 = x.foo();
						List<Object> l2 = x.bar();
					}
				}
				""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 10)
				void m(X x) {
				       ^
			X is a raw type. References to generic type X<T> should be parameterized
			----------
			2. ERROR in X.java (at line 11)
				List<Object> l1 = x.foo();
				                  ^^^^^^^
			Type mismatch: cannot convert from List<String> to List<Object>
			----------
			3. WARNING in X.java (at line 12)
				List<Object> l2 = x.bar();
				                  ^^^^^^^
			Type safety: The expression of type List needs unchecked conversion to conform to List<Object>
			----------
			""");
}
public void test1134() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				
				class Y<U> {
					List<String> foo() { return null; }
				}
				
				public class X<T> extends Y<T> {
					List<String> bar() { return null; }
				\t
					void m(X x) {
						List<Object> l1 = x.foo();
						List<Object> l2 = x.bar();
						Zork z;
					}
				}
				""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 10)
				void m(X x) {
				       ^
			X is a raw type. References to generic type X<T> should be parameterized
			----------
			2. WARNING in X.java (at line 11)
				List<Object> l1 = x.foo();
				                  ^^^^^^^
			Type safety: The expression of type List needs unchecked conversion to conform to List<Object>
			----------
			3. WARNING in X.java (at line 12)
				List<Object> l2 = x.bar();
				                  ^^^^^^^
			Type safety: The expression of type List needs unchecked conversion to conform to List<Object>
			----------
			4. ERROR in X.java (at line 13)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=185422
public void test1135() {
	runNegativeTest(
		new String[] { /* test files */
			"X.java",
			"""
				class Foo <T>{
				    private T myT;
				
				    public T getT() {
				        return myT;
				    }
				
				    public void setT(T aT) {
				        myT = aT;
				    }
				}
				
				public class X extends Foo<X.Baz> {
					X.Baz baz;
				    public static void main(String[] args) {
				        X myBar = new X();
				        myBar.setT(new Baz());
				        System.out.println(myBar.getT().toString());
				    }
				
				    private static class Baz {
				        @Override
				        public String toString() {
				            return "Baz";
				        }
				    }   \s
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 13)
				public class X extends Foo<X.Baz> {
				                           ^^^^^
			The type X.Baz is not visible
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=154029
public void test1136() {
	Map options = getCompilerOptions();
	options.put(JavaCore.COMPILER_PB_UNCHECKED_TYPE_OPERATION, JavaCore.IGNORE);
	String xSource =
			"""
		import java.util.*;
		public class X {
			public static void main(String[] args) {
				List<Object>  l1 = Arrays.asList(1, "X");
			\t
				B<String> b = null;
				C<String>c = null;
				List<Object>  l2 = Arrays.asList(b, c);
			}
		}
		class A<T> {}
		interface I {}
		class B<T> extends A<T> implements I {}
		class C<T> extends A<T> implements I {}
		""";
	if (this.complianceLevel < ClassFileConstants.JDK1_8) {
		this.runNegativeTest(
			new String[] {
				"X.java",
				xSource,
			},
			"----------\n" +
			"1. ERROR in X.java (at line 4)\n" +
			"	List<Object>  l1 = Arrays.asList(1, \"X\");\n" +
			"	                   ^^^^^^^^^^^^^^^^^^^^^\n" +
			"Type mismatch: cannot convert from List<Object&"+ intersection("Comparable<?>") +"&Serializable> to List<Object>\n" +
			"----------\n" +
			"2. ERROR in X.java (at line 8)\n" +
			"	List<Object>  l2 = Arrays.asList(b, c);\n" +
			"	                   ^^^^^^^^^^^^^^^^^^^\n" +
			"Type mismatch: cannot convert from List<A<String>&I> to List<Object>\n" +
			"----------\n",
			null,
			true,
			options);
	} else {
		runConformTest(new String[] { "X.java", xSource }, options);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=154267
public void test1137() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.awt.Container;
				import java.util.Collection;
				
				abstract class Kollection<T extends Container> implements Collection<T> {}
				abstract class Kontainer extends Container {
					private static final long serialVersionUID = 1L;
				}
				
				public class X {
					private <T extends Container> Collection<T> foo() {
						return null;
					}
					private <T extends Container> Kollection<T> bar() {
						return null;
					}
				
					private void showProblem() {
						Collection<?> result = foo();
						Collection<? extends Container> result1 = foo();
					\t
						Collection<?> result2 = (Collection<Container>)foo();
						String result3 = foo();
						String result4 = (String) foo();	\t
				
						Kollection<?> result5 = bar();
						Kollection<? extends Kontainer> result6 = bar();
					}
				}
				""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 21)
				Collection<?> result2 = (Collection<Container>)foo();
				                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Unnecessary cast from Collection<Container> to Collection<Container>
			----------
			2. ERROR in X.java (at line 22)
				String result3 = foo();
				                 ^^^^^
			Type mismatch: cannot convert from Collection<Container> to String
			----------
			3. ERROR in X.java (at line 23)
				String result4 = (String) foo();	\t
				                 ^^^^^^^^^^^^^^
			Cannot cast from Collection<Container> to String
			----------
			""");
}
public void test1138() {
	// binary prerequisite
	this.runConformTest(
		new String[] {
			"p/E.java",
			"""
				package p;
				public enum E {
				}
				""", // =================
		},
		"");
	this.runConformTest(
			new String[] {
				"X.java",
				"""
					import static p.E.*;
					public class X implements java.io.Serializable {
					}
					""", // =================
			},
			"",
			null, // use default class-path
			false, // do not flush previous output dir content
			null); // no special vm args		);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=186833
public void test1139() {
	this.runNegativeTest(
		new String[] {
			"p/X.java",
			"""
				package p;
				import p.X.Super;
				import static p.Top.*;
				
				class Top<T> {
					static class A<U> {}
				}
				
				public class X extends Super<A<X>> {
					static class Super<T> extends Top<T>{
					}
				}""", // =================
		},
		"""
			----------
			1. ERROR in p\\X.java (at line 9)
				public class X extends Super<A<X>> {
				                       ^^^^^
			Cycle detected: the type X cannot extend/implement itself or one of its own member types
			----------
			"""
	);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=186788
public void test1140() {
	this.runNegativeTest(
		new String[] {
			"p/X.java",
			"""
				package p;
				import static p.X.Super;
				import static p.Top.*;
				
				class Top<T> {
				        static class A<U> {}
				}
				
				public class X extends Super<A<X>> {
				        class Super<T> extends Top<T>{
				        }
				}""", // =================
		},
		"""
			----------
			1. ERROR in p\\X.java (at line 2)
				import static p.X.Super;
				              ^^^^^^^^^
			The import p.X.Super cannot be resolved
			----------
			2. ERROR in p\\X.java (at line 9)
				public class X extends Super<A<X>> {
				                       ^^^^^
			Super cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=186833 - variation
public void test1141() {
	this.runNegativeTest(
		new String[] {
			"p/X.java",
			"""
				package p;
				import static p.Top.*;
				
				class Top<T> {
					static class A<U> {}
				}
				
				public class X extends p.X.Super<A<X>> {
					static class Super<T> extends Top<T>{
					}
				}""", // =================
		},
		"""
			----------
			1. ERROR in p\\X.java (at line 8)
				public class X extends p.X.Super<A<X>> {
				                       ^^^^^^^^^
			Cycle detected: the type X cannot extend/implement itself or one of its own member types
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=190945
public void test1142() {
	runNegativeTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				import java.util.Comparator;
				import java.util.List;
				public class X {
				  public static <T> Comparator<T> compound(Comparator<? super T> a, Comparator<? super T> b) {
					  return compound(asList(a, b));
				  }
				
				  public static <T> Comparator<T> compound(Iterable<? extends Comparator<? super T>> comparators) {
				    return null;
				  }
				  public static <E> List<E> asList(E a, E b) {
				    return null;
				  }
				}
				""", // =================
		},
		// compiler results
		"----------\n" + /* expected compiler log */
		"1. ERROR in X.java (at line 5)\n" +
		"	return compound(asList(a, b));\n" +
		"	       ^^^^^^^^\n" +
		"The method compound(Iterable<? extends Comparator<? super T>>) in the type X is not applicable for the arguments (List<Comparator<? extends Object>>)\n" +
		"----------\n",
		// javac options
		JavacTestOptions.JavacHasABug.JavacBug6573446 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=190945 - variation
public void test1143() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.Comparator;
				import java.util.List;
				public class X {
				  public static <T> Comparator<T> compound(Comparator<? super T> a, Comparator<? super T> b) {
					  int i = asList(a, b);
				  }
				
				  public static <T> Comparator<T> compound(Iterable<? extends Comparator<? super T>> comparators) {
				    return null;
				  }
				  public static <E> List<E> asList(E a, E b) {
				    return null;
				  }
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 5)
				int i = asList(a, b);
				        ^^^^^^^^^^^^
			Type mismatch: cannot convert from List<Comparator<? extends Object>> to int
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=190945 - variation
public void test1144() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.Comparator;
				import java.util.List;
				public class X {
				  Iterable<Comparator<? extends Object>> itc1;
				  Iterable<? extends Comparator<? super Object>> itc2 = itc1;
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 5)
				Iterable<? extends Comparator<? super Object>> itc2 = itc1;
				                                                      ^^^^
			Type mismatch: cannot convert from Iterable<Comparator<? extends Object>> to Iterable<? extends Comparator<? super Object>>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=190945 - variation
public void test1145() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				
				public class X {
					<T> Comparator<T> compound(Comparator<? super T> a, Comparator<? super T> b) {
						return compound(asList(a));
					}
					<T> Comparator<T> compound(Iterable<? extends Comparator<? super T>> c) {
						return null;
					}
					<E> List<E> asList(E a) {
						return null;
					}
				}
				""", // =================
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=190945 - variation
public void test1146() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				public class X {
					public static <T> Comparator<T> compound(
							Comparator<? super T> a,
							Comparator<? super T> b,\s
							Comparator<? super T>... rest) {
						int i = asList(a, b, rest);
						int j = asList2(a, b);
						return compound(asList(a, b, rest));
					}
					public static <U> Comparator<U> compound(Iterable<? extends Comparator<? super U>> comparators) {
						return null;
					}
					public static <E> List<E> asList(E a, E b, E... rest) {
						return null;
					}
					public static <E> List<E> asList2(E a, E b) {
						return null;
					}\t
				}
				""", // =================
		},
		this.complianceLevel < ClassFileConstants.JDK1_7 ?
		"""
			----------
			1. ERROR in X.java (at line 7)
				int i = asList(a, b, rest);
				        ^^^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from List<Comparator<?>> to int
			----------
			2. ERROR in X.java (at line 8)
				int j = asList2(a, b);
				        ^^^^^^^^^^^^^
			Type mismatch: cannot convert from List<Comparator<? extends Object>> to int
			----------
			3. ERROR in X.java (at line 9)
				return compound(asList(a, b, rest));
				       ^^^^^^^^
			The method compound(Iterable<? extends Comparator<? super U>>) in the type X is not applicable for the arguments (List<Comparator<?>>)
			----------
			""":
		(this.complianceLevel == ClassFileConstants.JDK1_7 ?
			"""
				----------
				1. WARNING in X.java (at line 6)
					Comparator<? super T>... rest) {
					                         ^^^^
				Type safety: Potential heap pollution via varargs parameter rest
				----------
				2. ERROR in X.java (at line 7)
					int i = asList(a, b, rest);
					        ^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from List<Comparator<?>> to int
				----------
				3. ERROR in X.java (at line 8)
					int j = asList2(a, b);
					        ^^^^^^^^^^^^^
				Type mismatch: cannot convert from List<Comparator<? extends Object>> to int
				----------
				4. ERROR in X.java (at line 9)
					return compound(asList(a, b, rest));
					       ^^^^^^^^
				The method compound(Iterable<? extends Comparator<? super U>>) in the type X is not applicable for the arguments (List<Comparator<?>>)
				----------
				5. WARNING in X.java (at line 14)
					public static <E> List<E> asList(E a, E b, E... rest) {
					                                                ^^^^
				Type safety: Potential heap pollution via varargs parameter rest
				----------
				"""
			: """
				----------
				1. WARNING in X.java (at line 6)
					Comparator<? super T>... rest) {
					                         ^^^^
				Type safety: Potential heap pollution via varargs parameter rest
				----------
				2. ERROR in X.java (at line 7)
					int i = asList(a, b, rest);
					        ^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from List<Comparator<? super T>> to int
				----------
				3. ERROR in X.java (at line 8)
					int j = asList2(a, b);
					        ^^^^^^^^^^^^^
				Type mismatch: cannot convert from List<Comparator<? extends Object>> to int
				----------
				4. WARNING in X.java (at line 14)
					public static <E> List<E> asList(E a, E b, E... rest) {
					                                                ^^^^
				Type safety: Potential heap pollution via varargs parameter rest
				----------
				"""));
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=190945 - variation
public void test1147() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				public class X {
					void foo(Comparator<? super X> cx, Comparator<? super X>[] cxs) {
						int i = cx;
						int j = cxs;
						int k = cxs[0];
						int l = asList2(cxs[0], cxs[1]);
					}
					public static <E> List<E> asList2(E a, E b) {
						return null;
					}\t
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 4)
				int i = cx;
				        ^^
			Type mismatch: cannot convert from Comparator<capture#1-of ? super X> to int
			----------
			2. ERROR in X.java (at line 5)
				int j = cxs;
				        ^^^
			Type mismatch: cannot convert from Comparator<? super X>[] to int
			----------
			3. ERROR in X.java (at line 6)
				int k = cxs[0];
				        ^^^^^^
			Type mismatch: cannot convert from Comparator<capture#2-of ? super X> to int
			----------
			4. ERROR in X.java (at line 7)
				int l = asList2(cxs[0], cxs[1]);
				        ^^^^^^^^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from List<Comparator<? extends Object>> to int
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=190945 - variation
// FAIL ERRMSG
public void test1148() {
	if (this.complianceLevel >= ClassFileConstants.JDK1_8)
		return;
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				public class X {
					public static <T> Comparator<T> compound(Comparator<? super T> a, Comparator<? super T> b, Comparator<? super T>... rest) {
						int i = asList(a, b, rest);
						int j = compound(asList(a, b, rest));
						compound(asList(a, b, rest));
						if (true) return compound(asList(a, b, rest));
					\t
						List<Comparator<?>> c = null;
						compound(c);
						return compound(c);
					}
					public static <U> Comparator<U> compound(Iterable<? extends Comparator<? super U>> comparators) {
						return null;
					}
					public static <E> List<E> asList(E a, E b, E... rest) {
						return null;
					}
				}
				""", // =================
		},
		this.complianceLevel < ClassFileConstants.JDK1_7 ?
		"""
			----------
			1. ERROR in X.java (at line 4)
				int i = asList(a, b, rest);
				        ^^^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from List<Comparator<?>> to int
			----------
			2. ERROR in X.java (at line 5)
				int j = compound(asList(a, b, rest));
				        ^^^^^^^^
			The method compound(Iterable<? extends Comparator<? super U>>) in the type X is not applicable for the arguments (List<Comparator<?>>)
			----------
			3. ERROR in X.java (at line 6)
				compound(asList(a, b, rest));
				^^^^^^^^
			The method compound(Iterable<? extends Comparator<? super U>>) in the type X is not applicable for the arguments (List<Comparator<?>>)
			----------
			4. ERROR in X.java (at line 7)
				if (true) return compound(asList(a, b, rest));
				                 ^^^^^^^^
			The method compound(Iterable<? extends Comparator<? super U>>) in the type X is not applicable for the arguments (List<Comparator<?>>)
			----------
			5. ERROR in X.java (at line 10)
				compound(c);
				^^^^^^^^
			The method compound(Iterable<? extends Comparator<? super U>>) in the type X is not applicable for the arguments (List<Comparator<?>>)
			----------
			6. ERROR in X.java (at line 11)
				return compound(c);
				       ^^^^^^^^
			The method compound(Iterable<? extends Comparator<? super U>>) in the type X is not applicable for the arguments (List<Comparator<?>>)
			----------
			""":
		this.complianceLevel == ClassFileConstants.JDK1_7 ?
			"""
				----------
				1. WARNING in X.java (at line 3)
					public static <T> Comparator<T> compound(Comparator<? super T> a, Comparator<? super T> b, Comparator<? super T>... rest) {
					                                                                                                                    ^^^^
				Type safety: Potential heap pollution via varargs parameter rest
				----------
				2. ERROR in X.java (at line 4)
					int i = asList(a, b, rest);
					        ^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from List<Comparator<?>> to int
				----------
				3. ERROR in X.java (at line 5)
					int j = compound(asList(a, b, rest));
					        ^^^^^^^^
				The method compound(Iterable<? extends Comparator<? super U>>) in the type X is not applicable for the arguments (List<Comparator<?>>)
				----------
				4. ERROR in X.java (at line 6)
					compound(asList(a, b, rest));
					^^^^^^^^
				The method compound(Iterable<? extends Comparator<? super U>>) in the type X is not applicable for the arguments (List<Comparator<?>>)
				----------
				5. ERROR in X.java (at line 7)
					if (true) return compound(asList(a, b, rest));
					                 ^^^^^^^^
				The method compound(Iterable<? extends Comparator<? super U>>) in the type X is not applicable for the arguments (List<Comparator<?>>)
				----------
				6. ERROR in X.java (at line 10)
					compound(c);
					^^^^^^^^
				The method compound(Iterable<? extends Comparator<? super U>>) in the type X is not applicable for the arguments (List<Comparator<?>>)
				----------
				7. ERROR in X.java (at line 11)
					return compound(c);
					       ^^^^^^^^
				The method compound(Iterable<? extends Comparator<? super U>>) in the type X is not applicable for the arguments (List<Comparator<?>>)
				----------
				8. WARNING in X.java (at line 16)
					public static <E> List<E> asList(E a, E b, E... rest) {
					                                                ^^^^
				Type safety: Potential heap pollution via varargs parameter rest
				----------
				"""
		: """
			----------
			1. WARNING in X.java (at line 3)
				public static <T> Comparator<T> compound(Comparator<? super T> a, Comparator<? super T> b, Comparator<? super T>... rest) {
				                                                                                                                    ^^^^
			Type safety: Potential heap pollution via varargs parameter rest
			----------
			2. ERROR in X.java (at line 4)
				int i = asList(a, b, rest);
				        ^^^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from List<Comparator<?>> to int
			----------
			3. ERROR in X.java (at line 5)
				int j = compound(asList(a, b, rest));
				        ^^^^^^^^
			The method compound(Iterable<? extends Comparator<? super U>>) in the type X is not applicable for the arguments (List<Comparator<?>>)
			----------
			4. ERROR in X.java (at line 10)
				compound(c);
				^^^^^^^^
			The method compound(Iterable<? extends Comparator<? super U>>) in the type X is not applicable for the arguments (List<Comparator<?>>)
			----------
			5. ERROR in X.java (at line 11)
				return compound(c);
				       ^^^^^^^^
			The method compound(Iterable<? extends Comparator<? super U>>) in the type X is not applicable for the arguments (List<Comparator<?>>)
			----------
			6. WARNING in X.java (at line 16)
				public static <E> List<E> asList(E a, E b, E... rest) {
				                                                ^^^^
			Type safety: Potential heap pollution via varargs parameter rest
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=198051
public void test1149() {
	String bSource =
		"""
		public class B {
		    	void b() throws ClassNotFoundException {
			    new<ClassNotFoundException> A();
		    }
		}
		""";
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"A.java",
			"""
				public class A {
				    <T extends Throwable> A() throws T {}
				    void a() throws ClassNotFoundException {
					    new<ClassNotFoundException> A();
				    }
				}
				""",
			"B.java",
			bSource
		},
		// javac options
		JavacTestOptions.EclipseJustification.EclipseBug234815 /* javac test options */);
	runConformTest(
		// test directory preparation
		false /* do not flush output directory */,
		new String[] { /* test files */
			"B.java",
			bSource
		},
		// compiler results
		"" /* expected compiler log */,
		// runtime results
		"" /* expected output string */,
		"" /* expected error string */,
		// javac options
		JavacTestOptions.EclipseJustification.EclipseBug234815 /* javac test options */);
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=234815 (invalid)
public void test1149b() {
	runConformTest(
		new String[] {
			"A.java",
			"""
				public class A {
				    <T extends Throwable> void foo() throws T {}
				    void a() throws ClassNotFoundException {
					   new A().<ClassNotFoundException>foo();
				    }
				}
				""",
		},
		""
	);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=189158
public void test1150() throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.lang.ref.Reference;
				public class X<T> {
					static class Rather {
						static class Deeply {
							static class Inside {
							}
						}
					}
					Reference<X.Rather.Deeply> x;
					Reference<X.Rather> y;\t
					Reference<X.Rather.Deeply.Inside> z;\t
				
					public static void main(String[] args) throws Exception {
						System.out.print(X.class.getDeclaredField("x").getGenericType());
						System.out.print("##");
						System.out.print(X.class.getDeclaredField("y").getGenericType());
						System.out.print("##");
						System.out.print(X.class.getDeclaredField("z").getGenericType());
						System.out.println();
					}
				}
				"""
		},
		"java.lang.ref.Reference<X$Rather$Deeply>##java.lang.ref.Reference<X$Rather>##java.lang.ref.Reference<X$Rather$Deeply$Inside>"
	);
	String expectedOutput =
		"""
		  // Field descriptor #6 Ljava/lang/ref/Reference;
		  // Signature: Ljava/lang/ref/Reference<LX$Rather$Deeply;>;
		  java.lang.ref.Reference x;
		 \s
		  // Field descriptor #6 Ljava/lang/ref/Reference;
		  // Signature: Ljava/lang/ref/Reference<LX$Rather;>;
		  java.lang.ref.Reference y;
		 \s
		  // Field descriptor #6 Ljava/lang/ref/Reference;
		  // Signature: Ljava/lang/ref/Reference<LX$Rather$Deeply$Inside;>;
		  java.lang.ref.Reference z;
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}

}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=189158 - variation
public void test1151() throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"import java.lang.ref.Reference;\n"+
			"public class X<T> {\n" +
			"	class Other<U> {\n" +
			"		class Deeply {\n" +
			"			class Inside<V> {\n" +
			"			}			\n" +
			"		}\n" +
			"	}\n" +
			"	Reference<X<String>.Other<Thread>.Deeply> t;\n" +
			"	Reference<X<String>.Other<Thread>.Deeply.Inside<Number>> u;\n" +
			"\n" +
			"	public static void main(String[] args) throws Exception {\n" +
			"		System.out.print(X.class.getDeclaredField(\"t\").getGenericType());\n" +
			"		//System.out.print(\"##\");\n" +
			"		//System.out.print(X.class.getDeclaredField(\"u\").getGenericType());\n" + // TODO disabled due to bug in libs (unable to re-read the generated signature)
			"		System.out.println();\n" +
			"	}\n" +
			"}\n"
		},
		//"java.lang.ref.Reference<X<java.lang.String>.Other<java.lang.Thread>.Deeply>##java.lang.ref.Reference<X<java.lang.String>.Other<java.lang.Thread>.Deeply$Inside<java.lang.Number>>"
		(reflectNestedClassUseDollar
		? "java.lang.ref.Reference<X<java.lang.String>$Other<java.lang.Thread>$Deeply>"
		: "java.lang.ref.Reference<X<java.lang.String>.Other<java.lang.Thread>.Deeply>")
	);
	String expectedOutput =
		"""
		  // Field descriptor #6 Ljava/lang/ref/Reference;
		  // Signature: Ljava/lang/ref/Reference<LX<Ljava/lang/String;>.Other<Ljava/lang/Thread;>.Deeply;>;
		  java.lang.ref.Reference t;
		 \s
		  // Field descriptor #6 Ljava/lang/ref/Reference;
		  // Signature: Ljava/lang/ref/Reference<LX<Ljava/lang/String;>.Other<Ljava/lang/Thread;>.Deeply.Inside<Ljava/lang/Number;>;>;
		  java.lang.ref.Reference u;
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=189158 - variation
public void test1152() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.lang.ref.Reference;
				public class X<T> {
					class Other<U> {
						class Deeply {
							class Inside<V> {
							}		\t
						}
					}
					Reference<X<String>.Other<Thread>.Deeply.Inside> u;
				
					public static void main(String[] args) throws Exception {
						System.out.print(X.class.getDeclaredField("u").getGenericType());
						System.out.println();
					}
				}
				"""
		},
		"""
			----------
			1. ERROR in X.java (at line 9)
				Reference<X<String>.Other<Thread>.Deeply.Inside> u;
				          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			The member type X<String>.Other<Thread>.Deeply.Inside must be parameterized, since it is qualified with a parameterized type
			----------
			"""	);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=189158 - variation
public void test1153() {
	// check proper decoding of binary signatures, by compiling against generated binary
	this.runConformTest(
		new String[] {
			"p/X.java",
			"""
				package p;
				import java.lang.ref.Reference;
				public class X<T> {
					public static class Rather {
						public static class Deeply {
							public static class Inside {
							}
						}
					}
					public class Other<U> {
						public class Deeply {
							public class Inside<V> {
							}		\t
						}
					}
					public Reference<X.Rather.Deeply> x;
					public Reference<X.Rather> y;\t
					public Reference<X.Rather.Deeply.Inside> z;\t
					public Reference<X<String>.Other<Thread>.Deeply> t;
					public Reference<X<String>.Other<Thread>.Deeply.Inside<Number>> u;
				}
				""",
		},
		""
	);
	this.runConformTest(
		new String[] {
			"Y.java",
			"import java.lang.ref.Reference;\n" +
			"import p.X;\n" +
			"public class Y {\n" +
			"	Reference<X.Rather.Deeply> x;\n" +
			"	Reference<X.Rather> y;	\n" +
			"	Reference<X.Rather.Deeply.Inside> z;	\n" +
			"	Reference<X<String>.Other<Thread>.Deeply> t;\n" +
			"	Reference<X<String>.Other<Thread>.Deeply.Inside<Number>> u;\n" +
			"	Y(X someX) {\n" +
			"		this.x = someX.x;\n" +
			"		this. y = someX.y;	\n" +
			"		this.z = someX.z;	\n" +
			"		this.t = someX.t;\n" +
			"		this.u = someX.u;		\n" +
			"	}\n" +
			"	public static void main(String[] args) throws Exception {\n" +
			"		System.out.print(Y.class.getDeclaredField(\"x\").getGenericType());\n" +
			"		System.out.print(\"##\");\n" +
			"		System.out.print(Y.class.getDeclaredField(\"y\").getGenericType());\n" +
			"		System.out.print(\"##\");\n" +
			"		System.out.print(Y.class.getDeclaredField(\"z\").getGenericType());\n" +
			"		System.out.print(\"##\");\n" +
			"		System.out.print(Y.class.getDeclaredField(\"t\").getGenericType());\n" +
			"		//System.out.print(\"##\");\n" +
			"		//System.out.print(Y.class.getDeclaredField(\"u\").getGenericType());\n" + // TODO disabled due to bug in libs (unable to re-read the generated signature)
			"		System.out.println();\n" +
			"	}\n" +
			"}\n"
		},
		"java.lang.ref.Reference<p.X$Rather$Deeply>##java.lang.ref.Reference<p.X$Rather>##java.lang.ref.Reference<p.X$Rather$Deeply$Inside>##"+
		(reflectNestedClassUseDollar
		? "java.lang.ref.Reference<p.X<java.lang.String>$Other<java.lang.Thread>$Deeply>"
		: "java.lang.ref.Reference<p.X<java.lang.String>.Other<java.lang.Thread>.Deeply>"),
		null,
		false, // do not flush output
		null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=189158 - variation
public void test1154() throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"import java.lang.ref.Reference;\n" +
			"public class X {\n" +
			"	class Other<U> {\n" +
			"		class Deeply {\n" +
			"			class Deeper {\n" +
			"				class Inside<V> {\n" +
			"				}			\n" +
			"			}\n" +
			"		}\n" +
			"	}\n" +
			"	Reference<X.Other<Thread>.Deeply> t;\n" +
			"	Reference<X.Other<Thread>.Deeply.Deeper.Inside<Number>> u;\n" +
			"\n" +
			"	public static void main(String[] args) throws Exception {\n" +
			"		//System.out.print(X.class.getDeclaredField(\"t\").getGenericType());\n" +  // TODO disabled due to bug in libs (unable to re-read the generated signature)
			"		//System.out.print(\"##\");\n" +
			"		//System.out.print(X.class.getDeclaredField(\"u\").getGenericType());\n" + // TODO disabled due to bug in libs (unable to re-read the generated signature)
			"		System.out.println();\n" +
			"	}\n" +
			"}\n"
		},
		"");

	String expectedOutput =
		"""
		  // Field descriptor #6 Ljava/lang/ref/Reference;
		  // Signature: Ljava/lang/ref/Reference<LX$Other<Ljava/lang/Thread;>.Deeply;>;
		  java.lang.ref.Reference t;
		 \s
		  // Field descriptor #6 Ljava/lang/ref/Reference;
		  // Signature: Ljava/lang/ref/Reference<LX$Other<Ljava/lang/Thread;>.Deeply.Deeper.Inside<Ljava/lang/Number;>;>;
		  java.lang.ref.Reference u;
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=189158 - variation
public void test1155() throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"import java.lang.ref.Reference;\n" +
			"public class X<T> {\n" +
			"	class Other<U> {\n" +
			"		class Deeply {\n" +
			"			class Deeper {\n" +
			"				class Inside<V> {\n" +
			"				}			\n" +
			"			}\n" +
			"		}\n" +
			"	}\n" +
			"	Reference<X<String>.Other<Thread>.Deeply> t;\n" +
			"	Reference<X<String>.Other<Thread>.Deeply.Deeper.Inside<Number>> u;\n" +
			"\n" +
			"	public static void main(String[] args) throws Exception {\n" +
			"		System.out.print(X.class.getDeclaredField(\"t\").getGenericType());\n" +
			"		//System.out.print(\"##\");\n" +
			"		//System.out.print(X.class.getDeclaredField(\"u\").getGenericType());\n" + // TODO disabled due to bug in libs (unable to re-read the generated signature)
			"		System.out.println();\n" +
			"	}\n" +
			"}\n"
		},
		(reflectNestedClassUseDollar
		? "java.lang.ref.Reference<X<java.lang.String>$Other<java.lang.Thread>$Deeply>"
		: "java.lang.ref.Reference<X<java.lang.String>.Other<java.lang.Thread>.Deeply>")	);

	String expectedOutput =
		"""
		  // Field descriptor #6 Ljava/lang/ref/Reference;
		  // Signature: Ljava/lang/ref/Reference<LX<Ljava/lang/String;>.Other<Ljava/lang/Thread;>.Deeply;>;
		  java.lang.ref.Reference t;
		 \s
		  // Field descriptor #6 Ljava/lang/ref/Reference;
		  // Signature: Ljava/lang/ref/Reference<LX<Ljava/lang/String;>.Other<Ljava/lang/Thread;>.Deeply.Deeper.Inside<Ljava/lang/Number;>;>;
		  java.lang.ref.Reference u;
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=196253
public void test1156() {
	this.runConformTest(
		new String[] {
			"C.java",
			"""
				public class C {
					R<X.N<X.N<?>>> xx = D.r;
				}""",
			"D.java",
			"""
				public class D {
					public static R<X.N<X.N<?>>> r;
				}""",
			"R.java",
			"public class R<T> {}",
			"X.java",
			"""
				public class X<T> {
					public static class N<U> {}
				}"""
		},
		""
	);
	this.runConformTest(
		new String[] {
			"C.java",
			"""
				public class C {
					R<X.N<X.N<?>>> xx = D.r;
				}""",
		},
		"",
		null,
		false, // do not flush output
		null
	);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=202624
public void test1157() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
				        public <A, B> void func(Class<? extends XX<A,B>> cls) {}
				        public void func() {
				                func(XX.class);
				               \s
				                Class<? extends XX<String,String>> c = XX.class;
				        }
				        class XX<A, B> {}
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 4)
				func(XX.class);
				^^^^
			The method func(Class<? extends X.XX<A,B>>) in the type X is not applicable for the arguments (Class<X.XX>)
			----------
			2. ERROR in X.java (at line 6)
				Class<? extends XX<String,String>> c = XX.class;
				                                       ^^^^^^^^
			Type mismatch: cannot convert from Class<X.XX> to Class<? extends X.XX<String,String>>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=202404
public void test1158() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				 class A {}
				 class B extends A {}
				 class C extends A{}
				\s
				 class D<U extends A, V extends U> {}
				
				public class X {
					void foo() {
						D<?, ? super A> d1 = null;
						D<?, ? extends A> d2 = null;
						D<B, C> d3 = null;
						D<?, ?> d4 = null;
					}
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 11)
				D<B, C> d3 = null;
				     ^
			Bound mismatch: The type C is not a valid substitute for the bounded parameter <V extends U> of the type D<U,V>
			----------
			"""
		);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=202404 - variation
public void test1159() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				class Y<U extends Y<U>> {}
				public class X<V extends X<V>> extends Y<V>{
					void foo(X<? extends V> x) {}
				}
				""", // =================
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=202404 - variation
public void test1160() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				class Y<T extends Y<T>> {}
				class Z<U extends Y<U>> {}
				public class X<V extends Z<V>> extends Z<V>{
					void foo(X<? extends V> x) {}
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 3)
				public class X<V extends Z<V>> extends Z<V>{
				                           ^
			Bound mismatch: The type V is not a valid substitute for the bounded parameter <U extends Y<U>> of the type Z<U>
			----------
			2. ERROR in X.java (at line 3)
				public class X<V extends Z<V>> extends Z<V>{
				                                         ^
			Bound mismatch: The type V is not a valid substitute for the bounded parameter <U extends Y<U>> of the type Z<U>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=202404 - variation
public void test1161() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				class Y<T extends Y<T>> {}
				class Z<U extends Y<U>> extends Y<U> {}
				public class X<V extends Z<V>> extends Z<V> {
					void foo(X<? extends V> x) {}
				}
				""", // =================
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=202404 - variation
public void test1162() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				class Y<T extends Y<T>> {}
				class Z<U extends Z<U>> extends Y<U> {}
				public class X<V extends X<V>> extends Z<V>{
					void foo(Y<? extends V> y) {}
				}
				""", // =================
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=203061 - variation
public void test1163() {
	String errMessage = isMinimumCompliant(ClassFileConstants.JDK11) ?
			"""
				----------
				1. ERROR in X.java (at line 5)
					Object o1 = mObj;
					            ^^^^
				The blank final field mObj may not have been initialized
				----------
				2. ERROR in X.java (at line 7)
					Object o2 = mObj;
					            ^^^^
				The blank final field mObj may not have been initialized
				----------
				"""
			:
			"""
				----------
				1. WARNING in X.java (at line 5)
					Object o1 = mObj;
					            ^^^^
				Read access to enclosing field X<T>.mObj is emulated by a synthetic accessor method
				----------
				2. ERROR in X.java (at line 5)
					Object o1 = mObj;
					            ^^^^
				The blank final field mObj may not have been initialized
				----------
				3. WARNING in X.java (at line 7)
					Object o2 = mObj;
					            ^^^^
				Read access to enclosing field X<T>.mObj is emulated by a synthetic accessor method
				----------
				4. ERROR in X.java (at line 7)
					Object o2 = mObj;
					            ^^^^
				The blank final field mObj may not have been initialized
				----------
				5. WARNING in X.java (at line 9)
					Object o3 = mObj;
					            ^^^^
				Read access to enclosing field X<T>.mObj is emulated by a synthetic accessor method
				----------
				""";
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public final class X<T> {
					private final Object mObj;
					private final Object mDependent = new Object() {
						{
							Object o1 = mObj;
						}
						Object o2 = mObj;
						void foo() {
							Object o3 = mObj;
						}
					};
					public X() {
						mObj = "";
					}
				}
				""", // =================
		},
		errMessage);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=203061 - variation
public void test1164() {
	String errMessage = isMinimumCompliant(ClassFileConstants.JDK11) ?
			"""
				----------
				1. ERROR in X.java (at line 5)
					Object o1 = mObj;
					            ^^^^
				The blank final field mObj may not have been initialized
				----------
				2. ERROR in X.java (at line 6)
					mObj = "1";
					^^^^
				The final field X<T>.mObj cannot be assigned
				----------
				3. ERROR in X.java (at line 8)
					Object o2 = mObj = "2";
					            ^^^^
				The final field X<T>.mObj cannot be assigned
				----------
				4. ERROR in X.java (at line 11)
					mObj = "3";
					^^^^
				The final field X<T>.mObj cannot be assigned
				----------
				"""
			:
			"""
				----------
				1. WARNING in X.java (at line 5)
					Object o1 = mObj;
					            ^^^^
				Read access to enclosing field X<T>.mObj is emulated by a synthetic accessor method
				----------
				2. ERROR in X.java (at line 5)
					Object o1 = mObj;
					            ^^^^
				The blank final field mObj may not have been initialized
				----------
				3. WARNING in X.java (at line 6)
					mObj = "1";
					^^^^
				Write access to enclosing field X<T>.mObj is emulated by a synthetic accessor method
				----------
				4. ERROR in X.java (at line 6)
					mObj = "1";
					^^^^
				The final field X<T>.mObj cannot be assigned
				----------
				5. WARNING in X.java (at line 8)
					Object o2 = mObj = "2";
					            ^^^^
				Write access to enclosing field X<T>.mObj is emulated by a synthetic accessor method
				----------
				6. ERROR in X.java (at line 8)
					Object o2 = mObj = "2";
					            ^^^^
				The final field X<T>.mObj cannot be assigned
				----------
				7. WARNING in X.java (at line 10)
					Object o3 = mObj;
					            ^^^^
				Read access to enclosing field X<T>.mObj is emulated by a synthetic accessor method
				----------
				8. WARNING in X.java (at line 11)
					mObj = "3";
					^^^^
				Write access to enclosing field X<T>.mObj is emulated by a synthetic accessor method
				----------
				9. ERROR in X.java (at line 11)
					mObj = "3";
					^^^^
				The final field X<T>.mObj cannot be assigned
				----------
				""";	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public final class X<T> {
					private final Object mObj;
					private final Object mDependent = new Object() {
						{
							Object o1 = mObj;
							mObj = "1";
						}
						Object o2 = mObj = "2";
						void foo() {
							Object o3 = mObj;
							mObj = "3";
						}
					};
					public X() {
						mObj = "";
					}
				}
				"""
		}, errMessage);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=202404 - variation
public void test1165() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				 interface A {}
				 class B implements A {}
				 class C implements A{}
				\s
				 class D<U extends A, V extends U> {}
				
				public class X {
					void foo() {
						D<?, ? super A> d1 = null;
						D<?, ? extends A> d2 = null;
						D<B, C> d3 = null;
						D<?, ?> d4 = null;
					}
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 11)
				D<B, C> d3 = null;
				     ^
			Bound mismatch: The type C is not a valid substitute for the bounded parameter <V extends U> of the type D<U,V>
			----------
			"""
		);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=203318
public void test1166() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends Number> {
					T get() {	return null; };
				    void foo(X<? extends Object> x) {
						x.get().intValue();    \t
				    }
				}
				""", // =================
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=179902
public void test1167() {
	this.runNegativeTest(
		new String[] {
			"Foo.java",
			"""
				public class Foo<F extends Enum<F>> {
				  class Bar<B> {
				    Bar(Foo<? extends B> bar) {}
				  }
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in Foo.java (at line 3)
				Bar(Foo<? extends B> bar) {}
				        ^^^^^^^^^^^
			Bound mismatch: The type ? extends B is not a valid substitute for the bounded parameter <F extends Enum<F>> of the type Foo<F>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=169049
public void test1168() {
	this.runNegativeTest(
		new String[] {
			"example/Container.java",
			"""
				package example;
				class A<E> {}
				class B<E> extends A<E> {}
				
				public interface Container<T, U extends T, V extends A<T>> {
					<T1, U1 extends T1, V1 extends A<T1>> void f(
							Container<?, ?, ?> a,\s
							Container<?, ? extends T1, ?> b,\s
							Container<T1, U1, V1> c,\s
							Container<? extends T1, ? extends U1, ? extends V1> d,\s
							Container<T1, ? extends U1, ? extends V1> e,\s
							Container<T1, ? extends U1, A<T>> f,\s
							Container<T1, U1, A<U1>> g,
							Container<T1, U1, A<T1>> h);
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in example\\Container.java (at line 12)
				Container<T1, ? extends U1, A<T>> f,\s
				                            ^
			Bound mismatch: The type A<T> is not a valid substitute for the bounded parameter <V extends A<T>> of the type Container<T,U,V>
			----------
			2. ERROR in example\\Container.java (at line 13)
				Container<T1, U1, A<U1>> g,
				                  ^
			Bound mismatch: The type A<U1> is not a valid substitute for the bounded parameter <V extends A<T>> of the type Container<T,U,V>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=169049 - variation
public void test1169() {
	this.runNegativeTest(
		new String[] {
			"example/Container2.java",
			"""
				package example;
				class A<E> {}
				class B<E> extends A<E> {}
				
				public interface Container2<T, U extends T, V extends A<? extends T>> {
					<T1, U1 extends T1, V1 extends A<? extends T1>> void g(
							Container2<?, ?, ?> a,\s
							Container2<?, ? extends T1, ?> b,\s
							Container2<T1, U1, V1> c,\s
							Container2<? extends T1, ? extends U1, ? extends V1> d,\s
							Container2<T1, ? extends U1, ? extends V1> e,\s
							Container2<T1, ? extends U1, A<T>> f,\s
							Container2<T1, U1, A<U1>> g,\s
							Container2<? extends T1, U1, ? extends V1> h);
				
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in example\\Container2.java (at line 12)
				Container2<T1, ? extends U1, A<T>> f,\s
				                             ^
			Bound mismatch: The type A<T> is not a valid substitute for the bounded parameter <V extends A<? extends T>> of the type Container2<T,U,V>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=169049 - variation
public void test1170() {
	this.runNegativeTest(
		new String[] {
			"example/Container3.java",
			"""
				package example;
				class A<E> {}
				class B<E> extends A<E> {}
				
				public interface Container3<T, U extends T, V extends A<? super T>> {
					<T1, U1 extends T1, V1 extends A<? super T1>> void g(
							Container3<?, ?, ?> a,\s
							Container3<?, ? extends T1, ?> b,\s
							Container3<T1, U1, V1> c,\s
							Container3<? extends T1, ? extends U1, ? extends V1> d,\s
							Container3<T1, ? extends U1, ? extends V1> e,\s
							Container3<T1, ? extends U1, A<T>> f,\s
							Container3<T1, U1, A<U1>> g,\s
							Container3<? extends T1, U1, ? extends V1> h,\s
							Container3<T1, ? extends U1, A<? super T>> i,\s
							Container3<T1, ? extends U1, A> j);
				
					<T1, U1 extends T1, V1 extends B<? super T1>> void h(
							Container3<?, ?, ?> a,\s
							Container3<?, ? extends T1, ?> b,\s
							Container3<T1, U1, V1> c,\s
							Container3<? extends T1, ? extends U1, ? extends V1> d,\s
							Container3<T1, ? extends U1, ? extends V1> e,\s
							Container3<T1, ? extends U1, B<T>> f,\s
							Container3<T1, U1, B<U1>> g,\s
							Container3<? extends T1, U1, ? extends V1> h,\s
							Container3<T1, ? extends U1, B<? super T>> i,\s
							Container3<T1, ? extends U1, B> j);
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in example\\Container3.java (at line 12)
				Container3<T1, ? extends U1, A<T>> f,\s
				                             ^
			Bound mismatch: The type A<T> is not a valid substitute for the bounded parameter <V extends A<? super T>> of the type Container3<T,U,V>
			----------
			2. ERROR in example\\Container3.java (at line 13)
				Container3<T1, U1, A<U1>> g,\s
				                   ^
			Bound mismatch: The type A<U1> is not a valid substitute for the bounded parameter <V extends A<? super T>> of the type Container3<T,U,V>
			----------
			3. ERROR in example\\Container3.java (at line 15)
				Container3<T1, ? extends U1, A<? super T>> i,\s
				                             ^
			Bound mismatch: The type A<? super T> is not a valid substitute for the bounded parameter <V extends A<? super T>> of the type Container3<T,U,V>
			----------
			4. WARNING in example\\Container3.java (at line 16)
				Container3<T1, ? extends U1, A> j);
				                             ^
			A is a raw type. References to generic type A<E> should be parameterized
			----------
			5. ERROR in example\\Container3.java (at line 16)
				Container3<T1, ? extends U1, A> j);
				                             ^
			Bound mismatch: The type A is not a valid substitute for the bounded parameter <V extends A<? super T>> of the type Container3<T,U,V>
			----------
			6. ERROR in example\\Container3.java (at line 24)
				Container3<T1, ? extends U1, B<T>> f,\s
				                             ^
			Bound mismatch: The type B<T> is not a valid substitute for the bounded parameter <V extends A<? super T>> of the type Container3<T,U,V>
			----------
			7. ERROR in example\\Container3.java (at line 25)
				Container3<T1, U1, B<U1>> g,\s
				                   ^
			Bound mismatch: The type B<U1> is not a valid substitute for the bounded parameter <V extends A<? super T>> of the type Container3<T,U,V>
			----------
			8. ERROR in example\\Container3.java (at line 27)
				Container3<T1, ? extends U1, B<? super T>> i,\s
				                             ^
			Bound mismatch: The type B<? super T> is not a valid substitute for the bounded parameter <V extends A<? super T>> of the type Container3<T,U,V>
			----------
			9. WARNING in example\\Container3.java (at line 28)
				Container3<T1, ? extends U1, B> j);
				                             ^
			B is a raw type. References to generic type B<E> should be parameterized
			----------
			10. ERROR in example\\Container3.java (at line 28)
				Container3<T1, ? extends U1, B> j);
				                             ^
			Bound mismatch: The type B is not a valid substitute for the bounded parameter <V extends A<? super T>> of the type Container3<T,U,V>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=203905
public void test1171() {
	this.runConformTest(
		new String[] {
			"Function.java",
			"""
				public abstract class Function<A, B> {
				        public abstract B apply(A a);
				
				        /** (f andThen g)(x) = g(f(x)) */
				        public <C1> Function<A, C1> andThen(final Function<B, C1> g) {
				                return new Function<A, C1>() {
				                		@Override
				                        public C1 apply(A a) {
				                                return g.apply(Function.this.apply(a));
				                        }
				                };
				        }
				
				        /** (f compose g)(x) = f(g(x)) */
				        public <C2> Function<C2, B> compose(final Function<C2, A> g) {
				                return g.andThen(this);
				        }
				}
				""", // =================
		},
		"");
}
public void test1172() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {
					T field;
					void foo(X<String> xs, X<Number> xn, boolean b) {
						(b ? xs : xn).field = xs.field;
					}
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 4)
				(b ? xs : xn).field = xs.field;
				                      ^^^^^^^^
			Type mismatch: cannot convert from String to capture#1-of ? extends Serializable
			----------
			""");
}
public void test1173() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {
					T field;
					void foo(X<Integer> x1, X<Long> x2, boolean b) {
						(b ? x1 : x2).field = x1.field;
					}
				}
				""", // =================
		},
		"----------\n" +
		"1. ERROR in X.java (at line 4)\n" +
		"	(b ? x1 : x2).field = x1.field;\n" +
		"	                      ^^^^^^^^\n" +
		"Type mismatch: cannot convert from Integer to capture#1-of ? extends "+intersection("Number","Comparable<?>")+"\n" +
		"----------\n");
}
public void test1174() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {
					T field;
					void foo(X<Integer> x1, X<Long> x2, boolean b) {
						(b ? x1 : x2).field = (b ? x1 : x2).field;
					}
				}
				""", // =================
		},
		"----------\n" +
		"1. ERROR in X.java (at line 4)\n" +
		"	(b ? x1 : x2).field = (b ? x1 : x2).field;\n" +
		"	                      ^^^^^^^^^^^^^^^^^^^\n" +
		"Type mismatch: cannot convert from capture#2-of ? extends "+intersection("Number","Comparable<?>")+" to capture#1-of ? extends "+intersection("Number","Comparable<?>")+"\n" +
		"----------\n");
}
public void test1175() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends A & B> {
					T field;
					void foo(X<? extends C> x1, X<? extends C> x2, boolean b) {
						(b ? x1 : x2).field = new C();
					}
				}
				class A {}
				interface B {}
				class C extends A implements B {}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 4)
				(b ? x1 : x2).field = new C();
				                      ^^^^^^^
			Type mismatch: cannot convert from C to capture#3-of ? extends C
			----------
			""");
}
public void test1176() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				public class X<T extends Foo & Bar> {
					T get() { return null; }
					void method(X<? extends C> x1, X<? extends C> x2, boolean b) {
						(b ? x1 : x2).get().foo();
						(b ? x1 : x2).get().bar();
					}
				}
				class Foo {
					void foo() {/**/}
				}
				interface Bar {
					void bar();
				}
				abstract class C extends Foo implements Bar {/**/}
				
				""", // =================
		},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}
public void test1177() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				public class X<T extends Foo & Bar> {
					T get() { return null; }
					void method(X<? extends Runnable> x1, X<? extends java.io.Serializable> x2, boolean b) {
						(b ? x1 : x2).get().foo();
						(b ? x1 : x2).get().bar();
					}
				}
				class Foo {
					void foo() {/**/}
				}
				interface Bar {
					void bar();
				}
				
				""", // =================
		},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}
public void test1178() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				public class X<T extends Foo & Bar> {
					T get() { return null; }
					void method(X<? extends C> x1, X<? extends D> x2, boolean b) {
						(b ? x1 : x2).get().baz();
					}
				}
				class Foo {
					void foo() {/**/}
				}
				interface Bar {
					void bar();
				}
				abstract class C extends Foo implements Bar {
					void baz() {/**/}
				}
				abstract class D extends C {/**/}
				abstract class E extends C {/**/}
				
				""", // =================
		},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}
public void test1179() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"public class X<T extends Object&V, V> {}\n" +
			"\n", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 1)
				public class X<T extends Object&V, V> {}
				                                ^
			The type V is not an interface; it cannot be specified as a bounded parameter
			----------
			""");
}
public void test1180() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public static <S, T extends Comparable<S>, R extends S & T> R max1(T arg1, S arg2) {
						return (R) ((arg1.compareTo(arg2) > 0) ? arg1 : arg2);
					}
				
					public static <T extends Comparable<S>, S, R extends S & Comparable<S>> R max2(T arg1, S arg2) {
						return (R) ((arg1.compareTo(arg2) > 0) ? arg1 : arg2);
					}
				
					public static <T extends Comparable<S>, S, R extends Comparable<S>> R max3(T arg1, S arg2) {
						return (R) ((arg1.compareTo(arg2) > 0) ? arg1 : arg2);
					}
				
					public static void main(String[] args) {
					}
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 2)
				public static <S, T extends Comparable<S>, R extends S & T> R max1(T arg1, S arg2) {
				                                                         ^
			Cannot specify any additional bound T when first bound is a type parameter
			----------
			2. WARNING in X.java (at line 3)
				return (R) ((arg1.compareTo(arg2) > 0) ? arg1 : arg2);
				       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from Object to R
			----------
			3. ERROR in X.java (at line 6)
				public static <T extends Comparable<S>, S, R extends S & Comparable<S>> R max2(T arg1, S arg2) {
				                                                         ^^^^^^^^^^
			Cannot specify any additional bound Comparable<S> when first bound is a type parameter
			----------
			4. WARNING in X.java (at line 7)
				return (R) ((arg1.compareTo(arg2) > 0) ? arg1 : arg2);
				       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from Object to R
			----------
			5. WARNING in X.java (at line 11)
				return (R) ((arg1.compareTo(arg2) > 0) ? arg1 : arg2);
				       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from Object to R
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=204534
public void test1181() {
	// http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6182950
	String expectedCompilerLog = (this.complianceLevel == ClassFileConstants.JDK1_6)?
			"""
				----------
				1. ERROR in X.java (at line 2)
					public static <S, T extends Comparable<S>, R extends S & T> R max(T arg1, S arg2) {
					                                                         ^
				Cannot specify any additional bound T when first bound is a type parameter
				----------
				2. ERROR in X.java (at line 2)
					public static <S, T extends Comparable<S>, R extends S & T> R max(T arg1, S arg2) {
					                                                              ^^^^^^^^^^^^^^^^^^^
				Erasure of method max(T, S) is the same as another method in type X
				----------
				3. WARNING in X.java (at line 3)
					return (R) ((arg1.compareTo(arg2) > 0) ? arg1 : arg2);
					       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Object to R
				----------
				4. ERROR in X.java (at line 5)
					public static <T extends Comparable<S>, S, R extends S & Comparable<S>> R max(T arg1, S arg2) {
					                                                         ^^^^^^^^^^
				Cannot specify any additional bound Comparable<S> when first bound is a type parameter
				----------
				5. ERROR in X.java (at line 5)
					public static <T extends Comparable<S>, S, R extends S & Comparable<S>> R max(T arg1, S arg2) {
					                                                                          ^^^^^^^^^^^^^^^^^^^
				Erasure of method max(T, S) is the same as another method in type X
				----------
				6. WARNING in X.java (at line 6)
					return (R) ((arg1.compareTo(arg2) > 0) ? arg1 : arg2);
					       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Object to R
				----------
				7. WARNING in X.java (at line 8)
					public static <T extends Comparable<S>, S, R extends Comparable<S>> R max(T arg1, S arg2) {
					                                                                      ^^^^^^^^^^^^^^^^^^^
				Erasure of method max(T, S) is the same as another method in type X
				----------
				8. WARNING in X.java (at line 9)
					return (R) ((arg1.compareTo(arg2) > 0) ? arg1 : arg2);
					       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Object to R
				----------
				""":
				"""
					----------
					1. ERROR in X.java (at line 2)
						public static <S, T extends Comparable<S>, R extends S & T> R max(T arg1, S arg2) {
						                                                         ^
					Cannot specify any additional bound T when first bound is a type parameter
					----------
					2. ERROR in X.java (at line 2)
						public static <S, T extends Comparable<S>, R extends S & T> R max(T arg1, S arg2) {
						                                                              ^^^^^^^^^^^^^^^^^^^
					Erasure of method max(T, S) is the same as another method in type X
					----------
					3. WARNING in X.java (at line 3)
						return (R) ((arg1.compareTo(arg2) > 0) ? arg1 : arg2);
						       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
					Type safety: Unchecked cast from Object to R
					----------
					4. ERROR in X.java (at line 5)
						public static <T extends Comparable<S>, S, R extends S & Comparable<S>> R max(T arg1, S arg2) {
						                                                         ^^^^^^^^^^
					Cannot specify any additional bound Comparable<S> when first bound is a type parameter
					----------
					5. ERROR in X.java (at line 5)
						public static <T extends Comparable<S>, S, R extends S & Comparable<S>> R max(T arg1, S arg2) {
						                                                                          ^^^^^^^^^^^^^^^^^^^
					Erasure of method max(T, S) is the same as another method in type X
					----------
					6. WARNING in X.java (at line 6)
						return (R) ((arg1.compareTo(arg2) > 0) ? arg1 : arg2);
						       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
					Type safety: Unchecked cast from Object to R
					----------
					7. ERROR in X.java (at line 8)
						public static <T extends Comparable<S>, S, R extends Comparable<S>> R max(T arg1, S arg2) {
						                                                                      ^^^^^^^^^^^^^^^^^^^
					Erasure of method max(T, S) is the same as another method in type X
					----------
					8. WARNING in X.java (at line 9)
						return (R) ((arg1.compareTo(arg2) > 0) ? arg1 : arg2);
						       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
					Type safety: Unchecked cast from Object to R
					----------
					""";
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public static <S, T extends Comparable<S>, R extends S & T> R max(T arg1, S arg2) {
						return (R) ((arg1.compareTo(arg2) > 0) ? arg1 : arg2);
					}
					public static <T extends Comparable<S>, S, R extends S & Comparable<S>> R max(T arg1, S arg2) {
						return (R) ((arg1.compareTo(arg2) > 0) ? arg1 : arg2);
					}
					public static <T extends Comparable<S>, S, R extends Comparable<S>> R max(T arg1, S arg2) {
						return (R) ((arg1.compareTo(arg2) > 0) ? arg1 : arg2);
					}
					public static void main(String[] args) {}
				}
				""", // =================
		},
		expectedCompilerLog
	);
/*
X.java:2: a type variable may not be followed by other bounds
        public static <S, T extends Comparable<S>, R extends S & T> R max(T arg1, S arg2) {
                                                                 ^
X.java:5: a type variable may not be followed by other bounds
        public static <T extends Comparable<S>, S, R extends S & Comparable<S>>
R max(T arg1, S arg2) {
                                                                           ^
X.java:5: name clash: <T#1,S#2,R#3>max(T#1,S#2) and <S#4,T#5,R#6>max(T#5,S#4) have the same erasure
        public static <T extends Comparable<S>, S, R extends S & Comparable<S>>
R max(T arg1, S arg2) {

  ^
  where T#1,S#2,R#3,S#4,T#5,R#6 are type-variables:
    T#1 extends Comparable<S#2> declared in method <T#1,S#2,R#3>max(T#1,S#2)
    S#2 extends Object declared in method <T#1,S#2,R#3>max(T#1,S#2)
    R#3 extends S#2 declared in method <T#1,S#2,R#3>max(T#1,S#2)
    S#4 extends Object declared in method <S#4,T#5,R#6>max(T#5,S#4)
    T#5 extends Comparable<S#4> declared in method <S#4,T#5,R#6>max(T#5,S#4)
    R#6 extends S#4 declared in method <S#4,T#5,R#6>max(T#5,S#4)
X.java:8: name clash: <T#1,S#2,R#3>max(T#1,S#2) and <S#4,T#5,R#6>max(T#5,S#4) have the same erasure
        public static <T extends Comparable<S>, S, R extends Comparable<S>> R max(T arg1, S arg2) {
                                                                              ^
  where T#1,S#2,R#3,S#4,T#5,R#6 are type-variables:
    T#1 extends Comparable<S#2> declared in method <T#1,S#2,R#3>max(T#1,S#2)
    S#2 extends Object declared in method <T#1,S#2,R#3>max(T#1,S#2)
    R#3 extends Comparable<S#2> declared in method <T#1,S#2,R#3>max(T#1,S#2)
    S#4 extends Object declared in method <S#4,T#5,R#6>max(T#5,S#4)
    T#5 extends Comparable<S#4> declared in method <S#4,T#5,R#6>max(T#5,S#4)
    R#6 extends S#4 declared in method <S#4,T#5,R#6>max(T#5,S#4)
X.java:3: warning: [unchecked] unchecked cast
                return (R) ((arg1.compareTo(arg2) > 0) ? arg1 : arg2);
                           ^
  required: R
  found:    Object
  where R,S,T are type-variables:
    R extends S declared in method <S,T,R>max(T,S)
    S extends Object declared in method <S,T,R>max(T,S)
    T extends Comparable<S> declared in method <S,T,R>max(T,S)
X.java:6: warning: [unchecked] unchecked cast
                return (R) ((arg1.compareTo(arg2) > 0) ? arg1 : arg2);
                           ^
  required: R
  found:    Object
  where R,T,S are type-variables:
    R extends S declared in method <T,S,R>max(T,S)
    T extends Comparable<S> declared in method <T,S,R>max(T,S)
    S extends Object declared in method <T,S,R>max(T,S)
X.java:9: warning: [unchecked] unchecked cast
                return (R) ((arg1.compareTo(arg2) > 0) ? arg1 : arg2);
                           ^
  required: R
  found:    Object
  where R,T,S are type-variables:
    R extends Comparable<S> declared in method <T,S,R>max(T,S)
    T extends Comparable<S> declared in method <T,S,R>max(T,S)
    S extends Object declared in method <T,S,R>max(T,S)
4 errors
3 warnings
 */
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=204536
public void test1182() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"public class X<T extends Zork & Zork & Object> {\n" +
			"}\n", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 1)
				public class X<T extends Zork & Zork & Object> {
				                         ^^^^
			Zork cannot be resolved to a type
			----------
			2. ERROR in X.java (at line 1)
				public class X<T extends Zork & Zork & Object> {
				                                ^^^^
			Zork cannot be resolved to a type
			----------
			3. ERROR in X.java (at line 1)
				public class X<T extends Zork & Zork & Object> {
				                                       ^^^^^^
			The type Object is not an interface; it cannot be specified as a bounded parameter
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=204536 - variation
public void test1183() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends Zork & Runnable> {
					void foo(T t) {
						t.run();
					}
				\t
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 1)
				public class X<T extends Zork & Runnable> {
				                         ^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=204536 - variation
public void test1184() {
	// check that unresolved first bound got erased into Object (and not Runnable)
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends Zork & Runnable> {
					T get() { return null; }
					void foo(X x) {
						Runnable r = x.get();
					}
				\t
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 1)
				public class X<T extends Zork & Runnable> {
				                         ^^^^
			Zork cannot be resolved to a type
			----------
			2. WARNING in X.java (at line 3)
				void foo(X x) {
				         ^
			X is a raw type. References to generic type X<T> should be parameterized
			----------
			3. ERROR in X.java (at line 4)
				Runnable r = x.get();
				               ^^^
			The method get() from the type X refers to the missing type Zork
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=203587
public void test1185() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<U, V> {
					<T> void foo(Class<X> c) {};
					<A, B> void foo(Class<X<A, B>> c) {}
					void foo2(Class<X<U, V>> c) {};
					<A, B> void foo2(Class<X<U, V>> c) {}
				}"""
		},
		"""
			----------
			1. ERROR in X.java (at line 2)
				<T> void foo(Class<X> c) {};
				         ^^^^^^^^^^^^^^^
			Erasure of method foo(Class<X>) is the same as another method in type X<U,V>
			----------
			2. WARNING in X.java (at line 2)
				<T> void foo(Class<X> c) {};
				                   ^
			X is a raw type. References to generic type X<U,V> should be parameterized
			----------
			3. ERROR in X.java (at line 3)
				<A, B> void foo(Class<X<A, B>> c) {}
				            ^^^^^^^^^^^^^^^^^^^^^
			Erasure of method foo(Class<X<A,B>>) is the same as another method in type X<U,V>
			----------
			4. ERROR in X.java (at line 4)
				void foo2(Class<X<U, V>> c) {};
				     ^^^^^^^^^^^^^^^^^^^^^^
			Duplicate method foo2(Class<X<U,V>>) in type X<U,V>
			----------
			5. ERROR in X.java (at line 5)
				<A, B> void foo2(Class<X<U, V>> c) {}
				            ^^^^^^^^^^^^^^^^^^^^^^
			Duplicate method foo2(Class<X<U,V>>) in type X<U,V>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=158870 - variation
public void test1186() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.io.Serializable;
				
				public class X<T> {
					void foo1(X<? extends String> x1, X<? extends Number> x2) {
						x1 = (X<? extends String>) x2;
					}
					void foo2(X<? extends String> x1, X<? extends Runnable> x2) {
						x1 = (X<? extends String>) x2;
					}\t
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 5)
				x1 = (X<? extends String>) x2;
				     ^^^^^^^^^^^^^^^^^^^^^^^^
			Cannot cast from X<capture#2-of ? extends Number> to X<? extends String>
			----------
			2. ERROR in X.java (at line 8)
				x1 = (X<? extends String>) x2;
				     ^^^^^^^^^^^^^^^^^^^^^^^^
			Cannot cast from X<capture#5-of ? extends Runnable> to X<? extends String>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=158870 - variation
public void test1187() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.io.Serializable;
				public class X<T> {
					void foo3(X<? extends Serializable> x1, X<? extends Runnable> x2) {
						x1 = (X<? extends Serializable>) x2;
					}\t
					void foo4(X<? extends Runnable> x1, X<? extends String> x2) {
						x1 = (X<? extends Runnable>) x2;
					}\t
				}
				""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 4)
				x1 = (X<? extends Serializable>) x2;
				     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from X<capture#2-of ? extends Runnable> to X<? extends Serializable>
			----------
			2. ERROR in X.java (at line 7)
				x1 = (X<? extends Runnable>) x2;
				     ^^^^^^^^^^^^^^^^^^^^^^^^^^
			Cannot cast from X<capture#5-of ? extends String> to X<? extends Runnable>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=158870 - variation
public void test1188() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					<T extends String, S extends Comparable<T>> void foo(Integer i) {
				        S a = (S) i; // error?
					}
					<U extends Comparable<U>> void bar(Integer i) {
				        U a = (U) i; // unchecked?
					}
				}
				""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 2)
				<T extends String, S extends Comparable<T>> void foo(Integer i) {
				           ^^^^^^
			The type parameter T should not be bounded by the final type String. Final types cannot be further extended
			----------
			2. ERROR in X.java (at line 3)
				S a = (S) i; // error?
				      ^^^^^
			Cannot cast from Integer to S
			----------
			3. WARNING in X.java (at line 6)
				U a = (U) i; // unchecked?
				      ^^^^^
			Type safety: Unchecked cast from Integer to U
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=158870 - variation
public void test1189() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					<T extends String, S extends Comparable<T>> void foo(Number n) {
				        S a = (S) n; // unchecked?
					}
					<U extends Comparable<U>> void bar(Number n) {
				        U a = (U) n; // unchecked?
					}
				}
				""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 2)
				<T extends String, S extends Comparable<T>> void foo(Number n) {
				           ^^^^^^
			The type parameter T should not be bounded by the final type String. Final types cannot be further extended
			----------
			2. WARNING in X.java (at line 3)
				S a = (S) n; // unchecked?
				      ^^^^^
			Type safety: Unchecked cast from Number to S
			----------
			3. WARNING in X.java (at line 6)
				U a = (U) n; // unchecked?
				      ^^^^^
			Type safety: Unchecked cast from Number to U
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=158870 - variation
public void test1190() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					<U extends Integer, T extends U, S extends Comparable<T>> void foo2(Integer i) {
				        S a = (S) i; // unchecked1?
				        Comparable<T> b = (Comparable<T>) i; // unchecked2?
					}	\t
					<U extends String, T extends U, S extends Comparable<T>> void foo3(Integer i) {
				        S a = (S) i; // error?
				        Comparable<T> b = (Comparable<T>) i; // error3?
					}\t
				}
				""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 2)
				<U extends Integer, T extends U, S extends Comparable<T>> void foo2(Integer i) {
				           ^^^^^^^
			The type parameter U should not be bounded by the final type Integer. Final types cannot be further extended
			----------
			2. WARNING in X.java (at line 3)
				S a = (S) i; // unchecked1?
				      ^^^^^
			Type safety: Unchecked cast from Integer to S
			----------
			3. WARNING in X.java (at line 4)
				Comparable<T> b = (Comparable<T>) i; // unchecked2?
				                  ^^^^^^^^^^^^^^^^^
			Type safety: Unchecked cast from Integer to Comparable<T>
			----------
			4. WARNING in X.java (at line 6)
				<U extends String, T extends U, S extends Comparable<T>> void foo3(Integer i) {
				           ^^^^^^
			The type parameter U should not be bounded by the final type String. Final types cannot be further extended
			----------
			5. ERROR in X.java (at line 7)
				S a = (S) i; // error?
				      ^^^^^
			Cannot cast from Integer to S
			----------
			6. ERROR in X.java (at line 8)
				Comparable<T> b = (Comparable<T>) i; // error3?
				                  ^^^^^^^^^^^^^^^^^
			Cannot cast from Integer to Comparable<T>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=158870 - variation
public void test1191() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					void foo(SomeEnum en) {
						Enum<?> myvar = en;
						SomeEnum en2 = (SomeEnum) myvar;
						if (myvar instanceof SomeEnum) {
							return;
						}
					}
					Zork z;
				}
				enum SomeEnum {
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 9)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=165352
public void test1192() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				public class X {
				        void foo(ArrayList<Object> a) {
				                Object o = (List<? extends String>) a; // ko
				        }
				        void bar(List<Object> a) {
				                Object o = (ArrayList<? extends String>) a; // ko
				        }
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 4)
				Object o = (List<? extends String>) a; // ko
				           ^^^^^^^^^^^^^^^^^^^^^^^^^^
			Cannot cast from ArrayList<Object> to List<? extends String>
			----------
			2. WARNING in X.java (at line 4)
				Object o = (List<? extends String>) a; // ko
				           ^^^^^^^^^^^^^^^^^^^^^^^^^^
			Unnecessary cast from ArrayList<Object> to List<? extends String>
			----------
			3. ERROR in X.java (at line 7)
				Object o = (ArrayList<? extends String>) a; // ko
				           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Cannot cast from List<Object> to ArrayList<? extends String>
			----------
			4. WARNING in X.java (at line 7)
				Object o = (ArrayList<? extends String>) a; // ko
				           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Unnecessary cast from List<Object> to ArrayList<? extends String>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=148046 - variation
public void test1193() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				class A {}
				class B extends A {}
				public class X<T> {
				        public void foo(X<? super A> param) {
				                X<B> bar = (X<B>) param; // unchecked warning vs error
				        }
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 5)
				X<B> bar = (X<B>) param; // unchecked warning vs error
				           ^^^^^^^^^^^^
			Cannot cast from X<capture#1-of ? super A> to X<B>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=120088
public void test1194() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public static void main(String[] args) {
						X t = new X();
						if (t.getClass() == Object.class)
							System.out.println("OK");
					}
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 4)
				if (t.getClass() == Object.class)
				    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Incompatible operand types Class<capture#1-of ? extends X> and Class<Object>
			----------
			""");
}
public void test1195() {
	this.runConformTest(
		new String[] {
			"java/lang/Class.java",
			"""
				package java.lang;
				public class Class<T> {
					Class<? super T> getSuperclass() { return null; }
					void foo() {
						boolean foo = getSuperclass() == Enum.class;
					}
				}
				""", // =================
		},
		"");
}
public void test1196() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				public class X<T> {
					Class<? super T> getSuperclass() { return null; }
					void foo() {
						boolean foo = getSuperclass() == Enum.class;
					}
				}
				class Y {
					void bar() {
						boolean bar = this.getClass().getSuperclass() == Enum.class;
					}	\t
				}
				""", // =================
		},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_6_10 /* javac test options */);
}
public void test1197() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					void test() {
						B b = new C();
						Class<? extends B> cb = C.class;
						YYY<C> y = new XXX();
						Class<? extends YYY<C>> cy = XXX.class;
						YYY<? extends B> yb = new XXX();
						Class<? extends YYY<? extends B>> ybc = XXX.class;
						Class<? extends YYY> ybb = yb.getClass();
						Class<? extends YYY<?>> ybb2 = yb.getClass();
						Class<? extends YYY<? extends B>> ybb3 = yb.getClass();
					}
				}
				
				class Obj {}
				class B extends Obj {}
				class C extends B {}
				class ZZZ<T extends Obj> {}
				class YYY<T extends B> extends ZZZ<T> {}
				class XXX extends YYY<C> {}\s
				""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 9)
				Class<? extends YYY> ybb = yb.getClass();
				                ^^^
			YYY is a raw type. References to generic type YYY<T> should be parameterized
			----------
			2. ERROR in X.java (at line 10)
				Class<? extends YYY<?>> ybb2 = yb.getClass();
				                               ^^^^^^^^^^^^^
			Type mismatch: cannot convert from Class<capture#4-of ? extends YYY> to Class<? extends YYY<?>>
			----------
			3. ERROR in X.java (at line 11)
				Class<? extends YYY<? extends B>> ybb3 = yb.getClass();
				                                         ^^^^^^^^^^^^^
			Type mismatch: cannot convert from Class<capture#6-of ? extends YYY> to Class<? extends YYY<? extends B>>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=121024 - variation
public void test1198() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X {
				    interface Listener {}
				    interface ErrorListener {} \s
				    static Object createParser(Listener l) {
				    	System.out.println("FAILED");
				      return null;
				    }
				    static <L extends Object & Listener & ErrorListener> Object createParser(L l) {
				    	System.out.println("SUCCESS");
				      return null;
				    }
				    public static void main(String[] args) {
				      class A implements Listener, ErrorListener {
				      }
				      createParser(new A()); // error here
				    }
				}
				""", // =================
		},
		"SUCCESS");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=121024 - variation
public void test1198a() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X {
				    interface Listener {}
				    interface ErrorListener {} \s
				    static Object createParser(Listener l) {
				    	System.out.println("FAILED");
				      return null;
				    }
				    static <L extends Object & ErrorListener & Listener> Object createParser(L l) {
				    	System.out.println("SUCCESS");
				      return null;
				    }
				    public static void main(String[] args) {
				      class A implements Listener, ErrorListener {
				      }
				      createParser(new A()); // error here
				    }
				}
				""", // =================
		},
		"SUCCESS");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=121024 - variation
public void test1199() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X {
				    interface Listener {}
				    interface ErrorListener {} \s
				    static Object createParser(Listener l) {
				    	System.out.println("SUCCESS");
				      return null;
				    }
				    static <L extends ErrorListener & Listener> Object createParser(L l) {
				    	System.out.println("FAILED");
				      return null;
				    }
				    public static void main(String[] args) {
				      class A implements Listener {
				      }
				      createParser(new A()); // error here
				    }
				}
				""", // =================
		},
		"SUCCESS");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=205594
public void test1200() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public class Map<T1, T2> {
					}
				
					public <K, V> Map<K, V> make(K key, V value) {
						return null;
					}
				
					public Map<Class<?>, X> method1() {
						X value = new X();
						Class<?> type = X.class;
						return make(type, value);//1
					}
					public Map<Class<?>, X> method2() {
						X value = new X();
						Class<?> type = X.class;
						return (Map<Class<?>, X>) make(type, value);//2
					}
					public Map<Class<?>, X> method3() {
						X value = new X();
						return make(X.class, value);//3
					}
					public Map<Class<?>, X> method4() {
						X value = new X();
						return (Map<Class<?>, X>) make(X.class, value);//4
					}\t
				}
				""", // =================
		},
		(this.complianceLevel < ClassFileConstants.JDK1_8 ?
		"""
			----------
			1. ERROR in X.java (at line 12)
				return make(type, value);//1
				       ^^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from X.Map<Class<capture#1-of ?>,X> to X.Map<Class<?>,X>
			----------
			2. ERROR in X.java (at line 17)
				return (Map<Class<?>, X>) make(type, value);//2
				       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Cannot cast from X.Map<Class<capture#2-of ?>,X> to X.Map<Class<?>,X>
			----------
			3. ERROR in X.java (at line 21)
				return make(X.class, value);//3
				       ^^^^^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from X.Map<Class<X>,X> to X.Map<Class<?>,X>
			----------
			4. ERROR in X.java (at line 25)
				return (Map<Class<?>, X>) make(X.class, value);//4
				       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Cannot cast from X.Map<Class<X>,X> to X.Map<Class<?>,X>
			----------
			"""
		: // fewer errors in 1.8+:
			"----------\n" +
			"1. ERROR in X.java (at line 17)\n" +
			"	return (Map<Class<?>, X>) make(type, value);//2\n" +
			"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Cannot cast from X.Map<Class<capture#2-of ?>,X> to X.Map<Class<?>,X>\n" + // FIXME: javac8 only reports a warning here
			"----------\n" +
			"2. ERROR in X.java (at line 25)\n" +
			"	return (Map<Class<?>, X>) make(X.class, value);//4\n" +
			"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Cannot cast from X.Map<Class<X>,X> to X.Map<Class<?>,X>\n" +
			"----------\n"));
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=174282
public void test1201() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X {
				    public MyClass f() {
				        SuperClass<? extends SuperDataModel> val = null;
				        return (MyClass) val;
				    }
				}
				class MyClass extends SuperClass<MyDataModel> {
				}
				class MyDataModel extends SuperDataModel {
				}
				class SuperClass<A extends SuperDataModel> {
				}
				class SuperDataModel {
				}
				""", // =================
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=168230
public void test1202() {
	String expectedOutput = this.complianceLevel < ClassFileConstants.JDK1_7
		? 	"""
			----------
			1. ERROR in X.java (at line 4)
				X.<String>foo();
				          ^^^
			The method foo() of type X is not generic; it cannot be parameterized with arguments <String>
			----------
			2. ERROR in X.java (at line 5)
				X.<Zork>foo();
				   ^^^^
			Zork cannot be resolved to a type
			----------
			3. ERROR in X.java (at line 5)
				X.<Zork>foo();
				        ^^^
			The method foo() of type X is not generic; it cannot be parameterized with arguments <Zork>
			----------
			"""
		: 	"""
			----------
			1. WARNING in X.java (at line 4)
				X.<String>foo();
				   ^^^^^^
			Unused type arguments for the non generic method foo() of type X; it should not be parameterized with arguments <String>
			----------
			2. ERROR in X.java (at line 5)
				X.<Zork>foo();
				   ^^^^
			Zork cannot be resolved to a type
			----------
			3. WARNING in X.java (at line 5)
				X.<Zork>foo();
				   ^^^^
			Unused type arguments for the non generic method foo() of type X; it should not be parameterized with arguments <Zork>
			----------
			""";

	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
				    public static void foo() {}
				    public static void bar() {
				        X.<String>foo();
				        X.<Zork>foo();
				    }
				}
				""", // =================
		},
		expectedOutput);
}

// https://bugs.eclipse.org/bugs/show_bug.cgi?id=168230 - variation
// split because of https://bugs.eclipse.org/bugs/show_bug.cgi?id=207935
public void test1203a() {
	String[] sources =
		new String[] {
			"X.java",
			"""
				public class X {
				  public static String foo(String one, String two) {
				    return X.<String>foo(one, two);
				  }
				  public String bar(String one, String two) {
				    return this.<String>bar(one, two);
				  }
				}
				""", // =================
		};
	if (this.complianceLevel < ClassFileConstants.JDK1_7) {
		runNegativeTest(
			sources,
			"""
				----------
				1. ERROR in X.java (at line 3)
					return X.<String>foo(one, two);
					                 ^^^
				The method foo(String, String) of type X is not generic; it cannot be parameterized with arguments <String>
				----------
				2. ERROR in X.java (at line 6)
					return this.<String>bar(one, two);
					                    ^^^
				The method bar(String, String) of type X is not generic; it cannot be parameterized with arguments <String>
				----------
				""");
	} else {
		runConformTest(
			true,
			sources,
			"""
				----------
				1. WARNING in X.java (at line 3)
					return X.<String>foo(one, two);
					          ^^^^^^
				Unused type arguments for the non generic method foo(String, String) of type X; it should not be parameterized with arguments <String>
				----------
				2. WARNING in X.java (at line 6)
					return this.<String>bar(one, two);
					             ^^^^^^
				Unused type arguments for the non generic method bar(String, String) of type X; it should not be parameterized with arguments <String>
				----------
				""",
			null, null,
			JavacTestOptions.Excuse.EclipseHasSomeMoreWarnings);
	}
}

// https://bugs.eclipse.org/bugs/show_bug.cgi?id=207935
// this case is not solved as expected in 1.5 and 1.6 mode; keeping the 1.7 mode
// activated test in all modes so we can track any changes
public void test1203b() {
	String expectedOutput = this.complianceLevel < ClassFileConstants.JDK1_7
		? 	"""
			----------
			1. WARNING in X.java (at line 4)
				return this.<String>foobar(one, two);
				             ^^^^^^
			Unused type arguments for the non generic method foobar(String, String) of type X; it should not be parameterized with arguments <String>
			----------
			2. ERROR in X.java (at line 8)
				return this.<String>foobar2(one, two);// silenced
				                    ^^^^^^^
			The method foobar2(String, String) of type X is not generic; it cannot be parameterized with arguments <String>
			----------
			3. ERROR in X.java (at line 16)
				this.<String,String>foobar(one, two);
				                    ^^^^^^
			Incorrect number of type arguments for generic method <T>foobar(String, String) of type Y; it cannot be parameterized with arguments <String, String>
			----------
			"""
		: 	"""
			----------
			1. WARNING in X.java (at line 4)
				return this.<String>foobar(one, two);
				             ^^^^^^
			Unused type arguments for the non generic method foobar(String, String) of type X; it should not be parameterized with arguments <String>
			----------
			2. ERROR in X.java (at line 16)
				this.<String,String>foobar(one, two);
				                    ^^^^^^
			Incorrect number of type arguments for generic method <T>foobar(String, String) of type Y; it cannot be parameterized with arguments <String, String>
			----------
			""";

	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X extends Y {
				  @Override
				  public String foobar(String one, String two) {
				    return this.<String>foobar(one, two);
				  }
					@SuppressWarnings("unused")
				  public String foobar2(String one, String two) {
				    return this.<String>foobar2(one, two);// silenced
				  }
				}
				class Y {
				  public <T> String foobar(String one, String two) {
				    return null;
				  }
				  void test(String one, String two) {
					  this.<String,String>foobar(one, two);
				  }
				}
				""", // =================
		},
		expectedOutput);
}

// https://bugs.eclipse.org/bugs/show_bug.cgi?id=207935
public void test1203c() {
	String[] sources =
		new String[] {
			"X.java",
			"public class X extends Y {\n" +
			"	public static void main(String[] args) {\n" +
			"		String s = \"\";\n" +
			"		new X().<String> a(s);\n" + // fails before 7
			"		new X().<String> b(s, s);\n" + // fails before 7
			"		new X().<String> c(s, s);\n" + // works in 1.5, 6.0 & 7.0
			"		new X().<String> d(s, s);\n" + // works in 1.5, 6.0 & 7.0
			"	}\n" +
			"	@Override void a(String one) {}\n" +
			"	void b(String one, Object two) {}\n" +
			"	@Override void c(String one, String two) {}\n" +
			"	@Override void d(String one, Object two) {}\n" +
			"}\n" +
			"class Y extends Z {\n" +
			"	void a(String one) {}\n" +
			"	<U> void b(String one) {}\n" +
			"	@Override void c(String one, String two) {}\n" +
			"}\n" +
			"class Z {\n" +
			"	<U> void c(String one, String two) {}\n" +
			"	<U> void d(String one, U u) {}\n" +
			"}"
		};
	if (this.complianceLevel < ClassFileConstants.JDK1_7) {
		runNegativeTest(
			sources,
			"""
				----------
				1. ERROR in X.java (at line 4)
					new X().<String> a(s);
					                 ^
				The method a(String) of type X is not generic; it cannot be parameterized with arguments <String>
				----------
				2. ERROR in X.java (at line 5)
					new X().<String> b(s, s);
					                 ^
				The method b(String, Object) of type X is not generic; it cannot be parameterized with arguments <String>
				----------
				3. WARNING in X.java (at line 6)
					new X().<String> c(s, s);
					         ^^^^^^
				Unused type arguments for the non generic method c(String, String) of type X; it should not be parameterized with arguments <String>
				----------
				4. WARNING in X.java (at line 7)
					new X().<String> d(s, s);
					         ^^^^^^
				Unused type arguments for the non generic method d(String, Object) of type X; it should not be parameterized with arguments <String>
				----------
				""");
	} else {
		runConformTest(
			true,
			sources,
			"""
				----------
				1. WARNING in X.java (at line 4)
					new X().<String> a(s);
					         ^^^^^^
				Unused type arguments for the non generic method a(String) of type X; it should not be parameterized with arguments <String>
				----------
				2. WARNING in X.java (at line 5)
					new X().<String> b(s, s);
					         ^^^^^^
				Unused type arguments for the non generic method b(String, Object) of type X; it should not be parameterized with arguments <String>
				----------
				3. WARNING in X.java (at line 6)
					new X().<String> c(s, s);
					         ^^^^^^
				Unused type arguments for the non generic method c(String, String) of type X; it should not be parameterized with arguments <String>
				----------
				4. WARNING in X.java (at line 7)
					new X().<String> d(s, s);
					         ^^^^^^
				Unused type arguments for the non generic method d(String, Object) of type X; it should not be parameterized with arguments <String>
				----------
				""",
			null, null,
			JavacTestOptions.Excuse.EclipseHasSomeMoreWarnings);
	}
}

// https://bugs.eclipse.org/bugs/show_bug.cgi?id=207935
public void test1203d() {
	String[] sources =
		new String[] {
			"X.java",
			"public class X implements I {\n" +
			"	public static void main(String[] args) {\n" +
			"		String s = \"\";\n" +
			"		new X().<String> a(s);\n" + // fails before 7
			"		new X().<String> b(s, s);\n" + // fails before 7
			"		new X().<String> c(s, s);\n" + // fails before 7
			"		new X().<String> d(s, s);\n" + // fails before 7
			"	}\n" +
			"	public void a(String one) {}\n" +
			"	public void b(String one, Object two) {}\n" +
			"	public void c(String one, String two) {}\n" +
			"	public void d(String one, Object two) {}\n" +
			"}\n" +
			"interface I extends J {\n" +
			"	void a(String one);\n" +
			"	void c(String one, String two);\n" +
			"}\n" +
			"interface J {\n" +
			"	<U> void c(String one, String two);\n" +
			"	<U> void d(String one, U u);\n" +
			"}"
		};
	if (this.complianceLevel < ClassFileConstants.JDK1_7) {
		runNegativeTest(
			sources,
			"""
				----------
				1. ERROR in X.java (at line 4)
					new X().<String> a(s);
					                 ^
				The method a(String) of type X is not generic; it cannot be parameterized with arguments <String>
				----------
				2. ERROR in X.java (at line 5)
					new X().<String> b(s, s);
					                 ^
				The method b(String, Object) of type X is not generic; it cannot be parameterized with arguments <String>
				----------
				3. ERROR in X.java (at line 6)
					new X().<String> c(s, s);
					                 ^
				The method c(String, String) of type X is not generic; it cannot be parameterized with arguments <String>
				----------
				4. ERROR in X.java (at line 7)
					new X().<String> d(s, s);
					                 ^
				The method d(String, Object) of type X is not generic; it cannot be parameterized with arguments <String>
				----------
				""");
	} else {
		runConformTest(
			true,
			sources,
			"""
				----------
				1. WARNING in X.java (at line 4)
					new X().<String> a(s);
					         ^^^^^^
				Unused type arguments for the non generic method a(String) of type X; it should not be parameterized with arguments <String>
				----------
				2. WARNING in X.java (at line 5)
					new X().<String> b(s, s);
					         ^^^^^^
				Unused type arguments for the non generic method b(String, Object) of type X; it should not be parameterized with arguments <String>
				----------
				3. WARNING in X.java (at line 6)
					new X().<String> c(s, s);
					         ^^^^^^
				Unused type arguments for the non generic method c(String, String) of type X; it should not be parameterized with arguments <String>
				----------
				4. WARNING in X.java (at line 7)
					new X().<String> d(s, s);
					         ^^^^^^
				Unused type arguments for the non generic method d(String, Object) of type X; it should not be parameterized with arguments <String>
				----------
				""",
			null, null,
			JavacTestOptions.Excuse.EclipseHasSomeMoreWarnings);
	}
}

//https://bugs.eclipse.org/bugs/show_bug.cgi?id=207299
public void test1204() {
	this.runConformTest(
		new String[] {
			"ExpressionGraph.java",
			"""
				import java.util.*;
				public class ExpressionGraph<G extends ExpressionGraph<G, V>, V extends IVertex<G, V>> {
					void foo(Set<V> set, Collection<? extends V> col) {
						if (set == col) return;
					}
				}
				interface IVertex<G extends ExpressionGraph<G, V>, V extends IVertex<G, V>> {\t
					// empty
				}
				""", // =================
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=207299 - variation
public void test1205() {
	this.runConformTest(
		new String[] {
			"ExpressionGraph.java",
			"""
				import java.util.*;
				
				public class ExpressionGraph<G extends ExpressionGraph<G, V, L>, V extends ExpressionVertex<G, V, L>, L> extends AbstractGraph<G, V> {
					void foo(Set<V> set, Collection<? extends V> col) {
						if (set == col) return;
					}
				
					interface IVertex<G extends ExpressionGraph<G, V, L>, V extends IVertex<G, V, L>, L> extends ExpressionVertex<G, V, L> {\t
						// empty
					}
					static abstract class Vertex<G extends ExpressionGraph<G, V, L>, V extends IVertex<G, V, L>, L> /*extends TaggableVertex<G, V>*/ implements IVertex<G, V, L> {\t
						// empty
					}
				}
				
				abstract class AbstractGraph<G extends AbstractGraph<G,V>, V extends Vertex<G,V>> implements Graph<G,V> {
					// empty
				}
				interface Graph<G extends Graph<G,V>, V extends Vertex<G,V>> {\t
					// empty
				}
				interface Vertex<G extends Graph<G,V>, V extends Vertex<G,V>> {
					// empty
				}
				interface ExpressionVertex<G extends Graph<G,V>, V extends ExpressionVertex<G,V,L>, L> extends Vertex<G,V> {
					// empty
				}
				""", // =================
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=207573
public void test1206() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public final <E extends Exception> E throwE(E ex, Object... args) throws E {
						Object[] oar = new Object[0];
						return throwE(oar, ex, args);
					}
				
					public final <E extends Exception> E throwE(Object[] oar, E ex, Object... args) throws E {
						throw ex;
					}
				}""", // =================
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=207573 - variation
public void test1207() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
				    public final <E extends Exception> E throwE (E ex) throws E {
				    	throw ex;
				    }
				    void foo(Object[] objs) {
				    	throwE(objs);
				    }
				}
				""", // =================
		},
		this.complianceLevel < ClassFileConstants.JDK1_8 ?
		"""
			----------
			1. ERROR in X.java (at line 6)
				throwE(objs);
				^^^^^^
			Bound mismatch: The generic method throwE(E) of type X is not applicable for the arguments (Object[]). The inferred type Object[] is not a valid substitute for the bounded parameter <E extends Exception>
			----------
			""" :
			"""
				----------
				1. ERROR in X.java (at line 6)
					throwE(objs);
					^^^^^^
				The method throwE(E) in the type X is not applicable for the arguments (Object[])
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=207573 - variation
public void test1208() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public final <E extends Exception> E throwE2(E ex, Object... args) throws E {
						Object[] oar = new Object[0];
						return throwE(oar, ex, args);
					}
				
					public final <E extends Exception> E throwE(Object[] oar, E ex, Object... args) throws E {
						throw ex;
					}
				}""", // =================
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=207573 - variation
public void test1209() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
				    public final <E extends Exception> E throwE (E ex, Object ... args) throws E {
				    	throw ex;
				    }
				    void foo(Object[] objs) {
				    	throwE(objs);
				    }
				}""", // =================
		},
		this.complianceLevel < ClassFileConstants.JDK1_8 ?
		"""
			----------
			1. ERROR in X.java (at line 6)
				throwE(objs);
				^^^^^^
			Bound mismatch: The generic method throwE(E, Object...) of type X is not applicable for the arguments (Object[]). The inferred type Object[] is not a valid substitute for the bounded parameter <E extends Exception>
			----------
			""" :
			"""
				----------
				1. ERROR in X.java (at line 6)
					throwE(objs);
					^^^^^^
				The method throwE(E, Object...) in the type X is not applicable for the arguments (Object[])
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=207573 - variation
// FAIL ERRMSG
public void test1210() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
				    public final <E extends Exception> E throwE (Object ... args) throws E {
				    	return null;
				    }
				    void foo(Object[] objs) {
				    	Object[] o  = throwE(objs);
				    }
				}
				""", // =================
		},
		(this.complianceLevel < ClassFileConstants.JDK1_8 ?
		"""
			----------
			1. ERROR in X.java (at line 6)
				Object[] o  = throwE(objs);
				              ^^^^^^
			Bound mismatch: The generic method throwE(Object...) of type X is not applicable for the arguments (Object[]). The inferred type Object[]&Exception is not a valid substitute for the bounded parameter <E extends Exception>
			----------
			2. ERROR in X.java (at line 6)
				Object[] o  = throwE(objs);
				              ^^^^^^^^^^^^
			Type mismatch: cannot convert from Object[]&Exception to Object[]
			----------
			"""
		:
		"""
			----------
			1. ERROR in X.java (at line 6)
				Object[] o  = throwE(objs);
				              ^^^^^^^^^^^^
			Type mismatch: cannot convert from RuntimeException to Object[]
			----------
			"""));
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=208030
public void test1211() {
	if (this.complianceLevel < ClassFileConstants.JDK1_7) {
		this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
						public X(String t){
							System.out.println(t);
							Zork z;
						}
						public static void main(String[] args) {
							class Local extends X {
								Local() {
									<String>super("FAILED");
								}
							};
							new <String>Local();
							new <String>Local(){};
						}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				2. ERROR in X.java (at line 9)
					<String>super("FAILED");
					        ^^^^^^^^^^^^^^^^
				The constructor X(String) of type X is not generic; it cannot be parameterized with arguments <String>
				----------
				3. ERROR in X.java (at line 12)
					new <String>Local();
					^^^^^^^^^^^^^^^^^^^
				The constructor Local() of type Local is not generic; it cannot be parameterized with arguments <String>
				----------
				4. ERROR in X.java (at line 13)
					new <String>Local(){};
					^^^^^^^^^^^^^^^^^^^^^
				The constructor Local() of type Local is not generic; it cannot be parameterized with arguments <String>
				----------
				""");
		return;
	}
	this.runNegativeTest(
			new String[] {
				"X.java",
				"""
					public class X {
						public X(String t){
							System.out.println(t);
							Zork z;
						}
						public static void main(String[] args) {
							class Local extends X {
								Local() {
									<String>super("FAILED");
								}
							};
							new <String>Local();
							new <String>Local(){};
						}
					}
					""",
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				2. WARNING in X.java (at line 9)
					<String>super("FAILED");
					 ^^^^^^
				Unused type arguments for the non generic constructor X(String) of type X; it should not be parameterized with arguments <String>
				----------
				3. WARNING in X.java (at line 12)
					new <String>Local();
					     ^^^^^^
				Unused type arguments for the non generic constructor Local() of type Local; it should not be parameterized with arguments <String>
				----------
				4. WARNING in X.java (at line 13)
					new <String>Local(){};
					     ^^^^^^
				Unused type arguments for the non generic constructor Local() of type Local; it should not be parameterized with arguments <String>
				----------
				""");
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=77918
// generic variants
public void test1212() {
	Map customOptions = getCompilerOptions();
	customOptions.put(CompilerOptions.OPTION_ReportRedundantSuperinterface,  CompilerOptions.ERROR);
	runNegativeTest(
		// test directory preparation
		true /* flush output directory */,
		new String[] { /* test files */
			"X.java",
			"""
				public class X<T> implements I<T> {}
				class Y<T extends Z> extends X<T> implements I<T>, J {}
				class Z {}\
				interface I <T> {}
				interface J {}
				"""
		},
		// compiler options
		null /* no class libraries */,
		customOptions /* custom options */,
		// compiler results
		"----------\n" + /* expected compiler log */
		"1. ERROR in X.java (at line 2)\n" +
		"	class Y<T extends Z> extends X<T> implements I<T>, J {}\n" +
		"	                                             ^\n" +
		"Redundant superinterface I<T> for the type Y<T>, already defined by X<T>\n" +
		"----------\n",
		// javac options
		JavacTestOptions.SKIP /* skip javac tests - configured eclipse specific warning as error */);
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=77918
// generic variants - the 'different arguments' error overrides the
// redundant error
public void test1213() {
	Map customOptions = getCompilerOptions();
	customOptions.put(CompilerOptions.OPTION_ReportRedundantSuperinterface, CompilerOptions.ERROR);
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T> implements I<T> {}
				class Y<T extends Z, U extends T> extends X<T> implements I<U>, J {}
				class Z {}\
				interface I <T> {}
				interface J {}
				"""
		},
		"""
			----------
			1. ERROR in X.java (at line 2)
				class Y<T extends Z, U extends T> extends X<T> implements I<U>, J {}
				      ^
			The interface I cannot be implemented more than once with different arguments: I<T> and I<U>
			----------
			""",
		null /* no extra class libraries */,
		true /* flush output directory */,
		customOptions);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=208873
public void test1214() {
	runConformTest(
		// test directory preparation
		true /* flush output directory */,
		new String[] { /* test files */
			"X.java",
			"""
				public class X {
					public interface Loader {
						public <T extends Integer, K extends String> T load(final K key);
					}
					Loader loader;
					public <K extends String, T extends Integer> T get(final K key) {
						T data = this.loader.load(key);
						return null;
					}
				}
				""", // =================
		},
		// compiler results
		null /* do not check compiler log */,
		// runtime results
		"" /* expected output string */,
		"" /* expected error string */,
		// javac options
		JavacTestOptions.JavacHasABug.JavacBug5042462 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=208873 - variation
public void test1215() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				public class X {
				    <T, U extends T, V extends T> T cond1(boolean z, U x1, V x2) {
				        return (z? x1: x2);
				    }
				}
				""",
		},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBug5042462 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=209153
public void test1216() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public static void main(String[] args) {
						p.A myA = new p.A();
						myA.p = myA.box.get(); // [msgSend] generic cast to P -> error
						Object o = myA.box.get(); // ok, since no generic cast actually inserted
						myA.p = myA.getBox().t;// [fieldRef] generic cast to P -> error
						myA.p = myA.box.t;// [qName] generic cast to P -> error
						int pval = myA.box.t.pval;// intermediate access through P already flagged as error
					}
				}
				""",
			"p/A.java",
			"""
				package p;
				public class A {
					public static class Box<T> {
						public T t;
						public void set(T t) { this.t = t; }
						public T get()	{ return this.t; }
					}
					private class P {
						public int pval;
					}
					public P p;
					public Box<P> box;
					public Box<P> getBox() { return this.box; }
					public A next;
					public A getNext() { return this;}\s
					public A() {
						this.box = new Box<P>();
						this.box.set(new P());
					}
				}
				"""
		},
		"----------\n" +
		"1. ERROR in X.java (at line 4)\n" +
		"	myA.p = myA.box.get(); // [msgSend] generic cast to P -> error\n" +
		"	        ^^^^^^^^^^^^^\n" +
		"The type A.P is not visible\n" +
		"----------\n" +
		"2. ERROR in X.java (at line 6)\n" +
		"	myA.p = myA.getBox().t;// [fieldRef] generic cast to P -> error\n" +
		"	        ^^^^^^^^^^^^^^\n" +
		"The type A.P is not visible\n" +
		"----------\n" +
		"3. ERROR in X.java (at line 7)\n" +
		"	myA.p = myA.box.t;// [qName] generic cast to P -> error\n" +
		"	        ^^^\n" +
		"The type A.P is not visible\n" +
		"----------\n" +
		"4. ERROR in X.java (at line 8)\n" +
		"	int pval = myA.box.t.pval;// intermediate access through P already flagged as error\n" +
		"	           ^^^^^^^^^\n" +
		"The type A.P is not visible\n" +
		"----------\n" +
		(isMinimumCompliant(ClassFileConstants.JDK11) ? "" :
		"----------\n" +
		"1. WARNING in p\\A.java (at line 18)\n" +
		"	this.box.set(new P());\n" +
		"	             ^^^^^^^\n" +
		"Access to enclosing constructor A.P() is emulated by a synthetic accessor method\n" +
		"----------\n"));
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=209153 - variation
public void test1217() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public static void main(String[] args) {
						p.A myA = new p.A();
						myA.p = myA.box.get(); // [msgSend] generic cast to P -> error
						Object o = myA.box.get(); // ok, since no generic cast actually inserted
						myA.p = myA.getBox().t;// [fieldRef] generic cast to P -> error
						myA.p = myA.box.t;// [qName] generic cast to P -> error
						int pval = myA.box.t.pval;// intermediate access through P already flagged as error
					}
				}
				""",
			"p/A.java",
			"""
				package p;
				public class A {
					public static class Box<T> {
						public T t;
						public void set(T t) { this.t = t; }
						public T get()	{ return this.t; }
					}
					protected class P {
						public int pval;
					}
					public P p;
					public Box<P> box;
					public Box<P> getBox() { return this.box; }
					public A next;
					public A getNext() { return this;}\s
					public A() {
						this.box = new Box<P>();
						this.box.set(new P());
					}
				}
				"""
		},
		"""
			----------
			1. ERROR in X.java (at line 4)
				myA.p = myA.box.get(); // [msgSend] generic cast to P -> error
				        ^^^^^^^^^^^^^
			The type A.P is not visible
			----------
			2. ERROR in X.java (at line 6)
				myA.p = myA.getBox().t;// [fieldRef] generic cast to P -> error
				        ^^^^^^^^^^^^^^
			The type A.P is not visible
			----------
			3. ERROR in X.java (at line 7)
				myA.p = myA.box.t;// [qName] generic cast to P -> error
				        ^^^
			The type A.P is not visible
			----------
			4. ERROR in X.java (at line 8)
				int pval = myA.box.t.pval;// intermediate access through P already flagged as error
				           ^^^^^^^^^
			The type A.P is not visible
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=209153 - variation
public void test1218() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public static void main(String[] args) {
						p.A myA = new p.A();
						myA.p = myA.box.get(); // [msgSend] generic cast to P -> error
						Object o = myA.box.get(); // ok, since no generic cast actually inserted
						myA.p = myA.getBox().t;// [fieldRef] generic cast to P -> error
						myA.p = myA.box.t;// [qName] generic cast to P -> error
						int pval = myA.box.t.pval;// intermediate access through P already flagged as error
					}
				}
				""",
			"p/A.java",
			"""
				package p;
				public class A {
					public static class Box<T> {
						public T t;
						public void set(T t) { this.t = t; }
						public T get()	{ return this.t; }
					}
					class P {
						public int pval;
					}
					public P p;
					public Box<P> box;
					public Box<P> getBox() { return this.box; }
					public A next;
					public A getNext() { return this;}\s
					public A() {
						this.box = new Box<P>();
						this.box.set(new P());
					}
				}
				"""
		},
		"""
			----------
			1. ERROR in X.java (at line 4)
				myA.p = myA.box.get(); // [msgSend] generic cast to P -> error
				        ^^^^^^^^^^^^^
			The type A.P is not visible
			----------
			2. ERROR in X.java (at line 6)
				myA.p = myA.getBox().t;// [fieldRef] generic cast to P -> error
				        ^^^^^^^^^^^^^^
			The type A.P is not visible
			----------
			3. ERROR in X.java (at line 7)
				myA.p = myA.box.t;// [qName] generic cast to P -> error
				        ^^^
			The type A.P is not visible
			----------
			4. ERROR in X.java (at line 8)
				int pval = myA.box.t.pval;// intermediate access through P already flagged as error
				           ^^^^^^^^^
			The type A.P is not visible
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=209779
public void test1219() {
	runConformTest(
		// test directory preparation
		true /* flush output directory */,
		new String[] { /* test files */
			"X.java",
			"""
				import java.util.ArrayList;
				import java.util.List;
				
				public class X {
					public static void main(String[] args) {
						final List<String> stringList = new ArrayList<String>();
						stringList.add("test1");
						stringList.add("test2");
						((List) stringList).add(new Integer(1000));
						try {
							Object o = stringList.get(2);
						} catch (ClassCastException e) {
							System.out.print("[ClassCastException1]");
						}
						try {
							String s = stringList.get(2);
						} catch (ClassCastException e) {
							System.out.print("[ClassCastException2]");
						}	\t
						try {
							for (Object obj : stringList) {
								System.out.print(obj);
							}
						} catch (ClassCastException e) {
							System.out.print("[ClassCastException3]");
						}	\t
						try {
							for (String str : stringList) {
								System.out.print(str);
							}
						} catch (ClassCastException e) {
							System.out.print("[ClassCastException4]");
						}
						System.out.println();
					}
				}
				"""
		},
		// compiler results
		null /* do not check compiler log */,
		// runtime results
		"[ClassCastException2]test1test21000test1test2[ClassCastException4]" /* expected output string */,
		"" /* expected error string */,
		// javac options
		JavacTestOptions.JavacHasABug.JavacBug6500701 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=209152
public void test1220() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.List;
				
				public class X {
				        public static void doIt(List<?> list) {
				                list.add(list.remove(0));
				        }
				}
				"""
		},
		"""
			----------
			1. ERROR in X.java (at line 5)
				list.add(list.remove(0));
				     ^^^
			The method add(capture#1-of ?) in the type List<capture#1-of ?> is not applicable for the arguments (capture#2-of ?)
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=209071
public void test1221() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				public class X {
					void foo() {
						Set<List> listSet = new HashSet<List>();
						Set<List> otherListSet = new HashSet<List>();
						otherListSet.add((List) listSet);	\t
					}
					void bar() {
						Set<String> stringSet = new HashSet<String>();
						Set<String> otherStringSet = new HashSet<String>();
						otherStringSet.add((String) stringSet);	\t
					}
					public static void main(String[] args) {
						new X().foo();
						new X().bar();
					}
				}\t
				"""
		},
		"""
			----------
			1. WARNING in X.java (at line 4)
				Set<List> listSet = new HashSet<List>();
				    ^^^^
			List is a raw type. References to generic type List<E> should be parameterized
			----------
			2. WARNING in X.java (at line 4)
				Set<List> listSet = new HashSet<List>();
				                                ^^^^
			List is a raw type. References to generic type List<E> should be parameterized
			----------
			3. WARNING in X.java (at line 5)
				Set<List> otherListSet = new HashSet<List>();
				    ^^^^
			List is a raw type. References to generic type List<E> should be parameterized
			----------
			4. WARNING in X.java (at line 5)
				Set<List> otherListSet = new HashSet<List>();
				                                     ^^^^
			List is a raw type. References to generic type List<E> should be parameterized
			----------
			5. WARNING in X.java (at line 6)
				otherListSet.add((List) listSet);	\t
				                  ^^^^
			List is a raw type. References to generic type List<E> should be parameterized
			----------
			6. ERROR in X.java (at line 11)
				otherStringSet.add((String) stringSet);	\t
				                   ^^^^^^^^^^^^^^^^^^
			Cannot cast from Set<String> to String
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=207959
public void test1222() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends Zork & Runnable> {
				  T get() { return null; }
				  void foo2(X<T> x2) {
					    Runnable r = x2.get();
					  } \s
				}
				"""
		},
		"""
			----------
			1. ERROR in X.java (at line 1)
				public class X<T extends Zork & Runnable> {
				                         ^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=211718
public void test1223() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.Arrays;
				import java.util.List;
				public class X<E> {
				    public static enum IsABug {
				        TRUE,
				        FALSE;
				    }  \s
				    public List<IsABug> getPossibleBugStates() {
				    	String s1 = IsABug.values();
				    	String s2 = IsABug.valueOf(s1);
				        return Arrays.asList(IsABug.values());
				    }
				}
				"""
		},
		"""
			----------
			1. ERROR in X.java (at line 9)
				String s1 = IsABug.values();
				            ^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from X.IsABug[] to String
			----------
			2. ERROR in X.java (at line 10)
				String s2 = IsABug.valueOf(s1);
				            ^^^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from X.IsABug to String
			----------
			""");
}
public void test1224() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.Collection;
				import java.util.Collections;
				public class X {
					class Request<R extends Request<R, V>,V> {}
					class RequestMap {
						public <R extends Request<R, W>,W> R intersection (Collection<R> c) {
							return null;
						}
					}
					class DeltaRequest extends Request<DeltaRequest,double[]> {}
					public void test () {
						RequestMap m = new RequestMap ();
						Collection<DeltaRequest> c = Collections.singleton (new DeltaRequest ());
						DeltaRequest o = m.intersection (c);
					}
				}
				"""
		},
		"");
}
public void test1225() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				import java.util.Collection;
				import java.util.List;
				public class X {
				   static <B> void m(List<? super B> list, Collection<? super B> coll) {
				     m(list, coll);
				   }
				}
				"""
		},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_7 /* javac test options */);
}
public void test1226() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"public class X<T> {\n" +
			"	class M {\n" +
			"		X<T> foo() { return null; }\n" +
			"	}\n" +
			"	void bar(M m) {\n" +
			"		X<T> xt = m.foo();\n" + // no unchecked warning
			"		Zork z;\n" +
			"	}\n" +
			"}\n"
		},
		"""
			----------
			1. ERROR in X.java (at line 7)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
public void test1227() {
	if (this.complianceLevel >= ClassFileConstants.JDK1_7) return;
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.Arrays;
				public class  X {
					void foo() {
						Arrays.asList(String.class, Integer.class);
					}
					Zork z;
				}
				"""
		},
		"----------\n" +
		"1. WARNING in X.java (at line 4)\n" +
		"	Arrays.asList(String.class, Integer.class);\n" +
		"	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
		"Type safety: A generic array of Class<? extends Object&Serializable&"+ intersection("Comparable<?>") +"> is created for a varargs parameter\n" +
		"----------\n" +
		"2. ERROR in X.java (at line 6)\n" +
		"	Zork z;\n" +
		"	^^^^\n" +
		"Zork cannot be resolved to a type\n" +
		"----------\n");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=214972
public void test1228()  throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<U extends Class> {
					public <Y> X(Y b1, U b2) {
					}
					public class Binner {
						public class BinnerInner<I> {
							public <J> BinnerInner<J> $new$() {
								return new BinnerInner<J>();
							}
						}
					}
				}
				"""
		},
		"");
	// check $new$ method generic signature
	String expectedOutput =
		"""
		  // Method descriptor #22 ()LX$Binner$BinnerInner;
		  // Signature: <J:Ljava/lang/Object;>()LX<TU;>.Binner.BinnerInner<TJ;>;
		  // Stack: 3, Locals: 1
		  public X.Binner.BinnerInner $new$();
		     0  new X$Binner$BinnerInner [1]
		     3  dup
		     4  aload_0 [this]
		     5  getfield X$Binner$BinnerInner.this$1 : X.Binner [10]
		     8  invokespecial X$Binner$BinnerInner(X$Binner) [25]
		    11  areturn
		      Line numbers:
		        [pc: 0, line: 7]
		      Local variable table:
		        [pc: 0, pc: 12] local: this index: 0 type: X.Binner.BinnerInner
		      Local variable type table:
		        [pc: 0, pc: 12] local: this index: 0 type: X<U>.Binner.BinnerInner<I>
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X$Binner$BinnerInner.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=214972 - variation
public void test1229() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<U extends Class> {
					public <Y> X(Y b1, U b2) {
					}
					public class Binner {
						public class BinnerInner<I> {
							public <J> BinnerInner<J> $new$() {
								return new BinnerInner<J>();
							}
							X<U> root() {
								return X.this;
							}
						}
					}
				}
				""",
			"Z.java",
			"""
				public class Z {
					public static void main(String[] args) {
						X<Class>.Binner.BinnerInner<String> binString = new X<Class>(null, null).new Binner().new BinnerInner<String>();
						String s = binString.$new$().root();
					}
				}
				"""
		},
		"""
			----------
			1. WARNING in X.java (at line 1)
				public class X<U extends Class> {
				                         ^^^^^
			Class is a raw type. References to generic type Class<T> should be parameterized
			----------
			2. WARNING in X.java (at line 1)
				public class X<U extends Class> {
				                         ^^^^^
			The type parameter U should not be bounded by the final type Class. Final types cannot be further extended
			----------
			----------
			1. WARNING in Z.java (at line 3)
				X<Class>.Binner.BinnerInner<String> binString = new X<Class>(null, null).new Binner().new BinnerInner<String>();
				  ^^^^^
			Class is a raw type. References to generic type Class<T> should be parameterized
			----------
			2. WARNING in Z.java (at line 3)
				X<Class>.Binner.BinnerInner<String> binString = new X<Class>(null, null).new Binner().new BinnerInner<String>();
				                                                      ^^^^^
			Class is a raw type. References to generic type Class<T> should be parameterized
			----------
			3. ERROR in Z.java (at line 4)
				String s = binString.$new$().root();
				           ^^^^^^^^^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from X<Class> to String
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=214972 - variation
public void test1230() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<U extends Class> {
					public <Y> X(Y b1, U b2) {
					}
					public class Binner {
						public class BinnerInner<I> {
							public <J> BinnerInner<J> $new$() {
								return new BinnerInner<J>();
							}
							X<U> root() {
								return X.this;
							}
						}
					}
				}
				""",
		},
		"");
	this.runNegativeTest(
			new String[] {
				"Z.java",
				"""
					public class Z {
						public static void main(String[] args) {
							X<Class>.Binner.BinnerInner<String> binString = new X<Class>(null, null).new Binner().new BinnerInner<String>();
							String s = binString.$new$().root();
						}
					}
					"""
			},
			"""
				----------
				1. WARNING in Z.java (at line 3)
					X<Class>.Binner.BinnerInner<String> binString = new X<Class>(null, null).new Binner().new BinnerInner<String>();
					  ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				2. WARNING in Z.java (at line 3)
					X<Class>.Binner.BinnerInner<String> binString = new X<Class>(null, null).new Binner().new BinnerInner<String>();
					                                                      ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				3. ERROR in Z.java (at line 4)
					String s = binString.$new$().root();
					           ^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from X<Class> to String
				----------
				""",
			null,
			false,
			null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=214972 - variation
public void test1231() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<U extends Class> {
					public <Y> X(Y b1, U b2) {
					}
					public class Binner {
						public class BinnerInner<I> {
							public <J> BinnerInner<J> $new$() {
								return new BinnerInner<J>();
							}
							X<U> root() {
								return X.this;
							}
						}
					}
				}
				""",
		},
		"");
	this.runConformTest(
			new String[] {
				"Z.java",
				"""
					public class Z {
						public static void main(String[] args) {
							X<Class>.Binner.BinnerInner<String> binString = new X<Class>(null, null).new Binner().new BinnerInner<String>();
							X<Class>.Binner.BinnerInner<Number> binNumber = binString.$new$();
						}
					}
					"""
			},
			"",
			null,
			false,
			null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=215843
public void test1232() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public static void testCovariant(SubInterface sub1, SubInterface sub2) {
						SubInterface sub3 = sub1.and(sub2);
					}
					public interface SuperInterface<E> {
						public Number getNumber();
						public SuperInterface<E> and(SuperInterface<E> a);
					}
					public interface SubInterface extends SuperInterface {
						public Integer getNumber();
						public SubInterface and(SuperInterface s);
					}
				}
				""",
		},
		"");

}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=215843 - variation
public void test1233() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public static void testCovariant(SubInterface<String> sub1, SubInterface<String> sub2) {
						SubInterface<String> sub3 = sub1.and(sub2);
					}
					public interface SuperInterface<E> {
						public Number getNumber();
						public SuperInterface<E> and(SuperInterface<E> a);
					}
					public interface SubInterface<F> extends SuperInterface<F> {
						public Integer getNumber();
						public SubInterface<F> and(SuperInterface<F> s);
					}
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=215843 - variation
public void test1234() {
	this.runNegativeTest(
		false /* skipJavac */,
		JavacTestOptions.EclipseHasABug.EclipseBug427719,
		new String[] {
			"X.java",
			"""
				public class X {\s
					void a3(G x) {}\s
					<T extends F<X>> void a3(T x) {}
				
					public static void ambiguousCases() {\s
						H<X> hx = null;
						H hraw = null;
						new X().a3(hx);
						new X().a3(hraw);
					}\s
				}
				class F<T1> {} \s
				class G<T2> extends F<T2> {}
				class H<T3> extends G<T3> {}
				""",
		},
		"----------\n" +
		"1. WARNING in X.java (at line 2)\n" +
		"	void a3(G x) {} \n" +
		"	        ^\n" +
		"G is a raw type. References to generic type G<T2> should be parameterized\n" +
		"----------\n" +
		"2. WARNING in X.java (at line 7)\n" +
		"	H hraw = null;\n" +
		"	^\n" +
		"H is a raw type. References to generic type H<T3> should be parameterized\n" +
		"----------\n" +
		(this.complianceLevel < ClassFileConstants.JDK1_8 ?
		"3. ERROR in X.java (at line 8)\n" +
		"	new X().a3(hx);\n" +
		"	        ^^\n" +
		"The method a3(G) is ambiguous for the type X\n" +
		"----------\n" +
		"4. ERROR in X.java (at line 9)\n" +
		"	new X().a3(hraw);\n" +
		"	        ^^\n" +
		"The method a3(G) is ambiguous for the type X\n" +
		"----------\n"
		: // not ambiguous in 1.8
		""));
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=215843 - variation
public void test1235() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X {\s
					<T extends G<X>> void a3(T x) {}
					<T extends F<X>> void a3(T x) {}
				
					public static void ambiguousCases() {\s
						H<X> hx = null;
						H hraw = null;
						new X().a3(hx);
						new X().a3(hraw);
					}\s
				}
				class F<T1> {} \s
				class G<T2> extends F<T2> {}
				class H<T3> extends G<T3> {}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=215843 - variation
public void test1236() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public static void testCovariant(SubInterface sub1, SubInterface sub2) {
						SubInterface sub3 = sub1.and(sub2);
					}
					public interface SuperInterface<E> {
						public Number getNumber();
						public SuperInterface<E> and(SuperInterface<E> a);
					}
					public interface SubInterface extends SuperInterface, OtherSubInterface {
						public Integer getNumber();
						public SubInterface and(SuperInterface s);
					}
					public interface OtherSubInterface<U> extends SuperInterface<U> {
						public OtherSubInterface<U> and(SuperInterface<U> a);
					}
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=215843 - variation
public void test1237() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public static void testCovariant(SubInterface sub1, SubInterface sub2) {
						SubInterface sub3 = sub1.and(sub2);
					}
					public interface SuperInterface<E> {
						public Number getNumber();
						public SuperInterface<E> and(SuperInterface<E> a);
					}
					public interface SubInterface extends SuperInterface, OtherSubInterface {
					}
					public interface OtherSubInterface<U> extends SuperInterface<U> {
						public OtherSubInterface<U> and(SuperInterface<U> a);
					}
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 3)
				SubInterface sub3 = sub1.and(sub2);
				                    ^^^^^^^^^^^^^^
			Type safety: The method and(X.SuperInterface) belongs to the raw type X.OtherSubInterface. References to generic type X.OtherSubInterface<U> should be parameterized
			----------
			2. ERROR in X.java (at line 3)
				SubInterface sub3 = sub1.and(sub2);
				                    ^^^^^^^^^^^^^^
			Type mismatch: cannot convert from X.OtherSubInterface to X.SubInterface
			----------
			3. WARNING in X.java (at line 9)
				public interface SubInterface extends SuperInterface, OtherSubInterface {
				                                      ^^^^^^^^^^^^^^
			X.SuperInterface is a raw type. References to generic type X.SuperInterface<E> should be parameterized
			----------
			4. WARNING in X.java (at line 9)
				public interface SubInterface extends SuperInterface, OtherSubInterface {
				                                                      ^^^^^^^^^^^^^^^^^
			X.OtherSubInterface is a raw type. References to generic type X.OtherSubInterface<U> should be parameterized
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=215843 - variation
public void test1238() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public static void testCovariant(SubInterface sub1, SubInterface sub2) {
						SubInterface sub3 = sub1.and(sub2);
					}
					public interface SuperInterface<E> {
						public Number getNumber();
						public SuperInterface<E> and(SuperInterface<E> a);
					}
					public interface SubInterface extends SuperInterface, OtherSubInterface {
					}
					public interface OtherSubInterface extends SuperInterface {
						public OtherSubInterface and(SuperInterface a);
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 3)
				SubInterface sub3 = sub1.and(sub2);
				                    ^^^^^^^^^^^^^^
			Type mismatch: cannot convert from X.OtherSubInterface to X.SubInterface
			----------
			2. WARNING in X.java (at line 9)
				public interface SubInterface extends SuperInterface, OtherSubInterface {
				                                      ^^^^^^^^^^^^^^
			X.SuperInterface is a raw type. References to generic type X.SuperInterface<E> should be parameterized
			----------
			3. WARNING in X.java (at line 11)
				public interface OtherSubInterface extends SuperInterface {
				                                           ^^^^^^^^^^^^^^
			X.SuperInterface is a raw type. References to generic type X.SuperInterface<E> should be parameterized
			----------
			4. WARNING in X.java (at line 12)
				public OtherSubInterface and(SuperInterface a);
				                             ^^^^^^^^^^^^^^
			X.SuperInterface is a raw type. References to generic type X.SuperInterface<E> should be parameterized
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=215843 - variation
public void test1239() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public static void testCovariant(CombinedSubInterface sub1, SubInterface sub2) {
						SubInterface sub3 = sub1.and(sub2);
					}
					public interface SuperInterface<E> {
						public Number getNumber();
						public SuperInterface<E> and(SuperInterface<E> a);
					}
					public interface SubInterface extends SuperInterface {
						public Integer getNumber();
						public SubInterface and(SuperInterface s);
					}
					public interface CombinedSubInterface extends SubInterface, OtherSubInterface {}
				\t
					public interface OtherSubInterface extends SuperInterface {
						public OtherSubInterface and(SuperInterface a);
					}
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 3)
				SubInterface sub3 = sub1.and(sub2);
				                         ^^^
			The method and(X.SuperInterface) is ambiguous for the type X.CombinedSubInterface
			----------
			2. WARNING in X.java (at line 9)
				public interface SubInterface extends SuperInterface {
				                                      ^^^^^^^^^^^^^^
			X.SuperInterface is a raw type. References to generic type X.SuperInterface<E> should be parameterized
			----------
			3. WARNING in X.java (at line 11)
				public SubInterface and(SuperInterface s);
				                        ^^^^^^^^^^^^^^
			X.SuperInterface is a raw type. References to generic type X.SuperInterface<E> should be parameterized
			----------
			4. ERROR in X.java (at line 13)
				public interface CombinedSubInterface extends SubInterface, OtherSubInterface {}
				                 ^^^^^^^^^^^^^^^^^^^^
			The return types are incompatible for the inherited methods X.SubInterface.and(X.SuperInterface), X.OtherSubInterface.and(X.SuperInterface)
			----------
			5. WARNING in X.java (at line 15)
				public interface OtherSubInterface extends SuperInterface {
				                                           ^^^^^^^^^^^^^^
			X.SuperInterface is a raw type. References to generic type X.SuperInterface<E> should be parameterized
			----------
			6. WARNING in X.java (at line 16)
				public OtherSubInterface and(SuperInterface a);
				                             ^^^^^^^^^^^^^^
			X.SuperInterface is a raw type. References to generic type X.SuperInterface<E> should be parameterized
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=215843 - variation
public void test1240() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public static void testCovariant(CombinedSubInterface sub1, SubInterface sub2) {
						SubInterface sub3 = sub1.and(sub2);
					}
					public interface SuperInterface<E> {
						public Number getNumber();
						public SuperInterface<E> and(SuperInterface<E> a);
					}
					public interface SubInterface extends SuperInterface {
						public Integer getNumber();
						public SubInterface and(SuperInterface s);
					}
					public interface OtherSubInterface extends SubInterface {
						public OtherSubInterface and(SuperInterface a);
					}
					public interface CombinedSubInterface extends OtherSubInterface {}
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=215843 - variation
public void test1241() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X {
					public static void testCovariant(CombinedSubInterface sub1, SubInterface sub2) {
						CombinedSubInterface sub3 = sub1.and(sub2);
					}
					public interface SuperInterface<E> {
						public SuperInterface<E> and(SuperInterface<E> a);
					}
					public interface SubInterface extends SuperInterface {
					}
					public interface OtherSubInterface extends SuperInterface {
						public CombinedSubInterface and(SuperInterface a);
					}
					public interface CombinedSubInterface extends SubInterface, OtherSubInterface {}
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=164665
public void test1242() {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				import java.util.LinkedList;
				import java.util.List;
				
				public class X {
					public void testCase() {
						TypedCollection<SuperTypeAbstractClass> collection = TypedCollectionFactory.createTypedCollection(SubTypeClass.class);
						collection.add(new SubTypeClass());
						List<SuperTypeAbstractClass> list = collection.list();
						assert (list.size() > 0);
					}
				}
				
				abstract class SuperTypeAbstractClass {
				}
				
				class SubTypeClass extends SuperTypeAbstractClass {
				}
				
				interface TypedCollection<T> {
					TypedCollection<T> add(T object);
					List<T> list();
				}
				
				class TypedCollectionFactory {
					public static <T, U extends T> TypedCollection<T> createTypedCollection(Class<U> c) {
						return new TypedCollectionImpl<T>();
					}
				}
				
				class TypedCollectionImpl<T> implements TypedCollection<T> {
					private List<T> list = new LinkedList<T>();
					public TypedCollection<T> add(T object) {
						list.add(object);
						return (this);
					}
					public List<T> list() {
						return list;
					}
				}
				""", // =================
		},
		// javac options
		JavacTestOptions.JavacHasABug.JavacBugFixed_7 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216100
public void test1243() {
	this.runConformTest(
		new String[] {
			"eclipse/modifier/impl/EclipseModifierBug.java",
			"""
				package eclipse.modifier.impl;
				import eclipse.modifier.Pool;
				public class EclipseModifierBug {
				  static class MyEntry extends Pool.AbstractEntry<MyEntry> { } \s
				  static final Pool<MyEntry> pool=new Pool<MyEntry>() {
				    @Override
				    protected MyEntry delegate() {
				      return new MyEntry();
				    } \s
				  };
				  public static void main(String[] args) {
				    MyEntry entry=pool.m(); \s
				  }
				}""", // =================
			"eclipse/modifier/Pool.java",
			"""
				package eclipse.modifier;
				public abstract class Pool<E extends Pool.Entry<E>> {
				    static abstract class Entry<E extends Entry<E>> {
				        E next;
				    }
				    static public class AbstractEntry<E extends AbstractEntry<E>> extends Entry<E> {
				    }
				    public E m() {
				      return delegate();
				    }
				    protected abstract E delegate();
				  }
				
				""", // =================
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216100 - variation
public void test1244() {
	runNegativeTest(
		new String[] { /* test files */
			"X.java",
			"""
				public class X {
				  static class MyEntry extends Pool.AbstractEntry<MyEntry> { } \s
				  static final Pool<MyEntry> pool=new Pool<MyEntry>() {
				    @Override
				    protected MyEntry delegate() {
				      return new MyEntry();
				    } \s
				  };
				  public static void main(String[] args) {
				    MyEntry entry=pool.m();
				  }
				}
				
				abstract class Pool<E extends Pool.Entry<E>> {
				    private static abstract class Entry<E extends Entry<E>> {
				        E next;
				    }
				    static public class AbstractEntry<E extends AbstractEntry<E>> extends Entry<E> {
				    }
				    public E m() {
				        System.out.println("SUCCESS");
				      return delegate();
				    }
				    protected abstract E delegate();
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 14)
				abstract class Pool<E extends Pool.Entry<E>> {
				                              ^^^^^^^^^^
			The type Pool.Entry is not visible
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216100 - variation
public void test1245() {
	this.runNegativeTest(
		new String[] {
				"X.java",
				"""
					public class X<T extends Secondary.Private> {
					}
					class Secondary {
						static private class Private {}
					}
					""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 1)
				public class X<T extends Secondary.Private> {
				                         ^^^^^^^^^^^^^^^^^
			The type Secondary.Private is not visible
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216100 - variation
public void test1246() {
	runNegativeTest(
		new String[] { /* test files */
			"X.java",
			"""
				public class X<T extends X.Private> {
					static private class Private {}
					<U extends X.Private> void foo(U u) {}
				}
				""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 1)
				public class X<T extends X.Private> {
				                         ^^^^^^^^^
			The type X.Private is not visible
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216558
public void test1247() {
	String xSource =
				"""
		public class X {
		
			public static void test() {
				Foo<?, ?> foo = null;
				eval(foo); // fails
				X.<Foo<?, ?>> eval(foo);
			}
		
			public static <T extends Iterable<T>> void eval(T x) {
			}
			public static interface Foo<S, T> extends Iterable<Foo<?, ?>> {
			}
		}""";
	if (this.complianceLevel < ClassFileConstants.JDK1_8) {
		this.runNegativeTest(
			new String[] {
				"X.java",
				xSource,
			},
			"""
				----------
				1. ERROR in X.java (at line 5)
					eval(foo); // fails
					^^^^
				Bound mismatch: The generic method eval(T) of type X is not applicable for the arguments (X.Foo<capture#1-of ?,capture#2-of ?>). The inferred type X.Foo<capture#1-of ?,capture#2-of ?> is not a valid substitute for the bounded parameter <T extends Iterable<T>>
				----------
				""");
	} else {
		runConformTest(new String[] { "X.java", xSource });
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216558 - variation
public void test1248() {
	runConformTest(
 		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				public class X {
				
					public static void test() {
						Foo<?, ?> foo = null;
						eval(foo); // fails
						X.<Foo<?, ?>> eval(foo);
					}
				
					public static <T extends Iterable<T>> void eval(T x) {
					}
					public static interface Foo<S, T> extends Iterable<Foo<S,T>> {
					}
				}""", // =================
		},
		// javac options
		JavacTestOptions.EclipseHasABug.EclipseBug216558 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216558 - variation
public void test1249() {
	this.runConformTest(
		new String[] {
				"X.java",
				"""
					public class X {
						public static void test() {
							Foo<?, ?> foo = null;
							eval(foo, foo);
							X.<Foo<?, ?>> eval(foo, foo);
						}
						public static <T extends Iterable<T>> void eval(T t1, T t2) {
						}
						public static interface Foo<S, T> extends Iterable<Foo<?, ?>> {
						}
					}""", // =================
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216565
public void test1250() {
	this.runConformTest(
		new String[] {
				"X.java",
				"""
					import java.util.List;
					public class X {
					    static <T> List<T> asList(T[] x) { return null; }
					    static interface Foo<T> {
					        static interface Sub<T> extends Foo<T> {
					            static List<Sub<?>> LIST = asList(ARRAY);\s
					       }
					        static Sub<?>[] ARRAY = new Sub[] { };
					    }
					}""", // =================
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216565 - variation
public void test1251() {
	this.runConformTest(
		new String[] {
				"X.java",
				"""
					public class X {
					    static <T> T asList(T[] x) { return null; }
					    static interface Foo<T> {
					        static interface Sub<T> extends Foo<T> {
					            static Sub<?> LIST = asList(ARRAY);\s
					       }
					        static Sub<?>[] ARRAY = new Sub[] { };
					    }
					}
					""", // =================
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216608
public void test1252() {
	this.runNegativeTest(
		new String[] {
				"X.java",
				"""
					public class X {
						Zork z;
						@SuppressWarnings({"unchecked", "rawtypes"})
						public B getB() {
							return new B<Object>();
						}
					
						@SuppressWarnings("unused")
						public void test() {
							C<String> c = getB().getC();
							String s = getB().toString();
						}
					}
					class B<S> {
						public C<String> getC() {
							return new C<String>();
						}
					}
					class C<T> {
					}
					""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 2)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			2. WARNING in X.java (at line 10)
				C<String> c = getB().getC();
				              ^^^^^^^^^^^^^
			Type safety: The expression of type C needs unchecked conversion to conform to C<String>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216608 - variation
public void test1253() {
	this.runNegativeTest(
		new String[] {
				"X.java",
				"""
					public class X {
						Zork z;
						@SuppressWarnings("unchecked")
						public B<?> getB() {
							return new B<Object>();
						}
					
						@SuppressWarnings("unused")
						public void test() {
							C<String> c = getB().getC();
							String s = getB().toString();
						}
					}
					class B<S> {
						public C<String> getC() {
							return new C<String>();
						}
					}
					class C<T> {
					}
					""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 2)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216565 - variation
public void test1254() {
	this.runConformTest(
		new String[] {
				"X.java",
				"""
					 import java.util.List;
					
					public class X {
					    static <T> XList<T> asList(T[] x) { return null; }
					    static interface Foo<T> {
					        static interface Sub<T> extends Foo<T> {
					            static XList<Sub<String>> LIST = asList(ARRAY);\s
					       }
					        static Sub<String>[] ARRAY = new Sub[] { };
					    }
					}
					
					class XList<T> {
					}
					""", // =================
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216565 - variation
public void test1255() {
	String xSource =
				"""
		 import java.util.List;
		
		public class X {
		    static <T> XList<T> asList(T x) { return null; }
		    static interface Foo<T> {
		        static interface Sub<T> extends Foo<T> {
		            static XList<Sub<?>> LIST = asList(ARRAY);\s
		       }
		        @SuppressWarnings("rawtypes")
		        static Sub<?> ARRAY = new Sub() { };
		    }
		}
		
		class XList<T> {
		}
		""";
	if (this.complianceLevel < ClassFileConstants.JDK1_8) {
		this.runNegativeTest(
			new String[] {
				"X.java",
				xSource,
			},
			"""
				----------
				1. ERROR in X.java (at line 7)
					static XList<Sub<?>> LIST = asList(ARRAY);\s
					                            ^^^^^^^^^^^^^
				Type mismatch: cannot convert from XList<X.Foo.Sub<capture#1-of ?>> to XList<X.Foo.Sub<?>>
				----------
				""");
	} else {
		runConformTest(new String[]{ "X.java", xSource });
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216565 - variation
public void test1256() {
	this.runConformTest(
		new String[] {
				"X.java",
				"""
					public class X {
					    static <T> XList<T> asList(T[] x) { return null; }
					    static interface Foo<T> {
					        static interface Sub<T> extends Foo<T> {
					            static XList<Sub<? extends Object>> LIST = asList(ARRAY);\s
					       }
					        static Sub<?>[] ARRAY = new Sub[] { };
					    }
					}
					
					class XList<T> {
					}
					""", // =================
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216565 - variation
public void test1257() {
	this.runNegativeTest(
		new String[] {
				"X.java",
				"""
					public class X {
					    static <T> XList<T> asList(T[] x) { return null; }
					    static interface Foo<T> {
					        static interface Sub<T> extends Foo<T> {
					            static XList<Sub<? extends Object>> LIST = asList(ARRAY);\s
					       }
					        static Sub<? extends Object>[] ARRAY = new Sub[] { };
					    }
					}
					
					class XList<T> {
						Zork z;
					}
					""", // =================
		},
		"""
			----------
			1. WARNING in X.java (at line 7)
				static Sub<? extends Object>[] ARRAY = new Sub[] { };
				                                       ^^^^^^^^^^^^^
			Type safety: The expression of type X.Foo.Sub[] needs unchecked conversion to conform to X.Foo.Sub<? extends Object>[]
			----------
			2. ERROR in X.java (at line 12)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216565 - variation
public void test1258() {
	this.runConformTest(
		new String[] {
				"X.java",
				"""
					public class X {
					    static <T> XList<T> asList(T[] x) { return null; }
					    static interface Foo<T> {
					        static interface Sub<T> extends Foo<T> {
					            static XList<Sub<? extends Number>> LIST = asList(ARRAY);\s
					       }
					        static Sub<? extends Number>[] ARRAY = new Sub[] { };
					    }
					}
					
					class XList<T> {
					}
					""", // =================
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216565 - variation
public void test1259() {
	String xSource =
				"""
		public class X {
		    static <T> XList<T> asList(T[] x) { return null; }
		    static interface Foo<T> {
		        static interface Sub<T> extends Foo<T> {
		            static XList<Sub<? extends Number>> LIST = asList(ARRAY);\s
		       }
		        @SuppressWarnings("rawtypes")
		        static Sub<? extends Integer>[] ARRAY = new Sub[] { };
		    }
		}
		
		class XList<T> {
		}
		""";
	if (this.complianceLevel < ClassFileConstants.JDK1_8) {
		this.runNegativeTest(
			new String[] {
				"X.java",
				xSource,
			},
			"""
				----------
				1. ERROR in X.java (at line 5)
					static XList<Sub<? extends Number>> LIST = asList(ARRAY);\s
					                                           ^^^^^^^^^^^^^
				Type mismatch: cannot convert from XList<X.Foo.Sub<? extends Integer>> to XList<X.Foo.Sub<? extends Number>>
				----------
				2. WARNING in X.java (at line 8)
					static Sub<? extends Integer>[] ARRAY = new Sub[] { };
					                                        ^^^^^^^^^^^^^
				Type safety: The expression of type X.Foo.Sub[] needs unchecked conversion to conform to X.Foo.Sub<? extends Integer>[]
				----------
				""");
	} else {
		runConformTest(new String[]{ "X.java", xSource });
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216565 - variation
public void test1260() {
	this.runConformTest(
		new String[] {
				"X.java",
				"""
					public class X {
					    static <T> XList<T> asList(T[] x) { return null; }
					    static interface Foo<T> {
					        static interface Sub<T> extends Foo<T> {
					            static XList<Sub<? super Number>> LIST = asList(ARRAY);\s
					       }
					        static Sub<? super Number>[] ARRAY = new Sub[] { };
					    }
					}
					
					class XList<T> {
					}
					""", // =================
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216565 - variation
public void test1261() {
	String xSource =
				"""
		public class X {
		    static <T> XList<T> asList(T[] x) { return null; }
		    static interface Foo<T> {
		        static interface Sub<T> extends Foo<T> {
		            static XList<Sub<?>> LIST = asList(ARRAY);\s
		       }
		        static Sub<? super Number>[] ARRAY = new Sub[] { };
		    }
		}
		
		class XList<T> {
		}
		""";
	if (this.complianceLevel < ClassFileConstants.JDK1_8) {
		this.runNegativeTest(
			new String[] {
				"X.java",
				xSource,
			},
			"""
				----------
				1. ERROR in X.java (at line 5)
					static XList<Sub<?>> LIST = asList(ARRAY);\s
					                            ^^^^^^^^^^^^^
				Type mismatch: cannot convert from XList<X.Foo.Sub<? super Number>> to XList<X.Foo.Sub<?>>
				----------
				2. WARNING in X.java (at line 7)
					static Sub<? super Number>[] ARRAY = new Sub[] { };
					                                     ^^^^^^^^^^^^^
				Type safety: The expression of type X.Foo.Sub[] needs unchecked conversion to conform to X.Foo.Sub<? super Number>[]
				----------
				""");
	} else {
		runConformTest(new String[]{ "X.java", xSource });
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216565 - variation
public void test1262() {
	this.runNegativeTest(
		new String[] {
				"X.java",
				"""
					public class X {
					    static <T> XList<T> asList(T[] x) { return null; }
					    static interface Foo<T> {
					        static interface Sub<T> extends Foo<T> {
					            static XList<Sub<? super Number>> LIST = asList(ARRAY);\s
					       }
					        static Sub<?>[] ARRAY = new Sub[] { };
					    }
					}
					
					class XList<T> {
					}
					""", // =================
		},
		"""
			----------
			1. ERROR in X.java (at line 5)
				static XList<Sub<? super Number>> LIST = asList(ARRAY);\s
				                                         ^^^^^^^^^^^^^
			Type mismatch: cannot convert from XList<X.Foo.Sub<?>> to XList<X.Foo.Sub<? super Number>>
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216565 - variation
public void test1263() {
	String xSource =
				"""
		public class X {
		    static <T> XList<T> asList(T[] x) { return null; }
		    static interface Foo<T> {
		        static interface Sub<T> extends Foo<T> {
		            static XList<Sub<?>> LIST = asList(ARRAY);\s
		       }
		        @SuppressWarnings("rawtypes")
		        static Sub<? super Object>[] ARRAY = new Sub[] { };
		    }
		}
		
		class XList<T> {
		}
		""";
	if (this.complianceLevel < ClassFileConstants.JDK1_8) {
		this.runNegativeTest(
			new String[] {
				"X.java",
				xSource,
			},
			"""
				----------
				1. ERROR in X.java (at line 5)
					static XList<Sub<?>> LIST = asList(ARRAY);\s
					                            ^^^^^^^^^^^^^
				Type mismatch: cannot convert from XList<X.Foo.Sub<? super Object>> to XList<X.Foo.Sub<?>>
				----------
				2. WARNING in X.java (at line 8)
					static Sub<? super Object>[] ARRAY = new Sub[] { };
					                                     ^^^^^^^^^^^^^
				Type safety: The expression of type X.Foo.Sub[] needs unchecked conversion to conform to X.Foo.Sub<? super Object>[]
				----------
				""");
	} else {
		runConformTest(new String[]{ "X.java", xSource });
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216565 - variation
public void test1264() {
	this.runConformTest(
		new String[] {
				"X.java",
				"""
					import java.util.List;
					public class X {
					    static <T> List<T> asList(T[] x) { return null; }
					    static interface Foo<T> {
					        static interface Sub<T> extends Foo<T> {
					            static List<X.Foo.Sub<?>> LIST = asList(ARRAY);\s
					       }
					        static X.Foo.Sub<?>[] ARRAY = new Sub[] { };
					    }
					}""", // =================
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216565 - variation
public void test1265() {
	this.runConformTest(
			new String[] {
					"X.java",
					"""
						import java.util.List;
						public class X {
						    static <T> List<T> asList(T[] x) { return null; }
						    static interface Foo<T> {
						        static interface Sub<T> extends Foo<T> {
						            static List<Foo.Sub<?>> LIST = asList(ARRAY);\s
						       }
						        static Sub<?>[] ARRAY = new Sub[] { };
						    }
						}""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216565 - variation
public void test1266() {
	this.runConformTest(
			new String[] {
					"X.java",
					"""
						import java.util.List;
						public class X {
						    static <T> List<T> asList(T[] x) { return null; }
						    static interface Foo<T> {
						        static interface Sub<T> extends Foo<T> {
						            static List<Sub<?>> LIST = asList(ARRAY);\s
						       }
						        static Foo.Sub<?>[] ARRAY = new Sub[] { };
						    }
						}""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216705
public void test1267() {
	this.runConformTest(
			new String[] {
					"X.java",
					"""
						import java.util.List;
						public class X {
							static interface Foo {
							}
							static interface SubFoo extends Foo {
							}
							static abstract class AbstractTest<T extends Foo> {
								protected static class Bar<T extends Foo> {
								}
								protected abstract List<Bar<? extends T>> get();
							}
							static class Test extends AbstractTest<SubFoo> {
								@Override
								protected List<Bar<? extends SubFoo>> get() {
									return null;
								}
							}
						}""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216692
public void test1268() {
	this.runConformTest(
			new String[] {
					"pkg1/Foo.java",
					"""
						package pkg1;
						import java.util.Map;
						public class Foo<T> {
						    protected final Map<String, Field> fields = null;
						    protected static class Field { }
						}
						""",
					"pkg2/SubFoo.java",
					"""
						package pkg2;
						import pkg1.Foo;
						public class SubFoo<T> extends Foo<T> {
						    private Field field = null;
						    private void test() {
						        Field field = fields.get("test");
						    }
						}
						""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216686
public void test1269() {
	this.runConformTest(
			new String[] {
					"X.java",
					"""
						public class X {
							// some functor and functor instances definitions
							static interface OO<T, E> {\s
								public T eval(E x);
							}
							static interface TO<T> extends OO<String, T> {
								public String eval(T x);
							}
							static interface TT extends TO<String> {
								public String eval(String x);
							}
							static final TO<Object> FUNC1 = null;
							static final TT FUNC2 = null;
						
							// some functor combinators
							static <E> TO<E> combine(final TT x, final TO<? super E> y) { // # 1
								System.out.println("#1#");
								return new TO<E>() { public String eval(E o) { return x.eval(y.eval(o)); } };\s
							}
							// body of the test
							static <E> void put(Class<E> type, TO<? super E> func) {
							}
							public static void main(String[] args) {
								put(Integer.class, combine(FUNC2, FUNC1));
							}
						}
						""", // =================
			},
			"#1#");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216686 - variation
public void test1270() {
	this.runConformTest(
			new String[] {
					"X.java",
					"""
						public class X {
							// some functor and functor instances definitions
							static interface OO<T, E> {\s
								public T eval(E x);
							}
							static interface TO<T> extends OO<String, T> {
								public String eval(T x);
							}
							static interface TT extends TO<String> {
								public String eval(String x);
							}
							static final TO<Object> FUNC1 = null;
							static final TT FUNC2 = null;
						
							// some functor combinators
							static <E, T> TO<T> combine(final TO<? super E> x, final OO<E, T> y) { // # 2
								System.out.println("#2#");
								return new TO<T>() { public String eval(T o) { return x.eval(y.eval(o)); } };\s
							}
							// body of the test
							static <E> void put(Class<E> type, TO<? super E> func) {
							}
							public static void main(String[] args) {
								put(Integer.class, combine(FUNC2, FUNC1));
							}
						}
						""", // =================
			},
			"#2#");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216686 - variation
public void test1271() {
	this.runNegativeTest(
			new String[] {
					"X.java",
					"""
						public class X {
							// some functor and functor instances definitions
							static interface OO<T, E> {\s
								public T eval(E x);
							}
							static interface TO<T> extends OO<String, T> {
								public String eval(T x);
							}
							static interface TT extends TO<String> {
								public String eval(String x);
							}
							static final TO<Object> FUNC1 = null;
							static final TT FUNC2 = null;
						
							// some functor combinators
							static <E, T, V> OO<E, V> combine(final OO<E, ? super T> x, final OO<T, V> y) { // # 3
								System.out.println("#3#");
								return new OO<E, V>() { public E eval(V o) { return x.eval(y.eval(o)); } };
							}
							// body of the test
							static <E> void put(Class<E> type, TO<? super E> func) {
							}
							public static void main(String[] args) {
								put(Integer.class, combine(FUNC2, FUNC1));
							}
						}
						""", // =================
			},
			this.complianceLevel < ClassFileConstants.JDK1_8 ?
			"""
				----------
				1. ERROR in X.java (at line 24)
					put(Integer.class, combine(FUNC2, FUNC1));
					^^^
				The method put(Class<E>, X.TO<? super E>) in the type X is not applicable for the arguments (Class<Integer>, X.OO<String,Object>)
				----------
				"""
			: """
				----------
				1. ERROR in X.java (at line 24)
					put(Integer.class, combine(FUNC2, FUNC1));
					^^^
				The method put(Class<E>, X.TO<? super E>) in the type X is not applicable for the arguments (Class<Integer>, X.OO<String,Object>)
				----------
				2. ERROR in X.java (at line 24)
					put(Integer.class, combine(FUNC2, FUNC1));
					                   ^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from X.OO<String,Object> to X.TO<? super E>
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216686 - variation
public void test1272() {
	this.runConformTest(
			new String[] {
					"X.java",
					"""
						public class X {
							// some functor and functor instances definitions
							static interface OO<T, E> {\s
								public T eval(E x);
							}
							static interface TO<T> extends OO<String, T> {
								public String eval(T x);
							}
							static interface TT extends TO<String> {
								public String eval(String x);
							}
							static final TO<Object> FUNC1 = null;
							static final TT FUNC2 = null;
						
							// some functor combinators
							static <E, T, V> OO<E, V> combine(final OO<E, ? super T> x, final OO<T, V> y) { // # 3
								System.out.print("#3#");
								return new OO<E, V>() { public E eval(V o) { return x.eval(y.eval(o)); } };
							}
							// body of the test
							static <E> void put(Class<E> type, TO<? super E> func) {
							}
							public static void main(String[] args) {
						      try {
								   put(Integer.class, (TO<Object>)combine(FUNC2, FUNC1));
						      } catch(ClassCastException e) {
								   System.out.println("#CLASSCAST#");
								}
							}
						}
						""", // =================
			},
			"#3##CLASSCAST#");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216686 - variation
public void test1273() {
	String sourceX =
			"""
		public class X {
			// some functor and functor instances definitions
			static interface OO<T, E> {\s
				public T eval(E x);
			}
			static interface TO<T> extends OO<String, T> {
				public String eval(T x);
			}
			static interface TT extends TO<String> {
				public String eval(String x);
			}
			static final TO<Object> FUNC1 = null;
			static final TT FUNC2 = null;
		
			// some functor combinators
			static <E> TO<E> combine(final TT x, final TO<? super E> y) { // # 1
				System.out.println("#1#");
				return new TO<E>() { public String eval(E o) { return x.eval(y.eval(o)); } };\s
			}
			static <E, T> TO<T> combine(final TO<? super E> x, final OO<E, T> y) { // # 2
				System.out.println("#2#");
				return new TO<T>() { public String eval(T o) { return x.eval(y.eval(o)); } };\s
			}
			// body of the test
			static <E> void put(Class<E> type, TO<? super E> func) {
			}
			public static void main(String[] args) {
				put(Integer.class, combine(FUNC2, FUNC1));
			}
		}
		""";
	if (this.complianceLevel < ClassFileConstants.JDK1_8) {
		this.runConformTest(
			new String[] {
				"X.java",
				sourceX,
			},
			"#1#");
	} else {
		runNegativeTest(
			new String[] {
				"X.java",
				sourceX
			},
			"""
				----------
				1. ERROR in X.java (at line 28)
					put(Integer.class, combine(FUNC2, FUNC1));
					                   ^^^^^^^
				The method combine(X.TT, X.TO<? super Object>) is ambiguous for the type X
				----------
				""" );
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216686 - variation
public void test1274() {
	this.runConformTest(
			new String[] {
					"X.java",
					"""
						public class X {
							// some functor and functor instances definitions
							static interface OO<T, E> {\s
								public T eval(E x);
							}
							static interface TO<T> extends OO<String, T> {
								public String eval(T x);
							}
							static interface TT extends TO<String> {
								public String eval(String x);
							}
							static final TO<Object> FUNC1 = null;
							static final TT FUNC2 = null;
						
							// some functor combinators
							static <E> TO<E> combine(final TT x, final TO<? super E> y) { // # 1
								System.out.println("#1#");
								return new TO<E>() { public String eval(E o) { return x.eval(y.eval(o)); } };\s
							}
							static <E, T> TO<T> combine(final TO<? super E> x, final OO<E, T> y) { // # 2
								System.out.println("#2#");
								return new TO<T>() { public String eval(T o) { return x.eval(y.eval(o)); } };\s
							}
							// body of the test
							static <E> void put(Class<E> type, TO<? super E> func) {
							}
							public static void main(String[] args) {
								put(Integer.class, X.<Object>combine(FUNC2, FUNC1));
							}
						}
						""", // =================
			},
			"#1#");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216686 - variation
public void test1275() {
	String[] input =
			new String[] {
					"X.java",
					"""
						public class X {
							// some functor and functor instances definitions
							static interface OO<T, E> {\s
								public T eval(E x);
							}
							static interface TO<T> extends OO<String, T> {
								public String eval(T x);
							}
							static interface TT extends TO<String> {
								public String eval(String x);
							}
							static final TO<Object> FUNC1 = null;
							static final TT FUNC2 = null;
						
							// some functor combinators
							static <E> TO<E> combine(final TT x, final TO<? super E> y) { // # 1
								System.out.println("#1#");
								return new TO<E>() { public String eval(E o) { return x.eval(y.eval(o)); } };\s
							}
							static <E, T, V> OO<E, V> combine(final OO<E, ? super T> x, final OO<T, V> y) { // # 3
								System.out.println("#3#");
								return new OO<E, V>() { public E eval(V o) { return x.eval(y.eval(o)); } };
							}
							// body of the test
							static <E> void put(Class<E> type, TO<? super E> func) {
							}
							public static void main(String[] args) {
								put(Integer.class, combine(FUNC2, FUNC1));
							}
						}
						""", // =================
			};
	if (this.complianceLevel < ClassFileConstants.JDK1_8) {
		runConformTest(
			input,
			"#1#");
	} else {
		runNegativeTest(
			input,
			"""
				----------
				1. ERROR in X.java (at line 28)
					put(Integer.class, combine(FUNC2, FUNC1));
					                   ^^^^^^^
				The method combine(X.TT, X.TO<? super Object>) is ambiguous for the type X
				----------
				""");
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216686 - variation
public void test1276() {
	this.runConformTest(
			new String[] {
					"X.java",
					"""
						public class X {
							// some functor and functor instances definitions
							static interface OO<T, E> {\s
								public T eval(E x);
							}
							static interface TO<T> extends OO<String, T> {
								public String eval(T x);
							}
							static interface TT extends TO<String> {
								public String eval(String x);
							}
							static final TO<Object> FUNC1 = null;
							static final TT FUNC2 = null;
						
							// some functor combinators
							static <E> TO<E> combine(final TT x, final TO<? super E> y) { // # 1
								System.out.println("#1#");
								return new TO<E>() { public String eval(E o) { return x.eval(y.eval(o)); } };\s
							}
							static <E, T, V> OO<E, V> combine(final OO<E, ? super T> x, final OO<T, V> y) { // # 3
								System.out.println("#3#");
								return new OO<E, V>() { public E eval(V o) { return x.eval(y.eval(o)); } };
							}
							// body of the test
							static <E> void put(Class<E> type, TO<? super E> func) {
							}
							public static void main(String[] args) {
								put(Integer.class, X.<Object>combine(FUNC2, FUNC1));
							}
						}
						""", // =================
			},
			"#1#");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216686 - variation
public void test1277() {
	this.runConformTest(
			new String[] {
					"X.java",
					"""
						public class X {
							// some functor and functor instances definitions
							static interface OO<T, E> {\s
								public T eval(E x);
							}
							static interface TO<T> extends OO<String, T> {
								public String eval(T x);
							}
							static interface TT extends TO<String> {
								public String eval(String x);
							}
							static final TO<Object> FUNC1 = null;
							static final TT FUNC2 = null;
						
							// some functor combinators
							static <E, T> TO<T> combine(final TO<? super E> x, final OO<E, T> y) { // # 2
								System.out.println("#2#");
								return new TO<T>() { public String eval(T o) { return x.eval(y.eval(o)); } };\s
							}
							static <E, T, V> OO<E, V> combine(final OO<E, ? super T> x, final OO<T, V> y) { // # 3
								System.out.println("#3#");
								return new OO<E, V>() { public E eval(V o) { return x.eval(y.eval(o)); } };
							}
							// body of the test
							static <E> void put(Class<E> type, TO<? super E> func) {
							}
							public static void main(String[] args) {
								put(Integer.class, combine(FUNC2, FUNC1));
							}
						}
						""", // =================
			},
			"#2#");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216686 - variation
public void test1278() {
	String[] input =
			new String[] {
					"X.java",
					"""
						public class X {
							// some functor and functor instances definitions
							static interface OO<T, E> {\s
								public T eval(E x);
							}
							static interface TO<T> extends OO<String, T> {
								public String eval(T x);
							}
							static interface TT extends TO<String> {
								public String eval(String x);
							}
							static final TO<Object> FUNC1 = null;
							static final TT FUNC2 = null;
						
							// some functor combinators
							static <E> TO<E> combine(final TT x, final TO<? super E> y) { // # 1
								System.out.println("#1#");
								return new TO<E>() { public String eval(E o) { return x.eval(y.eval(o)); } };\s
							}
							static <E, T> TO<T> combine(final TO<? super E> x, final OO<E, T> y) { // # 2
								System.out.println("#2#");
								return new TO<T>() { public String eval(T o) { return x.eval(y.eval(o)); } };\s
							}
							static <E, T, V> OO<E, V> combine(final OO<E, ? super T> x, final OO<T, V> y) { // # 3
								System.out.println("#3#");
								return new OO<E, V>() { public E eval(V o) { return x.eval(y.eval(o)); } };
							}
							// body of the test
							static <E> void put(Class<E> type, TO<? super E> func) {
							}
							public static void main(String[] args) {
								put(Integer.class, combine(FUNC2, FUNC1));
							}
						}
						""", // =================
			};
	if (this.complianceLevel < ClassFileConstants.JDK1_8) {
		runConformTest(
			input,
			"#1#");
	} else {
		runNegativeTest(
			input,
			"""
				----------
				1. ERROR in X.java (at line 32)
					put(Integer.class, combine(FUNC2, FUNC1));
					                   ^^^^^^^
				The method combine(X.TT, X.TO<? super Object>) is ambiguous for the type X
				----------
				""");
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216686 - variation
public void test1279() {
	this.runConformTest(
			new String[] {
					"X.java",
					"""
						public class X {
							// some functor and functor instances definitions
							static interface OO<T, E> {\s
								public T eval(E x);
							}
							static interface TO<T> extends OO<String, T> {
								public String eval(T x);
							}
							static interface TT extends TO<String> {
								public String eval(String x);
							}
							static final TO<Object> FUNC1 = null;
							static final TT FUNC2 = null;
						
							// some functor combinators
							static <E> TO<E> combine(final TT x, final TO<? super E> y) { // # 1
								System.out.println("#1#");
								return new TO<E>() { public String eval(E o) { return x.eval(y.eval(o)); } };\s
							}
							static <E, T> TO<T> combine(final TO<? super E> x, final OO<E, T> y) { // # 2
								System.out.println("#2#");
								return new TO<T>() { public String eval(T o) { return x.eval(y.eval(o)); } };\s
							}
							static <E, T, V> OO<E, V> combine(final OO<E, ? super T> x, final OO<T, V> y) { // # 3
								System.out.println("#3#");
								return new OO<E, V>() { public E eval(V o) { return x.eval(y.eval(o)); } };
							}
							// body of the test
							static <E> void put(Class<E> type, TO<? super E> func) {
							}
							public static void main(String[] args) {
								put(Integer.class, X.<Object>combine(FUNC2, FUNC1));
							}
						}
						""", // =================
			},
			"#1#");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216686 - variation
public void test1280() {
	this.runConformTest(
			new String[] {
					"X.java",
					"""
						interface OO<T,E> {}
						interface TO<T> extends OO<String,T> {}
						interface TT extends TO<String> {}
						
						public class X {
							<E, T> TO<T> combine(final TO<? super E> x, final OO<E, T> y) { return null; }
						  void foo(TT tt, TO<? super Object> too) {
						     combine(tt, too);
						  }
						}""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216686 - variation
// FAIL EXTRA ERR, see http://mail.openjdk.java.net/pipermail/lambda-spec-experts/2013-December/000444.html
public void test1281() {
	if (this.complianceLevel >= ClassFileConstants.JDK1_8)
		return;
	this.runConformTest(
			new String[] {
					"X.java",
					"""
						interface OO<T,E> {}
						interface TO<T> extends OO<String,T> {}
						interface TT extends TO<String> {}
						
						public class X {
							<E, T> TO<T> combine(final TO<? super E> x, final OO<E, T>[] y) { return null; }
						  void foo(TT tt, TO<? super Object>[] too) {
						     combine(tt, too);
						  }
						}""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216686 - variation
public void test1282() {
	this.runNegativeTest(
			new String[] {
					"X.java",
					"""
						public class X {
							static interface OO<T,E> {}
							static interface TO<T> extends OO<String,T> {}
							static interface TT extends TO<String> {}
						\t
							<E, T> TO<T> combine(TT x, TO<? super E> y) { return null; }
							void foo(TO<? super String> too, OO<String,Object> oo) {
								combine(too, oo);
							}
						}""", // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 8)
					combine(too, oo);
					^^^^^^^
				The method combine(X.TT, X.TO<? super E>) in the type X is not applicable for the arguments (X.TO<capture#1-of ? super String>, X.OO<String,Object>)
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=216686 - variation
public void test1283() {
	this.runNegativeTest(
			new String[] {
					"X.java",
					"""
						public class X {
							static interface OO<T,E> {}
							static interface TO<T> extends OO<String,T> {}
							static interface TT extends TO<String> {}
						\t
							<E, T> TO<T> combine(TT[] x, TO<? super E>[] y) { return null; }
							void foo(TO<? super String>[] too, OO<String,Object>[] oo) {
								combine(too, oo);
							}
						}""", // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 8)
					combine(too, oo);
					^^^^^^^
				The method combine(X.TT[], X.TO<? super E>[]) in the type X is not applicable for the arguments (X.TO<? super String>[], X.OO<String,Object>[])
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=210425
public void test1284() {
	this.runNegativeTest(
			new String[] {
					"X.java",
					"""
						public class X {
							public static void main(String[] args) {
								Thread th = Thread.currentThread();
								Z<String, Thread> z1 = new Z<String, Thread>(th);
								Z<String, Exception> z2 = new Z<String, Exception>(new Exception());
								Y<String, Thread> y = new Y<String, Thread>() {};
								y.foo(z1).get().getThreadGroup();
								y.foo(z2).get().getThreadGroup(); // heap pollution: we get a CCE because we return a U2
								Zork z;
							}
						}
						abstract class Y<T, U> {
							I2<T, U> foo(I1<T> i) {
								return (I2<T, U>) i;
							}
						}
						interface I1<T> {
						}
						interface I2<T, U> extends I1<T> {
							U get();
						}
						class Z<V, W> implements I2<V, W> {
							W w;
							Z(W w) {
								this.w = w;
							}
							public W get() {
								return this.w;
							}
						}
						""", // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 9)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				2. WARNING in X.java (at line 14)
					return (I2<T, U>) i;
					       ^^^^^^^^^^^^
				Type safety: Unchecked cast from I1<T> to I2<T,U>
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=210425 - variation
public void test1285() {
	this.runNegativeTest(
			new String[] {
					"X.java",
					"""
						public class X {
							public static void main(String[] args) {
								Thread th = Thread.currentThread();
								Z<String, Thread> z1 = new Z<String, Thread>(th);
								Z<String, Exception> z2 = new Z<String, Exception>(new Exception());
								Y<String, Thread> y = new Y<String, Thread>() {};
								y.foo(z1).get().getThreadGroup();
								y.foo(z2).get().getThreadGroup();
							}
						}
						abstract class Y<T, U> {
							I2<T, U> foo(I1<T,U> i) {
								return (I2<T, U>) i;
							}
						}
						interface I1<T, U> {
						}
						interface I2<T, U> extends I1<T,U> {
							U get();
						}
						class Z<V, W> implements I2<V, W> {
							W w;
							Z(W w) {
								this.w = w;
							}
							public W get() {
								return this.w;
							}
						}
						""", // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 8)
					y.foo(z2).get().getThreadGroup();
					  ^^^
				The method foo(I1<String,Thread>) in the type Y<String,Thread> is not applicable for the arguments (Z<String,Exception>)
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=210425 - variation
public void test1286() {
	this.runNegativeTest(
			new String[] {
					"X.java",
					"""
						public class X {
							public static void main(String[] args) {
								Thread th = Thread.currentThread();
								Z<String, Thread> z1 = new Z<String, Thread>(th);
								Z<String, Exception> z2 = new Z<String, Exception>(new Exception());
								Y<String, Thread> y = new Y<String, Thread>() {};
								y.foo(z1).get().getThreadGroup();
								y.foo(z2).get().getThreadGroup(); // heap pollution: we get a CCE because we return a U2
								Zork z;
							}
						}
						abstract class Y<T, U> {
							I2<U> foo(I1 i) {
								return (I2<U>) i;
							}
						}
						interface I1 {}
						interface I2<U> extends I1 {
							U get();
						}
						class Z<V, W> implements I2<W> {
							W w;
							Z(W w) {
								this.w = w;
							}
							public W get() {
								return this.w;
							}
						}
						""", // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 9)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				2. WARNING in X.java (at line 14)
					return (I2<U>) i;
					       ^^^^^^^^^
				Type safety: Unchecked cast from I1 to I2<U>
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=210425 - variation
public void test1287() {
	this.runNegativeTest(
			new String[] {
					"X.java",
					"""
						public class X {
							public static void main(String[] args) {
								Thread th = Thread.currentThread();
								Z<String, Thread> z1 = new Z<String, Thread>(th);
								Z<String, Exception> z2 = new Z<String, Exception>(new Exception());
								Y<String, Thread> y = new Y<String, Thread>() {};
								y.foo(z1).get().getThreadGroup();
								y.foo(z2).get().getThreadGroup(); // heap pollution: we get a CCE because we return a U2
								Zork z;
							}
						}
						abstract class Y<T, U> {
							I2<T,U> foo(I1<T,T> i) {
								return (I2<T,U>) i;
							}
						}
						interface I1<D,E> {}
						interface I2<F,G> extends I1<F,F> {
							G get();
						}
						class Z<V, W> implements I2<V,W> {
							W w;
							Z(W w) {
								this.w = w;
							}
							public W get() {
								return this.w;
							}
						}
						""", // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 9)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				2. WARNING in X.java (at line 14)
					return (I2<T,U>) i;
					       ^^^^^^^^^^^
				Type safety: Unchecked cast from I1<T,T> to I2<T,U>
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=210425 - variation
public void test1288() {
	this.runNegativeTest(
			new String[] {
					"X.java",
					"""
						import java.util.Map;
						public class X {
							public static void main(String[] args) {
								Thread th = Thread.currentThread();
								Z<String, Thread> z1 = new Z<String, Thread>(th);
								Z<String, Exception> z2 = new Z<String, Exception>(new Exception());
								Y<String, Thread> y = new Y<String, Thread>() {};
								y.foo(z1).get().getThreadGroup();
								y.foo(z2).get().getThreadGroup(); // heap pollution: we get a CCE because we return a U2
								Zork z;
							}
						}
						abstract class Y<T, U> {
							I2<T,U> foo(I1<Map<T,T>> i) {
								return (I2<T,U>) i;
							}
						}
						interface I1<D> {}
						interface I2<F,G> extends I1<Map<F,F>> {
							G get();
						}
						class Z<V, W> implements I2<V,W> {
							W w;
							Z(W w) {
								this.w = w;
							}
							public W get() {
								return this.w;
							}
						}""", // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 10)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				2. WARNING in X.java (at line 15)
					return (I2<T,U>) i;
					       ^^^^^^^^^^^
				Type safety: Unchecked cast from I1<Map<T,T>> to I2<T,U>
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=210425 - variation
public void test1289() {
	this.runNegativeTest(
			new String[] {
					"X.java",
					"""
						import java.util.Map;
						public class X {
							public static void main(String[] args) {
								Thread th = Thread.currentThread();
								Z<String, Thread> z1 = new Z<String, Thread>(th);
								Z<String, Exception> z2 = new Z<String, Exception>(new Exception());
								Y<String, Thread> y = new Y<String, Thread>() {};
								y.foo(z1).get().getThreadGroup();
								y.foo(z2).get().getThreadGroup(); // heap pollution: we get a CCE because we return a U2
								Zork z;
							}
						}
						abstract class Y<T, U> {
							I2<T,U> foo(I1<Map<T,T>> i) {
								return (I2<T,U>) i;
							}
						}
						interface I1<D> {}
						interface I2<F,G> extends I1<Map<F,G>> {
							G get();
						}
						class Z<V, W> implements I2<V,W> {
							W w;
							Z(W w) {
								this.w = w;
							}
							public W get() {
								return this.w;
							}
						}""", // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 8)
					y.foo(z1).get().getThreadGroup();
					  ^^^
				The method foo(I1<Map<String,String>>) in the type Y<String,Thread> is not applicable for the arguments (Z<String,Thread>)
				----------
				2. ERROR in X.java (at line 9)
					y.foo(z2).get().getThreadGroup(); // heap pollution: we get a CCE because we return a U2
					  ^^^
				The method foo(I1<Map<String,String>>) in the type Y<String,Thread> is not applicable for the arguments (Z<String,Exception>)
				----------
				3. ERROR in X.java (at line 10)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				4. ERROR in X.java (at line 15)
					return (I2<T,U>) i;
					       ^^^^^^^^^^^
				Cannot cast from I1<Map<T,T>> to I2<T,U>
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=210425 - variation
public void test1290() {
	this.runNegativeTest(
			new String[] {
					"X.java",
					"""
						public class X <T, U> {
						  K<T> foo(I<T> i) {
						        return (K<T>) i;
						  }
						  Zork z;
						}
						interface I<T> {
						}
						interface J<T, U> extends I<T> {
						}
						interface K<T> extends J<T, String> {
						}""", // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 5)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=218677
// FAIL ERRMSG
public void test1291() {
	if (this.complianceLevel >= ClassFileConstants.JDK1_8)
		return;
	this.runNegativeTest(
			new String[] {
					"X.java",
					"""
						import java.util.ArrayList;
						import java.util.List;
						public class X {
						    public static <D, E extends D> List<D> moreGeneric(List<E> list) {
						        List<D> result = new ArrayList<D>();
						        result.addAll( list );
						        return result;
						    }
						    class A {}
						    class B extends A {}
						    class C extends B {}
						    public static void main( String[] args ) {
						        List<B> b = new ArrayList<B>();
						        List<A> a = moreGeneric(b);
						        List<C> c = moreGeneric(b);
						    }
						}
						""", // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 15)
					List<C> c = moreGeneric(b);
					            ^^^^^^^^^^^
				Bound mismatch: The generic method moreGeneric(List<E>) of type X is not applicable for the arguments (List<X.B>). The inferred type X.B is not a valid substitute for the bounded parameter <E extends D>
				----------
				""",
			JavacTestOptions.EclipseJustification.EclipseBug218677);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=218677 - variation
// FAIL ERRMSG
public void test1292() {
	if (this.complianceLevel >= ClassFileConstants.JDK1_8)
		return;
	this.runNegativeTest(
			new String[] {
					"X.java",
					"""
						import java.util.ArrayList;
						import java.util.List;
						public class X {
						    public static <D, E extends D> List<E> moreSpecific(List<D> list) {
						        List<E> result = new ArrayList<E>();
						        result.addAll( (List<?>)list );
						        return result;
						    }
						    class A {}
						    class B extends A {}
						    class C extends B {}
						    public static void main( String[] args ) {
						        List<B> b = new ArrayList<B>();
						        List<A> a = moreSpecific(b);
						        List<C> c = moreSpecific(b);
						    }
						}
						""", // =================
			},
			this.complianceLevel < ClassFileConstants.JDK1_8 ?
			"""
				----------
				1. ERROR in X.java (at line 6)
					result.addAll( (List<?>)list );
					       ^^^^^^
				The method addAll(Collection<? extends E>) in the type List<E> is not applicable for the arguments (List<capture#1-of ?>)
				----------
				2. ERROR in X.java (at line 14)
					List<A> a = moreSpecific(b);
					            ^^^^^^^^^^^^
				Bound mismatch: The generic method moreSpecific(List<D>) of type X is not applicable for the arguments (List<X.B>). The inferred type X.A is not a valid substitute for the bounded parameter <E extends D>
				----------
				""" :
				"""
					----------
					1. ERROR in X.java (at line 6)
						result.addAll( (List<?>)list );
						       ^^^^^^
					The method addAll(Collection<? extends E>) in the type List<E> is not applicable for the arguments (List<capture#1-of ?>)
					----------
					2. ERROR in X.java (at line 14)
						List<A> a = moreSpecific(b);
						            ^^^^^^^^^^^^^^^
					Type mismatch: cannot convert from List<X.B> to List<X.A>
					----------
					""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=220111
public void test1293() {
	this.runConformTest(
			new String[] {
					"X.java",
					"""
						public class X<Token, NodeType> {
						    class Table {
						        State<Token>   s;
						        Table() {
						            this.s = new State<Token>();
						        }
								class State<T> {
								}
						    }
						}
						""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=220111 - variation
public void test1294() {
	this.runConformTest(
			new String[] {
					"X.java",
					"""
						public class X<Token, NodeType> {
						    static class Table {
						        State<String>   s;
						        Table() {
						            this.s = new State<String>();
						        }
								class State<T> {
								}
						    }
						}
						""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=97303 - variation
public void test1295() {
	Map options = getCompilerOptions();
	options.put(JavaCore.COMPILER_PB_UNCHECKED_TYPE_OPERATION, JavaCore.IGNORE);
	this.runNegativeTest(
			new String[] {
					"X.java",
					"""
						class Deejay {
							class Counter<T> {}
						
							Deejay.Counter<Song> songCounter = new Deejay.Counter<Song>();
							Deejay.Counter<Genre> genreCounter = new Deejay.Counter<Genre>();
						
							java.util.List<Counter<?>> list1 = java.util.Arrays.asList(songCounter, genreCounter);
							java.util.List<Counter<? extends Object>> list2 = java.util.Arrays.asList(songCounter, genreCounter);
							java.util.List<Counter<?>> list3 = java.util.Arrays.<Deejay.Counter<?>>asList(songCounter, genreCounter);
							java.util.List<Counter<?>> list4 = java.util.Arrays.asList(new Deejay.Counter<?>[] {songCounter, genreCounter});
							java.util.List<Counter<? extends String>> list5 = java.util.Arrays.asList(songCounter, genreCounter);
						}
						class Genre {}
						class Song {}
						""", // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 11)
					java.util.List<Counter<? extends String>> list5 = java.util.Arrays.asList(songCounter, genreCounter);
					                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from List<Deejay.Counter<? extends Object>> to List<Deejay.Counter<? extends String>>
				----------
				""",
			null,
			true,
			options);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=220111 - variation
public void test1296() {
	this.runConformTest(
			new String[] {
					"X.java",
					"""
						public class X<Token, NodeType> {
							class Table {
								Table.State<Token> s;
						
								Table() {
									this.s = new Table.State<Token>();
								}
						
								class State<T> {
								}
							}
						}
						""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=220111 - variation
public void test1297() {
	this.runConformTest(
			new String[] {
					"X.java",
					"""
						public class X<Token, NodeType> {
							class Table {
								X<Token, NodeType>.Table.State<Token> s;
						
								Table() {
									this.s = new X<Token, NodeType>().new Table().new State<Token>();
								}
						
								class State<T> {
								}
							}
						}
						""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=220111 - variation
public void test1298() {
	this.runConformTest(
			new String[] {
					"X.java",
					"""
						public class X<Token, NodeType> {
							static class Table {
								X.Table.State<String> s;
						
								Table() {
									this.s = new X.Table().new State<String>();
								}
						
								class State<T> {
								}
							}
						}
						""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=220361
public void test1299() {
	this.runConformTest(
			new String[] {
					"X.java",
					"""
						public class X<U, V> {
							static class Table {
								X.Table.State<String> s;
						
								Table() {
									this.s = new X.Table.State<String>();
								}
						
								static class State<T> {
								}
							}
						}
						""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=220361 - variation
public void test1300() {
	this.runConformTest(
			new String[] {
					"X.java",
					"""
						public class X<U, V> {
							static class Table {
								State<String> s;
						
								Table() {
									this.s = new State<String>();
								}
						
								static class State<T> {
								}
							}
						}
						""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=220361 - variation
public void test1301() {
	this.runConformTest(
			new String[] {
					"X.java",
					"""
						public class X<U, V> {
							static class Table {
								Table.State<String> s;
						
								Table() {
									this.s = new Table.State<String>();
								}
						
								static class State<T> {
								}
							}
						}
						""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=220361 - variation
public void test1302() {
	runConformTest(
		true,
		new String[] {
			"EMap.java",
			"""
				import java.util.ArrayList;
				import java.util.Map;
				
				public abstract class EMap<A, B> implements Map<A, B> {
				  public abstract static class Unsettable<K, V> extends EMap<K, V> {
				    protected class UnsettableEList<E extends Object & Entry<K, V>> extends EList<E> {
				    }
				  }
				  protected class EList<E extends Object & Entry<A,B>> extends ArrayList<E>{
				  }
				}
				""", // =================
		},
		null,
		"",
		null,
		JavacTestOptions.EclipseHasABug.EclipseBug159851);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=219625
public void test1303() {
	this.runConformTest(
			new String[] {
					"X.java",
					"""
						public class X {
						  interface Foo<T> {
						    T getValue();
						    void doSomething(T o);
						  }
						  public static abstract class AbstractFoo<T> implements Foo<T> {
						    /**
						     * If this is removed ConcreteFoo no longer compiles.
						     */
						    public void doSomething(final String o) {
						    }
						  }
						  public static final class ConcreteFoo extends AbstractFoo<String> {
						    public String getValue() {
						      return "I am a string";
						    }
						  }
						  /**
						   * We lose the type infomation here so try but fail to call the doSomething(Object) method.
						   */
						  private static <T> void feedFoosValueIntoFoo(final Foo<T> foo) {
						    foo.doSomething(foo.getValue());
						  }
						  private static void testTypedString() {
						    final ConcreteFoo foo = new ConcreteFoo();
						    foo.doSomething(foo.getValue());
						  }
						  private static void testGenericString() {
						    feedFoosValueIntoFoo(new ConcreteFoo());
						  }
						  public static void main(String[] args) {
						    testTypedString();
						    testGenericString();
						    System.out.println("SUCCESS");
						  }
						}
						""", // =================
			},
			"SUCCESS");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=219625 - variation
public void test1304() {
	this.runConformTest(
			new String[] {
					"X.java",
					"""
						interface Foo<T> {
							T get();
							void doSomething(T t);
						}
						abstract class XSuper implements Foo<String> {
							public void doSomething(String s) { System.out.println(s); }
						}
						public class X extends XSuper {
							public String get() { return "SUCCESS"; }
							static <U> void doIt(Foo<U> f) {
								f.doSomething(f.get());
							}
							public static void main(String[] args) {
								doIt(new X());
							}
						}
						""", // =================
			},
			"SUCCESS");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=223334
public void test1305() {
	this.runConformTest(
			new String[] {
					"bug/ConflictManager.java",// =================
					"""
						package bug;
						import java.util.*;
						public class ConflictManager<T> {
							public List<Map.Entry<Integer, ? extends Collection<T>>> getConflictsSortedBySize() {
								return null;
							}
						}
						""",
					"bug/LayoutOrganizable.java",// =================
					"""
						package bug;
						public class LayoutOrganizable<T> {
							private T t;
						
							public LayoutOrganizable(T t) {
								this.t = t;
						
							}
						}
						""",
					"bug/LayoutOrganizer.java",
					"""
						package bug;
						import java.util.*;
						public class LayoutOrganizer<T> {
							ConflictManager<LayoutOrganizable<T>> conflictManager = new ConflictManager<LayoutOrganizable<T>>();
							private boolean optimizeEqual() {
								List<Map.Entry<Integer, ? extends Collection<LayoutOrganizable<T>>>> list;
								ListIterator<Map.Entry<Integer, ? extends Collection<LayoutOrganizable<T>>>> i;
								// create sorted list of pairs
								// (#conflicts, list of LayoutOrganizable sharing this #conflicts)
								// Here is the problem...
								list = conflictManager.getConflictsSortedBySize();
								return null == list;
							}
						}
						""", // =================
			},
			"");
	this.runConformTest(
			new String[] {
					"bug/LayoutOrganizer.java",
					"""
						package bug;
						import java.util.*;
						public class LayoutOrganizer<T> {
							ConflictManager<LayoutOrganizable<T>> conflictManager = new ConflictManager<LayoutOrganizable<T>>();
							private boolean optimizeEqual() {
								List<Map.Entry<Integer, ? extends Collection<LayoutOrganizable<T>>>> list;
								ListIterator<Map.Entry<Integer, ? extends Collection<LayoutOrganizable<T>>>> i;
								// create sorted list of pairs
								// (#conflicts, list of LayoutOrganizable sharing this #conflicts)
								// Here is the problem...
								list = conflictManager.getConflictsSortedBySize();
								return null == list;
							}
						}
						""", // =================
			},
			"",
			null,
			false,
			null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=106744 - variation
public void test1306() {
	runNegativeTest(
		// test directory preparation
		new String[] { /* test files */
				"X.java",
				"""
					import java.lang.reflect.Constructor;
					import java.lang.annotation.Documented;
					import java.util.List;
					
					public class X {
					    Constructor c = null;
					    Documented d = c.getAnnotation(Documented.class);
					}
					""", // =================
		},
		// compiler results
		"----------\n" + /* expected compiler log */
		"1. WARNING in X.java (at line 6)\n" +
		"	Constructor c = null;\n" +
		"	^^^^^^^^^^^\n" +
		"Constructor is a raw type. References to generic type Constructor<T> should be parameterized\n" +
		"----------\n" +
		"2. WARNING in X.java (at line 7)\n" +
		"	Documented d = c.getAnnotation(Documented.class);\n" +
		"	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
		"Type safety: The method getAnnotation(Class) belongs to the raw type Constructor. References to generic type Constructor<T> should be parameterized\n" +
		"----------\n" +
		"3. ERROR in X.java (at line 7)\n" +
		"	Documented d = c.getAnnotation(Documented.class);\n" +
		"	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
		"Type mismatch: cannot convert from Annotation to Documented\n" +
		"----------\n",
		// javac options
		JavacTestOptions.JavacHasABug.JavacBug6400189 /* javac test options */);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=106744 - variation
public void test1307() {
	this.runNegativeTest(
			new String[] {
					"Y.java",
					"""
						import java.util.List;
						public class Y<T> {
							Zork z;
							Y<T> itself() { return this; }
							List<String> list() { return null; }
							Y<String> someY() { return null; }
						}
						class Z {
							void foo(Y y) {
								Z z = y.itself(); // Y cannot be converted to Z (itself() return type got erased)
								List<String> l = y.list(); // unchecked conversion from List to List<String>
								Y<String> ys = y.someY(); // unchecked conversion from Y to Y<String>
							}
						}
						""", // =================
			},
			"""
				----------
				1. ERROR in Y.java (at line 3)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				2. WARNING in Y.java (at line 9)
					void foo(Y y) {
					         ^
				Y is a raw type. References to generic type Y<T> should be parameterized
				----------
				3. ERROR in Y.java (at line 10)
					Z z = y.itself(); // Y cannot be converted to Z (itself() return type got erased)
					      ^^^^^^^^^^
				Type mismatch: cannot convert from Y to Z
				----------
				4. WARNING in Y.java (at line 11)
					List<String> l = y.list(); // unchecked conversion from List to List<String>
					                 ^^^^^^^^
				Type safety: The expression of type List needs unchecked conversion to conform to List<String>
				----------
				5. WARNING in Y.java (at line 12)
					Y<String> ys = y.someY(); // unchecked conversion from Y to Y<String>
					               ^^^^^^^^^
				Type safety: The expression of type Y needs unchecked conversion to conform to Y<String>
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=106744 - variation
public void test1308() {
	this.runNegativeTest(
			new String[] {
					"Y.java",
					"""
						@interface MyAnnotation {
						}
						class MyAccessibleObject {
							<T extends java.lang.annotation.Annotation> Object getAnnotation(Class<T> c) {
								return null;
							}
						}
						class MyConstructor<V> extends MyAccessibleObject {
							<T extends java.lang.annotation.Annotation> T getAnnotation(Class<T> c) {
								return null;
							}
						}
						class X {
							void bar1(java.lang.reflect.Constructor constr, Class<MyAnnotation> ann) {
								MyAnnotation a = constr.getAnnotation(ann); // 1
							}
							void bar2(MyConstructor constr, Class<MyAnnotation> ann) {
								MyAnnotation a = constr.getAnnotation(ann); // 2
							}
						}
						""", // =================
			},
			"""
				----------
				1. WARNING in Y.java (at line 9)
					<T extends java.lang.annotation.Annotation> T getAnnotation(Class<T> c) {
					                                              ^^^^^^^^^^^^^^^^^^^^^^^^^
				The method getAnnotation(Class<T>) of type MyConstructor<V> should be tagged with @Override since it actually overrides a superclass method
				----------
				2. WARNING in Y.java (at line 14)
					void bar1(java.lang.reflect.Constructor constr, Class<MyAnnotation> ann) {
					          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Constructor is a raw type. References to generic type Constructor<T> should be parameterized
				----------
				3. WARNING in Y.java (at line 15)
					MyAnnotation a = constr.getAnnotation(ann); // 1
					                 ^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: The method getAnnotation(Class) belongs to the raw type Constructor. References to generic type Constructor<T> should be parameterized
				----------
				4. ERROR in Y.java (at line 15)
					MyAnnotation a = constr.getAnnotation(ann); // 1
					                 ^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Annotation to MyAnnotation
				----------
				5. WARNING in Y.java (at line 17)
					void bar2(MyConstructor constr, Class<MyAnnotation> ann) {
					          ^^^^^^^^^^^^^
				MyConstructor is a raw type. References to generic type MyConstructor<V> should be parameterized
				----------
				6. WARNING in Y.java (at line 18)
					MyAnnotation a = constr.getAnnotation(ann); // 2
					                 ^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: The method getAnnotation(Class) belongs to the raw type MyConstructor. References to generic type MyConstructor<V> should be parameterized
				----------
				7. ERROR in Y.java (at line 18)
					MyAnnotation a = constr.getAnnotation(ann); // 2
					                 ^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Annotation to MyAnnotation
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=226145
public void test1309() {
	this.runNegativeTest(
			new String[] {
					"EclipseGenericBug.java",
					"""
						public class EclipseGenericBug {
						  static class ParametricClass<T> {
						    static interface NonParametricInterface {
						      static interface ParametricInterface<S> {
						      }
						    }
						  }
						 \s
						  static class ParametricInstance<T> extends ParametricClass<T> {
						    NonParametricInterface.ParametricInterface<T> instance = null;
						  }
						}
						""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=224855
public void test1310() {
	this.runNegativeTest(
			new String[] {
					"X.java",
					"""
						import java.util.Set;
						public class X {
							public void testCast(){
								Set<Class> classes = (Set<Class>)getClasses();
							}
							public Set<Class<? extends Object>> getClasses() {
								return null;
							}
						}
						""", // =================
			},
			"""
				----------
				1. WARNING in X.java (at line 4)
					Set<Class> classes = (Set<Class>)getClasses();
					    ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				2. ERROR in X.java (at line 4)
					Set<Class> classes = (Set<Class>)getClasses();
					                     ^^^^^^^^^^^^^^^^^^^^^^^^
				Cannot cast from Set<Class<? extends Object>> to Set<Class>
				----------
				3. WARNING in X.java (at line 4)
					Set<Class> classes = (Set<Class>)getClasses();
					                          ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=209149
public void test1311() {
	String[] test = new String[] {
		"X.java",
		"class X<E, D extends E> {}\n" +
		"class Y<E extends D, D> {}"
	};
	if (this.complianceLevel < ClassFileConstants.JDK1_7) {
		this.runNegativeTest(
			test,
			"""
				----------
				1. ERROR in X.java (at line 2)
					class Y<E extends D, D> {}
					        ^
				Illegal forward reference to type parameter D
				----------
				""");
	} else {
		this.runConformTest(test, "");
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=226535
public void test1312() {
	this.runConformTest(
			new String[] {
					"X.java",
					"""
						 class Tuple3f<T extends Tuple3f<T>> {
							private float x, y, z;
							float getX() { return this.x; }
							float getY() { return this.y; }
							float getZ() { return this.z; }
							void set(float newX, float newY, float newZ) {
								this.x = newX;
								this.y = newY;
								this.z = newZ;
							}
							public T add(Tuple3f<?> t) {
								this.set(this.getX() + t.getX(), this.getY() + t.getY(), this.getZ() + t.getZ());
								@SuppressWarnings("unchecked")
								T result = (T) this;
								return result;
							}
						}
						
						class Vector3f extends Tuple3f<Vector3f> {
							float magnitude () {
								float x = this.getX(), y = this.getY(), z = this.getZ();
								return (float) Math.sqrt((x*x) + (y*y) + (z*z));
							}
						}
						
						public class X {
							public static void main(String[] args) {
								Vector3f v = new Vector3f();
								float magn = v.add(v).add(v).magnitude();
								System.out.println((int)magn);
							}
						}
						""", // =================
			},
			"0");
}
public void test1313() {
	this.runNegativeTest(
			new String[] {
					"X.java",
					"""
						import java.util.*;
						
						public class X {
							public static void main(String[] args) {
								List<?>[] l1 = new List<?>[1];
								List<?>[] l2 = new List<? extends Object>[2];
								List<? extends Object> l3 = new List<?>[3];
							}
						}
						""", // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 6)
					List<?>[] l2 = new List<? extends Object>[2];
					               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Cannot create a generic array of List<? extends Object>
				----------
				2. ERROR in X.java (at line 7)
					List<? extends Object> l3 = new List<?>[3];
					                            ^^^^^^^^^^^^^^
				Type mismatch: cannot convert from List<?>[] to List<? extends Object>
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=230070
public void test1314() {
	this.runNegativeTest(
			new String[] {
					"X.java",
					"""
						class B {
						}
						class Y<K> {
							Y(K k) {
								System.out.println(k);
							}
						}
						public class X<K> {
							static final B b = new B();
							Object foo(K toKey) {
								if (false) return new Y(b);//1
								if (false) return new Y((K) b);//2
								return new Y((K) (Object) b);//3
							}
							Object bar(K toKey) {
								if (false) return new Y<K>(b);//4
								if (false) return new Y<K>((K) b);//5
								return new Y<K>((K) (Object) b);//6
							}\t
						}
						""", // =================
			},
			"""
				----------
				1. WARNING in X.java (at line 11)
					if (false) return new Y(b);//1
					           ^^^^^^^^^^^^^^^^
				Dead code
				----------
				2. WARNING in X.java (at line 11)
					if (false) return new Y(b);//1
					                  ^^^^^^^^
				Type safety: The constructor Y(Object) belongs to the raw type Y. References to generic type Y<K> should be parameterized
				----------
				3. WARNING in X.java (at line 11)
					if (false) return new Y(b);//1
					                      ^
				Y is a raw type. References to generic type Y<K> should be parameterized
				----------
				4. WARNING in X.java (at line 12)
					if (false) return new Y((K) b);//2
					           ^^^^^^^^^^^^^^^^^^^^
				Dead code
				----------
				5. WARNING in X.java (at line 12)
					if (false) return new Y((K) b);//2
					                  ^^^^^^^^^^^^
				Type safety: The constructor Y(Object) belongs to the raw type Y. References to generic type Y<K> should be parameterized
				----------
				6. WARNING in X.java (at line 12)
					if (false) return new Y((K) b);//2
					                      ^
				Y is a raw type. References to generic type Y<K> should be parameterized
				----------
				7. WARNING in X.java (at line 12)
					if (false) return new Y((K) b);//2
					                        ^^^^^
				Type safety: Unchecked cast from B to K
				----------
				8. WARNING in X.java (at line 12)
					if (false) return new Y((K) b);//2
					                        ^^^^^
				Unnecessary cast from B to K
				----------
				9. WARNING in X.java (at line 13)
					return new Y((K) (Object) b);//3
					       ^^^^^^^^^^^^^^^^^^^^^
				Type safety: The constructor Y(Object) belongs to the raw type Y. References to generic type Y<K> should be parameterized
				----------
				10. WARNING in X.java (at line 13)
					return new Y((K) (Object) b);//3
					           ^
				Y is a raw type. References to generic type Y<K> should be parameterized
				----------
				11. WARNING in X.java (at line 13)
					return new Y((K) (Object) b);//3
					             ^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Object to K
				----------
				12. WARNING in X.java (at line 13)
					return new Y((K) (Object) b);//3
					             ^^^^^^^^^^^^^^
				Unnecessary cast from Object to K
				----------
				13. WARNING in X.java (at line 13)
					return new Y((K) (Object) b);//3
					                 ^^^^^^^^^^
				Unnecessary cast from B to Object
				----------
				14. ERROR in X.java (at line 16)
					if (false) return new Y<K>(b);//4
					                  ^^^^^^^^^^^
				The constructor Y<K>(B) is undefined
				----------
				15. WARNING in X.java (at line 17)
					if (false) return new Y<K>((K) b);//5
					                           ^^^^^
				Type safety: Unchecked cast from B to K
				----------
				16. WARNING in X.java (at line 18)
					return new Y<K>((K) (Object) b);//6
					                ^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Object to K
				----------
				17. WARNING in X.java (at line 18)
					return new Y<K>((K) (Object) b);//6
					                    ^^^^^^^^^^
				Unnecessary cast from B to Object
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=228291
public void test1315() {
	this.runNegativeTest(
			new String[] {
					"X.java",
					"""
						import java.util.*;
						
						public class X<T> extends Vector<Collection<T>> {
							private static final long serialVersionUID = 1L;
							public Vector<T> cast(List<T> in) {
								return (Vector<T>) in;
							}
							public X<T> castSilly(Vector<Collection<T>> in) {
								return (X<T>) in;
							}
							public static void main(String[] args) {
								Zork z;
							}
						}
						""", // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 12)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=230466
public void test1316() {
	this.runConformTest(
			new String[] {
					"e/AbstractClass.java", // =================
					"""
						package e;
						public abstract class AbstractClass<E> {
						        protected abstract void method1();
						}
						""",
					"q/AbstractTest.java", // =================
					"""
						package q;
						import java.util.Map;
						import e.AbstractClass;
						public abstract class AbstractTest<T> {
						        protected class InnerClass extends AbstractClass<InnerClass>{
						                public void innerMethod() {
						                        System.out.println("innerMethod");
						                }
						                @Override
						                protected void method1() {
						                        System.out.println("method1");
						                }
						        }
						        protected Map<String, InnerClass> records;
						        public abstract void method();\s
						}
						""",
					"w/Test.java", // =================
					"""
						package w;
						import q.AbstractTest;
						public class Test extends AbstractTest<Test> {
						        @Override
						        public void method() {
						            // Error here
						                InnerClass inner = records.get("1");
						        }
						}
						""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=229928
public void test1317() {
	this.runNegativeTest(
			new String[] {
					"X.java", // =================
					"""
						public class X {
						        void foo(String name, String value) {}
						        <T extends M> void foo(String name, T value) {}
						
						        void foo2(String name, String value) {}
						        <T extends N<T>> void foo2(String name, T value) {}
						
						        <T extends N<T>> T foo3(String name, T value) {}
						}
						class M {}
						class N<T> {}
						
						class Test {
						        void test() {
						                new X().foo("HI", null); // correctly report error
						                new X().foo2("HI", null); // miss ambiguous error
						               \s
						                Thread t1 = foo3("HI", null);
						                Thread t2 = (Thread)foo3("HI", null);
						        }
						}
						""", // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 8)
					<T extends N<T>> T foo3(String name, T value) {}
					                   ^^^^^^^^^^^^^^^^^^^^^^^^^^
				This method must return a result of type T
				----------
				2. ERROR in X.java (at line 15)
					new X().foo("HI", null); // correctly report error
					        ^^^
				The method foo(String, String) is ambiguous for the type X
				----------
				3. ERROR in X.java (at line 16)
					new X().foo2("HI", null); // miss ambiguous error
					        ^^^^
				The method foo2(String, String) is ambiguous for the type X
				----------
				4. ERROR in X.java (at line 18)
					Thread t1 = foo3("HI", null);
					            ^^^^
				The method foo3(String, null) is undefined for the type Test
				----------
				5. ERROR in X.java (at line 19)
					Thread t2 = (Thread)foo3("HI", null);
					                    ^^^^
				The method foo3(String, null) is undefined for the type Test
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=229928 - variation
public void test1318() {
	this.runNegativeTest(
			new String[] {
					"X.java", // =================
					"""
						public class X {
						        <T extends N<T>> void foo2(String name, T value) {}
						}
						class N<T> {}
						
						class Test {
						        void test() {
						                new X().foo2("HI", null);
						                new X().<N<?>>foo2("HI", null);
						                new X().<N<? extends N<?>>>foo2("HI", null);
						        }
						}
						""", // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 9)
					new X().<N<?>>foo2("HI", null);
					              ^^^^
				Bound mismatch: The generic method foo2(String, T) of type X is not applicable for the arguments (String, null). The inferred type N<?> is not a valid substitute for the bounded parameter <T extends N<T>>
				----------
				2. ERROR in X.java (at line 10)
					new X().<N<? extends N<?>>>foo2("HI", null);
					                           ^^^^
				Bound mismatch: The generic method foo2(String, T) of type X is not applicable for the arguments (String, null). The inferred type N<? extends N<?>> is not a valid substitute for the bounded parameter <T extends N<T>>
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=229928 - variation
public void test1319() {
	this.runConformTest(
			new String[] {
					"X.java", // =================
					"""
						import java.util.List;
						public class X {
						        <T extends List<U>, U extends List<W>, W extends List<T>> void foo2(String name, U u, T t, W w) {}
						}
						
						class Test {
						        void test() {
						                new X().foo2("HI", null, null, null);
						        }
						}
						""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=229928 - variation
public void test1320() {
	this.runConformTest(
			new String[] {
					"X.java", // =================
					"""
						import java.util.List;
						public class X {
						        <T extends List<U>, U extends List<W>, W extends List<U>> void foo2(String name, U u, T t, W w) {}
						}
						
						class Test {
						        void test() {
						                new X().foo2("HI", null, null, null);
						        }
						}
						""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=229928 - variation
public void test1321() {
	this.runConformTest(
			new String[] {
					"X.java", // =================
					"""
						import java.util.List;
						public class X {
						        <T, U extends List<T>, W extends List<U>> void foo2(String name, U u, T t, W w) {}
						}
						
						class Test {
						        void test() {
						                new X().foo2("HI", null, null, null);
						        }
						}
						""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=231094
public void test1322() {
	this.runNegativeTest(
			new String[] {
					"X.java", // =================
					"""
						public class X {
							public static void main(String[] args) {
								X x = new X();
						
								/** OK: Bob.class is correct. No idea about the Thingy */
								x.doStuff(Bob.class, new Thingy());
						
								/**
								 * This line will fail when compiled with the Java 5 SDK: Test.java:25:
								 * <T>doStuff(java.lang.Class<T>,Thingy<T>) in Test cannot be applied to
								 * (java.lang.Class<Bill>,Thingy) test.doStuff(Bill.class, new
								 * Thingy()); ^ Note: Test.java uses unchecked or unsafe operations.
								 * Note: Recompile with -Xlint:unchecked for details. 1 error
								 */
								x.doStuff(Jim.class, new Thingy());
							}
							<T extends Bob> void doStuff(Class<T> klass, Thingy<T> thingy) {
							}
						}
						class Jim {}
						class Bob {}
						class Bob2 extends Bob {}
						class Thingy<T extends Bob> {}
						""", // =================
			},
			this.complianceLevel < ClassFileConstants.JDK1_8 ?
			"""
				----------
				1. WARNING in X.java (at line 6)
					x.doStuff(Bob.class, new Thingy());
					^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked invocation doStuff(Class<Bob>, Thingy) of the generic method doStuff(Class<T>, Thingy<T>) of type X
				----------
				2. WARNING in X.java (at line 6)
					x.doStuff(Bob.class, new Thingy());
					                     ^^^^^^^^^^^^
				Type safety: The expression of type Thingy needs unchecked conversion to conform to Thingy<Bob>
				----------
				3. WARNING in X.java (at line 6)
					x.doStuff(Bob.class, new Thingy());
					                         ^^^^^^
				Thingy is a raw type. References to generic type Thingy<T> should be parameterized
				----------
				4. ERROR in X.java (at line 15)
					x.doStuff(Jim.class, new Thingy());
					  ^^^^^^^
				Bound mismatch: The generic method doStuff(Class<T>, Thingy<T>) of type X is not applicable for the arguments (Class<Jim>, Thingy). The inferred type Jim is not a valid substitute for the bounded parameter <T extends Bob>
				----------
				5. WARNING in X.java (at line 15)
					x.doStuff(Jim.class, new Thingy());
					                         ^^^^^^
				Thingy is a raw type. References to generic type Thingy<T> should be parameterized
				----------
				""" :
				"""
					----------
					1. WARNING in X.java (at line 6)
						x.doStuff(Bob.class, new Thingy());
						^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
					Type safety: Unchecked invocation doStuff(Class<Bob>, Thingy) of the generic method doStuff(Class<T>, Thingy<T>) of type X
					----------
					2. WARNING in X.java (at line 6)
						x.doStuff(Bob.class, new Thingy());
						                     ^^^^^^^^^^^^
					Type safety: The expression of type Thingy needs unchecked conversion to conform to Thingy<Bob>
					----------
					3. WARNING in X.java (at line 6)
						x.doStuff(Bob.class, new Thingy());
						                         ^^^^^^
					Thingy is a raw type. References to generic type Thingy<T> should be parameterized
					----------
					4. ERROR in X.java (at line 15)
						x.doStuff(Jim.class, new Thingy());
						  ^^^^^^^
					The method doStuff(Class<T>, Thingy<T>) in the type X is not applicable for the arguments (Class<Jim>, Thingy)
					----------
					5. WARNING in X.java (at line 15)
						x.doStuff(Jim.class, new Thingy());
						                         ^^^^^^
					Thingy is a raw type. References to generic type Thingy<T> should be parameterized
					----------
					""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=231094 - variation
// FAIL ERRMSG and MISSING WARNINGS(?)
public void test1323() {
	if (this.complianceLevel >= ClassFileConstants.JDK1_8)
		return;
	this.runNegativeTest(
			new String[] {
					"X.java", // =================
					"""
						public class X {
							public static void main(String[] args) {
								X x = new X();
								x.doStuff2(Jim.class, new Thingy());
								String s = x.doStuff2(Bob2.class, new Thingy());
							}
							<T extends Bob, U extends Bob> T doStuff2(Class<T> klass, Thingy<U> thingy) { return null; }
						}
						class Jim {}
						class Bob {}
						class Bob2 extends Bob {}
						class Thingy<T extends Bob> {}
						""", // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					x.doStuff2(Jim.class, new Thingy());
					  ^^^^^^^^
				Bound mismatch: The generic method doStuff2(Class<T>, Thingy<U>) of type X is not applicable for the arguments (Class<Jim>, Thingy). The inferred type Jim is not a valid substitute for the bounded parameter <T extends Bob>
				----------
				2. WARNING in X.java (at line 4)
					x.doStuff2(Jim.class, new Thingy());
					                          ^^^^^^
				Thingy is a raw type. References to generic type Thingy<T> should be parameterized
				----------
				3. WARNING in X.java (at line 5)
					String s = x.doStuff2(Bob2.class, new Thingy());
					           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked invocation doStuff2(Class<Bob2>, Thingy) of the generic method doStuff2(Class<T>, Thingy<U>) of type X
				----------
				4. ERROR in X.java (at line 5)
					String s = x.doStuff2(Bob2.class, new Thingy());
					           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Bob2 to String
				----------
				5. WARNING in X.java (at line 5)
					String s = x.doStuff2(Bob2.class, new Thingy());
					                                  ^^^^^^^^^^^^
				Type safety: The expression of type Thingy needs unchecked conversion to conform to Thingy<Bob>
				----------
				6. WARNING in X.java (at line 5)
					String s = x.doStuff2(Bob2.class, new Thingy());
					                                      ^^^^^^
				Thingy is a raw type. References to generic type Thingy<T> should be parameterized
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=231094 - variation
public void test1324() {
	this.runNegativeTest(
			new String[] {
					"X.java", // =================
					"""
						public class X {
							public static void main(String[] args) {
								X x = new X();
						
								/** OK: Bob.class is correct. No idea about the Thingy */
								x.doStuff(Bob.class, new Thingy());
								x.doStuff(Bob.class, new Thingy<Bob>()); // second invocation is NOT unchecked
								Zork z;
							}
							<T extends Bob> T doStuff(Class<T> klass, Thingy<T> thingy) { return null; }
						}
						class Jim {}
						class Bob {}
						class Thingy<T extends Bob> {}
						""", // =================
			},
			"""
				----------
				1. WARNING in X.java (at line 6)
					x.doStuff(Bob.class, new Thingy());
					^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked invocation doStuff(Class<Bob>, Thingy) of the generic method doStuff(Class<T>, Thingy<T>) of type X
				----------
				2. WARNING in X.java (at line 6)
					x.doStuff(Bob.class, new Thingy());
					                     ^^^^^^^^^^^^
				Type safety: The expression of type Thingy needs unchecked conversion to conform to Thingy<Bob>
				----------
				3. WARNING in X.java (at line 6)
					x.doStuff(Bob.class, new Thingy());
					                         ^^^^^^
				Thingy is a raw type. References to generic type Thingy<T> should be parameterized
				----------
				4. ERROR in X.java (at line 8)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=231094 - variation
public void test1325() {
	this.runNegativeTest(
			new String[] {
					"X.java", // =================
					"""
						public class X<E> {
							<T,U> U foo(X<T> xt) {
								return null;
							}
							void bar(X x) {
								X<String> xs2 = foo(x);
							}
						}
						""", // =================
			},
			(this.complianceLevel < ClassFileConstants.JDK1_8
			?
			"""
				----------
				1. WARNING in X.java (at line 5)
					void bar(X x) {
					         ^
				X is a raw type. References to generic type X<E> should be parameterized
				----------
				2. WARNING in X.java (at line 6)
					X<String> xs2 = foo(x);
					                ^^^^^^
				Type safety: Unchecked invocation foo(X) of the generic method foo(X<T>) of type X<E>
				----------
				3. WARNING in X.java (at line 6)
					X<String> xs2 = foo(x);
					                ^^^^^^
				Type safety: The expression of type X needs unchecked conversion to conform to X<String>
				----------
				4. WARNING in X.java (at line 6)
					X<String> xs2 = foo(x);
					                    ^
				Type safety: The expression of type X needs unchecked conversion to conform to X<Object>
				----------
				"""
			: """
				----------
				1. WARNING in X.java (at line 5)
					void bar(X x) {
					         ^
				X is a raw type. References to generic type X<E> should be parameterized
				----------
				2. ERROR in X.java (at line 6)
					X<String> xs2 = foo(x);
					                ^^^^^^
				Type mismatch: cannot convert from Object to X<String>
				----------
				"""));
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=231094 - variation
public void test1326() {
	this.runNegativeTest(
			new String[] {
					"X.java", // =================
					"""
						public class X<E> {
							<T extends Thread,U> X<T> foo(X<T> xt, X<U> xt2) {
								return null;
							}
							X<E> identity() {
								return this;
							}
							void bar(X x, X<String> xs) {
								X<String> xs2 = foo(xs, x).identity();
							}
						}
						""", // =================
			},
			this.complianceLevel < ClassFileConstants.JDK1_8 ?
			"""
				----------
				1. WARNING in X.java (at line 8)
					void bar(X x, X<String> xs) {
					         ^
				X is a raw type. References to generic type X<E> should be parameterized
				----------
				2. ERROR in X.java (at line 9)
					X<String> xs2 = foo(xs, x).identity();
					                ^^^
				Bound mismatch: The generic method foo(X<T>, X<U>) of type X<E> is not applicable for the arguments (X<String>, X). The inferred type String is not a valid substitute for the bounded parameter <T extends Thread>
				----------
				""" :
				"""
					----------
					1. WARNING in X.java (at line 8)
						void bar(X x, X<String> xs) {
						         ^
					X is a raw type. References to generic type X<E> should be parameterized
					----------
					2. ERROR in X.java (at line 9)
						X<String> xs2 = foo(xs, x).identity();
						                ^^^
					The method foo(X<T>, X<U>) in the type X<E> is not applicable for the arguments (X<String>, X)
					----------
					""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=231094 - variation
public void test1327() {
	this.runNegativeTest(
			new String[] {
					"X.java", // =================
					"""
						public class X<E> {
							<T,U> X<Object> foo(X<T> xt, X<U> xt2) {
								return null;
							}
							X<E> identity() {
								return this;
							}
							void bar(X x, X<String> xs) {
								X<String> xs2 = foo(x, xs).identity();
							}
						}
						""", // =================
			},
			"""
				----------
				1. WARNING in X.java (at line 8)
					void bar(X x, X<String> xs) {
					         ^
				X is a raw type. References to generic type X<E> should be parameterized
				----------
				2. WARNING in X.java (at line 9)
					X<String> xs2 = foo(x, xs).identity();
					                ^^^^^^^^^^
				Type safety: Unchecked invocation foo(X, X<String>) of the generic method foo(X<T>, X<U>) of type X<E>
				----------
				3. WARNING in X.java (at line 9)
					X<String> xs2 = foo(x, xs).identity();
					                ^^^^^^^^^^^^^^^^^^^^^
				Type safety: The expression of type X needs unchecked conversion to conform to X<String>
				----------
				4. WARNING in X.java (at line 9)
					X<String> xs2 = foo(x, xs).identity();
					                    ^
				Type safety: The expression of type X needs unchecked conversion to conform to X<Object>
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=231094 - variation
public void test1328() {
	this.runNegativeTest(
			new String[] {
					"X.java", // =================
					"""
						import java.util.List;
						
						public class X {
						\t
							void bar(List<B> lb, List<C> lc) {
								String s = foo(lb, lc);
							}
							<U extends A> U foo(List<? extends U> u, List<? extends U> v) { return null; }
						}
						class A {}
						class B extends A {}
						class C extends A {}
						""", // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 6)
					String s = foo(lb, lc);
					           ^^^^^^^^^^^
				Type mismatch: cannot convert from A to String
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=232174
public void test1329() {
	this.runConformTest(
			new String[] {
					"com/b/p1/A.java", // =================
					"""
						package com.b.p1;
						public class A<K> {
						    protected final class Inner {}
						}
						""",
					"com/b/p1/ADerivedSamePkg.java", // =================
					"""
						package com.b.p1;
						import java.util.Map;
						public class ADerivedSamePkg extends A<Object> {
						    protected void someMethod() {
						        Map.Entry<String, Inner> some = null;
						        Inner x = some.getValue();
						    }
						}
						""",
					"com/b/p2/ADerivedDifferentPkg.java", // =================
					"""
						package com.b.p2;
						import java.util.Map;
						import com.b.p1.A;
						public class ADerivedDifferentPkg extends A<Object> {
						    protected void someMethod()     {
						        Map.Entry<String, Inner> some = null;
						        Inner x = some.getValue(); // <-- error in this line
						    }
						}
						""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=231861
public void test1330() {
	this.runConformTest(
			new String[] {
				"p/BaseValue.java", // =================
				"""
					package p;
					interface Value<B> {}
					public class BaseValue<B> implements Value<B> {}
					""",
				"p/Model.java", // =================
				"""
					package p;
					public class Model {
					  public java.util.Map<String, Value> map = new java.util.LinkedHashMap<String,Value>();
					}
					""", // =================
			},
			"");
	this.runConformTest(
			new String[] {
				"p2/Person.java", // =================
				"""
					package p2;
					public class Person extends p.Model {
					        void test() {
					                this.map.put("name", new p.BaseValue<String>());
					        }
					}
					""", // =================
			},
			"",
			null,
			false,
			null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=231861 - variation
public void test1331() {
	this.runConformTest(
			new String[] {
				"p/BaseValue.java", // =================
				"""
					package p;
					interface Value<B> {}
					public class BaseValue<B> implements Value<B> {}
					""",
				"p/Model.java", // =================
				"""
					package p;
					public class Model {
					  public java.util.Map<String, Value> map = new java.util.LinkedHashMap<String,Value>();
					}
					""",
				"p2/Person.java", // =================
				"""
					package p2;
					public class Person extends p.Model {
					        void test() {
					                this.map.put("name", new p.BaseValue<String>());
					        }
					}
					""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=232487
public void test1332() throws Exception {
	runConformTest(
		// test directory preparation
		new String[] { /* test files */
			"X.java",
			"""
				import java.util.*;
				
				public class X implements Runnable {
					public void run() {/**/}
					void foo() {
						  List<X> runnables = new ArrayList<X>();
						  for (Runnable r : runnables) {
							  r.run();
						  }
						  Object o = runnables.get(0);
						  Runnable r = runnables.get(1);
					}
				}\s
				""",
		},
		// runtime results
		"" /* expected output string */);
	String expectedOutput =
		"""
		  // Method descriptor #8 ()V
		  // Stack: 2, Locals: 4
		  void foo();
		     0  new java.util.ArrayList [18]
		     3  dup
		     4  invokespecial java.util.ArrayList() [20]
		     7  astore_1 [runnables]
		     8  aload_1 [runnables]
		     9  invokeinterface java.util.List.iterator() : java.util.Iterator [21] [nargs: 1]
		    14  astore_3
		    15  goto 34
		    18  aload_3
		    19  invokeinterface java.util.Iterator.next() : java.lang.Object [27] [nargs: 1]
		    24  checkcast java.lang.Runnable [5]
		    27  astore_2 [r]
		    28  aload_2 [r]
		    29  invokeinterface java.lang.Runnable.run() : void [33] [nargs: 1]
		    34  aload_3
		    35  invokeinterface java.util.Iterator.hasNext() : boolean [35] [nargs: 1]
		    40  ifne 18
		    43  aload_1 [runnables]
		    44  iconst_0
		    45  invokeinterface java.util.List.get(int) : java.lang.Object [39] [nargs: 2]
		    50  astore_2 [o]
		    51  aload_1 [runnables]
		    52  iconst_1
		    53  invokeinterface java.util.List.get(int) : java.lang.Object [39] [nargs: 2]
		    58  checkcast java.lang.Runnable [5]
		    61  astore_3 [r]
		    62  return
		      Line numbers:
		        [pc: 0, line: 6]
		        [pc: 8, line: 7]
		        [pc: 28, line: 8]
		        [pc: 34, line: 7]
		        [pc: 43, line: 10]
		        [pc: 51, line: 11]
		        [pc: 62, line: 12]
		      Local variable table:
		        [pc: 0, pc: 63] local: this index: 0 type: X
		        [pc: 8, pc: 63] local: runnables index: 1 type: java.util.List
		        [pc: 28, pc: 34] local: r index: 2 type: java.lang.Runnable
		        [pc: 51, pc: 63] local: o index: 2 type: java.lang.Object
		        [pc: 62, pc: 63] local: r index: 3 type: java.lang.Runnable
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=225737
public void test1333() {
	this.runConformTest(
			new String[] {
				"X.java", // =================
				"""
					import java.util.ArrayList;
					import java.util.List;
					public class X extends AbstractProject<X, Object> {
						public void testBug() {
							// javac compiles the following line without complaining
							BuildStepDescriptor.filter(BuildStep.PUBLISHERS, getClass());
						}
					\t
						public static void main(String[] args) {
							new X().testBug();
						}
					}
					interface BuildStep {
						public static final PublisherList PUBLISHERS = new PublisherList();
					}
					
					@SuppressWarnings("serial")
					class PublisherList extends ArrayList<Descriptor<Publisher>> {
					}
					abstract class Publisher implements BuildStep, Describable<Publisher> {
					}
					interface Describable<T extends Describable<T>> {
					}
					abstract class Descriptor<T extends Describable<T>> {
					}
					abstract class BuildStepDescriptor<T extends BuildStep & Describable<T>> extends Descriptor<T> {
					\t
						public static <T extends BuildStep & Describable<T>> List<Descriptor<T>> filter(
								List<Descriptor<T>> base,
								Class<? extends AbstractProject<?, ?>> type) {
							return null;
						}
					}
					abstract class AbstractProject<P extends AbstractProject<P, R>, R> {
					}
					""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=225737 - variation
public void test1334() {
	this.runConformTest(
			new String[] {
				"X.java", // =================
				"""
					public class X extends AbstractProject<X, Object> {
						public void testBug() {
							filter(getClass());//1
							filter(this.getClass());//2
							filter(X.class);//3
						}
						public static void filter(Class<? extends AbstractProject<?, ?>> type) {
						}
					}
					abstract class AbstractProject<P extends AbstractProject<P, R>, R> {
					}
					""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=233800
public void test1335() {
	this.runNegativeTest(
			new String[] {
				"X.java", // =================
				"""
					public class X<T> {
						public void doesNotCompile(SomeInterface i) {
							T t = ((SomeDerivedInterface<T>) i).getItem();
						}
						static interface SomeInterface {
						}
						static interface SomeDerivedInterface<T> extends SomeInterface {
							T getItem();
						}
						Zork z;
					}
					""", // =================
			},
			"""
				----------
				1. WARNING in X.java (at line 3)
					T t = ((SomeDerivedInterface<T>) i).getItem();
					      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from X.SomeInterface to X.SomeDerivedInterface<T>
				----------
				2. ERROR in X.java (at line 10)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=233800 - variation
public void test1336() {
	this.runNegativeTest(
			new String[] {
				"X.java", // =================
				"""
					public class X {
						void foo(Other2<?>.Member2<?> om2) {
							Other<String>.Member m = (Other<String>.Member) om2;
						}
					}
					class Other<T> {
						class Member {}
					}
					class Other2<T> extends Other<T> {
						class Member2<U> extends Other<U>.Member {
						}
					}
					""", // =================
			},
			"""
				----------
				1. WARNING in X.java (at line 3)
					Other<String>.Member m = (Other<String>.Member) om2;
					                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Other2<?>.Member2<capture#1-of ?> to Other<String>.Member
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=233800 - variation
public void test1337() {
	this.runNegativeTest(
			new String[] {
				"X.java", // =================
				"""
					public class X {
						void foo(Other2.Member2<?> om2) {
							Other<String>.Member m = (Other<String>.Member) om2;
						}
					}
					class Other<T> {
						class Member {}
					}
					class Other2 extends Other<X> {
						class Member2<U> extends Other<U>.Member {
						}
					}
					""", // =================
			},
			"""
				----------
				1. WARNING in X.java (at line 3)
					Other<String>.Member m = (Other<String>.Member) om2;
					                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Other2.Member2<capture#1-of ?> to Other<String>.Member
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=234619
public void test1338() {
	this.runNegativeTest(
			new String[] {
				"X.java", // =================
				"""
					public class X {
					        void m(Object someObject, Integer intObject) {
					                Exception class1 = someObject.getClass();
					                Exception class2 = intObject.getClass();
					        }
					}
					""", // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					Exception class1 = someObject.getClass();
					                   ^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Class<capture#1-of ? extends Object> to Exception
				----------
				2. ERROR in X.java (at line 4)
					Exception class2 = intObject.getClass();
					                   ^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Class<capture#2-of ? extends Integer> to Exception
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=234619 - variation
public void test1339() {
	this.runNegativeTest(
			new String[] {
				"java/lang/Object.java", // =================
				"""
					package java.lang;
					
					public class Object {
						void foo() {
							Exception e1 = getClass();
							Exception e2 = this.getClass();
						}
						public Class<?> getClass() { return null; }
					}
					""", // =================
			},
			"""
				----------
				1. ERROR in java\\lang\\Object.java (at line 5)
					Exception e1 = getClass();
					               ^^^^^^^^^^
				Type mismatch: cannot convert from Class<capture#1-of ? extends Object> to Exception
				----------
				2. ERROR in java\\lang\\Object.java (at line 6)
					Exception e2 = this.getClass();
					               ^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Class<capture#2-of ? extends Object> to Exception
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=235460
public void test1340() {
	this.runConformTest(
			new String[] {
				"Derived_A.java", // =================
				"""
					import java.util.Map;
					import java.util.HashMap;
					class Base_A {}
					public class Derived_A extends Base_A {
						public Map<Object, Base_B> getMap() {
							return new HashMap<Object, Base_B>();
						}
					}
					""", // =================
				"Derived_B.java", // =================
				"""
					class Base_B<T> {
					}
					public class Derived_B extends Base_B<Object> {
					}
					""", // =================
			},
			"");
	this.runConformTest(
			new String[] {
				"InternalCompilerError_Main.java", // =================
				"""
					public class InternalCompilerError_Main {
						public static void main(String args[]) {
							Derived_A dummy = new Derived_A();
							Derived_B propPrice = (Derived_B)dummy.getMap().get(null);	\t
						}
					}
					""", // =================
			},
			"",
			null,
			false,
			null);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=235837
public void test1341() {
	Map options = getCompilerOptions();
	options.put(JavaCore.COMPILER_PB_UNCHECKED_TYPE_OPERATION, JavaCore.IGNORE);
	this.runNegativeTest(
			new String[] {
				"X.java", // =================
				"""
					import java.util.*;
					public class X {
					  void bar() {
					    Integer i = 0;
					    Double d = 0.0;
					    foo((Collection<Number>) Arrays.asList(i, d));
					  }
					  void foo(Collection<Number> c) {}
					}
					""", // =================
			},
			"----------\n" +
			"1. ERROR in X.java (at line 6)\n" +
			"	foo((Collection<Number>) Arrays.asList(i, d));\n" +
			"	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Cannot cast from List<"+intersection("Number","Comparable<?>")+"> to Collection<Number>\n" +
			"----------\n",
			null,
			true,
			options);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=235921 - variation
public void test1342() throws Exception {
	this.runConformTest(
			new String[] {
				"X.java", // =================
				"""
					import java.util.*;
					interface Adapter<T> {
					  interface Setter<V> {}
					  public <V> Setter<V> makeSetter();
					}
					
					public class X<T> implements Adapter<T> {
					  public <V> X.Setter<V> makeSetter() {
					    return new X.Setter<V>() {};
					  }
					  void foo() {
						  List<Adapter.Setter<T>> l = new ArrayList<X.Setter<T>>();
					  }
					}
					""", // =================
			},
			"");
	// check X$1
	String expectedOutput =
		"// Signature: Ljava/lang/Object;LAdapter$Setter<TV;>;\n" +
		"class X$1 implements Adapter$Setter {\n";

	File f = new File(OUTPUT_DIR + File.separator + "X$1.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}

	// check X
	expectedOutput =
		"""
			  // Signature: <V:Ljava/lang/Object;>()LAdapter$Setter<TV;>;
			  // Stack: 3, Locals: 1
			  public Adapter.Setter makeSetter();
			""";

	f = new File(OUTPUT_DIR + File.separator + "X.class");
	classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=235921 - variation
public void test1343() throws Exception {
	this.runConformTest(
			new String[] {
				"X.java", // =================
				"""
					import java.util.*;
					class Adapter<T> {
					  class Setter<V> {}
					  public <V> Setter<V> makeSetter() { return null; }
					}
					
					public class X<T> extends Adapter<T> {
					  public <V> X<T>.Setter<V> makeSetter() {
					    return new X<T>().new Setter<V>() {};
					  }
					  void foo() {
						  List<Adapter<T>.Setter<T>> l = new ArrayList<X<T>.Setter<T>>();
					  }
					}
					""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=235921 - variation
public void test1344() throws Exception {
	this.runNegativeTest(
			new String[] {
				"X.java", // =================
				"""
					import java.util.*;
					class Adapter<T> {
					  class Setter<V> {}
					  public <V> Setter<V> makeSetter() { return null; }
					}
					
					public class X<T> extends Adapter {
					  public <V> X.Setter makeSetter() {
					    return new X().new Setter() {};
					  }
					  void foo() {
						  List<Adapter.Setter> l = new ArrayList<X.Setter>();
					  }
					}
					""", // =================
			},
			"""
				----------
				1. WARNING in X.java (at line 7)
					public class X<T> extends Adapter {
					                          ^^^^^^^
				Adapter is a raw type. References to generic type Adapter<T> should be parameterized
				----------
				2. WARNING in X.java (at line 8)
					public <V> X.Setter makeSetter() {
					           ^^^^^^^^
				Adapter.Setter is a raw type. References to generic type Adapter<T>.Setter<V> should be parameterized
				----------
				3. ERROR in X.java (at line 8)
					public <V> X.Setter makeSetter() {
					                    ^^^^^^^^^^^^
				Name clash: The method makeSetter() of type X<T> has the same erasure as makeSetter() of type Adapter but does not override it
				----------
				4. WARNING in X.java (at line 9)
					return new X().new Setter() {};
					           ^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				5. WARNING in X.java (at line 9)
					return new X().new Setter() {};
					                   ^^^^^^
				Adapter.Setter is a raw type. References to generic type Adapter<T>.Setter<V> should be parameterized
				----------
				6. WARNING in X.java (at line 12)
					List<Adapter.Setter> l = new ArrayList<X.Setter>();
					     ^^^^^^^^^^^^^^
				Adapter.Setter is a raw type. References to generic type Adapter<T>.Setter<V> should be parameterized
				----------
				7. WARNING in X.java (at line 12)
					List<Adapter.Setter> l = new ArrayList<X.Setter>();
					                                       ^^^^^^^^
				Adapter.Setter is a raw type. References to generic type Adapter<T>.Setter<V> should be parameterized
				----------
				"""
		);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=235921 - variation
public void test1345() throws Exception {
	this.runNegativeTest(
			new String[] {
				"X.java", // =================
				"""
					import java.util.*;
					class Adapter<T> {
					  class Setter<V> {}
					  public <V> Setter<V> makeSetter() { return null; }
					}
					
					public class X<T> extends Adapter {
					  public <V> X.Setter makeSetter() {
					    return (String) new X().new Setter() {};
					  }
					  void foo() {
					          List<Adapter.Setter> l = new ArrayList<X.Setter>();
					  }
					}
					""", // =================
			},
			"""
				----------
				1. WARNING in X.java (at line 7)
					public class X<T> extends Adapter {
					                          ^^^^^^^
				Adapter is a raw type. References to generic type Adapter<T> should be parameterized
				----------
				2. WARNING in X.java (at line 8)
					public <V> X.Setter makeSetter() {
					           ^^^^^^^^
				Adapter.Setter is a raw type. References to generic type Adapter<T>.Setter<V> should be parameterized
				----------
				3. ERROR in X.java (at line 8)
					public <V> X.Setter makeSetter() {
					                    ^^^^^^^^^^^^
				Name clash: The method makeSetter() of type X<T> has the same erasure as makeSetter() of type Adapter but does not override it
				----------
				4. ERROR in X.java (at line 9)
					return (String) new X().new Setter() {};
					       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Cannot cast from new Adapter.Setter(){} to String
				----------
				5. ERROR in X.java (at line 9)
					return (String) new X().new Setter() {};
					       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from String to Adapter.Setter
				----------
				6. WARNING in X.java (at line 9)
					return (String) new X().new Setter() {};
					                    ^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				7. WARNING in X.java (at line 9)
					return (String) new X().new Setter() {};
					                            ^^^^^^
				Adapter.Setter is a raw type. References to generic type Adapter<T>.Setter<V> should be parameterized
				----------
				8. WARNING in X.java (at line 12)
					List<Adapter.Setter> l = new ArrayList<X.Setter>();
					     ^^^^^^^^^^^^^^
				Adapter.Setter is a raw type. References to generic type Adapter<T>.Setter<V> should be parameterized
				----------
				9. WARNING in X.java (at line 12)
					List<Adapter.Setter> l = new ArrayList<X.Setter>();
					                                       ^^^^^^^^
				Adapter.Setter is a raw type. References to generic type Adapter<T>.Setter<V> should be parameterized
				----------
				"""
		);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=235921 - variation
public void test1346() throws Exception {
	this.runNegativeTest(
			new String[] {
				"X.java", // =================
				"""
					import java.util.*;
					class Adapter<T> {
					  class Setter<V> {}
					}
					
					public class X<T> extends Adapter {
					  public <V> Adapter.Setter makeSetter() {
					    return (X.Setter) "a";
					  }
					}
					""", // =================
			},
			"""
				----------
				1. WARNING in X.java (at line 6)
					public class X<T> extends Adapter {
					                          ^^^^^^^
				Adapter is a raw type. References to generic type Adapter<T> should be parameterized
				----------
				2. WARNING in X.java (at line 7)
					public <V> Adapter.Setter makeSetter() {
					           ^^^^^^^^^^^^^^
				Adapter.Setter is a raw type. References to generic type Adapter<T>.Setter<V> should be parameterized
				----------
				3. ERROR in X.java (at line 8)
					return (X.Setter) "a";
					       ^^^^^^^^^^^^^^
				Cannot cast from String to Adapter.Setter
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=236220
public void test1347() throws Exception {
	this.runNegativeTest(
			new String[] {
				"DeprecatedType.java", // =================
				"""
					class Base {
						class Member<U> {
					   }
					}
					
					@Deprecated
					public class DeprecatedType<T> extends Base {
					}
					""",
				"X.java", // =================
				"""
					public class X {
					  DeprecatedType.Member m1; // DeprecatedType and Member are raw + indirect access to Member
					  DeprecatedType.Member<String> m2; // DeprecatedType is raw + indirect access to Member
					  Zork z;
					}
					""", // =================
			},
			"""
				----------
				1. WARNING in X.java (at line 2)
					DeprecatedType.Member m1; // DeprecatedType and Member are raw + indirect access to Member
					^^^^^^^^^^^^^^
				The type DeprecatedType<T> is deprecated
				----------
				2. WARNING in X.java (at line 2)
					DeprecatedType.Member m1; // DeprecatedType and Member are raw + indirect access to Member
					^^^^^^^^^^^^^^^^^^^^^
				Base.Member is a raw type. References to generic type Base.Member<U> should be parameterized
				----------
				3. WARNING in X.java (at line 3)
					DeprecatedType.Member<String> m2; // DeprecatedType is raw + indirect access to Member
					^^^^^^^^^^^^^^
				The type DeprecatedType is deprecated
				----------
				4. ERROR in X.java (at line 4)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=174282 - variation
public void test1348() {
	this.runNegativeTest(
			new String[] {
				"X.java", // =================
				"""
					abstract class AbstractOBOverlaySettings extends AbstractOverlaySettings implements RefSymbolTypeSettings {/*empty*/}
					abstract class AbstractOverlaySettings implements SymbolTypeSettings {/*empty*/}
					interface DAFDataController<V> {/*empty*/}
					interface ReferenceableData {/*empty*/}
					enum SymbolTypes {/*empty*/}
					interface SymbolTypeSettings {/*empty*/}
					interface AllOverlaySettingsController {/*empty*/}
					interface DAFDataWithRefController<V extends ReferenceableData> extends DAFDataController<V> {/*empty*/}
					class OBAreaOverlaySettings extends AbstractOBOverlaySettings {/*empty*/}
					interface RefSymbolTypeSettings extends SymbolTypeSettings, ReferenceableData {/*empty*/}
					public class X {
					    public X() {
					        DAFDataController<? extends SymbolTypeSettings> controller00 = null;
					        DAFDataWithRefController<OBAreaOverlaySettings> controller01 =\s
					            (DAFDataWithRefController<OBAreaOverlaySettings>) controller00;
					    }
					    Zork z;
					}
					""", // =================
			},
			"""
				----------
				1. WARNING in X.java (at line 15)
					(DAFDataWithRefController<OBAreaOverlaySettings>) controller00;
					^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from DAFDataController<capture#1-of ? extends SymbolTypeSettings> to DAFDataWithRefController<OBAreaOverlaySettings>
				----------
				2. ERROR in X.java (at line 17)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=236707
public void test1349() {
	this.runNegativeTest(
			new String[] {
				"Scratch.java", // =================
				"""
					public class Scratch {
					        private Y rawObject = new Y();
					        public void caller() {
					                method(new X<Y<Z>>(), rawObject); // compile error in javac, unchecked conversion in Eclipse
					                this.<Y<Z>>method(new X<Y<Z>>(), rawObject); // unchecked warning in both
					        }
					        public <T> void method(X<T> x, T t) {}
					}
					class X<S> {}
					class Y<S> {}
					class Z { Zork z; }
					""", // =================
			},
			"""
				----------
				1. WARNING in Scratch.java (at line 2)
					private Y rawObject = new Y();
					        ^
				Y is a raw type. References to generic type Y<S> should be parameterized
				----------
				2. WARNING in Scratch.java (at line 2)
					private Y rawObject = new Y();
					                          ^
				Y is a raw type. References to generic type Y<S> should be parameterized
				----------
				3. WARNING in Scratch.java (at line 4)
					method(new X<Y<Z>>(), rawObject); // compile error in javac, unchecked conversion in Eclipse
					^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked invocation method(X<Y<Z>>, Y) of the generic method method(X<T>, T) of type Scratch
				----------
				4. WARNING in Scratch.java (at line 4)
					method(new X<Y<Z>>(), rawObject); // compile error in javac, unchecked conversion in Eclipse
					                      ^^^^^^^^^
				Type safety: The expression of type Y needs unchecked conversion to conform to Y<Z>
				----------
				5. WARNING in Scratch.java (at line 5)
					this.<Y<Z>>method(new X<Y<Z>>(), rawObject); // unchecked warning in both
					^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked invocation method(X<Y<Z>>, Y) of the generic method method(X<T>, T) of type Scratch
				----------
				6. WARNING in Scratch.java (at line 5)
					this.<Y<Z>>method(new X<Y<Z>>(), rawObject); // unchecked warning in both
					                                 ^^^^^^^^^
				Type safety: The expression of type Y needs unchecked conversion to conform to Y<Z>
				----------
				7. ERROR in Scratch.java (at line 11)
					class Z { Zork z; }
					          ^^^^
				Zork cannot be resolved to a type
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=238484
public void test1350() {
	this.runConformTest(
			new String[] {
				"X.java", // =================
				"""
					import java.io.IOException;
					
					interface TreeVisitor<T, U> {
						public T visit(U location);
					}
					
					interface TreeVisitable<U> {
						public <T> T visit(TreeVisitor<T, U> visitor) throws IOException;
					}
					
					abstract class Param implements TreeVisitable<Param> {
						public final Param lookforParam(final String name) {
							TreeVisitor<Param, Param> visitor = new TreeVisitor<Param, Param>() {
								public Param visit(Param location) {
									return null;
								}
							};
							return visit(visitor);
						}
					
						public abstract <T> T visit(TreeVisitor<T, Param> visitor);
					}
					
					class StructParam extends Param {
						public <T> T visit(TreeVisitor<T, Param> visitor) {
							return null;
						}
					}
					
					public class X {
						public static void main(String[] args) {
							StructParam p = new StructParam();
							p.lookforParam("abc");
							System.out.println("done");
						}
					}
					""", // =================
			},
			"done");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=238484 - variation
public void test1351() {
	this.runConformTest(
			new String[] {
				"X.java", // =================
				"""
					import java.io.IOException;
					
					interface IFoo {
						<T> T foo(T t) throws IOException;
					}
					interface JFoo {
						<T> T foo(T t) throws Exception;
					}
					abstract class Foo implements IFoo, JFoo {}
					
					public class X {
						public static void main(String[] args) {
							Foo f = createFoo();
							try {
								f.foo(null);
							} catch(IOException e) {
							}
							System.out.println("done");
						}
						static Foo createFoo() {
							return new Foo() {
								public <T> T foo(T t) {
									return t;
								}
							};
						}
					}
					""", // =================
			},
			"done");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=238484 - variation
public void test1352() {
	this.runConformTest(
			new String[] {
				"X.java", // =================
				"""
					import java.io.IOException;
					
					interface IFoo<U> {
						<T> T foo(T t) throws IOException;
					}
					interface JFoo<U> {
						<T> T foo(T t) throws Exception;
					}
					abstract class Foo implements IFoo<String>, JFoo<String> {}
					
					public class X {
						public static void main(String[] args) {
							Foo f = createFoo();
							try {
								f.foo(null);
							} catch(IOException e) {
							}
							System.out.println("done"); //dd
						}
						static Foo createFoo() {
							return new Foo() {
								public <T> T foo(T t) {
									return t;
								}
							};
						}
					}
					""", // =================
			},
			"done");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=238484 - variation
public void test1353() {
	this.runNegativeTest(
			new String[] {
				"X.java", // =================
				"""
					import java.io.IOException;
					
					interface IFoo<U> {
						<T> T foo(T t) throws IOException;
					}
					interface JFoo<U> {
						<T> T foo(T t);
					}
					abstract class Foo implements IFoo<String>, JFoo<String> {}
					
					public class X {
						public static void main(String[] args) {
							Foo f = createFoo();
							try {
								f.foo(null);
							} catch(IOException e) {
							}
							System.out.println("done"); //dd
						}
						static Foo createFoo() {
							return new Foo() {
								public <T> T foo(T t) {
									return t;
								}
							};
						}
					}
					""", // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 16)
					} catch(IOException e) {
					        ^^^^^^^^^^^
				Unreachable catch block for IOException. This exception is never thrown from the try statement body
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=237912
public void test1354() {
	this.runConformTest(
			new String[] {
				"X.java", // =================
				"""
					interface Operation<In> extends CheckedOperation<In, RuntimeException> {
					  void op(In o);
					}
					
					interface CheckedOperation<In, E extends Exception> {
					  void op(In o) throws E;
					}
					
					class ToUpper implements Operation<String> {
					  public void op(String o) {
					    System.out.print("["+o.toUpperCase()+"]");
					  }
					}
					
					public class X {
					  public static void main(String[] args) {
					    new ToUpper().op("hello world 1"); // Works
					    Operation<String> t = new ToUpper();
					    t.op("hello world 2"); // Doesn't work: Exception in thread "main" java.lang.NoSuchMethodError: Operation.op(Ljava/lang/String;)V
					  }
					}
					""", // =================
			},
			"[HELLO WORLD 1][HELLO WORLD 2]");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=237912 - variation
public void test1355() {
	this.runConformTest(
			new String[] {
				"X.java", // =================
				"""
					interface Operation<In> extends CheckedOperation<In, RuntimeException> {
					  void op(In o) throws RuntimeException;
					}
					
					interface CheckedOperation<In, E extends Exception> {
					  void op(In o) throws E;
					}
					
					class ToUpper implements Operation<String> {
					  public void op(String o) {
					    System.out.print("["+o.toUpperCase()+"]");
					  }
					}
					
					public class X {
					  public static void main(String[] args) {
					    new ToUpper().op("hello world 1"); // Works
					    Operation<String> t = new ToUpper();
					    t.op("hello world 2"); // Doesn't work: Exception in thread "main" java.lang.NoSuchMethodError: Operation.op(Ljava/lang/String;)V
					  }
					}
					""", // =================
			},
			"[HELLO WORLD 1][HELLO WORLD 2]");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=237912 - variation
public void test1356() {
	this.runConformTest(
			new String[] {
				"X.java", // =================
				"""
					class Activator {
					}
					interface Child<T> extends Parent<T> {
						Activator get(T value);
					}
					interface Parent<T> {
						Activator get(T value) throws RuntimeException;
					}
					public class X {
						static class Impl<T> implements Child<T> {
							public Activator get(T value) {
								System.out.println("done");
								return null;
							}
						}
						public static void main(String[] args) {
							Child<Boolean> c = new Impl<Boolean>();
							try {
								c.get(true);
							} catch (Throwable t) {		\t
								t.printStackTrace();
							}
						}
					}
					""", // =================
			},
			"done");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=185422
public void test1357() {
	this.runNegativeTest(
			new String[] {
				"X.java", // =================
				"""
					import java.util.*;
					@interface Ann { Class<?> value(); }
					
					/**
					 * @see Private - Private is not visible here
					 */
					@Ann(X.Private.class) // Private is not visible here
					public abstract class X implements Map<X.Private,Secondary.SecondaryPrivate> {
						/**
					 * @see Private - Private is visible here
						 */
						private static interface Private {}
						Private field;
					}
					class Secondary {
						private static interface SecondaryPrivate {}
					}
					""", // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 8)
					public abstract class X implements Map<X.Private,Secondary.SecondaryPrivate> {
					                                       ^^^^^^^^^
				The type X.Private is not visible
				----------
				2. ERROR in X.java (at line 8)
					public abstract class X implements Map<X.Private,Secondary.SecondaryPrivate> {
					                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^
				The type Secondary.SecondaryPrivate is not visible
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=185422 - variation
public void test1358() {
	this.runNegativeTest(
			new String[] {
				"X.java", // =================
				"""
					import java.util.List;
					public abstract class X implements List<X.Inter.Private> {
						/**
						 * @see Inter.Private - Private is visible here
						 */
						class Inter {
							private class Private {}
						}
						Inter.Private field;
					}
					""", // =================
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					public abstract class X implements List<X.Inter.Private> {
					                                        ^^^^^^^^^^^^^^^
				The type X.Inter.Private is not visible
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=185422 - variation
public void test1359() {
	this.runConformTest(
			new String[] {
				"X.java", // =================
				"""
					public class X<T> {
						class M1 <U>{
							private class Private<U> {
							}
						}
						void foo() {
							M1<String>.Private<?> p;
						}
					}
					""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=239118
public void test1360() {
	this.runConformTest(
			new String[] {
				"X.java", // =================
				"""
					public class X {
					    public static <T> T getValue(final Object bean, final String property) {
					        return (T)new Object();
					    }
					    public void testGenerics() {
					        int value = getValue(new Object(), "");
					    }
					}
					""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=239118 - variation
public void test1361() {
	this.runConformTest(
			new String[] {
				"X.java", // =================
				"""
					public class X {
					    public static <T> T getValue(T t) {
					        return t;
					    }
					    public void testGenerics() {
					        int value = getValue(0);
					    }
					}
					""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=239118 - variation
public void test1362() {
	this.runConformTest(
			new String[] {
				"X.java", // =================
				"""
					public class X {
					    public static <T> T getValue(T t1, T t2) {
					        return t1;
					    }
					    public void testGenerics() {
					        getValue(0, this);
					    }
					}
					""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=239118 - variation
public void test1363() {
	this.runNegativeTest(
			new String[] {
				"X.java", // =================
				"""
					public class X {
					    public static <T> T getValue(T t1, T t2) {
					        return t1;
					    }
					
					    public void testGenerics(Comparable<String> s) {
					        int i = getValue(0, s);
					    }
					}
					""", // =================
			},
			"----------\n" +
			"1. ERROR in X.java (at line 7)\n" +
			"	int i = getValue(0, s);\n" +
			"	        ^^^^^^^^^^^^^^\n" +
			"Type mismatch: cannot convert from Comparable<capture#1-of ? extends "+intersection("Object","Comparable<?>","Serializable")+"> to int\n" +
			"----------\n");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=239225
public void test1364() {
	this.runNegativeTest(
			new String[] {
				"Status.java", // =================
				"""
					import java.util.HashMap;
					import java.util.Map;
					
					public enum Status {
						GOOD((byte) 0x00), BAD((byte) 0x02);
					
						private static Map<Byte, Status> mapping;
					
						private Status(final byte newValue) {
					
							if (Status.mapping == null) {
								Status.mapping = new HashMap<Byte, Status>();
							}
					
							Status.mapping.put(newValue, this);
						}
					}
					""", // =================
			},
			"""
				----------
				1. ERROR in Status.java (at line 11)
					if (Status.mapping == null) {
					           ^^^^^^^
				Cannot refer to the static enum field Status.mapping within an initializer
				----------
				2. ERROR in Status.java (at line 12)
					Status.mapping = new HashMap<Byte, Status>();
					       ^^^^^^^
				Cannot refer to the static enum field Status.mapping within an initializer
				----------
				3. ERROR in Status.java (at line 15)
					Status.mapping.put(newValue, this);
					       ^^^^^^^
				Cannot refer to the static enum field Status.mapping within an initializer
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=239203
public void test1365() {
	this.runConformTest(
			new String[] {
				"C.java", // =================
				"""
					class A<I extends B> {
					}
					
					class B {
					}
					
					public class C {
						<U extends B, V extends A<U>> A<U> foo(Class<V> clazz) {
							A<U> ret = bar("bla");
							return ret;
						}
					
						<U extends B, V extends A<U>> A<U> bar(String clazzName) {
							return null;
						}
					}
					""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=239758
public void test1366() {
	this.runConformTest(
			new String[] {
				"X.java", // =================
				"""
					import java.io.IOException;
					
					interface IServiceAction<Response, Request, Fault extends Exception> {
						Response execute(Request parameter) throws Fault;
					}
					
					interface IServiceOperation<Response, Request, Fault extends Exception> extends IServiceAction<Response, Request, Fault> {
						Response execute(Request parameter) throws Fault;
					}
					
					public class X {
						public String execute(String parameter) throws IOException {
							return serviceOperation.execute(parameter);
						}
					
						private final IServiceOperation<String, String, IOException> serviceOperation = null;
					}
					""", // =================
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=239439
public void test1367() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					public class X {
						private static Map<String, String> var;
						static {
							var= new HashMap<String, String>();
						}
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					private static Map<String, String> var;
					               ^^^
				Map cannot be resolved to a type
				----------
				2. ERROR in X.java (at line 4)
					var= new HashMap<String, String>();
					^^^
				Map cannot be resolved to a type
				----------
				3. ERROR in X.java (at line 4)
					var= new HashMap<String, String>();
					         ^^^^^^^
				HashMap cannot be resolved to a type
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=244164
public void test1368() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					import java.util.HashMap;
					import java.util.Map;
					public class X {
						private static Map<String, Zork> map = new HashMap<String, X>();
						public static X foo(String s) {
							return map.get(s);
						}
					}""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					private static Map<String, Zork> map = new HashMap<String, X>();
					                           ^^^^
				Zork cannot be resolved to a type
				----------
				2. ERROR in X.java (at line 6)
					return map.get(s);
					       ^^^
				Zork cannot be resolved to a type
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=244164
public void test1369() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					class X {
						A<E> a; // E is undefined on purpose
						X() { a = new A<E>(); } // causes Missing code implementation
					}""",
				"A.java",
				"class A<E> {}",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. ERROR in X.java (at line 2)
					A<E> a; // E is undefined on purpose
					  ^
				E cannot be resolved to a type
				----------
				2. ERROR in X.java (at line 3)
					X() { a = new A<E>(); } // causes Missing code implementation
					      ^
				E cannot be resolved to a type
				----------
				3. ERROR in X.java (at line 3)
					X() { a = new A<E>(); } // causes Missing code implementation
					                ^
				E cannot be resolved to a type
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=242448
public void test1370() {
	this.runConformTest(
			new String[] {
				"restricted/NonPublicInterface.java", //-----------------------------------------------------------------------
				"package restricted;\n" +
				"interface NonPublicInterface {}\n",
				"restricted/NonPublicInterfaceImplementor.java", //-----------------------------------------------------------------------
				"""
					package restricted;
					public class NonPublicInterfaceImplementor<E> implements NonPublicInterface {
					    public NonPublicInterfaceImplementor<E> selfCall() {
					        return this;
					    }
					}
					""",
				"restricted/UnuseableOutsideRestrictedWithECJ.java", //-----------------------------------------------------------------------
				"""
					package restricted;
					public class UnuseableOutsideRestrictedWithECJ {
					    public void ecjDoesNotLikeGenericizedParameter(NonPublicInterface notVisible) { }
					}
					""",
				"usesrestricted/CannotCompileInEcj.java", //-----------------------------------------------------------------------
				"""
					package usesrestricted;
					import restricted.UnuseableOutsideRestrictedWithECJ;
					import restricted.NonPublicInterfaceImplementor;
					public class CannotCompileInEcj {
					    public static void main(String[] args) {
					        new UnuseableOutsideRestrictedWithECJ().ecjDoesNotLikeGenericizedParameter(new NonPublicInterfaceImplementor().selfCall());
					    }
					}
					""",//-----------------------------------------------------------------------
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=242448 - variation
public void test1371() {
	this.runConformTest(
			new String[] {
				"restricted/NonPublicInterface.java", //-----------------------------------------------------------------------
				"package restricted;\n" +
				"interface NonPublicInterface {}\n",
				"restricted/NonPublicInterfaceImplementor.java", //-----------------------------------------------------------------------
				"""
					package restricted;
					public class NonPublicInterfaceImplementor<E extends NonPublicInterface> implements NonPublicInterface {
					    public E selfCall() {
					        return null;
					    }
					}
					""",
				"restricted/UnuseableOutsideRestrictedWithECJ.java", //-----------------------------------------------------------------------
				"""
					package restricted;
					public class UnuseableOutsideRestrictedWithECJ {
					    public void ecjDoesNotLikeGenericizedParameter(NonPublicInterface notVisible) { }
					}
					""",
				"usesrestricted/CannotCompileInEcj.java", //-----------------------------------------------------------------------
				"""
					package usesrestricted;
					import restricted.UnuseableOutsideRestrictedWithECJ;
					import restricted.NonPublicInterfaceImplementor;
					public class CannotCompileInEcj {
					    public static void main(String[] args) {
					        new UnuseableOutsideRestrictedWithECJ().ecjDoesNotLikeGenericizedParameter(new NonPublicInterfaceImplementor().selfCall());
					    }
					}
					""",//-----------------------------------------------------------------------
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=242448 - variation
public void test1372() {
	this.runConformTest(
			new String[] {
				"restricted/NonPublicInterface.java", //-----------------------------------------------------------------------
				"package restricted;\n" +
				"interface NonPublicInterface {}\n",
				"restricted/NonPublicInterfaceImplementor.java", //-----------------------------------------------------------------------
				"""
					package restricted;
					public class NonPublicInterfaceImplementor<E extends NonPublicInterfaceImplementor> implements NonPublicInterface {
					    public E selfCall() {
					        return null;
					    }
					}
					""",
				"restricted/UnuseableOutsideRestrictedWithECJ.java", //-----------------------------------------------------------------------
				"""
					package restricted;
					public class UnuseableOutsideRestrictedWithECJ {
					    public void ecjDoesNotLikeGenericizedParameter(NonPublicInterface notVisible) { }
					}
					""",
				"usesrestricted/CannotCompileInEcj.java", //-----------------------------------------------------------------------
				"""
					package usesrestricted;
					import restricted.UnuseableOutsideRestrictedWithECJ;
					import restricted.NonPublicInterfaceImplementor;
					public class CannotCompileInEcj {
					    public static void main(String[] args) {
					        new UnuseableOutsideRestrictedWithECJ().ecjDoesNotLikeGenericizedParameter(new NonPublicInterfaceImplementor().selfCall());
					    }
					}
					""",//-----------------------------------------------------------------------
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=242448 - variation
public void test1373() {
	this.runConformTest(
			new String[] {
				"restricted/NonPublicInterface.java", //-----------------------------------------------------------------------
				"package restricted;\n" +
				"interface NonPublicInterface {}\n",
				"restricted/NonPublicInterfaceImplementor.java", //-----------------------------------------------------------------------
				"""
					package restricted;
					public class NonPublicInterfaceImplementor<E> implements NonPublicInterface {
					    public NonPublicInterfaceImplementor<E> next;
					}
					""",
				"restricted/UnuseableOutsideRestrictedWithECJ.java", //-----------------------------------------------------------------------
				"""
					package restricted;
					public class UnuseableOutsideRestrictedWithECJ {
					    public void ecjDoesNotLikeGenericizedParameter(NonPublicInterface notVisible) { }
					}
					""",
				"usesrestricted/CannotCompileInEcj.java", //-----------------------------------------------------------------------
				"""
					package usesrestricted;
					import restricted.UnuseableOutsideRestrictedWithECJ;
					import restricted.NonPublicInterfaceImplementor;
					public class CannotCompileInEcj {
					    public static void main(String[] args) {
					        new UnuseableOutsideRestrictedWithECJ().ecjDoesNotLikeGenericizedParameter(new NonPublicInterfaceImplementor().next);
					    }
					}
					""",//-----------------------------------------------------------------------
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=242448 - variation
public void test1374() {
	this.runConformTest(
			new String[] {
				"restricted/NonPublicInterface.java", //-----------------------------------------------------------------------
				"package restricted;\n" +
				"interface NonPublicInterface {}\n",
				"restricted/NonPublicInterfaceImplementor.java", //-----------------------------------------------------------------------
				"""
					package restricted;
					public class NonPublicInterfaceImplementor<E> implements NonPublicInterface {
					    public NonPublicInterfaceImplementor<E> next;
					}
					""",
				"restricted/UnuseableOutsideRestrictedWithECJ.java", //-----------------------------------------------------------------------
				"""
					package restricted;
					public class UnuseableOutsideRestrictedWithECJ {
					    public void ecjDoesNotLikeGenericizedParameter(NonPublicInterface notVisible) { }
					}
					""",
				"usesrestricted/CannotCompileInEcj.java", //-----------------------------------------------------------------------
				"""
					package usesrestricted;
					import restricted.UnuseableOutsideRestrictedWithECJ;
					import restricted.NonPublicInterfaceImplementor;
					public class CannotCompileInEcj {
					    public static void main(String[] args) {
					        NonPublicInterfaceImplementor impl = new NonPublicInterfaceImplementor();
					        new UnuseableOutsideRestrictedWithECJ().ecjDoesNotLikeGenericizedParameter(impl.next);
					    }
					}
					""",//-----------------------------------------------------------------------
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=242448 - variation
public void test1375() {
	this.runConformTest(
			new String[] {
				"restricted/NonPublicInterface.java", //-----------------------------------------------------------------------
				"package restricted;\n" +
				"interface NonPublicInterface {}\n",
				"restricted/NonPublicInterfaceImplementor.java", //-----------------------------------------------------------------------
				"""
					package restricted;
					public class NonPublicInterfaceImplementor<E> implements NonPublicInterface {
					    public NonPublicInterfaceImplementor<E> next;
					}
					""",
				"restricted/UnuseableOutsideRestrictedWithECJ.java", //-----------------------------------------------------------------------
				"""
					package restricted;
					public class UnuseableOutsideRestrictedWithECJ {
					    public void ecjDoesNotLikeGenericizedParameter(NonPublicInterface notVisible) { }
					}
					""",
				"usesrestricted/CannotCompileInEcj.java", //-----------------------------------------------------------------------
				"""
					package usesrestricted;
					import restricted.UnuseableOutsideRestrictedWithECJ;
					import restricted.NonPublicInterfaceImplementor;
					public class CannotCompileInEcj {
					    public static void main(String[] args) {
					        NonPublicInterfaceImplementor impl = new NonPublicInterfaceImplementor();
					        new UnuseableOutsideRestrictedWithECJ().ecjDoesNotLikeGenericizedParameter(impl.next.next);
					    }
					}
					""",//-----------------------------------------------------------------------
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=242448 - variation
public void test1376() {
	this.runConformTest(
			new String[] {
				"restricted/NonPublicInterface.java", //-----------------------------------------------------------------------
				"package restricted;\n" +
				"interface NonPublicInterface {}\n",
				"restricted/NonPublicInterfaceImplementor.java", //-----------------------------------------------------------------------
				"package restricted;\n" +
				"public class NonPublicInterfaceImplementor<E> implements NonPublicInterface {}\n",
				"restricted/UnuseableOutsideRestrictedWithECJ.java", //-----------------------------------------------------------------------
				"""
					package restricted;
					public class UnuseableOutsideRestrictedWithECJ {
					    public void ecjDoesNotLikeGenericizedParameter(NonPublicInterface notVisible) { }
					}
					""",
				"usesrestricted/CannotCompileInEcj.java", //-----------------------------------------------------------------------
				"""
					package usesrestricted;
					import restricted.UnuseableOutsideRestrictedWithECJ;
					import restricted.NonPublicInterfaceImplementor;
					public class CannotCompileInEcj<E> {
					    public NonPublicInterfaceImplementor<E> next;
					    public void foo() {
					        new UnuseableOutsideRestrictedWithECJ().ecjDoesNotLikeGenericizedParameter(next);
					    }
					}
					""",//-----------------------------------------------------------------------
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=245453
public void test1377() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					import java.rmi.RemoteException;
					public class X {
					        private static <T extends Exception> T foo() throws T {
					                throw (T) new InterruptedException();
					        }
					        private static void foo2() {
					                try {
					                        RemoteException ex = foo();
					                } catch (RemoteException e) {
					                        e.printStackTrace();
					                }
					        }
					        public static void main( String[] args) {
					               foo2();
								Zork z;
					        }
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. WARNING in X.java (at line 4)
					throw (T) new InterruptedException();
					      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from InterruptedException to T
				----------
				2. ERROR in X.java (at line 15)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=241502
public void test1378() {
	this.runConformTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					//the remote-usable interface
					class RemoteException extends Throwable {}
					\t
					interface RemoteStore {
					    public abstract <P> P get(Class<P> c) throws RemoteException;
					}
					
					//the interface for local use
					interface Store extends RemoteStore{
					    public <P> P get(Class<P> c) ;
					}
					
					//the implementation
					class StoreImpl implements Store {
					    public <P> P get(Class<P> c) {
					        System.out.print("[get]");
					        return null;
					    }
					}
					
					class Persistent {
					}
					
					public class X {
					public static void main(String[] args) {
					    try {
					        RemoteStore t = new StoreImpl();
					        t.get(Object.class); //works
					        t.get(Persistent.class); //works
					    } catch (RemoteException e) {
					        e.printStackTrace();
					    }
					    Store t = new StoreImpl();
					    t.get(Object.class); //works
					    t.get(Persistent.class); //NoSuchMethodError
					}\s
					}
					""",//-----------------------------------------------------------------------
			},
			"[get][get][get][get]");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=245453 - variation
public void test1379() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					import java.rmi.RemoteException;
					public class X{
					        private static <T extends Exception> T foo() {
					                return (T)new InterruptedException();
					        }
					        public static void main( String[] args) {
					            RemoteException ex = foo();
								 Zork z;
					        }
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. WARNING in X.java (at line 4)
					return (T)new InterruptedException();
					       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from InterruptedException to T
				----------
				2. ERROR in X.java (at line 8)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=174447
public void test1380() {
	this.runConformTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					public class X {
					    public static <E extends Enum<E>> void f() {
					    }
					    public static void main(String[] args) {
					      f();
					    }
					}
					""",//-----------------------------------------------------------------------
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=247953
// FIXME javac8 rejects (why?)
public void test1381()  throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends AA & p.IB> {
					T t;
					void foo() {
						this.t.baz();
					}
					public static void main(String[] args) {
						X<CC> xcc = new X<CC>();
						xcc.t = new CC();
						xcc.foo();
					}
				}
				class AA {
					void bar() {}
				}
				class CC extends AA implements p.IB {
					public void baz() {
						System.out.println("done");
					}
				}
				""",
			"p/IB.java", // =====================
			"package p;\n" +
			"interface IA {\n" + // non visible
			"	void baz();\n" +
			"}\n" +
			"public interface IB extends IA {\n" +
			"}\n",
		},
		"done");
	// check #baz() invocation declaring class is IB
	String expectedOutput =
		"""
		  // Method descriptor #10 ()V
		  // Stack: 1, Locals: 1
		  void foo();
		     0  aload_0 [this]
		     1  getfield X.t : AA [21]
		     4  checkcast p.IB [23]
		     7  invokeinterface p.IB.baz() : void [25] [nargs: 1]
		    12  return
		      Line numbers:
		        [pc: 0, line: 4]
		        [pc: 12, line: 5]
		      Local variable table:
		        [pc: 0, pc: 13] local: this index: 0 type: X
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=247953 - variation
public void test1382()  throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {
					T get() { return null; }
				\t
					void foo() {
						X<BB> xbb = new X<BB>();
						xbb.get().bar();
					}
				}
				class AA {
					void bar() {}
				}
				class BB extends AA {}
				"""
		},
		"");
	// check #bar() invocation declaring class is BB
	String expectedOutput =
		"""
		  // Method descriptor #6 ()V
		  // Stack: 2, Locals: 2
		  void foo();
		     0  new X [1]
		     3  dup
		     4  invokespecial X() [21]
		     7  astore_1 [xbb]
		     8  aload_1 [xbb]
		     9  invokevirtual X.get() : java.lang.Object [22]
		    12  checkcast BB [24]
		    15  invokevirtual BB.bar() : void [26]
		    18  return
		      Line numbers:
		        [pc: 0, line: 5]
		        [pc: 8, line: 6]
		        [pc: 18, line: 7]
		      Local variable table:
		        [pc: 0, pc: 19] local: this index: 0 type: X
		        [pc: 8, pc: 19] local: xbb index: 1 type: X
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=247953 - variation
public void test1383()  throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {
					T get() { return null; }
				\t
					void foo() {
						X<BB> xbb = new X<BB>();
						int j = xbb.get().bar;
					}
				}
				class AA {
					int bar;
				}
				class BB extends AA {}
				"""
		},
		"");
	// check #bar field read declaring class is BB
	String expectedOutput =
		"""
		  // Method descriptor #6 ()V
		  // Stack: 2, Locals: 3
		  void foo();
		     0  new X [1]
		     3  dup
		     4  invokespecial X() [21]
		     7  astore_1 [xbb]
		     8  aload_1 [xbb]
		     9  invokevirtual X.get() : java.lang.Object [22]
		    12  checkcast BB [24]
		    15  getfield BB.bar : int [26]
		    18  istore_2 [j]
		    19  return
		      Line numbers:
		        [pc: 0, line: 5]
		        [pc: 8, line: 6]
		        [pc: 19, line: 7]
		      Local variable table:
		        [pc: 0, pc: 20] local: this index: 0 type: X
		        [pc: 8, pc: 20] local: xbb index: 1 type: X
		        [pc: 19, pc: 20] local: j index: 2 type: int
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=247953 - variation
public void test1384()  throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {
					T get() { return null; }
				\t
					void foo() {
						X<BB> xbb = new X<BB>();
						xbb.get().bar = 12;
					}
				}
				class AA {
					int bar;
				}
				class BB extends AA {}
				"""
		},
		"");
	// check #bar field store declaring class is BB
	String expectedOutput =
		"""
		  // Method descriptor #6 ()V
		  // Stack: 2, Locals: 2
		  void foo();
		     0  new X [1]
		     3  dup
		     4  invokespecial X() [21]
		     7  astore_1 [xbb]
		     8  aload_1 [xbb]
		     9  invokevirtual X.get() : java.lang.Object [22]
		    12  checkcast BB [24]
		    15  bipush 12
		    17  putfield BB.bar : int [26]
		    20  return
		      Line numbers:
		        [pc: 0, line: 5]
		        [pc: 8, line: 6]
		        [pc: 20, line: 7]
		      Local variable table:
		        [pc: 0, pc: 21] local: this index: 0 type: X
		        [pc: 8, pc: 21] local: xbb index: 1 type: X
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=247953 - variation
public void test1385()  throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends AA & IB> {
					T get() { return null; }
				\t
					void foo(X<T> xt) {
						xt.get().baz();
					}
				}
				class AA {
					void bar() {}
				}
				interface IA {
					void baz();
				}
				interface IB extends IA {
				}
				"""
		},
		"");
	// check #baz() invocation declaring class is not IA
	String expectedOutput =
		"""
		  // Method descriptor #21 (LX;)V
		  // Signature: (LX<TT;>;)V
		  // Stack: 1, Locals: 2
		  void foo(X xt);
		     0  aload_1 [xt]
		     1  invokevirtual X.get() : AA [23]
		     4  checkcast IB [25]
		     7  invokeinterface IB.baz() : void [27] [nargs: 1]
		    12  return
		      Line numbers:
		        [pc: 0, line: 5]
		        [pc: 12, line: 6]
		      Local variable table:
		        [pc: 0, pc: 13] local: this index: 0 type: X
		        [pc: 0, pc: 13] local: xt index: 1 type: X
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=247953 - variation
//FIXME javac8 rejects (why?)
public void test1386()  throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends AA & p.IB> {
					T get() { return null; }
				\t
					void foo(X<T> xt) {
						xt.get().baz();
					}
				}
				class AA {
					void bar() {}
				}
				""",
			"p/IB.java", // =====================
			"""
				package p;
				interface IA {
					void baz();
				}
				public interface IB extends IA {
				}
				""",
		},
		"");
	// check #baz() invocation declaring class is not IA
	String expectedOutput =
		"""
		  // Method descriptor #21 (LX;)V
		  // Signature: (LX<TT;>;)V
		  // Stack: 1, Locals: 2
		  void foo(X xt);
		     0  aload_1 [xt]
		     1  invokevirtual X.get() : AA [23]
		     4  checkcast p.IB [25]
		     7  invokeinterface p.IB.baz() : void [27] [nargs: 1]
		    12  return
		      Line numbers:
		        [pc: 0, line: 5]
		        [pc: 12, line: 6]
		      Local variable table:
		        [pc: 0, pc: 13] local: this index: 0 type: X
		        [pc: 0, pc: 13] local: xt index: 1 type: X
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=247953 - variation
//FIXME javac8 rejects (why?)
public void test1387()  throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends AA & p.IB> {
					T t;
					void foo() {
						System.out.println(this.t.baz);
					}
					public static void main(String[] args) {
						X<CC> xcc = new X<CC>();
						xcc.t = new CC();
						xcc.foo();
					}
				}
				class AA {
					void bar() {}
				}
				class CC extends AA implements p.IB {
				}
				""",
			"p/IB.java", // =====================
			"""
				package p;
				interface IA {
					Object baz = "done";
				}
				public interface IB extends IA {
				}
				""",
		},
		"done");
	// check #baz declaring class is not IA
	String expectedOutput =
		"""
		  // Method descriptor #10 ()V
		  // Stack: 2, Locals: 1
		  void foo();
		     0  getstatic java.lang.System.out : java.io.PrintStream [21]
		     3  aload_0 [this]
		     4  getfield X.t : AA [27]
		     7  checkcast p.IB [29]
		    10  pop
		    11  getstatic p.IB.baz : java.lang.Object [31]
		    14  invokevirtual java.io.PrintStream.println(java.lang.Object) : void [35]
		    17  return
		      Line numbers:
		        [pc: 0, line: 4]
		        [pc: 17, line: 5]
		      Local variable table:
		        [pc: 0, pc: 18] local: this index: 0 type: X
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=247953 - variation
//FIXME javac8 rejects (why?)
public void test1388()  throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends AA & p.IB> {
					T t;
					void foo() {
						System.out.println(t.baz);
					}
					public static void main(String[] args) {
						X<CC> xcc = new X<CC>();
						xcc.t = new CC();
						xcc.foo();
					}
				}
				class AA {
					void bar() {}
				}
				class CC extends AA implements p.IB {
				}
				""",
			"p/IB.java", // =====================
			"""
				package p;
				interface IA {
					Object baz = "done";
				}
				public interface IB extends IA {
				}
				""",
		},
		"done");
	// check #baz declaring class is not IA
	String expectedOutput =
		"""
		  // Method descriptor #10 ()V
		  // Stack: 2, Locals: 1
		  void foo();
		     0  getstatic java.lang.System.out : java.io.PrintStream [21]
		     3  aload_0 [this]
		     4  getfield X.t : AA [27]
		     7  checkcast p.IB [29]
		    10  pop
		    11  getstatic p.IB.baz : java.lang.Object [31]
		    14  invokevirtual java.io.PrintStream.println(java.lang.Object) : void [35]
		    17  return
		      Line numbers:
		        [pc: 0, line: 4]
		        [pc: 17, line: 5]
		      Local variable table:
		        [pc: 0, pc: 18] local: this index: 0 type: X
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=247953 - variation
public void test1389()  throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X extends AA implements p.IB {
					void foo() {
						System.out.println(baz);
					}
					public static void main(String[] args) {
						new X().foo();
					}
				}
				class AA {
					void bar() {}
				}
				""",
			"p/IB.java", // =====================
			"""
				package p;
				interface IA {
					Object baz = "done";
				}
				public interface IB extends IA {
				}
				""",
		},
		"done");
	// check #baz declaring class is not IA
	String expectedOutput =
		"""
		  // Method descriptor #8 ()V
		  // Stack: 2, Locals: 1
		  void foo();
		     0  getstatic java.lang.System.out : java.io.PrintStream [17]
		     3  getstatic X.baz : java.lang.Object [23]
		     6  invokevirtual java.io.PrintStream.println(java.lang.Object) : void [27]
		     9  return
		      Line numbers:
		        [pc: 0, line: 3]
		        [pc: 9, line: 4]
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
public void test1390()  throws Exception {
	this.runNegativeTest(
		new String[] {
			"X.java", //=================================
			"""
				public class X<T extends SubX1<SubX2<T>>> {
					T sx1() { return null; }
					void foo(X<T> x0) {
						x0.sx1().sx2().t().getClass();
					}
				}
				interface X1<T extends SubX2<T>> {
					T sx2();
				}
				abstract class SubX1<T extends SubX2<T>> implements X1<T> {
				}
				interface X2<T> {
					T t();
				}
				abstract class SubX2<T> implements X2<T> {
				}
				""",
		},
		"""
			----------
			1. ERROR in X.java (at line 1)
				public class X<T extends SubX1<SubX2<T>>> {
				                               ^^^^^
			Bound mismatch: The type SubX2<T> is not a valid substitute for the bounded parameter <T extends SubX2<T>> of the type SubX1<T>
			----------
			""");
}
public void test1391()  throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends SubX2<T>> {
					T sx1() { return null; }
					void foo(X<T> x0) {
						x0.sx1().sx2().t().getClass();
					}
				}
				interface X1<T extends SubX2<T>> {
					T sx2();
				}
				abstract class SubX1<T extends SubX2<T>> implements X1<T> {
				}
				interface X2<T> {
					T t();
				}
				abstract class SubX2<T extends SubX2<T>> implements X1<T>, X2<T> {
				}
				""",
		},
		"");
	String expectedOutput =
		"""
		  // Method descriptor #21 (LX;)V
		  // Signature: (LX<TT;>;)V
		  // Stack: 1, Locals: 2
		  void foo(X x0);
		     0  aload_1 [x0]
		     1  invokevirtual X.sx1() : SubX2 [23]
		     4  invokevirtual SubX2.sx2() : SubX2 [25]
		     7  invokevirtual SubX2.t() : java.lang.Object [30]
		    10  checkcast SubX2 [26]
		    13  invokevirtual java.lang.Object.getClass() : java.lang.Class [34]
		    16  pop
		    17  return
		      Line numbers:
		        [pc: 0, line: 4]
		        [pc: 17, line: 5]
		      Local variable table:
		        [pc: 0, pc: 18] local: this index: 0 type: X
		        [pc: 0, pc: 18] local: x0 index: 1 type: X
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
public void test1392()  throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends SubX2<T>> {
					T sx1;
					void foo(X<T> x0) {
						x0.sx1.sx2.t.getClass();
					}
				}
				class X1<T extends SubX2<T>> {
					T sx2;
				}
				abstract class SubX1<T extends SubX2<T>> extends X1<T> {
				}
				class X2<T extends SubX2<T>> extends X1<T>{
					T t;
				}
				abstract class SubX2<T extends SubX2<T>> extends X2<T> {
				}
				""",
		},
		"");
	String expectedOutput =
		"""
		  // Method descriptor #21 (LX;)V
		  // Signature: (LX<TT;>;)V
		  // Stack: 1, Locals: 2
		  void foo(X x0);
		     0  aload_1 [x0]
		     1  getfield X.sx1 : SubX2 [23]
		     4  getfield SubX2.sx2 : SubX2 [25]
		     7  getfield SubX2.t : SubX2 [30]
		    10  invokevirtual java.lang.Object.getClass() : java.lang.Class [33]
		    13  pop
		    14  return
		      Line numbers:
		        [pc: 0, line: 4]
		        [pc: 14, line: 5]
		      Local variable table:
		        [pc: 0, pc: 15] local: this index: 0 type: X
		        [pc: 0, pc: 15] local: x0 index: 1 type: X
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
public void test1393()  throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends SubX2<T>> {
					T sx1;
					void foo(X<T> x0) {
						x0.sx1.sx2.t.getClass();
					}
				}
				interface X1<T extends X2<T>> {
				}
				abstract class SubX1<T extends X2<T>> implements X1<T> {
					T sx2;
				}
				interface X2<T extends X2<T>> extends X1<T>{
				}
				abstract class SubX2<T extends X2<T>> extends SubX1<T> implements X2<T> {
					T t;
				}
				""",
		},
		"");
	String expectedOutput =
		"""
		  // Method descriptor #21 (LX;)V
		  // Signature: (LX<TT;>;)V
		  // Stack: 1, Locals: 2
		  void foo(X x0);
		     0  aload_1 [x0]
		     1  getfield X.sx1 : SubX2 [23]
		     4  getfield SubX2.sx2 : X2 [25]
		     7  checkcast SubX2 [26]
		    10  getfield SubX2.t : X2 [31]
		    13  checkcast SubX2 [26]
		    16  invokevirtual java.lang.Object.getClass() : java.lang.Class [34]
		    19  pop
		    20  return
		      Line numbers:
		        [pc: 0, line: 4]
		        [pc: 20, line: 5]
		      Local variable table:
		        [pc: 0, pc: 21] local: this index: 0 type: X
		        [pc: 0, pc: 21] local: x0 index: 1 type: X
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
public void test1394()  throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends SubX2<T>> {
					T sx1(){return null;}
					void foo(X<T> x0) {
						x0.sx1().sx2().t().getClass();
					}
				}
				interface X1<T extends X2<T>> {
				}
				abstract class SubX1<T extends X2<T>> implements X1<T> {
					T sx2(){return null;}
				}
				interface X2<T extends X2<T>> extends X1<T>{
				}
				abstract class SubX2<T extends X2<T>> extends SubX1<T> implements X2<T> {
					T t(){return null;}
				}
				""",
		},
		"");
	String expectedOutput =
		"""
		  // Method descriptor #21 (LX;)V
		  // Signature: (LX<TT;>;)V
		  // Stack: 1, Locals: 2
		  void foo(X x0);
		     0  aload_1 [x0]
		     1  invokevirtual X.sx1() : SubX2 [23]
		     4  invokevirtual SubX2.sx2() : X2 [25]
		     7  checkcast SubX2 [26]
		    10  invokevirtual SubX2.t() : X2 [31]
		    13  checkcast SubX2 [26]
		    16  invokevirtual java.lang.Object.getClass() : java.lang.Class [34]
		    19  pop
		    20  return
		      Line numbers:
		        [pc: 0, line: 4]
		        [pc: 20, line: 5]
		      Local variable table:
		        [pc: 0, pc: 21] local: this index: 0 type: X
		        [pc: 0, pc: 21] local: x0 index: 1 type: X
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
public void test1395()  throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends SubX2<T>> {
					T sx1(){return null;}
					void foo() {
						this.sx1().sx2().t().getClass();
					}
				}
				interface X1<T extends X2<T>> {
				}
				abstract class SubX1<T extends X2<T>> implements X1<T> {
					T sx2(){return null;}
				}
				interface X2<T extends X2<T>> extends X1<T>{
				}
				abstract class SubX2<T extends X2<T>> extends SubX1<T> implements X2<T> {
					T t(){return null;}
				}
				""",
		},
		"");
	String expectedOutput =
		"""
		  // Method descriptor #6 ()V
		  // Stack: 1, Locals: 1
		  void foo();
		     0  aload_0 [this]
		     1  invokevirtual X.sx1() : SubX2 [21]
		     4  invokevirtual SubX2.sx2() : X2 [23]
		     7  checkcast SubX2 [24]
		    10  invokevirtual SubX2.t() : X2 [29]
		    13  checkcast SubX2 [24]
		    16  invokevirtual java.lang.Object.getClass() : java.lang.Class [32]
		    19  pop
		    20  return
		      Line numbers:
		        [pc: 0, line: 4]
		        [pc: 20, line: 5]
		      Local variable table:
		        [pc: 0, pc: 21] local: this index: 0 type: X
		      Local variable type table:
		        [pc: 0, pc: 21] local: this index: 0 type: X<T>
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
public void test1396()  throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<T extends SubX2<T>> {
					T sx1;
					void foo(T t) {
						t.sx2.t.getClass();
					}
				}
				interface X1<T extends X2<T>> {
				}
				abstract class SubX1<T extends X2<T>> implements X1<T> {
					T sx2;
				}
				interface X2<T extends X2<T>> extends X1<T>{
				}
				abstract class SubX2<T extends X2<T>> extends SubX1<T> implements X2<T> {
					T t;
				}
				""",
		},
		"");
	String expectedOutput =
		"""
		  // Method descriptor #21 (LSubX2;)V
		  // Signature: (TT;)V
		  // Stack: 1, Locals: 2
		  void foo(SubX2 t);
		     0  aload_1 [t]
		     1  getfield SubX2.sx2 : X2 [23]
		     4  checkcast SubX2 [24]
		     7  getfield SubX2.t : X2 [29]
		    10  checkcast SubX2 [24]
		    13  invokevirtual java.lang.Object.getClass() : java.lang.Class [32]
		    16  pop
		    17  return
		      Line numbers:
		        [pc: 0, line: 4]
		        [pc: 17, line: 5]
		      Local variable table:
		        [pc: 0, pc: 18] local: this index: 0 type: X
		        [pc: 0, pc: 18] local: t index: 1 type: SubX2
		""";

	File f = new File(OUTPUT_DIR + File.separator + "X.class");
	byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
	ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
	String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
	int index = result.indexOf(expectedOutput);
	if (index == -1 || expectedOutput.length() == 0) {
		System.out.println(Util.displayString(result, 3));
	}
	if (index == -1) {
		assertEquals("Wrong contents", expectedOutput, result);
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=172672
public void _test1397()  throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				class A { }
				class B<T> { }
				class C<U> extends B<B<? super C<C<U>>>> {
					B<? super C<A>> foo(C<A> c) { return c; }
				}
				""",
		},
		"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=252120
public void test1398()  throws Exception {
	this.runNegativeTest(
		new String[] {
			"A.java",
			"""
				public class A<T> {
				  void f() {
				    boolean b=null instanceof A;\s
					 Zork z;
				  }
				}
				""",
		},
		"""
			----------
			1. ERROR in A.java (at line 4)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=252120 - variation
public void test1399()  throws Exception {
	this.runNegativeTest(
		new String[] {
			"A.java",
			"""
				public class A<T> {
				  void f() {
				    boolean b=null instanceof A<?>;\s
					 Zork z;
				  }
				}
				""",
		},
		"""
			----------
			1. ERROR in A.java (at line 4)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=252120 - variation
public void test1400()  throws Exception {
	this.runNegativeTest(
		new String[] {
			"A.java",
			"""
				public class A<T> {
				  void f() {
				    Object o = (A)this;\s
					 Zork z;
				  }
				}
				""",
		},
		"""
			----------
			1. WARNING in A.java (at line 3)
				Object o = (A)this;\s
				           ^^^^^^^
			Unnecessary cast from A<T> to A
			----------
			2. WARNING in A.java (at line 3)
				Object o = (A)this;\s
				            ^
			A is a raw type. References to generic type A<T> should be parameterized
			----------
			3. ERROR in A.java (at line 4)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=252120 - variation
public void test1401()  throws Exception {
	this.runNegativeTest(
		new String[] {
			"A.java",
			"""
				public class A<T> {
				  void f() {
				    Object o = (A<?>)this;\s
					 Zork z;
				  }
				}
				""",
		},
		"""
			----------
			1. WARNING in A.java (at line 3)
				Object o = (A<?>)this;\s
				           ^^^^^^^^^^
			Unnecessary cast from A<T> to A<?>
			----------
			2. ERROR in A.java (at line 4)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=252120 - variation
public void test1402()  throws Exception {
	this.runNegativeTest(
		new String[] {
			"A.java",
			"""
				public class A<T> {
				  void f() {
				    Class<?> c = A.class;\s
					 Zork z;
				  }
				}
				""",
		},
		"""
			----------
			1. ERROR in A.java (at line 4)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=252120 - variation
public void test1403()  throws Exception {
	this.runNegativeTest(
		new String[] {
			"A.java",
			"""
				public class A<T> {
				  void f() {
				    Class<?> c = A<?>.class;\s
					 Zork z;
				  }
				}
				""",
		},
		"""
			----------
			1. ERROR in A.java (at line 3)
				Class<?> c = A<?>.class;\s
				             ^
			Syntax error on token "A", . expected after this token
			----------
			2. ERROR in A.java (at line 3)
				Class<?> c = A<?>.class;\s
				              ^^^
			Syntax error on token(s), misplaced construct(s)
			----------
			""");
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=242159
// SHOULD FAIL AT 1.8 (RET): Type mismatch: cannot convert from X<Comparable<Comparable<T>>> to X
public void test1404()  throws Exception {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<A> {
					A get() { return null; }
					<B extends Comparable<B>> X<B> bar() {
						return null;
					}
					void foo() {
						bar(); // 0 rejected
						X raw = bar(); // 1 accepted
						X<?> wild = bar(); // 2 rejected
					}
				}
				""",
		});
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=240807
public void test1405()  throws Exception {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				public class X {
				    X(List rawList, List<?> unboundList) {
				            Throwable t0 = (Throwable) Collections.emptyList();
				            Throwable t1 = (Throwable) rawList;
				            Throwable t2 = (Throwable) unboundList;
				            Map m0 = (Map) Collections.emptyList();
				            Map m1 = (Map) rawList;
				            Map m2 = (Map) unboundList;
				            Zork z;
				    }
				}
				""",
		},
		"""
			----------
			1. WARNING in X.java (at line 3)
				X(List rawList, List<?> unboundList) {
				  ^^^^
			List is a raw type. References to generic type List<E> should be parameterized
			----------
			2. WARNING in X.java (at line 7)
				Map m0 = (Map) Collections.emptyList();
				^^^
			Map is a raw type. References to generic type Map<K,V> should be parameterized
			----------
			3. WARNING in X.java (at line 7)
				Map m0 = (Map) Collections.emptyList();
				          ^^^
			Map is a raw type. References to generic type Map<K,V> should be parameterized
			----------
			4. WARNING in X.java (at line 8)
				Map m1 = (Map) rawList;
				^^^
			Map is a raw type. References to generic type Map<K,V> should be parameterized
			----------
			5. WARNING in X.java (at line 8)
				Map m1 = (Map) rawList;
				          ^^^
			Map is a raw type. References to generic type Map<K,V> should be parameterized
			----------
			6. WARNING in X.java (at line 9)
				Map m2 = (Map) unboundList;
				^^^
			Map is a raw type. References to generic type Map<K,V> should be parameterized
			----------
			7. WARNING in X.java (at line 9)
				Map m2 = (Map) unboundList;
				          ^^^
			Map is a raw type. References to generic type Map<K,V> should be parameterized
			----------
			8. ERROR in X.java (at line 10)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
public void test1406() {
	this.runNegativeTest(
			new String[] {
				"GenericTest.java", //-----------------------------------------------------------------------
				"""
					import java.util.*;
					
					public class GenericTest {
					    public static void test() {
					        Set testList = GenericTest.method1(new Class[] { ArrayList.class });
					    }
					\s
					    public static <I> I method1(Class<List>[] params) {
					        return null;
					    }
					}
					""",//-----------------------------------------------------------------------
			},
			this.complianceLevel < ClassFileConstants.JDK1_8 ?
			"""
				----------
				1. WARNING in GenericTest.java (at line 5)
					Set testList = GenericTest.method1(new Class[] { ArrayList.class });
					^^^
				Set is a raw type. References to generic type Set<E> should be parameterized
				----------
				2. WARNING in GenericTest.java (at line 5)
					Set testList = GenericTest.method1(new Class[] { ArrayList.class });
					               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked invocation method1(Class[]) of the generic method method1(Class<List>[]) of type GenericTest
				----------
				3. WARNING in GenericTest.java (at line 5)
					Set testList = GenericTest.method1(new Class[] { ArrayList.class });
					                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: The expression of type Class[] needs unchecked conversion to conform to Class<List>[]
				----------
				4. WARNING in GenericTest.java (at line 8)
					public static <I> I method1(Class<List>[] params) {
					                                  ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				""" :
				"""
					----------
					1. WARNING in GenericTest.java (at line 5)
						Set testList = GenericTest.method1(new Class[] { ArrayList.class });
						^^^
					Set is a raw type. References to generic type Set<E> should be parameterized
					----------
					2. ERROR in GenericTest.java (at line 5)
						Set testList = GenericTest.method1(new Class[] { ArrayList.class });
						               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
					Type mismatch: cannot convert from Object to Set
					----------
					3. WARNING in GenericTest.java (at line 8)
						public static <I> I method1(Class<List>[] params) {
						                                  ^^^^
					List is a raw type. References to generic type List<E> should be parameterized
					----------
					""");
}
public void test1407() {
	this.runNegativeTest(
			new String[] {
				"Foo.java", //-----------------------------------------------------------------------
				"""
					public class Foo {
						public static <I> I m1(Class<Foo> c) { return null; }
						void bar() {
							Foo l1 = m1((Class)Foo.class);
						}
					}
					""",//-----------------------------------------------------------------------
			},
			this.complianceLevel < ClassFileConstants.JDK1_8 ?
			"""
				----------
				1. WARNING in Foo.java (at line 4)
					Foo l1 = m1((Class)Foo.class);
					         ^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked invocation m1(Class) of the generic method m1(Class<Foo>) of type Foo
				----------
				2. WARNING in Foo.java (at line 4)
					Foo l1 = m1((Class)Foo.class);
					            ^^^^^^^^^^^^^^^^
				Type safety: The expression of type Class needs unchecked conversion to conform to Class<Foo>
				----------
				3. WARNING in Foo.java (at line 4)
					Foo l1 = m1((Class)Foo.class);
					             ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				""" :
				"""
					----------
					1. WARNING in Foo.java (at line 4)
						Foo l1 = m1((Class)Foo.class);
						             ^^^^^
					Class is a raw type. References to generic type Class<T> should be parameterized
					----------
					2. ERROR in Foo.java (at line 4)
						Foo l1 = m1((Class)Foo.class);
						         ^^^^^^^^^^^^^^^^^^^^
					Type mismatch: cannot convert from Object to Foo
					----------
					""");
}
public void test1408() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					import java.util.*;
					public class X {
						void foo(Collection<? extends X> i) {
							Zork z = (List<? extends X>) i;
						}
						void bar(List<? extends X> i) {
							Zork z = (ArrayList<? extends X>) i;
						}\t
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					Zork z = (List<? extends X>) i;
					^^^^
				Zork cannot be resolved to a type
				----------
				2. ERROR in X.java (at line 7)
					Zork z = (ArrayList<? extends X>) i;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
}
public void test1409() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					import java.util.*;
					public class X {
						void foo(List<X> lx, List<?> lw) {
							LinkedList<Object> lo = (LinkedList<Object>) lx;
							LinkedList<String> ls = (LinkedList<String>) lw;
						}
						void bar(List<X> lx, List<Integer> li) {
							LinkedList<? extends Object> lo = (LinkedList<? extends Object>) lx;
							LinkedList<? extends Number> ln = (LinkedList<? extends Number>) li;	\t
						}
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					LinkedList<Object> lo = (LinkedList<Object>) lx;
					                        ^^^^^^^^^^^^^^^^^^^^^^^
				Cannot cast from List<X> to LinkedList<Object>
				----------
				2. WARNING in X.java (at line 5)
					LinkedList<String> ls = (LinkedList<String>) lw;
					                        ^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from List<capture#1-of ?> to LinkedList<String>
				----------
				""");
}
public void test1410() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					interface I<T> {}
					class Y<T> implements I<T> {}
					public class X {
						I<Short>[] x = null;
						Y<? extends Number>[] y1 = (Y<? extends Number>[]) x;
						Y<? extends Number> y2 = (Y<? extends Number>) x[0];
						Y<? extends X>[] y3 = (Y<? extends X>[]) x;
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. ERROR in X.java (at line 7)
					Y<? extends X>[] y3 = (Y<? extends X>[]) x;
					                      ^^^^^^^^^^^^^^^^^^^^
				Cannot cast from I<Short>[] to Y<? extends X>[]
				----------
				""");
}
public void test1411() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					public class X<T> {
						static class Child extends X<Object> {	}
						static <U> X<U> create() {
							Child child = new Child();
							child.set(new Object());
							return (X<U>) child;
						}
						public static void main(String[] args) {
							X<Number> c = create();
							Number n = c.get();
						}
						T t;
						void set(T t) {
							this.t = t;
						}
						T get() {
							return t;
						}
						static X<Object> willWarn = new X<Object>();
						static <U> X<U> raisesTheWarning() {
							return (X<U>) willWarn;
						}
						Zork z;
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. WARNING in X.java (at line 6)
					return (X<U>) child;
					       ^^^^^^^^^^^^
				Type safety: Unchecked cast from X.Child to X<U>
				----------
				2. WARNING in X.java (at line 21)
					return (X<U>) willWarn;
					       ^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from X<Object> to X<U>
				----------
				3. ERROR in X.java (at line 23)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
}
public void test1412() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					import java.util.List;
					class A<T> {
						List<String> foo() {
							return null;
						}
					}
					class B<U> {
						A a1 = new A<U>();
						A<?> a2 = new A<U>();
					}
					class X {
						void bar() {
							B<X> bx = new B<X>();
							List<String> s1 = bx.a1.foo();
							List<String> s2 = bx.a2.foo();
							Zork z;
						}
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. WARNING in X.java (at line 8)
					A a1 = new A<U>();
					^
				A is a raw type. References to generic type A<T> should be parameterized
				----------
				2. WARNING in X.java (at line 14)
					List<String> s1 = bx.a1.foo();
					                  ^^^^^^^^^^^
				Type safety: The expression of type List needs unchecked conversion to conform to List<String>
				----------
				3. ERROR in X.java (at line 16)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
}
public void test1413() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					import java.util.*;
					public class X  {
						HashMap <String, ArrayList> m = new HashMap<String, ArrayList>();
						ArrayList <X> ax = m.get("");
						Zork z;
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. WARNING in X.java (at line 3)
					HashMap <String, ArrayList> m = new HashMap<String, ArrayList>();
					                 ^^^^^^^^^
				ArrayList is a raw type. References to generic type ArrayList<E> should be parameterized
				----------
				2. WARNING in X.java (at line 3)
					HashMap <String, ArrayList> m = new HashMap<String, ArrayList>();
					                                                    ^^^^^^^^^
				ArrayList is a raw type. References to generic type ArrayList<E> should be parameterized
				----------
				3. WARNING in X.java (at line 4)
					ArrayList <X> ax = m.get("");
					                   ^^^^^^^^^
				Type safety: The expression of type ArrayList needs unchecked conversion to conform to ArrayList<X>
				----------
				4. ERROR in X.java (at line 5)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
}
public void test1414() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					interface A<T> {}
					class B<T> {}
					public class X {
					        A<?> a = null;
					        B y = (B)a;
					        Zork z;
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. WARNING in X.java (at line 5)
					B y = (B)a;
					^
				B is a raw type. References to generic type B<T> should be parameterized
				----------
				2. WARNING in X.java (at line 5)
					B y = (B)a;
					       ^
				B is a raw type. References to generic type B<T> should be parameterized
				----------
				3. ERROR in X.java (at line 6)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
}
public void test1415() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					public class X {
					    <T, U extends T, V extends T> T foo(boolean b, U u, V v) {
					        return b ? (T) u: v;
					    }
					    Zork z;
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. ERROR in X.java (at line 5)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""");
}
public void test1416() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					interface A {}
					interface B<RELATED extends A> extends A {}
					interface C<RELATED extends A, SOURCE  extends RELATED> extends B<RELATED> {}
					interface D<RELATED extends A, SOURCE  extends B<?>> extends C<RELATED, SOURCE> {}
					interface E<RELATED extends B<?>, SOURCE  extends RELATED> extends C<RELATED, SOURCE> {}
					public class X {
						C<B<?>,C<?,?>> ok;
						C<C<?,?>,B<?>> wrong;
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					interface D<RELATED extends A, SOURCE  extends B<?>> extends C<RELATED, SOURCE> {}
					                                                                        ^^^^^^
				Bound mismatch: The type SOURCE is not a valid substitute for the bounded parameter <SOURCE extends RELATED> of the type C<RELATED,SOURCE>
				----------
				2. ERROR in X.java (at line 8)
					C<C<?,?>,B<?>> wrong;
					         ^
				Bound mismatch: The type B<?> is not a valid substitute for the bounded parameter <SOURCE extends RELATED> of the type C<RELATED,SOURCE>
				----------
				""");
}
public void test1417() {
	this.runConformTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					class XSuper {
					    protected void bar() {}
					}
					interface I {
					    void baz();
					}
					public class X extends XSuper implements I{
					    public void baz() {}
					    public static void main(String argv[]) {
					        testMethod(new X());
					        System.out.println("SUCCESS");
					    }
					    static <T extends XSuper & I, U extends T> void testMethod(U u) {
					        u.baz();
					        u.bar();
					    }
					}
					""",//-----------------------------------------------------------------------
			},
			"SUCCESS");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=257434
public void test1418() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					class Box<U extends Box<?, ?>, V extends U> {
						V value;
						Box<U, V> next;
						Box(V value) {
							this.value = value;
						}
						Box() {}
					}
					class A extends Box<A, A> {}
					class B extends Box<B, B> {}
					public class X {
						public static void main(String[] args) {
							Box<Box<A, A>, Box<A, A>> a = new Box<Box<A, A>, Box<A, A>>(new Box<A, A>(new A()));
							Box<?, ?> b = a;
							b.value.next = new Box<B, B>(new B());
							A c = a.value.next.value;
							String s = b.value;
							b.value.next.next = new Box<B, B>(new B());
						}
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. ERROR in X.java (at line 15)
					b.value.next = new Box<B, B>(new B());
					               ^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Box<B,B> to Box<capture#3-of ?,capture#4-of ?>
				----------
				2. ERROR in X.java (at line 17)
					String s = b.value;
					           ^^^^^^^
				Type mismatch: cannot convert from capture#6-of ? to String
				----------
				3. ERROR in X.java (at line 18)
					b.value.next.next = new Box<B, B>(new B());
					                    ^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Box<B,B> to Box<capture#9-of ?,capture#10-of ?>
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=257434 - variation
public void test1419() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					class Box<U extends Box<?, ?>, V extends U> {
						private V value;
						Box<U, V> next;
						Box(V value) {
							this.value = value;
						}
						Box() {}
						V getValue() { return this.value; }
					}
					class A extends Box<A, A> {}
					class B extends Box<B, B> {}
					public class X {
						public static void main(String[] args) {
							Box<Box<A, A>, Box<A, A>> a = new Box<Box<A, A>, Box<A, A>>(new Box<A, A>(new A()));
							Box<?, ?> b = a;
							b.getValue().next = new Box<B, B>(new B());
							A c = a.getValue().next.getValue();
							String s = b.getValue();
							b.getValue().next.next = new Box<B, B>(new B());
						}
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. ERROR in X.java (at line 16)
					b.getValue().next = new Box<B, B>(new B());
					                    ^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Box<B,B> to Box<capture#3-of ?,capture#4-of ?>
				----------
				2. ERROR in X.java (at line 18)
					String s = b.getValue();
					           ^^^^^^^^^^^^
				Type mismatch: cannot convert from capture#6-of ? to String
				----------
				3. ERROR in X.java (at line 19)
					b.getValue().next.next = new Box<B, B>(new B());
					                         ^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Box<B,B> to Box<capture#9-of ?,capture#10-of ?>
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=257434 - variation
public void test1420() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					class Box<U extends Box<?, ?>, V extends U> {
						V value;
						Box<U, V> next(V v) { return new Box<U,V>(v); }
						Box(V value) {
							this.value = value;
						}
						Box() {/**/}
					}
					class A extends Box<A, A> {/**/}
					class B extends Box<B, B> {/**/}
					public class X {
						public static void main(String[] args) {
							Box<Box<A, A>, Box<A, A>> a = new Box<Box<A, A>, Box<A, A>>(new Box<A, A>(new A()));
							Box<?, ?> b = a;
							b.value.next(new Box<B, B>(new B()));
							b.value.next(b.value);
						}
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. ERROR in X.java (at line 15)
					b.value.next(new Box<B, B>(new B()));
					        ^^^^
				The method next(capture#4-of ?) in the type Box<capture#3-of ?,capture#4-of ?> is not applicable for the arguments (Box<B,B>)
				----------
				2. ERROR in X.java (at line 16)
					b.value.next(b.value);
					        ^^^^
				The method next(capture#10-of ?) in the type Box<capture#9-of ?,capture#10-of ?> is not applicable for the arguments (capture#8-of ?)
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=257849
// FIXME javac8 doesn't find the error
public void test1421() {
	this.runNegativeTest(
			false /* skipJavac */,
			this.complianceLevel < ClassFileConstants.JDK1_8 ?
			null : JavacTestOptions.Excuse.JavacCompilesIncorrectSource,
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					public class X {
						public interface ID {	};
						public abstract class DomainObject<T extends ID> {};
						public interface DAO<T extends DomainObject<ID>> {	};
						public abstract class HibernateDAOBase<DomainObject> implements DAO<DomainObject<ID>> {};
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. WARNING in X.java (at line 5)
					public abstract class HibernateDAOBase<DomainObject> implements DAO<DomainObject<ID>> {};
					                                       ^^^^^^^^^^^^
				The type parameter DomainObject is hiding the type X.DomainObject<T>
				----------
				2. ERROR in X.java (at line 5)
					public abstract class HibernateDAOBase<DomainObject> implements DAO<DomainObject<ID>> {};
					                                                                    ^^^^^^^^^^^^
				The type DomainObject is not generic; it cannot be parameterized with arguments <X.ID>
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=257849 - variation
public void test1422() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					public class X {
						public interface ID {	};
						public abstract class DomainObject<T extends ID> {};
						public interface DAO<T extends DomainObject<ID>> {	};
						public abstract class HibernateDAOBase<DomainObject> implements DAO<DomainObject<ID>.Zork> {};
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. WARNING in X.java (at line 5)
					public abstract class HibernateDAOBase<DomainObject> implements DAO<DomainObject<ID>.Zork> {};
					                                       ^^^^^^^^^^^^
				The type parameter DomainObject is hiding the type X.DomainObject<T>
				----------
				2. ERROR in X.java (at line 5)
					public abstract class HibernateDAOBase<DomainObject> implements DAO<DomainObject<ID>.Zork> {};
					                                                                    ^^^^^^^^^^^^
				The type DomainObject is not generic; it cannot be parameterized with arguments <X.ID>
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=257849
public void test1423() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					public class X {
						public interface ID {	};
						public abstract class DomainObject<T extends ID> {};
						public interface DAO<T extends DomainObject<ID>> {	};
						public abstract class HibernateDAOBase<DomainObject> implements DAO<DomainObject<? extends Zork>> {};
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. WARNING in X.java (at line 5)
					public abstract class HibernateDAOBase<DomainObject> implements DAO<DomainObject<? extends Zork>> {};
					                                       ^^^^^^^^^^^^
				The type parameter DomainObject is hiding the type X.DomainObject<T>
				----------
				2. ERROR in X.java (at line 5)
					public abstract class HibernateDAOBase<DomainObject> implements DAO<DomainObject<? extends Zork>> {};
					                                                                    ^^^^^^^^^^^^
				The type DomainObject is not generic; it cannot be parameterized with arguments <? extends Zork>
				----------
				3. ERROR in X.java (at line 5)
					public abstract class HibernateDAOBase<DomainObject> implements DAO<DomainObject<? extends Zork>> {};
					                                                                                           ^^^^
				Zork cannot be resolved to a type
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=257849 - variation
public void test1424() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					public class X {
						public interface ID {	};
						public abstract class DomainObject<T extends ID> {};
						public interface DAO<T extends DomainObject<ID>> {	};
						public abstract class HibernateDAOBase<DomainObject> implements DAO<DomainObject<? extends Zork>.Zork> {};
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. WARNING in X.java (at line 5)
					public abstract class HibernateDAOBase<DomainObject> implements DAO<DomainObject<? extends Zork>.Zork> {};
					                                       ^^^^^^^^^^^^
				The type parameter DomainObject is hiding the type X.DomainObject<T>
				----------
				2. ERROR in X.java (at line 5)
					public abstract class HibernateDAOBase<DomainObject> implements DAO<DomainObject<? extends Zork>.Zork> {};
					                                                                    ^^^^^^^^^^^^
				The type DomainObject is not generic; it cannot be parameterized with arguments <? extends Zork>
				----------
				3. ERROR in X.java (at line 5)
					public abstract class HibernateDAOBase<DomainObject> implements DAO<DomainObject<? extends Zork>.Zork> {};
					                                                                                           ^^^^
				Zork cannot be resolved to a type
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=206123
public void test1425() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					public class X {
						void test() {
							B b = new C();
							Class<? extends B> cb = C.class;
						\t
							YYY<C> y = new XXX();
							Class<? extends YYY<C>> cy = XXX.class;
						\t
							YYY<? extends B> yb = new XXX();
							Class<? extends YYY<? extends B>> ybc = XXX.class;
						\t
							Class<? extends YYY> ybb = yb.getClass();
							Class<? extends YYY<?>> ybb2 = yb.getClass();
							Class<? extends YYY<? extends B>> ybb3 = yb.getClass();
						}
					}
					class Obj {}
					class B extends Obj {}
					class C extends B {}
					class ZZZ<T extends Obj> {}
					class YYY<T extends B> extends ZZZ<T> {}
					class XXX extends YYY<C> {}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. WARNING in X.java (at line 12)
					Class<? extends YYY> ybb = yb.getClass();
					                ^^^
				YYY is a raw type. References to generic type YYY<T> should be parameterized
				----------
				2. ERROR in X.java (at line 13)
					Class<? extends YYY<?>> ybb2 = yb.getClass();
					                               ^^^^^^^^^^^^^
				Type mismatch: cannot convert from Class<capture#4-of ? extends YYY> to Class<? extends YYY<?>>
				----------
				3. ERROR in X.java (at line 14)
					Class<? extends YYY<? extends B>> ybb3 = yb.getClass();
					                                         ^^^^^^^^^^^^^
				Type mismatch: cannot convert from Class<capture#6-of ? extends YYY> to Class<? extends YYY<? extends B>>
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=258039
public void test1426() {
	if (this.complianceLevel >= ClassFileConstants.JDK16)
		return;
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					import java.util.*;
					public class X {
						boolean foo() {
							return null instanceof List<Object>;
						}
						<T extends List<Object>> boolean foo2() {
							return null instanceof T;
						}
						boolean foo3() {
							return null instanceof Map<Object,String>;
						}
						<T extends Map<Object,String>> boolean foo4() {
							return null instanceof T;
						}
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. ERROR in X.java (at line 4)
					return null instanceof List<Object>;
					       ^^^^^^^^^^^^^^^^^^^^
				Cannot perform instanceof check against parameterized type List<Object>. Use the form List<?> instead since further generic type information will be erased at runtime
				----------
				2. ERROR in X.java (at line 7)
					return null instanceof T;
					       ^^^^^^^^^^^^^^^^^
				Cannot perform instanceof check against type parameter T. Use its erasure List<?> instead since further generic type information will be erased at runtime
				----------
				3. ERROR in X.java (at line 10)
					return null instanceof Map<Object,String>;
					       ^^^^^^^^^^^^^^^^^^^
				Cannot perform instanceof check against parameterized type Map<Object,String>. Use the form Map<?,?> instead since further generic type information will be erased at runtime
				----------
				4. ERROR in X.java (at line 13)
					return null instanceof T;
					       ^^^^^^^^^^^^^^^^^
				Cannot perform instanceof check against type parameter T. Use its erasure Map<?,?> instead since further generic type information will be erased at runtime
				----------
				""");
}
public void test1427() {
	String xSource =
			"""
		import java.util.List;
		public class X {
		    public <T> List<T> nil() { return null; }
		    public <T> T getHead(List<T> x) { return null; }
		    X() {
			   String s = getHead(nil());
		    }
		}
		""";
	if (this.complianceLevel < ClassFileConstants.JDK1_8) {
		this.runNegativeTest(
				new String[] {
					"X.java",
					xSource
				},
				"""
					----------
					1. ERROR in X.java (at line 6)
						String s = getHead(nil());
						           ^^^^^^^^^^^^^^
					Type mismatch: cannot convert from Object to String
					----------
					""");
	} else {
		runConformTest(
			new String[] {
				"X.java",
				xSource
			});
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=239203
public void test1428() {
	this.runConformTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					class A<I extends B> {}
					class B {}
					public class X {
						public <I extends B, C extends A<I>> A<I> foo(Class<C> clazz) {
							A<I> ret = bar("bla");
							return ret;
						}
						public <I extends B, C extends A<I>> A<I> bar(String clazzName) {
							return null;
						}
					}
					""",//-----------------------------------------------------------------------
			},
			"");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=258798
public void test1429() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					class Foo<T> {}
					public class X {
						public void test() {
							Integer i = m(new Foo<Foo<Integer>>(), new Foo());
						}
						public <T> T m(Foo<T> x, T t) {
							return t;
						}
					}
					""",//-----------------------------------------------------------------------
			},
			this.complianceLevel < ClassFileConstants.JDK1_8 ?
			"""
				----------
				1. WARNING in X.java (at line 4)
					Integer i = m(new Foo<Foo<Integer>>(), new Foo());
					            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked invocation m(Foo<Foo<Integer>>, Foo) of the generic method m(Foo<T>, T) of type X
				----------
				2. ERROR in X.java (at line 4)
					Integer i = m(new Foo<Foo<Integer>>(), new Foo());
					            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Foo to Integer
				----------
				3. WARNING in X.java (at line 4)
					Integer i = m(new Foo<Foo<Integer>>(), new Foo());
					                                       ^^^^^^^^^
				Type safety: The expression of type Foo needs unchecked conversion to conform to Foo<Integer>
				----------
				4. WARNING in X.java (at line 4)
					Integer i = m(new Foo<Foo<Integer>>(), new Foo());
					                                           ^^^
				Foo is a raw type. References to generic type Foo<T> should be parameterized
				----------
				""" :
				"""
					----------
					1. ERROR in X.java (at line 4)
						Integer i = m(new Foo<Foo<Integer>>(), new Foo());
						            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
					Type mismatch: cannot convert from Foo to Integer
					----------
					2. WARNING in X.java (at line 4)
						Integer i = m(new Foo<Foo<Integer>>(), new Foo());
						                                           ^^^
					Foo is a raw type. References to generic type Foo<T> should be parameterized
					----------
					""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=258798 - variation
public void test1430() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					class Foo<T> {}
					public class X {
					        public void test() {
					                m(new Foo<Foo<Integer>>(), new Foo());
					        }
					        public <T> void m(Foo<T> x, T t) {}
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. WARNING in X.java (at line 4)
					m(new Foo<Foo<Integer>>(), new Foo());
					^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked invocation m(Foo<Foo<Integer>>, Foo) of the generic method m(Foo<T>, T) of type X
				----------
				2. WARNING in X.java (at line 4)
					m(new Foo<Foo<Integer>>(), new Foo());
					                           ^^^^^^^^^
				Type safety: The expression of type Foo needs unchecked conversion to conform to Foo<Integer>
				----------
				3. WARNING in X.java (at line 4)
					m(new Foo<Foo<Integer>>(), new Foo());
					                               ^^^
				Foo is a raw type. References to generic type Foo<T> should be parameterized
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=258039
public void test1431()  throws Exception {
	this.runNegativeTest(
		new String[] {
			"X.java", //=================================
			"""
				public class X {
					void foo() {
						class M<T extends Number> {}
						class N extends M<String> {}
						class O implements I<String>, I<Number> {}
					}
					class MM<T extends Number> {}
					class NN extends MM<String> {}
					class OO implements I<String>, I<Number> {}
				}
				interface I<T> {}"""
		},
		"""
			----------
			1. ERROR in X.java (at line 4)
				class N extends M<String> {}
				                  ^^^^^^
			Bound mismatch: The type String is not a valid substitute for the bounded parameter <T extends Number> of the type M<T>
			----------
			2. ERROR in X.java (at line 5)
				class O implements I<String>, I<Number> {}
				      ^
			The interface I cannot be implemented more than once with different arguments: I<Number> and I<String>
			----------
			3. ERROR in X.java (at line 8)
				class NN extends MM<String> {}
				                    ^^^^^^
			Bound mismatch: The type String is not a valid substitute for the bounded parameter <T extends Number> of the type X.MM<T>
			----------
			4. ERROR in X.java (at line 9)
				class OO implements I<String>, I<Number> {}
				      ^^
			The interface I cannot be implemented more than once with different arguments: I<Number> and I<String>
			----------
			"""
	);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=258798 - variation
public void test1432() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					class Foo<T> {
						T bar(Foo<T> ft, T t) {
							return t;
						}
					}
					public class X {
						public void test() {
							Foo<Foo<Integer>> ffi = new Foo<Foo<Integer>>();
							Integer j = ffi.bar(ffi, new Foo());
						}
					}
					""",//-----------------------------------------------------------------------
			},
			"----------\n" +
			"1. ERROR in X.java (at line 9)\n" +
			"	Integer j = ffi.bar(ffi, new Foo());\n" +
			"	            ^^^^^^^^^^^^^^^^^^^^^^^\n" +
			(this.complianceLevel < ClassFileConstants.JDK1_8
			? "Type mismatch: cannot convert from Foo<Integer> to Integer\n"
			: "Type mismatch: cannot convert from Foo to Integer\n") +
			"----------\n" +
			"2. WARNING in X.java (at line 9)\n" +
			"	Integer j = ffi.bar(ffi, new Foo());\n" +
			"	                         ^^^^^^^^^\n" +
			"Type safety: The expression of type Foo needs unchecked conversion to conform to Foo<Integer>\n" +
			"----------\n" +
			"3. WARNING in X.java (at line 9)\n" +
			"	Integer j = ffi.bar(ffi, new Foo());\n" +
			"	                             ^^^\n" +
			"Foo is a raw type. References to generic type Foo<T> should be parameterized\n" +
			"----------\n");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=258798 - variation
public void test1433() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					import java.util.*;
					public class X<T> {
						Zork z;
						<U> void foo(X<U> xu) {}
						void bar(X x) {
							foo(x);
						}
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				2. WARNING in X.java (at line 5)
					void bar(X x) {
					         ^
				X is a raw type. References to generic type X<T> should be parameterized
				----------
				3. WARNING in X.java (at line 6)
					foo(x);
					^^^^^^
				Type safety: Unchecked invocation foo(X) of the generic method foo(X<U>) of type X<T>
				----------
				4. WARNING in X.java (at line 6)
					foo(x);
					    ^
				Type safety: The expression of type X needs unchecked conversion to conform to X<Object>
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=258798 - variation
public void test1434() {
	this.runNegativeTest(
			new String[] {
				"Foo.java", //-----------------------------------------------------------------------
				"""
					public class Foo {
						public static <I> I m2(Class<I> c) { return null; }\t
						void bar() {
							Foo l2 = m2((Class)Foo.class);
						}
					}
					""",//-----------------------------------------------------------------------
			},
			(this.complianceLevel < ClassFileConstants.JDK1_8 ?
			"""
				----------
				1. WARNING in Foo.java (at line 4)
					Foo l2 = m2((Class)Foo.class);
					         ^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked invocation m2(Class) of the generic method m2(Class<I>) of type Foo
				----------
				2. WARNING in Foo.java (at line 4)
					Foo l2 = m2((Class)Foo.class);
					            ^^^^^^^^^^^^^^^^
				Type safety: The expression of type Class needs unchecked conversion to conform to Class<Foo>
				----------
				3. WARNING in Foo.java (at line 4)
					Foo l2 = m2((Class)Foo.class);
					            ^^^^^^^^^^^^^^^^
				Unnecessary cast from Class<Foo> to Class
				----------
				4. WARNING in Foo.java (at line 4)
					Foo l2 = m2((Class)Foo.class);
					             ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				"""
			: """
				----------
				1. ERROR in Foo.java (at line 4)
					Foo l2 = m2((Class)Foo.class);
					         ^^^^^^^^^^^^^^^^^^^^
				Type mismatch: cannot convert from Object to Foo
				----------
				2. WARNING in Foo.java (at line 4)
					Foo l2 = m2((Class)Foo.class);
					             ^^^^^
				Class is a raw type. References to generic type Class<T> should be parameterized
				----------
				"""));
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=258798 - variation
public void test1435() {
	String xSource =
				"""
		public class X {
			<T extends Comparable<T>>	T min(T x, T y) { return x; }
		\t
			void foo(Foo f, Bar b) {
				min(f, f);
				min(b, b);
			}
		}
		abstract class Foo implements Comparable<Foo> {
		}
		abstract class Bar extends Foo {}
		""";
	if (this.complianceLevel < ClassFileConstants.JDK1_8) {
		this.runNegativeTest(
				new String[] {
					"X.java",
					xSource,
				},
				"""
					----------
					1. ERROR in X.java (at line 6)
						min(b, b);
						^^^
					Bound mismatch: The generic method min(T, T) of type X is not applicable for the arguments (Bar, Bar). The inferred type Bar is not a valid substitute for the bounded parameter <T extends Comparable<T>>
					----------
					""");
	} else {
		runConformTest(new String[]{ "X.java", xSource });
	}
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=258798 - variation
public void test1436() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					import java.util.*;
					public class X {
						<U extends List<?>, T extends Throwable> void foo(List<U> lu, T t) throws T {
							if (lu.isEmpty()) throw t;
						}
						void bar(List l, IllegalArgumentException iae) {
							try {
								foo(l, iae);
							} catch (IllegalArgumentException e) {
							}
						}
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. WARNING in X.java (at line 6)
					void bar(List l, IllegalArgumentException iae) {
					         ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				2. WARNING in X.java (at line 8)
					foo(l, iae);
					^^^^^^^^^^^
				Type safety: Unchecked invocation foo(List, IllegalArgumentException) of the generic method foo(List<U>, T) of type X
				----------
				3. WARNING in X.java (at line 8)
					foo(l, iae);
					    ^
				Type safety: The expression of type List needs unchecked conversion to conform to List<List<?>>
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=258798 - variation
public void test1437() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					import java.util.*;
					public class X {
						<U extends List<?>, T extends Throwable> X(List<U> lu, T t) throws T {
							if (lu.isEmpty()) throw t;
						}
						void bar(List l, IllegalArgumentException iae) {
							try {
								new X(l, iae);
							} catch (IllegalArgumentException e) {
							}
						}
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. WARNING in X.java (at line 6)
					void bar(List l, IllegalArgumentException iae) {
					         ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				2. WARNING in X.java (at line 8)
					new X(l, iae);
					^^^^^^^^^^^^^
				Type safety: Unchecked invocation X(List, IllegalArgumentException) of the generic constructor X(List<U>, T) of type X
				----------
				3. WARNING in X.java (at line 8)
					new X(l, iae);
					      ^
				Type safety: The expression of type List needs unchecked conversion to conform to List<List<?>>
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=258798 - variation
public void test1438() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					import java.util.*;
					public class X {
						<U extends List<?>, T extends Throwable> X(List<U> lu, T t) throws T {
							if (lu.isEmpty()) throw t;
						}
						void bar(List l, IllegalArgumentException iae) {
							try {
								new X(l, iae){};
							} catch (IllegalArgumentException e) {
							}
						}
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. WARNING in X.java (at line 6)
					void bar(List l, IllegalArgumentException iae) {
					         ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				2. WARNING in X.java (at line 8)
					new X(l, iae){};
					^^^^^^^^^^^^^^^
				Type safety: Unchecked invocation X(List, IllegalArgumentException) of the generic constructor X(List<U>, T) of type X
				----------
				3. WARNING in X.java (at line 8)
					new X(l, iae){};
					      ^
				Type safety: The expression of type List needs unchecked conversion to conform to List<List<?>>
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=258798 - variation
public void test1439() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					import java.util.*;
					public class X {
						<U extends List<?>, T extends Throwable> X(List<U> lu, T t) throws T {
							if (lu.isEmpty()) throw t;
						}
						X() {\s
							this((List) null, null);
						}
					}
					class Y extends X {
						<U extends List<?>, T extends Throwable> Y(List<U> lu, T t) {
							super((List)lu, t);
						}
					}
					""",//-----------------------------------------------------------------------
			},
			"----------\n" +
			"1. WARNING in X.java (at line 7)\n" +
			"	this((List) null, null);\n" +
			"	^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Type safety: Unchecked invocation X(List, null) of the generic constructor X(List<U>, T) of type X\n" +
			"----------\n" +
			(this.complianceLevel < ClassFileConstants.JDK1_8 ?
			"2. ERROR in X.java (at line 7)\n" +
			"	this((List) null, null);\n" +
			"	^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Unhandled exception type Throwable\n" +
			"----------\n"
			: "" // no error in 1.8 (bug GH472)
			) +
			"3. WARNING in X.java (at line 7)\n" +
			"	this((List) null, null);\n" +
			"	     ^^^^^^^^^^^\n" +
			"Type safety: The expression of type List needs unchecked conversion to conform to List<List<?>>\n" +
			"----------\n" +
			"4. WARNING in X.java (at line 7)\n" +
			"	this((List) null, null);\n" +
			"	      ^^^^\n" +
			"List is a raw type. References to generic type List<E> should be parameterized\n" +
			"----------\n" +
			"5. WARNING in X.java (at line 12)\n" +
			"	super((List)lu, t);\n" +
			"	^^^^^^^^^^^^^^^^^^^\n" +
			"Type safety: Unchecked invocation X(List, T) of the generic constructor X(List<U>, T) of type X\n" +
			"----------\n" +
			"6. ERROR in X.java (at line 12)\n" +
			"	super((List)lu, t);\n" +
			"	^^^^^^^^^^^^^^^^^^^\n" +
			"Unhandled exception type Throwable\n" +
			"----------\n" +
			"7. WARNING in X.java (at line 12)\n" +
			"	super((List)lu, t);\n" +
			"	      ^^^^^^^^\n" +
			"Type safety: The expression of type List needs unchecked conversion to conform to List<List<?>>\n" +
			"----------\n" +
			"8. WARNING in X.java (at line 12)\n" +
			"	super((List)lu, t);\n" +
			"	       ^^^^\n" +
			"List is a raw type. References to generic type List<E> should be parameterized\n" +
			"----------\n");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=260567
public void test1440() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					import java.util.*;
					interface GenricInterface<T> {}
					class NewMapType<U, V, R extends GenricInterface<U>> extends HashMap<R<U>, V> {}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. ERROR in X.java (at line 3)
					class NewMapType<U, V, R extends GenricInterface<U>> extends HashMap<R<U>, V> {}
					                                                                     ^
				The type R is not generic; it cannot be parameterized with arguments <U>
				----------
				""");
}
public void test1441() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					public class X<T> {
						void bar(T t) {}
						void foo(X<? extends String> x1, X<? extends Integer> x2) {
							(x1 != null ? x1 : x2).bar(new Object());
						}
					}
					""",//-----------------------------------------------------------------------
			},
			"----------\n" +
			"1. ERROR in X.java (at line 4)\n" +
			"	(x1 != null ? x1 : x2).bar(new Object());\n" +
			"	                       ^^^\n" +
			"The method bar(capture#4-of ? extends "+intersection("Object","Serializable","Comparable<? extends "+intersection("Object","Serializable","Comparable<?>")+">")+") in the type X<capture#4-of ? extends "+intersection("Object","Serializable","Comparable<? extends "+intersection("Object","Serializable","Comparable<?>")+">")+"> is not applicable for the arguments (Object)\n" +
			"----------\n");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=221253
public void test1442() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					public class X<T extends Comparable<T>> {
					        T[] array;
					
					        @Override public boolean equals(Object o) {
					                X<Comparable<T>> x;
					                if (array.length == ((X<Comparable<T>>) o).array.length) {
					                        return true;
					                }
					                return false;
					        }
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. ERROR in X.java (at line 5)
					X<Comparable<T>> x;
					  ^^^^^^^^^^
				Bound mismatch: The type Comparable<T> is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type X<T>
				----------
				2. WARNING in X.java (at line 6)
					if (array.length == ((X<Comparable<T>>) o).array.length) {
					                    ^^^^^^^^^^^^^^^^^^^^^^
				Type safety: Unchecked cast from Object to X<Comparable<T>>
				----------
				3. ERROR in X.java (at line 6)
					if (array.length == ((X<Comparable<T>>) o).array.length) {
					                        ^^^^^^^^^^
				Bound mismatch: The type Comparable<T> is not a valid substitute for the bounded parameter <T extends Comparable<T>> of the type X<T>
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=254627
public void test1443() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					import java.util.List;
					public class X {
					  private static class C {}
					  private static class B<T extends C> {}
					  private static class A<T extends B<? extends C>> {}
					  void bar (List<A> a) {
					    baz((List)a);
					    // Neither of these two following statements compile under javac
					    buz(a);
					    buz((List)a);
					    // Side note: the following statement is correctly identified as an error
					    // by Eclipse, but it does not suggest casting as a Quick Fix.
					    baz(a);
					  }
					  <R extends C, T extends B<R>> void baz(List<A<T>> a) {}
					  <R extends C, T extends B<R>> void buz(List a) {}
					}
					""",//-----------------------------------------------------------------------
			},
			"""
				----------
				1. WARNING in X.java (at line 6)
					void bar (List<A> a) {
					               ^
				X.A is a raw type. References to generic type X.A<T> should be parameterized
				----------
				2. WARNING in X.java (at line 7)
					baz((List)a);
					^^^^^^^^^^^^
				Type safety: Unchecked invocation baz(List) of the generic method baz(List<X.A<T>>) of type X
				----------
				3. WARNING in X.java (at line 7)
					baz((List)a);
					    ^^^^^^^
				Type safety: The expression of type List needs unchecked conversion to conform to List<X.A<X.B<X.C>>>
				----------
				4. WARNING in X.java (at line 7)
					baz((List)a);
					     ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				5. WARNING in X.java (at line 10)
					buz((List)a);
					     ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				6. ERROR in X.java (at line 13)
					baz(a);
					^^^
				The method baz(List<X.A<T>>) in the type X is not applicable for the arguments (List<X.A>)
				----------
				7. WARNING in X.java (at line 16)
					<R extends C, T extends B<R>> void buz(List a) {}
					                                       ^^^^
				List is a raw type. References to generic type List<E> should be parameterized
				----------
				""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=263215
public void test1444() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					import java.util.ArrayList;
					import java.util.Iterator;
					import java.util.List;
					
					public class X {
						@SuppressWarnings("all") public static <T> T[] asArray(Iterator<? extends T> it, Class<T> clazz) {
							List<T> lst = new ArrayList<T>();
							while (it.hasNext()) {
								lst.add(it.next());
							}
							return lst.toArray((T[]) java.lang.reflect.Array.newInstance(clazz, lst.size()));
						}
						public void test() {
							String[] asString = null;
							// eclipse 3.5M4 this worked in build I20090129-1200 it doesnt anymore
							asString = X.<String> asArray(getIterator(), String.class);
							// now i have to do this:
							Iterator<String> iterator = getIterator();
							asString = X.<String> asArray(iterator, String.class);
							// this also works except if i have remove unnecessary cast enabled then
							// the cast is removed and i get a compile error
							asString = X.<String> asArray((Iterator<String>) getIterator(), String.class);
						}
						@SuppressWarnings("all") public Iterator getIterator() {
							return new Iterator() {
								public void remove() {
								}
								public Object next() {
									return null;
								}
								public boolean hasNext() {
									return false;
								}
							};
						}
						Zork z;
					}
					""",//-----------------------------------------------------------------------
			},
			"----------\n" +
			"1. WARNING in X.java (at line 16)\n" +
			"	asString = X.<String> asArray(getIterator(), String.class);\n" +
			"	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Type safety: Unchecked invocation asArray(Iterator, Class<String>) of the generic method asArray(Iterator<? extends T>, Class<T>) of type X\n" +
			"----------\n" +
			"2. WARNING in X.java (at line 16)\n" +
			"	asString = X.<String> asArray(getIterator(), String.class);\n" +
			"	                              ^^^^^^^^^^^^^\n" +
			"Type safety: The expression of type Iterator needs unchecked conversion to conform to Iterator<? extends String>\n" +
			"----------\n" +
			"3. WARNING in X.java (at line 18)\n" +
			"	Iterator<String> iterator = getIterator();\n" +
			"	                            ^^^^^^^^^^^^^\n" +
			"Type safety: The expression of type Iterator needs unchecked conversion to conform to Iterator<String>\n" +
			"----------\n" +
			"4. WARNING in X.java (at line 22)\n" +
			"	asString = X.<String> asArray((Iterator<String>) getIterator(), String.class);\n" +
			"	                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Type safety: Unchecked cast from Iterator to Iterator<String>\n" +
			"----------\n" +
			(this.complianceLevel < ClassFileConstants.JDK1_8 ?
			"5. WARNING in X.java (at line 22)\n" +
			"	asString = X.<String> asArray((Iterator<String>) getIterator(), String.class);\n" +
			"	                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Unnecessary cast from Iterator to Iterator<String>\n" +
			"----------\n" +
			"6. ERROR in X.java (at line 36)\n"
			: // secondary error no longer reported at 1.8+
			"5. ERROR in X.java (at line 36)\n"
			) +
			"	Zork z;\n" +
			"	^^^^\n" +
			"Zork cannot be resolved to a type\n" +
			"----------\n");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=263215 - variation
public void test1445() {
	this.runNegativeTest(
			new String[] {
				"X.java", //-----------------------------------------------------------------------
				"""
					import java.io.IOException;
					import java.util.List;
					
					public class X {
						<T extends Throwable> X(List<T> lt) throws T { }
						<T extends Throwable> List<T> foo(List<T> t) throws T { return t; }
					
						static void bar(List l) {
							new X(l).foo(l);
						}
						static void baz(List l) throws IOException {
							new <IOException> X(l). <IOException> foo(l);
						}
					\t
						X(List l, long l2) throws IOException {
							<IOException> this(l);
						}
					
						static void baz2(List l) throws IOException {
							new <IOException> X(l){}. <IOException> foo(l);
						}
					
					}
					""",
			},
			"----------\n" +
			"1. WARNING in X.java (at line 8)\n" +
			"	static void bar(List l) {\n" +
			"	                ^^^^\n" +
			"List is a raw type. References to generic type List<E> should be parameterized\n" +
			"----------\n" +
			"2. WARNING in X.java (at line 9)\n" +
			"	new X(l).foo(l);\n" +
			"	^^^^^^^^\n" +
			"Type safety: Unchecked invocation X(List) of the generic constructor X(List<T>) of type X\n" +
			"----------\n" +
			"3. WARNING in X.java (at line 9)\n" +
			"	new X(l).foo(l);\n" +
			"	^^^^^^^^^^^^^^^\n" +
			"Type safety: Unchecked invocation foo(List) of the generic method foo(List<T>) of type X\n" +
			"----------\n" +
			(this.complianceLevel < ClassFileConstants.JDK1_8 ?
			"4. ERROR in X.java (at line 9)\n" +
			"	new X(l).foo(l);\n" +
			"	^^^^^^^^\n" +
			"Unhandled exception type Throwable\n" +
			"----------\n"
			: "" // no error in 1.8 (bug GH472)
			) +
			(this.complianceLevel < ClassFileConstants.JDK1_8 ?
			"5. ERROR in X.java (at line 9)\n" +
			"	new X(l).foo(l);\n" +
			"	^^^^^^^^^^^^^^^\n" +
			"Unhandled exception type Throwable\n" +
			"----------\n"
			: "" // no error in 1.8 (bug GH472)
			) +
			"6. WARNING in X.java (at line 9)\n" +
			"	new X(l).foo(l);\n" +
			"	      ^\n" +
			(this.complianceLevel < ClassFileConstants.JDK1_8
			? "Type safety: The expression of type List needs unchecked conversion to conform to List<Throwable>\n"
			: "Type safety: The expression of type List needs unchecked conversion to conform to List<RuntimeException>\n" ) +
			"----------\n" +
			"7. WARNING in X.java (at line 9)\n" +
			"	new X(l).foo(l);\n" +
			"	             ^\n" +
			(this.complianceLevel < ClassFileConstants.JDK1_8
			? "Type safety: The expression of type List needs unchecked conversion to conform to List<Throwable>\n"
			: "Type safety: The expression of type List needs unchecked conversion to conform to List<RuntimeException>\n" ) +
			"----------\n" +
			"8. WARNING in X.java (at line 11)\n" +
			"	static void baz(List l) throws IOException {\n" +
			"	                ^^^^\n" +
			"List is a raw type. References to generic type List<E> should be parameterized\n" +
			"----------\n" +
			"9. WARNING in X.java (at line 12)\n" +
			"	new <IOException> X(l). <IOException> foo(l);\n" +
			"	^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Type safety: Unchecked invocation X(List) of the generic constructor X(List<T>) of type X\n" +
			"----------\n" +
			"10. WARNING in X.java (at line 12)\n" +
			"	new <IOException> X(l). <IOException> foo(l);\n" +
			"	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Type safety: Unchecked invocation foo(List) of the generic method foo(List<T>) of type X\n" +
			"----------\n" +
			"11. WARNING in X.java (at line 12)\n" +
			"	new <IOException> X(l). <IOException> foo(l);\n" +
			"	                    ^\n" +
			"Type safety: The expression of type List needs unchecked conversion to conform to List<IOException>\n" +
			"----------\n" +
			"12. WARNING in X.java (at line 12)\n" +
			"	new <IOException> X(l). <IOException> foo(l);\n" +
			"	                                          ^\n" +
			"Type safety: The expression of type List needs unchecked conversion to conform to List<IOException>\n" +
			"----------\n" +
			"13. WARNING in X.java (at line 15)\n" +
			"	X(List l, long l2) throws IOException {\n" +
			"	  ^^^^\n" +
			"List is a raw type. References to generic type List<E> should be parameterized\n" +
			"----------\n" +
			"14. WARNING in X.java (at line 16)\n" +
			"	<IOException> this(l);\n" +
			"	              ^^^^^^^^\n" +
			"Type safety: Unchecked invocation X(List) of the generic constructor X(List<T>) of type X\n" +
			"----------\n" +
			"15. WARNING in X.java (at line 16)\n" +
			"	<IOException> this(l);\n" +
			"	                   ^\n" +
			"Type safety: The expression of type List needs unchecked conversion to conform to List<IOException>\n" +
			"----------\n" +
			"16. WARNING in X.java (at line 19)\n" +
			"	static void baz2(List l) throws IOException {\n" +
			"	                 ^^^^\n" +
			"List is a raw type. References to generic type List<E> should be parameterized\n" +
			"----------\n" +
			"17. WARNING in X.java (at line 20)\n" +
			"	new <IOException> X(l){}. <IOException> foo(l);\n" +
			"	^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Type safety: Unchecked invocation X(List) of the generic constructor X(List<T>) of type X\n" +
			"----------\n" +
			"18. WARNING in X.java (at line 20)\n" +
			"	new <IOException> X(l){}. <IOException> foo(l);\n" +
			"	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
			"Type safety: Unchecked invocation foo(List) of the generic method foo(List<T>) of type X\n" +
			"----------\n" +
			"19. WARNING in X.java (at line 20)\n" +
			"	new <IOException> X(l){}. <IOException> foo(l);\n" +
			"	                    ^\n" +
			"Type safety: The expression of type List needs unchecked conversion to conform to List<IOException>\n" +
			"----------\n" +
			"20. WARNING in X.java (at line 20)\n" +
			"	new <IOException> X(l){}. <IOException> foo(l);\n" +
			"	                                            ^\n" +
			"Type safety: The expression of type List needs unchecked conversion to conform to List<IOException>\n" +
			"----------\n");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=202393
public void test1446() {
     this.runConformTest(
             new String[] {
                     "Bug202393.java",
                     """
						public class Bug202393 {
						   static <T> T id(T in) { return in; }
						   public static void main(String[] args) {
						      try {\
						         bad();\
						      } catch (Throwable t) {
						         System.out.print("CAUGHT");
						      }
						   }
						   static void bad() throws Throwable {
						      throw id(new Exception());
						   }
						}
						"""},
             "CAUGHT"
     );
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=263633
public void test1447() {
    this.runConformTest(
            new String[] {
                    "X.java",
        			"""
						public abstract class X implements Visitable {
							public <T, U extends Visitor<T>> T accept(U v) {
								return null;
							}
							public <T, U extends Visitor<T>> T accept2(U v) {
								if (v == null)
									return this.accept(v);
								else\s
									return this.<T, U> accept(v);
							}
						}
						interface Visitable {
							<T, U extends Visitor<T>> T accept(U v);
						}
						interface Visitor<T> {
						}
						""",
       		},
            ""
    );
}

//https://bugs.eclipse.org/bugs/show_bug.cgi?id=263633 - variation
public void test1448() {
    this.runConformTest(
            new String[] {
                    "X.java",
        			"""
						public abstract class X implements Visitable {
							public <T, U extends Visitor> T accept(U v) {
								return null;
							}
							public <T, U extends Visitor> T accept2(U v) {
								if (v == null)
									return this.accept(v);
								else\s
									return this.<T, U> accept(v);
							}
						}
						interface Visitable {
							<T, U extends Visitor> T accept(U v);
						}
						interface Visitor{
						}
						""",
       		},
            ""
    );
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=263633 - variation
public void test1449() {
     this.runConformTest(
             new String[] {
                     "X.java",
         			"""
						interface Visitor<T, C, O, P, EL, PM, S, COA, SSA, CT> {
						}
						public class X<U> {
							public <T, U extends Visitor<T, ?, ?, ?, ?, ?, ?, ?, ?, ?>> T accept(U v) {
								throw new UnsupportedOperationException();
							}
						}
						class Y<V> extends X<V> {
							public <T, U extends Visitor<T, ?, ?, ?, ?, ?, ?, ?, ?, ?>> T accept(U v) {
								if (v == null)
									return super.accept(v);
								else
									return super.<T, U> accept(v);
							}
						}
						""",
        		},
             ""
     );
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=159851
public void test1450() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.*;
				class A {}
				class B<T extends A> {}
				class X<T extends ArrayList<B<Integer>>> extends TreeMap<Integer, B<String>> {}
				
				class D<T> {}
				class E<T extends Number> {}
				class Y<T> extends E<D<T>> {}""",
		},
		"""
			----------
			1. WARNING in X.java (at line 4)
				class X<T extends ArrayList<B<Integer>>> extends TreeMap<Integer, B<String>> {}
				      ^
			The serializable class X does not declare a static final serialVersionUID field of type long
			----------
			2. ERROR in X.java (at line 4)
				class X<T extends ArrayList<B<Integer>>> extends TreeMap<Integer, B<String>> {}
				                              ^^^^^^^
			Bound mismatch: The type Integer is not a valid substitute for the bounded parameter <T extends A> of the type B<T>
			----------
			3. ERROR in X.java (at line 4)
				class X<T extends ArrayList<B<Integer>>> extends TreeMap<Integer, B<String>> {}
				                                                                    ^^^^^^
			Bound mismatch: The type String is not a valid substitute for the bounded parameter <T extends A> of the type B<T>
			----------
			4. ERROR in X.java (at line 8)
				class Y<T> extends E<D<T>> {}
				                     ^
			Bound mismatch: The type D<T> is not a valid substitute for the bounded parameter <T extends Number> of the type E<T>
			----------
			"""
	);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=159851
public void test1451() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				class A<T> {}
				class B<T2 extends Number> {}
				class C<T3, T4> {}
				class X<T1, T2> extends C<A<A<B<T1>>>, A<B<T2>>> {}
				class Y<T> extends A<A<B<T>>> {}
				class Z<T> extends C<B<T>, A<B<T>>> {}""",
		},
		"""
			----------
			1. ERROR in X.java (at line 4)
				class X<T1, T2> extends C<A<A<B<T1>>>, A<B<T2>>> {}
				                                ^^
			Bound mismatch: The type T1 is not a valid substitute for the bounded parameter <T2 extends Number> of the type B<T2>
			----------
			2. ERROR in X.java (at line 4)
				class X<T1, T2> extends C<A<A<B<T1>>>, A<B<T2>>> {}
				                                           ^^
			Bound mismatch: The type T2 is not a valid substitute for the bounded parameter <T2 extends Number> of the type B<T2>
			----------
			3. ERROR in X.java (at line 5)
				class Y<T> extends A<A<B<T>>> {}
				                         ^
			Bound mismatch: The type T is not a valid substitute for the bounded parameter <T2 extends Number> of the type B<T2>
			----------
			4. ERROR in X.java (at line 6)
				class Z<T> extends C<B<T>, A<B<T>>> {}
				                       ^
			Bound mismatch: The type T is not a valid substitute for the bounded parameter <T2 extends Number> of the type B<T2>
			----------
			5. ERROR in X.java (at line 6)
				class Z<T> extends C<B<T>, A<B<T>>> {}
				                               ^
			Bound mismatch: The type T is not a valid substitute for the bounded parameter <T2 extends Number> of the type B<T2>
			----------
			"""
	);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=273751
public void test1452() {
	this.runNegativeTest(
		new String[] {
			"A.java",
			"""
				class A<T> {}
				class B extends A<B.Secret> {
					private class Secret {};
					B.Secret s;
					A<B.Secret> a;
				}
				class C extends B.Secret {}
				class D {
					class M { private class Secret {}; }
					class N extends A<M.Secret> {}
				}
				class E {
					class M extends A<M.Secret> {
					  private class Secret {};
					}
				}"""
		},
		"""
			----------
			1. ERROR in A.java (at line 2)
				class B extends A<B.Secret> {
				                  ^^^^^^^^
			The type B.Secret is not visible
			----------
			2. ERROR in A.java (at line 7)
				class C extends B.Secret {}
				                ^^^^^^^^
			The type B.Secret is not visible
			----------
			"""
	);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=278305
public void test1453() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				class X {
					I<?> i = new I<?>() {};
				}
				class Y implements I<?> {}
				interface I<T> {}"""
		},
		"""
			----------
			1. ERROR in X.java (at line 2)
				I<?> i = new I<?>() {};
				             ^
			The type new I(){} cannot extend or implement I<?>. A supertype may not specify any wildcard
			----------
			2. ERROR in X.java (at line 4)
				class Y implements I<?> {}
				                   ^
			The type Y cannot extend or implement I<?>. A supertype may not specify any wildcard
			----------
			"""
	);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=289538
public void test1454() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				public class X<T> {
					Node first;
					public void add(T e) {
						first = new Node(e);
						System.out.print(true);
					}
					private class Node {
						private Node next;
						private Node(T d) {}
						private Node(T d, Node n) { next = n; }
					}
					public static void main(String[] args) {
						X<String> x = new X<String>();
						x.add("");
					}
				}"""
		},
   		"true"
	);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=287607
public void test1455() {
	this.runNegativeTest(
		new String[] {
			"Outer.java",
			"""
				public class Outer<E> {
				  Inner inner;
				  class Inner {
				    E e;
				    E getOtherElement(Object other) {
				      if (!(other instanceof Outer<?>.Inner))
				       throw new IllegalArgumentException(String.valueOf(other));
				      Inner that = (Inner) other;
				      return that.e;
				    }
				  }
				  public static void main(String[] args) {
				    Outer<String> s = new Outer<String>();
				    s.inner = s.new Inner();
				   s.inner.e = "hello";
				   Outer<Integer> i = new Outer<Integer>();
				   i.inner = i.new Inner();
				   i.inner.e = 1234;
				   s.inner.getOtherElement(i.inner);
				 }
				}"""
		},
		"""
			----------
			1. WARNING in Outer.java (at line 8)
				Inner that = (Inner) other;
				             ^^^^^^^^^^^^^
			Type safety: Unchecked cast from Object to Outer<E>.Inner
			----------
			"""
	);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=292428
public void test1456() {
	this.runConformTest(
		new String[] {
			"X.java",
			"""
				import java.util.ArrayList;
				
				public class X<K,V> {
					interface E<V> {}
					class S implements E<V> {
						V value;
					}
					class M implements E<V>  {
						ArrayList<V> list = new ArrayList<V>();
						M(E<V> se) {
							list.add(((S)se).value);
						}
					}
				}"""
		},
		""
	);
}
// Test to verify that partial types in a parameterized qualified reference are
// demarcated correctly while annotating an arity problem in case of wrong number of arguments.
// Related to https://bugs.eclipse.org/bugs/show_bug.cgi?id=292510
public void test1457() {
	this.runNegativeTest(
		new String[] {
			"test/X.java",
			"""
				package test;
				// Valid Parameterized Type Declaration
				public class X<A1, A2> {
					public class Y<A3,A4,A5> {
						public class Z<A6> {
						}
					}
				}
				// Invalid Valid Type Syntax (too many parameters)
				class Y {
					X<String, Number>.Y<String,Integer>.Z<String> x;
				}
				"""
		},
		"""
			----------
			1. ERROR in test\\X.java (at line 11)
				X<String, Number>.Y<String,Integer>.Z<String> x;
				^^^^^^^^^^^^^^^^^^^
			Incorrect number of arguments for type X<String,Number>.Y; it cannot be parameterized with arguments <String, Integer>
			----------
			"""
	);
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=285002 (visibility error for package private method)
public void test1458() {
	this.runNegativeTest(
			new String[] {
					"CompilerBug.java",
					"""
						@SuppressWarnings("deprecation")
						public class CompilerBug {
							public <T> T newInstance( Class<T> c ) throws InstantiationException, IllegalAccessException {
							      return c.newInstance();
								   }
								   protected void protectedMethod() {}
								   void packagePrivateMethod() {}
								   private void privateMethod() {}
								   private int privateInt = 0;
								   int packagePrivateInt = 0;
								   protected int protectedInt = 0;
								   private void isThisBuggy() throws InstantiationException, IllegalAccessException {
								      CompilerBug c = getClass().newInstance();
								      c.privateMethod();
								      c.packagePrivateMethod();
								      c.protectedMethod();
								      getClass().newInstance().packagePrivateMethod();
								      getClass().newInstance().privateMethod();
								      getClass().newInstance().protectedMethod();
								      getClass().newInstance().privateInt = 10;
								      getClass().newInstance().packagePrivateInt = 10;
								      getClass().newInstance().protectedInt = 10;
						             Zork z;
								   }
							}
						""",
			},
			this.complianceLevel <= ClassFileConstants.JDK1_6 ?
			"""
				----------
				1. ERROR in CompilerBug.java (at line 23)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				""" :

			"""
				----------
				1. ERROR in CompilerBug.java (at line 18)
					getClass().newInstance().privateMethod();
					                         ^^^^^^^^^^^^^
				The method privateMethod() from the type CompilerBug is not visible
				----------
				2. ERROR in CompilerBug.java (at line 20)
					getClass().newInstance().privateInt = 10;
					                         ^^^^^^^^^^
				The field CompilerBug.privateInt is not visible
				----------
				3. ERROR in CompilerBug.java (at line 23)
					Zork z;
					^^^^
				Zork cannot be resolved to a type
				----------
				"""
			);
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=295698
public void test1459() {
	this.runConformTest(
		new String[] {
			"B.java",
			"""
				import java.util.Collection;
				public class B extends X<Collection<?>> {
					public B(Collection<X<?>> c, I i) {
						super(c, i);
					}
				}""",
			"I.java",
			"public interface I<T>{}",
			"X.java",
			"""
				public class X<T> {
					public <V extends T> X(V v, I<T> i, Object... o) {}
				}"""
		},
		""); // no specific success output string
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=277643
// SHOULD FAIL AT 1.8 (18.2.3): The method get(Class<W>, T) in the type Test is not applicable for the arguments (Class<Test.W_Description>, Object)
// FIXME: javac rejects (correctly? how?), see http://mail.openjdk.java.net/pipermail/lambda-spec-experts/2013-December/000443.html
public void test277643() {
	this.runNegativeTest(
		false /* skipJavac */,
		this.complianceLevel < ClassFileConstants.JDK1_8 ? null :
		JavacTestOptions.EclipseHasABug.EclipseBug428061,
		new String[] {
	    "Test.java",
	    """
			public class Test {
			public final void addShortDescription(Object object, StringBuffer buf) {
				try {
					W_Description wdescription = get(W_Description.class, object);
				} catch (Exception e) {
				}
			}
			public abstract class W_Description<WRAPPED> extends WrapperLogic<WRAPPED> {}
			public <T, W extends WrapperLogic<? super T>> W get(Class<W> wrapperClass, T entity) {
				return getLogicFactory().get(wrapperClass, entity);
			}
			private LogicFactory logicFactory;
			public final LogicFactory getLogicFactory() {
				return logicFactory;
			}
			public interface LogicFactory {
				<LOGIC extends Logic> LOGIC get(Class<LOGIC> logicClass);
				<WRAPPED, WRAPPER_LOGIC extends WrapperLogic<? super WRAPPED>> WRAPPER_LOGIC get(Class<WRAPPER_LOGIC> wrapperLogicClass, WRAPPED entityToWrap);
			}
			public abstract class WrapperLogic<WRAPPED> extends AbstractLogic implements Wrapper<WRAPPED> {}
			public abstract class AbstractLogic {}
			public interface Wrapper<WRAPPED> {
				WRAPPED getWrapped();
			}
			public abstract class Logic extends AbstractLogic {}
			}"""
		},
		"""
			----------
			1. WARNING in Test.java (at line 4)
				W_Description wdescription = get(W_Description.class, object);
				^^^^^^^^^^^^^
			Test.W_Description is a raw type. References to generic type Test.W_Description<WRAPPED> should be parameterized
			----------
			2. WARNING in Test.java (at line 4)
				W_Description wdescription = get(W_Description.class, object);
				                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked invocation get(Class<Test.W_Description>, Object) of the generic method get(Class<W>, T) of type Test
			----------
			""");
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=280054
// SHOULD FAIL AT 1.8 (18.2.3): The method get(Class<V>, Class<S>) in the type X.L is not applicable for the arguments (Class<V>, Class<X.B>)
public void test280054() {
	this.runNegativeTest(
		new String[] {
	    "X.java",
	    """
			public class X {
			static class A<V> {
			L l;
			public Class<V> vtype() {
			   return null;
			}
			public A<V> method1() {
			   return l.get(vtype(), B.class);
			}
			}
			static class L {
			public <V,S extends A<V>> S get(Class<V> vtype, Class<S> stype) {
			   return null;
			}
			}
			static class B<V> extends A<V> {
			public B<V> method2() {
			   return l.get(vtype(), B.class);
			}
			}
			}
			"""
		},
		"""
			----------
			1. WARNING in X.java (at line 8)
				return l.get(vtype(), B.class);
				       ^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked invocation get(Class<V>, Class<X.B>) of the generic method get(Class<V>, Class<S>) of type X.L
			----------
			2. WARNING in X.java (at line 8)
				return l.get(vtype(), B.class);
				       ^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: The expression of type X.B needs unchecked conversion to conform to X.A<V>
			----------
			3. WARNING in X.java (at line 18)
				return l.get(vtype(), B.class);
				       ^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked invocation get(Class<V>, Class<X.B>) of the generic method get(Class<V>, Class<S>) of type X.L
			----------
			4. WARNING in X.java (at line 18)
				return l.get(vtype(), B.class);
				       ^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: The expression of type X.B needs unchecked conversion to conform to X.B<V>
			----------
			""");
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=283306
// SHOULD FAIL AT 1.8 (18.2.3): The method get(Class<V>, Class<S>) in the type X.L is not applicable for the arguments (Class<V>, Class<X.B>)
// FIXME: javac rejects (correctly? how?), see http://mail.openjdk.java.net/pipermail/lambda-spec-experts/2013-December/000443.html
public void test283306() {
	this.runNegativeTest(
		false /* skipJavac */,
		this.complianceLevel < ClassFileConstants.JDK1_8 ? null :
		JavacTestOptions.EclipseHasABug.EclipseBug428061,
		new String[] {
	    "Test.java",
	    """
			public class Test {
			    public WWorkflow<? extends Workflow> getMainWorkflow(){
			        return get(WWorkflow.class, null);
			    }
			    public <T, W extends WrapperLogic<? super T>> W get(Class<W> wrapperClass, T entity) {
			        return null;
			    }
			}
			class Workflow {}
			class WWorkflow<T extends Workflow> extends WrapperLogic<T> {}
			abstract class WrapperLogic<WRAPPED> {}
			"""
		},
		"""
			----------
			1. WARNING in Test.java (at line 3)
				return get(WWorkflow.class, null);
				       ^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked invocation get(Class<WWorkflow>, null) of the generic method get(Class<W>, T) of type Test
			----------
			2. WARNING in Test.java (at line 3)
				return get(WWorkflow.class, null);
				       ^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: The expression of type WWorkflow needs unchecked conversion to conform to WWorkflow<? extends Workflow>
			----------
			""");
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=294724
// Test extracted from bug submission code by kabir.khan@jboss.com (Kabir Khan)
// SHOULD FAIL AT 1.8 (18.2.3): The method cloneCollection(T, Class<? extends T>, Class<U>) in the type SimpleExample is not applicable for the arguments (Set<SimpleExample.Data>, Class<HashSet>, Class<SimpleExample.Data>)
public void test294724() {
	this.runNegativeTest(
		new String[] {
	    "SimpleExample.java",
	    """
			import java.util.Collection;
			import java.util.HashSet;
			import java.util.Set;
			public class SimpleExample {
			  Set<Data> data;
			  public void setData(Set<Data> data) {
			     this.data = data;
			  }
			  public void copy(SimpleExample clone) {
			     clone.setData(cloneCollection(data, HashSet.class, Data.class));
			  }
				public static <U extends Interface, T extends Collection<U>> T cloneCollection(T collection, Class<? extends T> expectedClass, Class<U> componentType) {
			   	return null;
			   }
			  private interface Interface {}
			  private class Data implements Interface {}
			}"""
	    },
		"""
			----------
			1. WARNING in SimpleExample.java (at line 10)
				clone.setData(cloneCollection(data, HashSet.class, Data.class));
				              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked invocation cloneCollection(Set<SimpleExample.Data>, Class<HashSet>, Class<SimpleExample.Data>) of the generic method cloneCollection(T, Class<? extends T>, Class<U>) of type SimpleExample
			----------
			2. WARNING in SimpleExample.java (at line 10)
				clone.setData(cloneCollection(data, HashSet.class, Data.class));
				              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: The expression of type Set needs unchecked conversion to conform to Set<SimpleExample.Data>
			----------
			""");
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=268798
// SHOULD FAIL AT 1.8 (18.2.3): The method min(Collection<? extends T>) in the type Collections is not applicable for the arguments (List<GenericDemo.A>)
public void test268798() {
	this.runNegativeTest(
		new String[] {
	    "GenericDemo.java",
	    """
			import java.util.Collections;
			import java.util.List;
			public class GenericDemo {
			  static class A implements Comparable {
			    public int compareTo(Object o) {
			      return 0;
			    }
			  }
			  void someCode(List<A> list) {
			    A min = Collections.min(list);\s
			  }
			}
			"""
	    },
		"""
			----------
			1. WARNING in GenericDemo.java (at line 4)
				static class A implements Comparable {
				                          ^^^^^^^^^^
			Comparable is a raw type. References to generic type Comparable<T> should be parameterized
			----------
			2. WARNING in GenericDemo.java (at line 10)
				A min = Collections.min(list);\s
				        ^^^^^^^^^^^^^^^^^^^^^
			Type safety: Unchecked invocation min(List<GenericDemo.A>) of the generic method min(Collection<? extends T>) of type Collections
			----------
			""");
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=268798
// SHOULD FAIL AT 1.8 (18.2.3): Type mismatch: cannot convert from Bug268798.SomeInterface<? super Bug268798.SomeInterface<T>> to Bug268798.A
public void test268798a() {
	this.runNegativeTest(
		new String[] {
	    "Bug268798.java",
	    """
			public class Bug268798 {
			  interface SomeInterface<T> {
			  }
			  class A implements SomeInterface {
			  }
			  <T extends SomeInterface<? super T>> T someMethod() {
			    return null;
			  }
			  void someCode() {
			    A a = someMethod();
			  }
			}
			"""
	    },
		"""
			----------
			1. WARNING in Bug268798.java (at line 4)
				class A implements SomeInterface {
				                   ^^^^^^^^^^^^^
			Bug268798.SomeInterface is a raw type. References to generic type Bug268798.SomeInterface<T> should be parameterized
			----------
			2. WARNING in Bug268798.java (at line 10)
				A a = someMethod();
				      ^^^^^^^^^^^^
			Type safety: Unchecked invocation someMethod() of the generic method someMethod() of type Bug268798
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=307885
public void test1460() {
	String log = this.complianceLevel < ClassFileConstants.JDK16 ?
			"""
				----------
				1. ERROR in Test.java (at line 9)
					if(!(o instanceof MyEntry))
					    ^^^^^^^^^^^^^^^^^^^^^^
				Cannot perform instanceof check against parameterized type Test<A>.MyEntry. Use the form Test.MyEntry instead since further generic type information will be erased at runtime
				----------
				""" :
				"""
					----------
					1. ERROR in Test.java (at line 9)
						if(!(o instanceof MyEntry))
						     ^
					Type Object cannot be safely cast to Test<A>.MyEntry
					----------
					""";
	this.runNegativeTest(
		new String[] {
			"Test.java",
			"""
				class Test<A> {
				    interface MyInt<K> {
				        K getKey();
				    }
				    class MyEntry implements MyInt<A> {
				        public A getKey() { return null; }
				        @Override
				        public boolean equals(Object o) {
				            if(!(o instanceof MyEntry))
				                return false;
				            return true;
				        }
				    }
				}"""
		}, log
		);
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=306464
public void test1461() {
	this.runNegativeTest(
		new String[] {
			"JoinImpl.java",
			"""
				import javax.persistence.criteria.Expression;
				import javax.persistence.criteria.Fetch;
				import javax.persistence.criteria.From;
				import javax.persistence.criteria.Join;
				import javax.persistence.criteria.JoinType;
				import javax.persistence.criteria.Path;
				import javax.persistence.metamodel.Attribute;
				import javax.persistence.metamodel.Bindable;
				import javax.persistence.metamodel.ManagedType;
				import javax.persistence.metamodel.Metamodel;
				public class JoinImpl<Z, X> extends FromImpl<Z, X> implements Join<Z, X>, Fetch<Z, X> {
				}""",
			"FromImpl.java",
			"""
				import java.util.ArrayList;
				import java.util.HashSet;
				import java.util.List;
				import java.util.Set;
				import java.util.Stack;
				
				import javax.persistence.criteria.CollectionJoin;
				import javax.persistence.criteria.Expression;
				import javax.persistence.criteria.Fetch;
				import javax.persistence.criteria.From;
				import javax.persistence.criteria.Join;
				import javax.persistence.criteria.JoinType;
				import javax.persistence.criteria.ListJoin;
				import javax.persistence.criteria.MapJoin;
				import javax.persistence.criteria.Path;
				import javax.persistence.criteria.SetJoin;
				import javax.persistence.metamodel.Attribute;
				import javax.persistence.metamodel.Bindable;
				import javax.persistence.metamodel.CollectionAttribute;
				import javax.persistence.metamodel.ListAttribute;
				import javax.persistence.metamodel.ManagedType;
				import javax.persistence.metamodel.MapAttribute;
				import javax.persistence.metamodel.Metamodel;
				import javax.persistence.metamodel.PluralAttribute;
				import javax.persistence.metamodel.SingularAttribute;
				import javax.persistence.metamodel.Attribute.PersistentAttributeType;
				import javax.persistence.metamodel.PluralAttribute.CollectionType;
				import javax.persistence.metamodel.Type.PersistenceType;
				
				import org.eclipse.persistence.internal.helper.ClassConstants;
				import org.eclipse.persistence.internal.localization.ExceptionLocalization;
				
				public class FromImpl<Z, X>  extends PathImpl<X> implements javax.persistence.criteria.From<Z, X> {
				
				    protected Set<Join<X, ?>> joins;
				   \s
				    public Set<Join<X, ?>> getJoins() {
				        return joins;
				    }
				
				    public void findJoins(AbstractQueryImpl query){
				        Stack stack = new Stack();
				        stack.push(this);
				        while(!stack.isEmpty()){
				            FromImpl currentJoin = (FromImpl) stack.pop();
				            stack.addAll(currentJoin.getJoins());
				            if (currentJoin.isLeaf){
				                    query.addJoin(currentJoin);
				                }
				        }
				    }
				}"""
		},
		"""
			----------
			1. ERROR in JoinImpl.java (at line 1)
				import javax.persistence.criteria.Expression;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			2. ERROR in JoinImpl.java (at line 2)
				import javax.persistence.criteria.Fetch;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			3. ERROR in JoinImpl.java (at line 3)
				import javax.persistence.criteria.From;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			4. ERROR in JoinImpl.java (at line 4)
				import javax.persistence.criteria.Join;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			5. ERROR in JoinImpl.java (at line 5)
				import javax.persistence.criteria.JoinType;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			6. ERROR in JoinImpl.java (at line 6)
				import javax.persistence.criteria.Path;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			7. ERROR in JoinImpl.java (at line 7)
				import javax.persistence.metamodel.Attribute;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			8. ERROR in JoinImpl.java (at line 8)
				import javax.persistence.metamodel.Bindable;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			9. ERROR in JoinImpl.java (at line 9)
				import javax.persistence.metamodel.ManagedType;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			10. ERROR in JoinImpl.java (at line 10)
				import javax.persistence.metamodel.Metamodel;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			11. ERROR in JoinImpl.java (at line 11)
				public class JoinImpl<Z, X> extends FromImpl<Z, X> implements Join<Z, X>, Fetch<Z, X> {
				                                                              ^^^^
			Join cannot be resolved to a type
			----------
			12. ERROR in JoinImpl.java (at line 11)
				public class JoinImpl<Z, X> extends FromImpl<Z, X> implements Join<Z, X>, Fetch<Z, X> {
				                                                                          ^^^^^
			Fetch cannot be resolved to a type
			----------
			----------
			1. ERROR in FromImpl.java (at line 7)
				import javax.persistence.criteria.CollectionJoin;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			2. ERROR in FromImpl.java (at line 8)
				import javax.persistence.criteria.Expression;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			3. ERROR in FromImpl.java (at line 9)
				import javax.persistence.criteria.Fetch;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			4. ERROR in FromImpl.java (at line 10)
				import javax.persistence.criteria.From;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			5. ERROR in FromImpl.java (at line 11)
				import javax.persistence.criteria.Join;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			6. ERROR in FromImpl.java (at line 12)
				import javax.persistence.criteria.JoinType;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			7. ERROR in FromImpl.java (at line 13)
				import javax.persistence.criteria.ListJoin;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			8. ERROR in FromImpl.java (at line 14)
				import javax.persistence.criteria.MapJoin;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			9. ERROR in FromImpl.java (at line 15)
				import javax.persistence.criteria.Path;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			10. ERROR in FromImpl.java (at line 16)
				import javax.persistence.criteria.SetJoin;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			11. ERROR in FromImpl.java (at line 17)
				import javax.persistence.metamodel.Attribute;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			12. ERROR in FromImpl.java (at line 18)
				import javax.persistence.metamodel.Bindable;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			13. ERROR in FromImpl.java (at line 19)
				import javax.persistence.metamodel.CollectionAttribute;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			14. ERROR in FromImpl.java (at line 20)
				import javax.persistence.metamodel.ListAttribute;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			15. ERROR in FromImpl.java (at line 21)
				import javax.persistence.metamodel.ManagedType;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			16. ERROR in FromImpl.java (at line 22)
				import javax.persistence.metamodel.MapAttribute;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			17. ERROR in FromImpl.java (at line 23)
				import javax.persistence.metamodel.Metamodel;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			18. ERROR in FromImpl.java (at line 24)
				import javax.persistence.metamodel.PluralAttribute;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			19. ERROR in FromImpl.java (at line 25)
				import javax.persistence.metamodel.SingularAttribute;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			20. ERROR in FromImpl.java (at line 26)
				import javax.persistence.metamodel.Attribute.PersistentAttributeType;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			21. ERROR in FromImpl.java (at line 27)
				import javax.persistence.metamodel.PluralAttribute.CollectionType;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			22. ERROR in FromImpl.java (at line 28)
				import javax.persistence.metamodel.Type.PersistenceType;
				       ^^^^^^^^^^^^^^^^^
			The import javax.persistence cannot be resolved
			----------
			23. ERROR in FromImpl.java (at line 30)
				import org.eclipse.persistence.internal.helper.ClassConstants;
				       ^^^^^^^^^^^
			The import org.eclipse cannot be resolved
			----------
			24. ERROR in FromImpl.java (at line 31)
				import org.eclipse.persistence.internal.localization.ExceptionLocalization;
				       ^^^^^^^^^^^
			The import org.eclipse cannot be resolved
			----------
			25. ERROR in FromImpl.java (at line 33)
				public class FromImpl<Z, X>  extends PathImpl<X> implements javax.persistence.criteria.From<Z, X> {
				                                     ^^^^^^^^
			PathImpl cannot be resolved to a type
			----------
			26. ERROR in FromImpl.java (at line 33)
				public class FromImpl<Z, X>  extends PathImpl<X> implements javax.persistence.criteria.From<Z, X> {
				                                                            ^^^^^^^^^^^^^^^^^
			javax.persistence cannot be resolved to a type
			----------
			27. ERROR in FromImpl.java (at line 35)
				protected Set<Join<X, ?>> joins;
				              ^^^^
			Join cannot be resolved to a type
			----------
			28. ERROR in FromImpl.java (at line 37)
				public Set<Join<X, ?>> getJoins() {
				           ^^^^
			Join cannot be resolved to a type
			----------
			29. ERROR in FromImpl.java (at line 38)
				return joins;
				       ^^^^^
			Join cannot be resolved to a type
			----------
			30. ERROR in FromImpl.java (at line 41)
				public void findJoins(AbstractQueryImpl query){
				                      ^^^^^^^^^^^^^^^^^
			AbstractQueryImpl cannot be resolved to a type
			----------
			31. WARNING in FromImpl.java (at line 42)
				Stack stack = new Stack();
				^^^^^
			Stack is a raw type. References to generic type Stack<E> should be parameterized
			----------
			32. WARNING in FromImpl.java (at line 42)
				Stack stack = new Stack();
				                  ^^^^^
			Stack is a raw type. References to generic type Stack<E> should be parameterized
			----------
			33. WARNING in FromImpl.java (at line 43)
				stack.push(this);
				^^^^^^^^^^^^^^^^
			Type safety: The method push(Object) belongs to the raw type Stack. References to generic type Stack<E> should be parameterized
			----------
			34. WARNING in FromImpl.java (at line 45)
				FromImpl currentJoin = (FromImpl) stack.pop();
				^^^^^^^^
			FromImpl is a raw type. References to generic type FromImpl<Z,X> should be parameterized
			----------
			35. WARNING in FromImpl.java (at line 45)
				FromImpl currentJoin = (FromImpl) stack.pop();
				                        ^^^^^^^^
			FromImpl is a raw type. References to generic type FromImpl<Z,X> should be parameterized
			----------
			36. WARNING in FromImpl.java (at line 46)
				stack.addAll(currentJoin.getJoins());
				^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			Type safety: The method addAll(Collection) belongs to the raw type Vector. References to generic type Vector<E> should be parameterized
			----------
			37. ERROR in FromImpl.java (at line 47)
				if (currentJoin.isLeaf){
				                ^^^^^^
			isLeaf cannot be resolved or is not a field
			----------
			""");
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=316889
public void test1462() {
	this.runNegativeTest(
		new String[] {
			"AnotherClass.java",
			"""
				public class AnotherClass<I extends IRecursiveInterface<? super I>> {}
				class ImplementingClass implements IRecursiveInterface<IReferencedInterface>, IReferencedInterface {
				    private AnotherClass<IReferencedInterface> m_var;
				    public void setAnother(final AnotherClass<? extends IReferencedInterface> a) {
					    m_var = a;
				    }
				}
				interface IRecursiveInterface<I extends IRecursiveInterface<? super I>> {
					void setAnother(final AnotherClass<? extends I> a);
				}
				interface IReferencedInterface extends IRecursiveInterface<IReferencedInterface> {}
				"""
		},
		"""
			----------
			1. ERROR in AnotherClass.java (at line 5)
				m_var = a;
				        ^
			Type mismatch: cannot convert from AnotherClass<capture#1-of ? extends IReferencedInterface> to AnotherClass<IReferencedInterface>
			----------
			""");
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=314556
public void test1463() {
	this.runNegativeTest(
		new String[] {
			"BaseType.java",
            """
				public interface BaseType {
					   BaseType clone() throws CloneNotSupportedException;
				}
				interface SubType<T extends BaseType & java.io.Closeable> extends BaseType {
				}
				"""
		},
		"""
			----------
			1. ERROR in BaseType.java (at line 4)
				interface SubType<T extends BaseType & java.io.Closeable> extends BaseType {
				                  ^
			The inherited method Object.clone() cannot hide the public abstract method in BaseType
			----------
			""");
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=319603
public void test1464() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				import java.util.Collection;
				import java.util.Set;
				
				public class X {
				
					public <T> Collection<T> m(Collection<T> a) {
						return null;
					}
					public <T> Set<T> m(Set<T> a) {
							return m(a);\s
					}
				   Zork z;
				}
				"""
		},
		"""
			----------
			1. ERROR in X.java (at line 12)
				Zork z;
				^^^^
			Zork cannot be resolved to a type
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=320275
public void _test1465() {
	this.runConformTest(
			new String[] {
				"AbstractSubClass.java",
				"public abstract class AbstractSubClass extends AbstractClass {}",
			},
			new String[] {
					"AbstractClass.java",
					"public abstract class AbstractClass implements BaseInterface {}",
					"AbstractSubClass.java",
					"public abstract class AbstractSubClass extends AbstractClass {}",
					"BaseInterface.java",
					"public interface BaseInterface extends GenericInterface<ConcreteClass> {}",
					"ConcreteClass.java",
					"public class ConcreteClass extends AbstractSubClass {}",
					"GenericInterface.java",
					"public interface GenericInterface<T> {}",
			},
			"");
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=320463
public void test1466() {
	this.runNegativeTest(
		new String[] {
			"Outer.java",
			"""
				public class Outer<T> {
				    class Cell {
				        final T value;
				        Cell(T value) {
				            this.value = value;
				        }
				    }
				    Class<Outer<T>.Cell> cellClass = Cell.class;
				    {
				    	this.cellClass = Cell.class;
				    	this.cellClass = Outer.Cell.class;
				    }
				    public static void main(String[] args) {
				        Outer<Integer>.Cell intCell = new Outer<Integer>().new Cell(314);
				        Outer<String>.Cell strCell = new Outer<String>().cellClass.cast(intCell);
				        String val = strCell.value; // ClassCastException
				        System.out.println(val);
				    }
				}
				"""
		},
		"""
			----------
			1. ERROR in Outer.java (at line 8)
				Class<Outer<T>.Cell> cellClass = Cell.class;
				                                 ^^^^^^^^^^
			Type mismatch: cannot convert from Class<Outer.Cell> to Class<Outer<T>.Cell>
			----------
			2. ERROR in Outer.java (at line 10)
				this.cellClass = Cell.class;
				                 ^^^^^^^^^^
			Type mismatch: cannot convert from Class<Outer.Cell> to Class<Outer<T>.Cell>
			----------
			3. ERROR in Outer.java (at line 11)
				this.cellClass = Outer.Cell.class;
				                 ^^^^^^^^^^^^^^^^
			Type mismatch: cannot convert from Class<Outer.Cell> to Class<Outer<T>.Cell>
			----------
			""");
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=312076
public void test1467() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"""
				public class X<T>  {\s
				    public abstract static class Base<S extends Base<S>> {
				        public Base(Class<S> sClass) {
				            Class<S> theClass = sClass;
				            System.out.println(theClass);
				            System.out.println(sClass);
				        }
				    }
				    public class Arr extends Base<Arr> {
				        public Arr() {\s
				            super(Arr.class);
				            System.out.println(Arr.class);
				        }
				    }
				    public static void main(String[] args) {
				        X<Integer> x = new X<Integer>();
				        X<Integer>.Arr a = x.new Arr();
				        System.out.println(a);
				    }
				}
				"""
		},
		"""
			----------
			1. ERROR in X.java (at line 11)
				super(Arr.class);
				^^^^^^^^^^^^^^^^^
			The constructor X.Base<X<T>.Arr>(Class<X.Arr>) is undefined
			----------
			""");
}
public void testBug401783() {
	if (this.complianceLevel >= ClassFileConstants.JDK1_8)
		runConformTest(
			new String[] {
				"X.java",
				"""
					import java.util.*;
					public class X {
						void foo() {
							Iterable<Iterable<Integer>> iterables = Arrays.asList(Arrays.asList(1,2,3,4),Arrays.asList(5,6,7));
						}
					}
					"""
			});
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=433989
public void testBug433989() {
	this.runConformTest(
		new String[] {
			"A.java",
			"""
				class A<V> {
				    public static class Container {
				        public static class In<T> {
				            public static class Inner<U> {}
				        }
				        public static <X> void doit() {
				            new In.Inner<X>();
				        }
				    }
				}
				"""
		});
}
// https://bugs.eclipse.org/bugs/show_bug.cgi?id=433989
public void testBug433989a() {
	this.runNegativeTest(
		new String[] {
			"A.java",
			"""
				class A<V> {
					public static class Nested {
						public class In<U> {
							public class Inner<V> {}
						}
						public <X> void create() {
							new In.Inner<X>();
						}
					}
				}"""
		},
		"""
			----------
			1. ERROR in A.java (at line 7)
				new In.Inner<X>();
				    ^^^^^^^^
			The member type A.Nested.In.Inner<X> must be qualified with a parameterized type, since it is not static
			----------
			""");
}
//https://bugs.eclipse.org/bugs/show_bug.cgi?id=433989
public void testBug433989b() {
	this.runNegativeTest(
		new String[] {
			"A.java",
			"""
				class A<V> {
					public class Nested {
						public class In<U> {
							public class Inner<W> {}
						}
						public <X> void create() {
							new In.Inner<X>();
						}
					}
				}"""
		},
		"""
			----------
			1. ERROR in A.java (at line 7)
				new In.Inner<X>();
				    ^^
			The member type A<V>.Nested.In must be parameterized, since it is qualified with a parameterized type
			----------
			""");
}

//https://bugs.eclipse.org/bugs/show_bug.cgi?id=469201
public void testBug469201_A(){
	this.runConformTest(
		new String[]{
			"T2.java",
			"""
				import java.util.*;
				
				class Bar {  }
				
				class FooPrime extends Bar {
				      void bar(Bar bar) { }
				}
				
				class Foo extends FooPrime { }
				
				public class T2 {
				
					public static void someMethod(List<? extends Foo> foos ) {
						Bar bar = new Bar();\s
						foos.get(0).bar(bar);
					}
				  public static void main(String... args) {
				      List<Foo> foos = new ArrayList<Foo>();
				      foos.add(new Foo());
				      someMethod(foos);
				  }
				}"""
		});
}

public void testBug469201_B(){
	this.runNegativeTest(
		new String[]{
				"A.java",
				"""
					package bug469201.p1;
					public class A {
						void bar(Bar bar) { }
					}
					class Bar {}
					""",
				"D.java",
				"""
					package bug469201.p1;
					import java.util.ArrayList;
					import java.util.List;
					import bug469201.p2.B;
					public class D{
						public static void main(String... args) {
						      List<? extends B> foos = new ArrayList<B>();
						      Bar bar = new Bar();
						      foos.get(0).bar(bar);
						}
					}""",
				"B.java",
				"""
					package bug469201.p2;
					import bug469201.p1.A;
					public class B extends A {}
					"""
		},
		"""
			----------
			1. ERROR in D.java (at line 9)
				foos.get(0).bar(bar);
				            ^^^
			The method bar(Bar) from the type A is not visible
			----------
			""");
		}
public void testBug460491() {
	if (this.complianceLevel >= ClassFileConstants.JDK1_7) {
		Map customOptions = getCompilerOptions();
		customOptions.put(CompilerOptions.OPTION_ReportRedundantSpecificationOfTypeArguments, CompilerOptions.WARNING);
		this.runConformTest(
			new String[] {
				"A.java",
				"""
					class A {
						private static final B.C c = new B.D<Void>();
					}""",
				"B.java",
				"""
					class B<T> {
						public interface C {}
						public static class D<R> implements C {}
					}"""
			},
			customOptions);
	}
}
public void testBug492450_comment0() {
	if (this.complianceLevel >= ClassFileConstants.JDK1_6) {
		runConformTest(
			new String[] {
				"DocumentObject.java",
				"""
					
					import java.util.ArrayList;
					
					interface IDocumentElementNode {
						public ArrayList<?> getChildNodesList();
					}
					
					abstract class DocumentElementNode implements IDocumentElementNode {
						@Override
						public ArrayList<IDocumentElementNode> getChildNodesList() {
							return null;
						}
					}
					
					interface IDocumentObject extends IDocumentElementNode {
						public ArrayList<?> getChildNodesList(Class<?>[] classes, boolean match);
					}
					
					public abstract class DocumentObject extends DocumentElementNode implements IDocumentObject {
						@Override
						public ArrayList<IDocumentElementNode> getChildNodesList(Class<?>[] classes, boolean match) {
							return null;
						}
					}
					"""
			});
	}
}
public void testBug532653() {
	if (this.complianceLevel >= ClassFileConstants.JDK1_6) {
		runConformTest(
			new String[] {
				"Builder.java",
				"""
					public interface Builder<T> {
						T build();
					}
					""",
				"ConcreteBuilder.java",
				"""
					public class ConcreteBuilder<B extends ConcreteBuilder<B>> implements Builder<String> {
						private String s = "";
						protected B b;
						@Override
						public String build() {
							return s;
						}
						public B append(String s) {
							this.s += s;
							return b;
						}
						public static ConcreteBuilder<?> create() {
							class ConcreteStringBuilder extends ConcreteBuilder<ConcreteStringBuilder> {
								public ConcreteStringBuilder() {
									b = this;
								}
							}
							return new ConcreteStringBuilder();
						}
					}""",
				"ConcreteSubBuilder.java",
				"""
					public class ConcreteSubBuilder<B extends ConcreteSubBuilder<B>> extends ConcreteBuilder<B>{
						public B appendTwice(String s) {
							return super.append(s).append(s);
						}
						public static ConcreteSubBuilder<?> create() {
							class ConcreteSubStringBuilder extends ConcreteSubBuilder<ConcreteSubStringBuilder> {
								public ConcreteSubStringBuilder() {
									b = this;
								}
							}
							return new ConcreteSubStringBuilder();
						}
					}
					"""
			});
	}
}
public void testBug541772() {
	runConformTest(
		new String[] {
			"bug541772Runtime/GeneratedMessage.java",
			"package bug541772Runtime;\n" +
			"\n" +
			"public class GeneratedMessage {\n" +
			"    public class Builder<T> {\n" +
			"    }\n" +
			"}\n" +
			"",
		},
		"",
		getCompilerOptions()
	);

	runConformTest(
	new String[] {
		"token/Token.java",
		"package token;\n" +
		"\n" +
		"public class Token {\n" +
		"  \n" +
		"  public Token() {\n" +
		"  }\n" +
		"\n" +
		"  public Token(TokenProto tokenPB) {\n" +
		"      tokenPB.hashCode();\n" +
		"  }\n" +
		"  public Token(String x) {\n" +
		"      x.hashCode();\n" +
		"  }\n" +
		"}\n" +
		"",
		"token/TokenProto.java",
		"package token;\n" +
		"\n" +
		"import bug541772Runtime.GeneratedMessage;\n" +
		"\n" +
		"public class TokenProto {\n" +
		"\n" +
		"    public TokenProto(GeneratedMessage.Builder<?> builder) {\n" +
		"        builder.hashCode();\n" +
		"    }\n" +
		"}\n" +
		"",
	},
	"",
	null /*classLibraries*/,
	false /*shouldFlushOutputDirectory*/,
	null /*vmArguments*/,
	getCompilerOptions(),
	null /*customRequestor*/);

	Util.flushDirectoryContent(new File(OUTPUT_DIR + File.separator + "bug541772Runtime"));

	runConformTest(
	new String[] {
		"pkg/Example.java",
		"package pkg;\n" +
		"\n" +
		"import token.Token;\n" +
		"\n" +
		"public abstract class Example {\n" +
		"	public static void setConnectorInfo() {\n" +
		"		new Token(\"\");\n" +
		"	}\n" +
		"}\n" +
		"",
	},
	"",
	null /*classLibraries*/,
	false /*shouldFlushOutputDirectory*/,
	null /*vmArguments*/,
	getCompilerOptions(),
	null /*customRequestor*/);
}
public void testBug541772_typeannotations() {
	if (this.complianceLevel < ClassFileConstants.JDK1_8) {
		return;
	}
	runConformTest(
		new String[] {
			"bug541772Runtime/GeneratedMessage.java",
			"package bug541772Runtime;\n" +
			"\n" +
			"public class GeneratedMessage {\n" +
			"    public class Builder<T> {\n" +
			"    }\n" +
			"}\n" +
			"",
		},
		"",
		getCompilerOptions()
	);

	runConformTest(
	new String[] {
		"token/Ann.java",
		"""
			package token;
			import java.lang.annotation.*;
			@Target(ElementType.TYPE_USE)
			@Retention(RetentionPolicy.CLASS)
			@interface Ann {}
			""",
		"token/Token.java",
		"package token;\n" +
		"\n" +
		"public class Token {\n" +
		"  \n" +
		"  public Token() {\n" +
		"  }\n" +
		"\n" +
		"  public Token(TokenProto tokenPB) {\n" +
		"      tokenPB.hashCode();\n" +
		"  }\n" +
		"  public Token(String x) {\n" +
		"      x.hashCode();\n" +
		"  }\n" +
		"}\n" +
		"",
		"token/TokenProto.java",
		"package token;\n" +
		"\n" +
		"import bug541772Runtime.GeneratedMessage;\n" +
		"\n" +
		"public class TokenProto {\n" +
		"\n" +
		"    public TokenProto(GeneratedMessage.@Ann Builder<?> builder) {\n" +
		"        builder.hashCode();\n" +
		"    }\n" +
		"}\n" +
		"",
	},
	"",
	null /*classLibraries*/,
	false /*shouldFlushOutputDirectory*/,
	null /*vmArguments*/,
	getCompilerOptions(),
	null /*customRequestor*/);

	Util.flushDirectoryContent(new File(OUTPUT_DIR + File.separator + "bug541772Runtime"));

	Map compilerOptions = getCompilerOptions();
	compilerOptions.put(JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS, JavaCore.ENABLED);
	runConformTest(
	new String[] {
		"pkg/Example.java",
		"package pkg;\n" +
		"\n" +
		"import token.Token;\n" +
		"\n" +
		"public abstract class Example {\n" +
		"	public static void setConnectorInfo() {\n" +
		"		new Token(\"\");\n" +
		"	}\n" +
		"}\n" +
		"",
	},
	"",
	null /*classLibraries*/,
	false /*shouldFlushOutputDirectory*/,
	null /*vmArguments*/,
	compilerOptions,
	null /*customRequestor*/);
}
/**
 * This test targets the optimization for parameterized dependencies in {@code BoundSet.combineSameSameWithProperType(...)}.
 */
public void testBug543480BasedOnTest2FromComment4ToSameSameOptimization() {
	if (this.complianceLevel >= ClassFileConstants.JDK1_8) {
		final List<Duration> durationsFor2TypeParameters = compileTimesAfterWarmup(() -> runConformTest(
			new String[] {
				"Test2_2.java",
				"""
					public class Test2_2 {
						void test() {
							m(s(
								f(1),
								f(2)
							));
						}
					
						static <R> R m(S<R> s) { return null; }
					    static <T> F<T> f(T t) { return null; }
						static <T1> S<R1<T1>> s(F<T1> t1) { return null; }
						static <T1, T2> S<R2<T1, T2>> s(F<T1> t1, F<T2> t2) { return null; }
					}
					interface F<T> {}
					interface S<R> {}
					interface R1<T1> {}
					interface R2<T1, T2> {}
					"""
			}));
		final List<Duration> durationsFor11TypeParameters = compileTimesAfterWarmup(() -> runConformTest(
				new String[] {
					"Test2_11.java",
					"""
						public class Test2_11 {
							void test() {
								m(s(
									f(1),
									f(2),
									f(3),
									f(4),
									f(5),
									f(6),
									f(7),
									f(8),
									f(9),
									f(10),
									f(11)
								));
							}
						
							static <R> R m(S<R> s) { return null; }
						   static <T> F<T> f(T t) { return null; }
							static <T1> S<R1<T1>> s(F<T1> t1) { return null; }
							static <T1, T2> S<R2<T1, T2>> s(F<T1> t1, F<T2> t2) { return null; }
							static <T1, T2, T3> S<R3<T1, T2, T3>> s(F<T1> t1, F<T2> t2, F<T3> t3) { return null; }
							static <T1, T2, T3, T4> S<R4<T1, T2, T3, T4>> s(F<T1> t1, F<T2> t2, F<T3> t3, F<T4> t4) { return null; }
							static <T1, T2, T3, T4, T5> S<R5<T1, T2, T3, T4, T5>> s(F<T1> t1, F<T2> t2, F<T3> t3, F<T4> t4, F<T5> t5) { return null; }
							static <T1, T2, T3, T4, T5, T6> S<R6<T1, T2, T3, T4, T5, T6>> s(F<T1> t1, F<T2> t2, F<T3> t3, F<T4> t4, F<T5> t5, F<T6> t6) { return null; }
							static <T1, T2, T3, T4, T5, T6, T7> S<R7<T1, T2, T3, T4, T5, T6, T7>> s(F<T1> t1, F<T2> t2, F<T3> t3, F<T4> t4, F<T5> t5, F<T6> t6, F<T7> t7) { return null; }
							static <T1, T2, T3, T4, T5, T6, T7, T8> S<R8<T1, T2, T3, T4, T5, T6, T7, T8>> s(F<T1> t1, F<T2> t2, F<T3> t3, F<T4> t4, F<T5> t5, F<T6> t6, F<T7> t7, F<T8> t8) { return null; }
							static <T1, T2, T3, T4, T5, T6, T7, T8, T9> S<R9<T1, T2, T3, T4, T5, T6, T7, T8, T9>> s(F<T1> t1, F<T2> t2, F<T3> t3, F<T4> t4, F<T5> t5, F<T6> t6, F<T7> t7, F<T8> t8, F<T9> t9) { return null; }
						   static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> S<R10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>> s(F<T1> t1, F<T2> t2, F<T3> t3, F<T4> t4, F<T5> t5, F<T6> t6, F<T7> t7, F<T8> t8, F<T9> t9, F<T10> t10) { return null; }
						   static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> S<R11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>> s(F<T1> t1, F<T2> t2, F<T3> t3, F<T4> t4, F<T5> t5, F<T6> t6, F<T7> t7, F<T8> t8, F<T9> t9, F<T10> t10, F<T11> t11) { return null; }
						}
						interface F<T> {}
						interface S<R> {}
						interface R1<T1> {}
						interface R2<T1, T2> {}
						interface R3<T1, T2, T3> {}
						interface R4<T1, T2, T3, T4> {}
						interface R5<T1, T2, T3, T4, T5> {}
						interface R6<T1, T2, T3, T4, T5, T6> {}
						interface R7<T1, T2, T3, T4, T5, T6, T7> {}
						interface R8<T1, T2, T3, T4, T5, T6, T7, T8> {}
						interface R9<T1, T2, T3, T4, T5, T6, T7, T8, T9> {}
						interface R10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> {}
						interface R11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> {}
						"""
				}));
		// Time complexity should grow roughly linearly, not O(2^n)
		// To make the test robust, it tests for the same order of magnitude only, i.e. factor 10.
		assertCompileTimes(durationsFor2TypeParameters, 10, durationsFor11TypeParameters);
	}
}
/**
 * This test targets the optimization for parameterized dependencies in {@code BoundSet.combineSameSubSuperWithProperType(...)}.
 */
public void testBug543480WithSameSubSuperOptimization() {
	if (this.complianceLevel >= ClassFileConstants.JDK1_8) {
		final List<Duration> durationsFor2TypeParameters = compileTimesAfterWarmup(() -> runConformTest(
			new String[] {
					"WithParameterizedDependencies_2.java",
					"abstract class WithParameterizedDependencies_2 {\n" +
					"    <T1, T2> \n" +
					"           Type1<T1, T2>\n" +
					"           s1(Type1<T1, T2> t) {\n" +
					// This line causes the optimization in BoundSet.combineSameSubSuperWithProperType(...) to be effective.
					"        return s2(new Type1<>(t));\n" +
					"    }\n" +
					"    abstract <E> E s2(E e);\n" +
					"}\n" +
					"class Type1<T1, T2> {\n" +
					"    Type1(final Type1<T1, T2> l) {}" +
					"}\n"
			}));
		final List<Duration> durationsFor12TypeParameters = compileTimesAfterWarmup(() -> runConformTest(
				new String[] {
					"WithParameterizedDependencies_12.java",
					"abstract class WithParameterizedDependencies_12 {\n" +
					"    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> \n" +
					"           Type1<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>\n" +
					"           s1(Type1<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> t) {\n" +
					// This line causes the optimization in BoundSet.combineSameSubSuperWithProperType(...) to be effective.
					"        return s2(new Type1<>(t));\n" +
					"    }\n" +
					"    abstract <E> E s2(E e);\n" +
					"}\n" +
					"class Type1<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> {\n" +
					"    Type1(final Type1<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> l) {}" +
					"}\n"
				}));
		// Time complexity should grow roughly linearly, not O(2^n).
		// To make the test robust, it tests for the same order of magnitude only, i.e. factor 10.
		assertCompileTimes(durationsFor2TypeParameters, 10, durationsFor12TypeParameters);
	}
}
/**
 * An earlier version of the fix for bug 543480 causes a NullPointerException when compiling this code.
 */
public void testBug543480WithoutNullPointerExceptionDuringBytecodeGeneration() {
	if (this.complianceLevel >= ClassFileConstants.JDK1_8) {
		runConformTest(
			new String[] {
				"Test.java",
				"""
					import java.util.function.BiConsumer;
					
					public class Test {
					\t
						interface I0<T extends I0<T>> {}
					
						class Type<T extends I0<T>, D> {
							// TODO: The problem might be that BiConsumer is not declared in the same file?
							public Type(final BiConsumer<T, D> b) { }
						}
					
						public void foo() {
							new Type<>((unused0, unused1) -> {});
						}
					}"""
			});
	}
}

public void testBugBug571785_001() {
	if (this.complianceLevel >= ClassFileConstants.JDK1_8) {
		runConformTest(
			new String[] {
				"Test.java",
				"""
					import java.util.Collection;
					
					public class Test {
						public static void main(String[] args) {
							new testclass();
						}
					}
					class testclass {
						public void update(final Collection<? extends byte[]> inputs) {
							inputs.forEach(this::update);
						}
						public void update(final byte[] input) {
						}
					}
					"""
			});
	}
}

protected void assertCompileTimes(final List<Duration> shortTimes, final double factor, final List<Duration> longTimes) {
	final double shortTimesAverage = minExcludingBoundaries(shortTimes);
	final double longTimesAverage = minExcludingBoundaries(longTimes);
	final String message = "Potential fluctuation of a performance test: minimum long compile time "
			+ longTimesAverage + "ms should be less than " + factor + "x the minimum short compile time " + shortTimesAverage +"ms\n"
			+ "long compile times: "+longTimes+"\n"
			+ "short compile times: "+shortTimes;
	if (PERFORMANCE_ASSERTS) {
		assertTrue(message,longTimesAverage < factor*shortTimesAverage);
		System.out.println(message);
	} else if (longTimesAverage >= factor*shortTimesAverage) {
		System.out.println(message);
	}
}

protected double minExcludingBoundaries(final List<Duration> durations) {
	return durations.stream()
			.filter(duration -> !duration.isExcluded)
			.mapToLong(duration -> duration.durationMs)
			.min().orElse(-1);
}

protected List<Duration> compileTimesAfterWarmup(final Runnable compileTask) {
	// warm up
	duration(compileTask);
	runGarbageCollection();
	// draw samples, exclude boundaries i.e. exclude potential outliers
	final int numberOfSamples = 10;
	final int boundarySize = 2;
	return IntStream.rangeClosed(1, numberOfSamples)
			.mapToObj(duration(compileTask))
			.sorted()
			.peek(markExcludedBoundaries(boundarySize, numberOfSamples))
			.collect(toList());
}

protected static IntFunction<Duration> duration(final Runnable runnable) {
	return index -> {
		java.time.Duration s00 = ProcessHandle.current().info().totalCpuDuration().get();
		// wait for a OS scheduler slice begin to increase probability to finish within a single slice:
		java.time.Duration s0;
		java.lang.Thread.yield();
		do {
			java.lang.Thread.onSpinWait();
			s0 = ProcessHandle.current().info().totalCpuDuration().get();
		} while (s0.equals(s00));
		long t0 = System.nanoTime();
		runnable.run();
		long t1 = System.nanoTime();
		long tdiff = (t1 - t0) / 1000_000;
		java.time.Duration s1 = ProcessHandle.current().info().totalCpuDuration().get();
		java.time.Duration diff = s1.minus(s0);
		long duration = diff.toMillis();
		// if more then one slice we better take the OS value:
		duration = duration == 0 ? tdiff : Math.min(duration, tdiff);
		return new Duration(index, duration);
	};
}

protected static Consumer<Duration> markExcludedBoundaries(final int boundarySize, final int numberOfSamples) {
	final AtomicInteger seenSamples = new AtomicInteger(0);
	return duration -> {
		final int indexFromBottom = seenSamples.get();
		final int indexFromTop = abs(seenSamples.get() - numberOfSamples);
		if(indexFromBottom < boundarySize) {
			// a sample within the lower boundary
			duration.isExcluded = true;
		} else if(indexFromTop <= boundarySize) {
			// a sample within the upper boundary
			duration.isExcluded = true;
		}
		seenSamples.incrementAndGet();
	};
}

protected static class Duration implements Comparable<Duration> {
	protected final int index;
	protected final long durationMs;
	protected boolean isExcluded = false;

	public Duration(final int index, final long durationMs) {
		this.index = index;
		this.durationMs = durationMs;
	}

	@Override
	public int compareTo(Duration other) {
		return (int)(this.durationMs - other.durationMs);
	}

	@Override
	public String toString() {
		return "#"+this.index + " " + this.durationMs + "ms" + (this.isExcluded?" (excluded)":"");
	}
}

}

